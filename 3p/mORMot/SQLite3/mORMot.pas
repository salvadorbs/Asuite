/// Common ORM and SOA classes for mORMot
// - this unit is a part of the freeware Synopse mORMot framework,
// licensed under a MPL/GPL/LGPL tri-license; version 1.18
unit mORMot;

(*
    This file is part of Synopse mORMot framework.

    Synopse mORMot framework. Copyright (C) 2013 Arnaud Bouchez
      Synopse Informatique - http://synopse.info

  *** BEGIN LICENSE BLOCK *****
  Version: MPL 1.1/GPL 2.0/LGPL 2.1

  The contents of this file are subject to the Mozilla Public License Version
  1.1 (the "License"); you may not use this file except in compliance with
  the License. You may obtain a copy of the License at
  http://www.mozilla.org/MPL

  Software distributed under the License is distributed on an "AS IS" basis,
  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  for the specific language governing rights and limitations under the License.

  The Original Code is Synopse mORMot framework.

  The Initial Developer of the Original Code is Arnaud Bouchez.

  Portions created by the Initial Developer are Copyright (C) 2013
  the Initial Developer. All Rights Reserved.

  Contributor(s):
  Alternatively, the contents of this file may be used under the terms of
  either the GNU General Public License Version 2 or later (the "GPL"), or
  the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  in which case the provisions of the GPL or the LGPL are applicable instead
  of those above. If you wish to allow use of your version of this file only
  under the terms of either the GPL or the LGPL, and not to allow others to
  use your version of this file under the terms of the MPL, indicate your
  decision by deleting the provisions above and replace them with the notice
  and other provisions required by the GPL or the LGPL. If you do not delete
  the provisions above, a recipient may use your version of this file under
  the terms of any one of the MPL, the GPL or the LGPL.

  ***** END LICENSE BLOCK *****


       Client-Server ORM and SOA kernel of the mORMot framework
      **********************************************************

	- Client-Server classes using a RESTful model via JSON, over named pipes
	  or GDI messages  (HTTP/1.1 protocol with unit mORMotHttpServer/Client)
	- Client-Server ORM via TSQLRecord classes definition
	- Client-Server interface-based services for SOA process
	- optimized low-level RTTI and JSON process (TSQLTable)
	- ready to be used by mORMotSQLite3.pas with a SQLite3 engine
	- implements in-memory database tables with JSON/binary disk persistence

      Initial version: 2008 March, by Arnaud Bouchez

    Version 1.1 - 14 January 2010:
    - SQLite3 database layer updated to version 3.6.22
    - new communication layer, to be used on a local computer: windows messages
      (see TSQLRestClientURIMessage class). On a local machine, this is faster
      than named pipes and http, for small messages (quite as fast as direct
      access); but named pipes seems to be better for bigger messages
    - allow to get rid of our Enhanced Runtime Library dependency if not available
      (e.g. for FPC or on cross-platform, or on Delphi version newer than Delphi
      2007): just define the ENHANCEDRTL conditional below if installed it
      (always undefined if UNICODE is defined)
    - attempt to reach Delphi 2009/2010 compilation (string=UnicodeString):
      the UNICODE conditional will adapt the framework to these compilers
      (you shouldn't have to change any conditional define below)
    - attempt to reach Free Pascal Compiler 2.4.0 compatibility
    - all asm code equivalence in pure pascal code for 64 bits compatibility
      (always slower, but always portable to all CPUs)
    - use of PtrUInt / PtrInt for 64 bits compatibility
    - in case of FPC, the typinfo.pp unit is used: so all published properties
      in any TSQLRecord descendant must have a setter (i.e. a "write fValue"
      statement); the FPC's RTTI is not the same as Delphi's: it's a shame :(

    Version 1.2 - 16 January 2010
    - compatibility tested up to Delphi 2009 (that is tested with Delphi 7,
      Delphi 2007 and Delphi 2009), with or without our Enhanced
      Run Time Library (which now compiles up to Delphi 2007) - by default, the
      ENHANCEDRTL compiler conditional is not defined;
    - lot of rewrite made for the Unicode version of the compiler (tested with
      Delphi 2009) - it was quite difficult to avoid most implicit conversions...
      the compiler is a bit tricky, as soon as you want to use the UTF-8 encoding
      (as we do, since JSON and HTTP do like this encoding, together as SQLite3),
      and not Unicode (which is in fact UTF-16);
    - can create an internal TSQLRestClientURIMessage messaging window, if
      you don't have any User Interface (so you don't have to add Forms unit)
    - named pipe speed improvement (10 times faster) under Vista and Seven

    Version 1.3 - January 22, 2010
    - disconnect piped name client after 30 min of inactivity to free the
      corresponding thread resource if the client failed to close cleanly
    - some small fixes (e.g. integer to and from string conversion, GPF) and
      multi-compiler (Delphi 2009/2010, especialy with TypInfo define) compatibility
    - compiler conditional renamed ENHANCEDRTL instead of ENHANCEDTRTL
    - new TSQLTable.GetRowValues overloaded methods

    Version 1.3.1 - January 23, 2010
    - some Pos() overload problem under Delphi 20007 compiler; since
      this Pos() is seldom used, it was decided to only define it under
      Delphi 2009/2010 (which expect such a RawUTF8 specific overloaded version)
    - source code adaptation to use only ASCII 7 bits characters: should be OK
      with asiatic MBCS text encoding and such IDE

    Version 1.3.2 - January 24, 2010
    - new StringToUTF8() and UTF8ToString() functions; it's prefered to use
    TLanguageFile.StringToUTF8() method from SQLite3i18n, which will handle full
    i18n of your application; these functions use the current RTL codepage
    under Delphi 3-2007

    Version 1.4 - February 8, 2010
    - whole Synopse SQLite3 database framework released under the GNU Lesser
      General Public License version 3, instead of generic "Public Domain"

    Version 1.5 - March 10, 2010
    - SQLite3 database layer updated to version 3.6.23
    - User Interface Query action implementation
    - added security attributes to the named pipes creation: now this
      communication layer can work as a windows service, under Vista or Seven
      (thanks to esmond comment in our blog for the tip)
    - added new FastCGI server (not 100% tested)
    - first attempt to add REST paging requests for 'GET ModelRoot/TableName',
      as expected by the YUI DataSource Request Syntax for data pagination:
      see http://developer.yahoo.com/yui/datatable/#data

    Version 1.6
    - SQLite3 database layer updated to version 3.6.23.1
    - most useful functions are now shared in a separate SynCommons unit
    - the framework is now licensed under a MPL/GPL/LGPL tri-license
    - obscure JSON parsing bug fixed (when a field content finished with '\')

    Version 1.7
    - alter table with newly added fields to a TSQLRecord (see GetSQLAddField()
      methods)
    - some compatibility fixes for Delphi 2009/2010
    - fixed bug: negative numbers were not updated when calling *.Update()

    Version 1.8
    - includes Unitary Testing class and functions
    - update engine to version 3.7.0
    - new direct methods to handle BLOB fields from clients or servers
    - new URI to GET or PUT BLOB fields: ModelRoot/TableName/ID/BlobFieldName
    - fixed bug in TSQLTable.GetJSONValues: FirstRow parameter not used
    - TTextWriter class moved from SQLite3Commons to SynCommons
    - new ModelRoot/[TableName/ID/]MethodName RESTful GET/PUT request
     (see TSQLRestServerCallBack definition and comments): implements some custom
     Client/Server request, similar to the DataSnap technology, but in a KISS way;
     it's fully integrated in the Client/Server architecture of our framework,
     and extend its ORM feature to Object-less communication - see new
     ModelRoot/Stat method implement in TSQLRestServer
    - floating point numbers are now encoded using new ExtendedStr[ing] methods:
     such values are now encoded in a more human readable way in the JSON content
    - new tests added (mostly relative to the new functions or classes)

    Version 1.9
    - update engine to version 3.7.1
    - fixed error calling a TSQLRestServerCallBack with both record & parameters
    - TSQLRecordSigned must now be signed with a specified content (content
      was formerly a fixed field of type RawUTF8, but it didn't apply in
      all cases, e.g. if content field is defined as TSQLRawBlob)
    - new TSQLRestClientURI.ForceBlobTransfert property which enable to
      get and set BLOB fields values with usual Add/Update/Retrieve methods
    - new TSQLRestClientURI.RetrieveBlobFields/UpdateBlobFields methods
      for retrieving/updating all BLOB fields of a record at once
    - better handling of sftID in the User Interface and database use (e.g.
      creates a dedicated index for the TSQLRecord published fields)
    - some code rewrite in order to avoid any implicit conversion from/to
      integer/cardinal after new definition of PtrInt/PtrUInt (matching
      NativeInt/NativeUInt types, available since Delphi 2007)
    - updated TSQLRibbonTabParameters object, with some new fields dedicated
      to the automatic edition of records, via the new SQLite3UIEdit unit
    - new sftSet SQL field kind, handling a TSQLRecord published property
      with a set of enumeration as Delphi type (stored as bit-mapped INTEGER)
    - handle now RowID as a valid alias to the ID field (needed for TSQLRecordFTS3)
    - defines a new TSQLRecordFTS3 type, for defining a FTS3 virtual table,
      i.e. implementing full-text search

    Version 1.9.1
    - update engine to version 3.7.2: an obscure but very old bug makes
      SQLite authors recommend to use 3.7.2  for all new development.
      Upgrading from all prior SQLite versions is also recommended.

    Version 1.9.2
    - WriteObject and CopyObject functions now handle Int64 properties,
      as TJSONWriter.WriteObject method does now also
    - new TSQLRestServerStatic.GetOne and TSQLRestServerStatic.UpdateOne methods,
      methods available since a TSQLRestServerStatic instance may be created
      stand-alone, i.e. without any associated Model/TSQLRestServer
    - diverse fixes in TSQLRestServerStatic which could occur in not expected
      behavior if security events are enabled for this table (wrong IDToIndex)
    - new TSQLRecordLog.CreateFrom method used to append some log records
      to an existing JSON log content

    Version 1.10
    - code modifications to compile with Delphi 6 compiler (Delphi 5 failed due
      to some obscure compiler bugs in SynCrypto.pas)
    - update SQLite3 engine to version 3.7.3

    Version 1.11
    - update SQLite3 engine to version 3.7.4
    - new TSQLRecordProperties class, used internally by TSQLRecord to access
      to the RTTI via some high-level structures (therefore save memory for each
      TSQLRecord instance, and make operations faster)
    - new TSQLRecordFill class, used internally by TSQLRecord.FillPrepare()
      to save memory: a TSQLRecord instance has now only 20 bytes of InstanceSize
    - TSQLRecord.ID reader has now a GetID() getter which can handle the fact that
      a published property declared as TSQLRecord (sftID type) contains not a
      true TSQLRecord instance, but the ID of this record: you can use
      aProperty.ID method in order to get the idea - but prefered method is to
      typecast it via PtrInt(aProperty), because GetID() relies on some low-level
      windows memory mapping trick
    - new TSQLRecordMany to handle "has many" and "has many through" relationships
    - TSQLRestServer.AfterDeleteForceCoherency now handles specifically
      TRecordReference, TSQLRecord (fixed) and new 'has many' Source/Dest fields
      (this is our internal "FOREIGN KEY" implementation - we choose not to
      rely on the database engine for that, in order to be engine-independent...
      and SQLite3 introduced FOREIGN KEY in 3.6.19 version only)
    - TSQLRestServer.AfterDeleteForceCoherency now synchronizes as expected
      TSQLRestServerStatic table content
    - new TSQLRestServerStatic.SearchField method, for fast retrieval of
      all IDs matching a field of a TSQLRestServerStatic table (faster than
      using any OneFieldValues method, which creates a temporary JSON content)
    - TSQLRecord.FillRow method has been made virtual, so that some calculated
      field can be initialize during table content enumeration
    - corrected possible GPF error in TSQLRestServer.Retrieve
    - sftMany/TSQLRecordMany field type handled as a not simple field
    - new TSQLRecord.SimplePropertiesFill() method, to fill the simple properties
      with a given list of const parameters, following the declared order of
      published properties of the supplied table
    - new TSQLRest.Add(aTable: TSQLRecordClass; const aSimpleFields: array of const)
      overloaded method to add a record from a supplied list of const parameters
    - new TSQLRest.Update(aTable: TSQLRecordClass; aID: integer; const aSimpleFields: array of const)
      overloaded method to update a record from a supplied list of const parameters
    - new class function TSQLRecord.SimpleFieldsCount
    - FTS3Match method renamed FTSMatch, in order to be used without hesitation
      for both FTS3 and FTS4 classes
    - new overloaded FTSMatch method, accepting ranking of MATCH, using the
      new RANK internal function - see http://www.sqlite.org/draft/fts3.html#appendix_a
    - new TSQLRecordFTS4 class, to handle new FTS4 extension module  - see
      http://sqlite.org/fts3.html#section_1_1 - which is available since 3.7.4
    - new TSQLRecord.FillClose method
    - new TSQLRecord.CreateAndFillPrepare() methods, to makes loop into records
      easier (an hidden TSQLTable is created and released by TSQLRecord.Destroy)
    - new overloaded TSQLRestServer.CreateSQLIndex() method, accepting an array
      of field names
    - new TSQLRecord.FillPrepare(const aIDs: TIntegerDynArray) overloaded method,
      which can be handy to loop into some records via an IDs set
    - new TSQLTable.OwnerMustFree property for generic owning of a TSQLTable
      by a record - used for both CreateAndFillPrepare and TSQLRecordMany.FillMany
    - better non-ascii search handling in TSQLTable.SearchValue
    - source code modified to be 7 bit Ansi (so will work with all encodings)

    Version 1.12
    - now handle automaticaly prepared SQL statements: the parameters must
      be surrounded with :(...): in order to use an internal pool of prepared
      TSQLRequest statements; example of possible inlined values are :(1234):
      :(12.34): :(12E-34): :("text"): or :('text'): (with double quoting
      inside the text, just like any SQL statement)
    - with Delphi 2009+, you can define any string parameter in your
      TSQLRecord definition (will be handled as sftUTF8Text field)
    - with Delphi 2009+, WriteObject, ReadObject and CopyObject functions
      now handle string (UnicodeString) properties, as TINIWriter.WriteObject
      method does also: UTF-8 encoding is used at the storage level
    - new function SQLParamContent() to retrieve :(...): param content and type
    - another review of Pos() calls in the code (now use our fast PosEx)
    - some functions or type/const definitions moved to SynCommons in order
      to introduce new TSynTable class (TJSONWriter, IsRowID, GotoNextJSONField,
      TSynTableStatement...)
    - new TSQLRestServer.CreateSQLMultiIndex method
    - new TSQLTable.GetString and TSQLTable.GetVariant methods
    - new TPropInfo.SetVariant/GetVariant/CopyValue methods
    - new GetFieldValue/SetFieldValue and GetFieldVariant/SetFieldVariant
      methods for TSQLRecord
    - fixed issue in TSQLTable.GetWP(), which truncated data in Grid display
    - fixed issue in TSQLRestServerNamedPipe[Response] multi-thread architecture:
      FastMM in full debug mode detected that a block has been modified after
      being freed - now TSQLRestServerNamedPipeResponse is fully stand-alone

    Version 1.13
    - the ORM will now include all published properties of the parents, up to
      TSQLRecord, to the database fields (it was only using the published
      properties at the topmost class level)
    - dynamic arrays can now be specified for TSQLRecord published properties:
      a new sftBlobDynArray field kind has been added - will be stored as BLOB in
      the database (following the TDynArray.SaveTo binary stream layout), and
      will be transmitted as Base64 encoded in the JSON stream - we implemented
      a sftBlobRecord field kind, but Delphi RTTI is not generated for published
      properties of records: so our code is disabled (see PUBLISHRECORD
      conditional) :( - but you can use dynamic arrays of records
    - TPersistent can be now be specified for TSQLRecord published properties:
      a new sftObject field kind has been added - will be stored as TEXT in the
      database (following the ObjectToJSON serialization format) - TStrings or
      TRawUTF8List will be stored as a JSON array of string, and TCollection
      as a JSON array of objects, other TPersistent classes will have their
      published properties serialized as a JSON object
    - introducing direct content filtering and validation using
      TSynFilterOrValidate dedicated classes
    - filtering is handled directly in the new TSQLRecord.Filter virtual method,
      or via some TSynFilter classes - TSynFilterUpperCase, TSynFilterUpperCaseU,
      TSynFilterLowerCase, TSynFilterLowerCaseU and TSynFilterTrim e.g.
    - validation is handled in the new TSQLRecord.Validate virtual method,
      or via some TSynValidate classes - TSynValidateRest, TSynValidateIPAddress,
      TSynValidateEmail, TSynValidatePattern, TSynValidatePatternI,
      TSynValidateText, TSynValidatePassWord e.g.
    - introducing TSQLRecordRTree to implement R-Tree virtual tables - and new
      TSQLRecordVirtual parent table for all virtual tables like TSQLRecordFTS*
    - new TSQLRestClientURI methods to implement BATCH sequences to speed up
      database modifications: after a call to BatchStart, database modification
      statements are added to the sequence via BatchAdd/BatchUpdate/BatchDelete,
      then all statments are sent as once to the remote server via BatchSend -
      this is MUCH faster than individual calls to Add/Update/Delete in case
      of a slow remote connection (typically HTTP over Internet)
    - introducing TSQLVirtualTableModule / TSQLVirtualTable /
      TSQLVirtualTableCursor classes for a generic Virtual table mechanism
      (used e.g. by TSQLVirtualTableModuleDB in the SQLite3 unit)
    - new TSQLRecordVirtualTableAutoID and TSQLRecordVirtualTableForcedID
      classes, used to access any TSQLVirtualTable in our ORM
    - security and per-user access rights is now implemented in the framework
      core using per-User authentication via in-memory sessions (stored as
      TAuthSession), with group-defined associated security parameters (via
      TSQLAuthUser and TSQLAuthGroup tables), and RESTful Query Authentication
      via URI signature; should avoid most MITM and replay attacks
    - new TJSONSerializer class and ObjectToJSON/JSONToObject method
      (handles also dynamic arrays following the TTextWriter.AddDynArrayJSON
      format, i.e. plain JSON array for common types aka '[1,2,3]', but Base64
      encoded stream aka '["\uFFF0base64encodedbinary"]' for other arrays) and
      corresponding UrlDecodeObject() function (to be called by RESTful Services
      implementation on Server side)
    - wider usage of TSQLRecordProperties, for faster RTTI access, via the new
      class function TSQLRecord.RecordProps: TSQLRecordProperties: only
      virtual class function or procedure are now defined in TSQLRecord
    - enhanced TPropInfo.GetLongStrValue/SetLongStrValue methods, now converting
      RawUnicode, WinAnsiString, TSQLRawBlob and AnsiString properties
    - now ensure that no published property named ID or RowID was defined (this
      unique primary key field must be handled directly by TSQLRecord)
    - MAX_SQLFIELDS default is still 64, but can now be set to any value (64,
      128, 192 and 256 have optimized fast code) so that you can have any number
      of fields in a Table
    - MAX_SQLTABLES default is now 256, i.e. you can have up to 256 tables in a
      TSQLModel instance (you can set any other value, on need)
    - TSQLModel implementation speed up, in case of a huge number of registered
      TSQLRecord in the database Model (since MAX_SQLTABLES=256 by default)
    - enhanced TSQLRecordMany.DestGetJoinedTable method to handle custom fields
    - TSQLRecordMany.DestGetJoined* methods now accept generic TSQLRest class
    - new aCustomFieldsCSV parameter for FillPrepare / CreateAndFillPrepare
      methods of TSQLRecord, to retrieve only neeeded fields: be aware that
      not specified fields will be left untouched, so a later Update() call may
      corrupt the row data - this optional parameter is about to save bandwidth
      when retrieving records field in a loop 
    - TSQLRestServerStaticInMemory can now store its content into UTF-8 JSON
      or an optimized (SynLZ) compressed binary format - associated TPropInfo
      GetBinary/SetBinary and TSQLRecord GetBinaryValues/SetBinaryValues methods
    - the generic TVarData type is now used as a standard way of fast values
      communication: only handled VType are varNull, varInt64, varDouble,
      varString (mapping a constant PUTF8Char), and varAny (BLOB with size =
      VLongs[0]) - used e.g. by SQLite3 unit (VarDataToContext/VarDataFromValue)
    - new TSQLRest.Retrieve(aPublishedRecord, aValue: TSQLRecord) and
      TSQLRecord.Create(aClient: TSQLRest; aPublishedRecord: TSQLRecord..) methods
    - ExecuteList defined in TSQLRest, so now available also in TSQLRestServer
    - added a magic pattern check to ignore broadcasted WM_COPYDATA message
    - fixed issue in serializing sftCurrency type in TSQLRecord.GetJSONValue

  Version 1.14
    - new TPropInfo.GetCurrencyValue method
    - fixed issue in produced JSON stream using '=' instead of ':'

  Version 1.15
    - unit now tested with Delphi XE2 (32 Bit)
    - new sftModTime / TModTime published field type in TSQLRecord, which will
      be set to the current server time stamp before update/adding
    - new sftCreateTime / TCreateTime published field type in TSQLRecord, which
      will be set to the current server time stamp at record creation
    - new TSQLRest.ServerTimeStamp property, which will return the current
      server time as TTimeLog/Int64 value (will use the new /TimeStamp RESTful
      service to retrieve the exact server time)
    - TSQLRestServerStaticInMemory uses a per-Table Critical Section to have
      its EngineList, EngineRetrieve, EngineAdd, EngineUpdate, EngineDelete,
      EngineRetrieveBlob, EngineUpdateBlob methods begin thread-safe
    - enhanced TSQLRestServer.URI thread-safety (e.g. Sessions access)
    - TSQLTable.InitFieldTypes will now also use column type retrieved during
      JSON parsing
    - new TSQLTable.GetCSVValues method
    - GetJSONValues() is now using an internal TRawByteStringStream when
      the expected result is a RawUTF8 (avoid copying content twice, and is
      perfectly thread-safe)
    - the shared fTempMemoryStream is not available any more (not thread-safe)
    - new TSQLRest.AcquireWrite/ReleaseWrite protected methods, used by
      TSQLRestServer.URI to safely write to the DB (e.g. for POST/PUT/DELETE...)
      with TSQLRest.AcquireWriteTimeOut, both thread-safe and transaction-safe
    - TSQLRest.TransactionBegin / Commit / RollBack methods now expect a
      SessionID parameter in order to allow safe concurent access: writing to
      the database is queued within a single client session
    - CreateSQLMultiIndex and CreateSQLIndex methods now working on external
      DB virtual tables (using SynDB.TSQLDBConnectionProperties.SQLAddIndex)
    - new TSQLRecordProperties.ExternalTableName and ExternalDatabase fields
      used by SQLite3DB to handle external SynDB-based database access
    - code refactoring to make TSQLRestServerStatic more generic (for SQLite3DB)
    - TSQLRestServer.UpdateField now accepts to search by ID or by value (used
      e.g. by rewritten TSQLRestServer.AfterDeleteForceCoherency method)
    - introducing TSQLRecordExternal kind of record, able to use any SynDB
      external database engine (e.g. OleDB/MSSQL/Oracle/SQLite3)
    - new ExtractInlineParameters procedure to handle :(1234): SQL statements
    - new MakePrivateCopy property in TSQLTableJSON.Create, which will avoid
      creating a private copy of the JSON (used e.g. in SynDBExplorer to handle
      very large result sets, with half the memory)
    - new TSQLRecordProperties.SQLUpdateSet, SQLInsertSet and AppendFieldName
      properties/method (used for external DB handling)
    - new TSQLRecord.Create, TSQLRecord.FillPrepare,
      TSQLRecord.CreateAndFillPrepare, TSQLRest.OneFieldValue,
      TSQLRest.MultiFieldValues, TSQLRestClient.EngineExecuteFmt and
      TSQLRestClient.ListFmt overloaded methods, accepting both '%' and '?'
      characters in the SQL WHERE format text, inlining '?' parameters
      with :(...): and auto-quoting strings
    - new UnicodeComparison parameter in TSQLTable.SearchValue to handle
      property non WinAnsi (code page 1252) characters
    - fixed issue in TPropInfo.GetBinary method with dynamic arrays (used e.g.
      by TSQLRestServerStaticInMemory.SaveToBinary)
    - fixed issue with TAuthSession.IDCardinal=0 or 1 after 76 connections
    - fixed issue in SetInt64Prop() with a setter method
    - fixed potential issue in TSQLTable.SearchValue in case of invalid Client
      supplied parameter (now checks TSQLRest class type)

  Version 1.16
    - mORMot framework now implements Client-Server service implementation
      using regular Delphi interfaces (over a RESTful or JSON-RPC protocol),
      using TServiceContainer / TServiceFactory classes, accessible via
      TSQLRest.Services property, on both client and server side, with
      auto-marshaling, JSON serialization, and built-in security 
    - added dedicated Exception classes (EORMException, EParsingException,
      ESecurityException, ECommunicationException, EBusinessLayerException,
      EServiceException) all inheriting from SynCommons.ESynException
    - added a generic JSON error message mechanism within the framework
      (including error code as integer and text, with custom error messages
      in RecordCanBeUpdated method and also in TSQLRestServerCallBackParams)
    - added TSQLRestServerFullMemory class to implement a basic REST server
      using only in-memory tables (will only handle CRUD commands, but is
      enough to handle authentication with optional persistence in JSON file)
    - added TSQLRestServerRemoteDB class to implement a REST server using a
      remote TSQLRestClient connection for all its ORM process: can be used
      e.g. to publish services with a dedicated process in a DMZ
    - deep refactoring of TSQLRestClient / TSQLRestClientURI methods, for
      better compliance with the Liskov substitution principle (LSP) 
    - TSQLRestServer published method names are now hash-stored for speed
    - the TSQLRestServerCallBack method prototype has been modified to supply
      "var aParams: TSQLRestServerCallBackParams" as unique parameter:
      this is a CODE BREAK change and you shall refresh ALL your server-side
      code to match the new signature (using a record passed by value as
      parameter will ensure faster code and seamless evolution of this structure) 
    - new TSQLRestServer.SessionGetUser method to be used e.g. by any
      TSQLRestServerCallBack method implementation to retrieve the connected user
    - now the TSQLAuthUser instance retrieved during the session opening will
      retrieve the Data BLOB field (ready to be consummed on the server side)
    - introduced TSQLRestServerSessionContext structure to include current User
      and Group ID to the execution context (in addition to the Session ID)
    - TSQLRestServerStaticInMemory binary format changed: now will store its
      content per field (to ensure better compression) - magic identifier changed 
    - now TSQLRestClientURI BATCH sequences methods will allow to mix several
      TSQLRecord in its sequence of BatchAdd/BatchUpdate/BatchDelete calls - if
      initiated as BatchStart(nil)
    - code clean-up of TSQLRestClientURI.SetUser + added aHashedPassword optional
      parameter (to use already hashed password) 
    - added TSQLOccasion to handle the special case of field type (like
      TCreateTime) in case of Upate/Insert/Select
    - TCreateTime published fields now are not modified at update
    - fixed unexpected exception raised in TSQLRecord.FillOne if FillPrepare
      was successfull, but did not return any row
    - introducing TSQLRest.Cache and TSQLRestCache class to handle Client or
      Server side fast in-memory cache (with tuned configuration and timeout)
    - associated TSQLRestServer.CacheFlush service for flushing the Server cache,
      and remote TSQLRestClientURI.ServerCacheFlush() method for the client
    - fixed issue in TSQLRecord.FillPrepare when the table has less columns
      that the filling TSQLTable (can occur e.g. when using aCustomFieldsCSV
      parameter in FillPrepare method)
    - EngineList methods (including TSQLRestServerStaticInMemory class) now
      handles an optional integer pointer, to return the count of row data
    - uses new generic TSynAnsiConvert classes for code page process: that is,
      SQLite3i18n S2U() and U2S() match the SynCommons StringToUTF8() and
      UTF8ToString() functions - therefore, the TUTF8ToStringEvent parameter is
      not useful any more
    - more than MAX_SQLFIELDS-1 columns (by default, 63) will raise an exception
    - added TJSONSerializer.RegisterCustomSerializer() method to allow JSON
      serialization of any class (thanks Pavel "aka mpv" for the idea and patch)
    - added TSQLRestServer.ServiceMethodByPassAuthentication method in order to
      allow by-pass of the RESTful authentication scheme for some methods (can
      be used e.g. to server some HTML content for a non SOA client)
    - fix issue about missing last item in JSONToObject() function
    - fix issue when handling null JSON objects in GetJSONObjectAsSQL() function
    - JSON functions now handle '0' as number according to http://json.org specs
    - fix issue about record locking in TSQLRestClientURI.Retrieve method
    - fix execution issue in TSQLRestServer.AfterDeleteForceCoherency()
    - fix issue about abusive session timeout: TSQLRestServer.SessionGet is now
      renamed SessionAccess and refreshes the session access timestamp each time
      a session is retrieved (+internal implementation fix)
    - fix issue in SetInt64Prop() procedure which failed the update of a property
      with no explicit setter
    - fix issue in TSQLRecord.FillFrom() which forgot to update InternalState
    - fix issue in TPropInfo.SetValue + TSQLRecord.ClearProperties with Value=nil
    - fix potential formating issue in TSQLTable.GetJSONValues/GetCSVValues
      methods which may create some wrong formating if TEXT is null/false/true
      (were formerly recognized as JSON keywords, whereas it should have already
      been transformed into nil, '0' or '1')
    - fix issue of unhandled buffer in TSQLTableJSON.UpdateFrom()
    - fix issue about transactions not working with TSQLRestServerStaticInMemory
    - fix issue in TSQLRestServerStaticInMemory on SELECT with only one column
    - fix TSQLTable.GetCSVValues() format (adding UTF-8 BOM)
    - TSQLRestServer.URI now returns "Location:" header without the digital
      signature (e.g. 'Location: People/11012') for a POST (=CRUD create/add)
    - TSQLRestClient.List and ListFmt methods now use TSQLRecordClass open
      array instead of TClass (for consistency)
    - new global RecordClassesToClasses() wrapper function to convert an
      array of TSQLRecordClass into the expected array of TClass
    - TPropInfo.CopyValue method now specifically handle copy of TCollection
      published properties items (used e.g. in TSQLRecord.FillFrom)
    - new GetEnumNameTrimed() wrapper function
    - new TRecordType definition, and TTypeinfo.RecordType associated method
    - now JSONToObject/ObjectToJSON functions and WriteObject method will handle
      standard TPersistent class serialization into/from JSON object
    - now ObjectToJSON/JSONToObject will unserialize sets and enumerations
      as an array of string, if HumanReadable is set to TRUE
    - now TSQLRestServer.Auth service returns true JSON response as specified
      by its content type (for better AJAX compatibility)
    - re-declared TSQLAccessRights record as an object, and added some
      dedicated methods: FromString, ToString, Edit
    - faster and more generic TSQLRecord.FillPrepare/FillRow implementation,
      including enhanced TSQLRecordFill class
    - faster TSQLRestServerStaticInMemory.LoadFromJSON and LoadFromBinary methods
    - reUrlEncodedSQL remote access right allows execution of SQL statement from
      a GET with the content encoded on the URI (as from XMLHTTPRequest)
    - new TSQLRest.EngineUpdateField protected method for a field content update
      (with PUT ModelRoot/TableName?setname=..&set=..&wherename=..&where=..)
    - new TSQLRecord.CreateAndFillPrepareMany and FillPrepareMany methods, able
      to create a JOINed SELECT statement including all nested TSQLRecordMany
      properties (including custom WHERE clause if necessary)
    - now nested TCollection and TStringList/TRawUTF8List objects are
      transmitted as true JSON arrays or objects for adding (POST) and update
      (PUT) - this will save bandwidth and increase compatibility
      with AJAX clients (they were formerly transmitted as JSON strings) - note
      that retrieval (GET) is not yet implemented, since it is faster to transmit
      directly the TEXT value as stored within the database
    - new TSQLRest.MainFieldIDs() method
    - new ForceID parameter for TSQLRest.Add() and TSQLRestClientURI.BatchAdd()
      to allow adding a record with a given ID
    - added TSQLRestClientURI.OnSetUser notification event (called from SetUser)
    - now TSQLRestClientURI.BatchUpdate() will set only ID, TModTime and mapped
      fields when called over a TSQLRecord on which a FillPrepare() was made
      (and no FillClose was performed)
    - now TSQLRestServerStats is a plain TPersistent class, and will be sent
      as a JSON object to the client
    - added function IsNotAjaxJSON() function - formerly internal IsExpanded()
    - added RecordManySourceProp / RecordManyDestProp / RecordManySourceClass /
      RecordManyDestClass to the TSQLRecordProperties
    - TSQLRestClientURI.CallBackPut() will now return any HTTP response content
      (even if it is not HTTP/1.1 compliant, and not work over some networks)
    - circumvent some bugs of Delphi XE2 background compiler (main compiler is OK)

  Version 1.17
    - TSQLRecord.Create/FillPrepare/CreateAndFillPrepare and
      TSQLRest.OneFieldValue/MultiFieldValues methods signature BREAKING CHANGE:
      array of const used to be ParamsSQLWhere and expecting '%' in the
      FormatSQLWhere statement, is now called BoundsSQLWhere, and expects bound
      parameters specified as '?' in the FormatSQLWhere statement - this is less
      confusing for new users, and more close to the usual way of preparing
      database queries; but your existing user code SHALL BE CHECKED and fixed
    - fixed issue in TSQLTable.GetJSONValues about JSON number encoding
    - added optional "rowCount": in TSQLRestServerStaticInMemory.GetJSONValues,
      TSQLTable.GetJSONValues and in TSQLTableJSON.ParseAndConvert for about
      5% faster process of huge content (mpv proposal)
    - major speedup of TSQLTableJSON.Create(): buffer hashing by-passed until
      TSQLTableJSON.UpdateFrom() method is effectively called
    - fixed issue about BLOB unproperly serialized into JSON (e.g. now uses null)
    - fixed issue about harcoded 'ID' column, not compatible with virtual tables
    - fixed issue about pessimistic TSQLRestServerStaticInMemory.fIDSorted value
    - fixed ticket [fdf7158601] - about incorrect null value parsing in
      JSONToObject when isObj = oCustom (fix by mpv - thanks!)
    - fixed ticket [a1d9e9148e] - about incorrect reading empty JSON object by
      JSONToObject (fix by mpv - thanks!)
    - fixed ticket [4f5df7f18f] - about potential overflow of TSQLRestServerStats
      values (changed to QWord kind of property)
    - implemented feature request [7f6828999d] - about the possibility to use
      standard read/write in conjunction with custom read/write in JSONToObject
      and ObjectToJSON (mpv proposal - thanks!)
    - JSONToObject is now able to un-serialize a TObjectList class, when a class
      for its items is supplied as TObjectListItemClass optional parameter
    - ExtractInlineParameters() and SQLParamContent() decode ':("\uFFF12012-05-04"):'
      inlined parameters (i.e. text starting with JSON_SQLDATE_MAGIC after UTF-8
      encoding) as sftDateTime kind of parameter
    - added TJSONObjectDecoder.DecodedRowID member and fix GPF issue in Decode()
    - change vague boolean parameter into a TSQLOccasion enumerate in
      TJSONObjectDecoder.EncodeAsSQLPrepared()
    - added ForceID: boolean parameter to TSQLRest.AddOne() method
    - fixed random issue in TSQLRest.GetServerTimeStamp method (using wrongly
      TTimeLog direct arithmetic, therefore raising EncodeTime() errors)
    - internal cache added in TSQLRest.GetServerTimeStamp method for better speed
    - added TSQLRest.Retrieve() overloaded method for easy parameter binding
    - added TSQLRest.Delete() overloaded method with a WHERE clause parameter
    - implemented transaction process for (external database) virtual tables
    - added ReplaceRowIDWithID optional parameter to GetJSONObjectAsSQL(), in
      order to allow working with external DB not allowing RowID (e.g. Oracle)
    - TSQLRestCache.Notify*() methods made public for low-level potential use
    - made URI check case-insensitive (as for official RFC)
    - new TPropInfo.GetHash and TPropInfo.SameValue methods, with optional
      case sentivity handling
    - changed TSQLRecordProperties.BlobFieldsBits property into BlobFields,
      as an array of PPropInfo (for faster process)
    - added TSQLRecordProperties.HasTypeFields containing set of field types
      appearing in the record - replaces HasModTimeFields and HasCreateTimeField
    - new TListFieldHash class for efficient O(1) search using hashing handling
    - now unique fields are hashed in TSQLRestServerStaticInMemory implementation:
      "stored: false" properties are now checked for unicity before adding or
      update, and search will use the hash table for very fast O(1) process
    - speed optimization: all TSQLRestServerStaticInMemory search methods will
      now call a generic FindWhereEqual() for better code speed and maintenance
    - added ObjectFromInterface() function working also with TInterfacedObjectFake
    - introducing SetWeak() function to handle Weak interface assignment
    - added SetWeakZero() function and TObject class helper to handle ZEROed
      Weak interface assignment (with small performance penalty and memory use),
      corresponding to the ARC's Zeroing Weak pointers model
    - CopyObject() procedure now handle TCollection kind of object not only
      as sub properties
    - introducing TInterfacedCollection dedicated class, properly handling
      collection item creation on the Server side, with interface-based services:
      all contract operations shall use it instead of TCollection
    - changed the non expanded JSON format to use lowercase first column names:
      {"fieldCount":1,"values":["col1"... instead of {"FieldCount":1,"Values":[..
    - added TSQLTable.FieldLengthMax() and ExpandAsSynUnicode() methods
    - added BlobToBytes() function and TSQLTable.GetBytes/GetStream methods
    - added virtual TSQLRestServer.FlushInternalDBCache method and dedicated
      TSQLRestServerStaticInMemoryExternal class, to properly handle external
      DB modification for virtual tables (i.e. flush SQL/JSON cache as expected)
    - added virtual TSQLRestServer.BeginCurrentThread method 
    - added virtual TSQLRestServer.EndCurrentThread method which will be called
      e.g. by TSQLite3HttpServer or TSQLRestServerNamedPipeResponse for each
      terminating threads, to release any thread-specific resources (like
      external DB connections defined in SQlite3DB)
    - added new TServiceMethod.ExecutionOptions member, and the new
      TServiceMethodExecutionOption[s] types - used by ExecuteInMainThread()
    - added TServiceFactoryServer.ExecuteInMainThread() method, to force a method
      to be executed with RunningThread.Synchronize() call on multi-thread server
      instances (e.g. TSQLite3HttpServer or TSQLRestServerNamedPipeResponse)
    - refactoring of TServiceMethod.InternalExecute low-level asm code, and
      changed the Instance parameter to be specified as an open array for
      fast execution over multiple instances of implementation classes
    - 'SELECT *' statements on virtual/external tables will by-pass the SQLite3
      virtual table module: TSQLRecord.FillPrepare can be up to 30% faster -
      added TSQLRestServerStatic.AdaptSQLForEngineList virtual method to
      handle most generic SELECT cases (overriden e.g. in SQLite3DB unit)
    - TSQLRestServerStaticInMemory.GetJSONValues will now generate expanded
      JSON content, if specified (only non-expanded format was implemented),
      via the new TSQLRestServerStaticInMemory.ExpandedJSON property
    - added TSQLRestServerStatic.InternalBatchStart / InternalBatchStop methods
      to handle fast grouped sending to remote database engine (e.g. Oracle
      bound arrays or MS SQL bulk insert via SynDB)
    - fixed issue in TSQLRestClientURI.EngineAdd() when server returned -1
    - changed TSQLRestServerCallBackParams content to be used as a generic
      parameters wrapper for both method callbacks and interface-based services:
      now aParams.Context.ID is to be used insted of aParams.ID
    - added TJSONObjectDecoder record/object helper for JSON object decoding
      (used e.g. by GetJSONObjectAsSQL() function, and for SQlite3DB process)
    - removed TSQLRecordExternal class type, to allow any TSQLRecord (e.g.
      TSQLRecordMany) to be used with VirtualTableExternalRegister() - there was
      indeed no implementation requirement to force a specific class type
    - added aUseBatchMode optional parameter to TSQLRecordMany.ManyDelete() method
    - now JSON parser will handle #1..' ' chars as whitespace (not only ' ')
    - now huge service JSON response is truncated (to default 20 KB) in logs

  Version 1.18
    - full Windows 64 bit compatibility, including RTTI and services
    - renamed SQLite3Commons.pas to mORMot.pas
    - BREAKING CHANGE in TSQLRestServerCallBackParams use: all method-based
      services should now be a procedure, and use Ctxt.Results()/Error()
      methods to return the content - new definition of Ctxt features now
      full access to incoming/outgoing context and parameters, especially via
      the new Input*[] properties, for easy URI parameter retrieval
    - BREAKING CHANGE of TJSONWriter.WriteObject() method and ObjectToJSON()
      function: serialization is now defined with TTextWriterWriteObjectOptions
      set - therefore, TJSONSerializerCustomWriter callback signature changed
    - changed RESTful URI to ModelRoot/Table?where=WhereClause to delete members
    - added TSQLRestServer.URIPagingParameters property, to support alternate
      URI parameters sets for request paging (in addition to YUI syntax),
      and an optional "total":... field within the JSON result (calling
      "SELECT count()" may be slow, especially on external databases)
    - deep code refactoring, introducing TSQLPropInfo* classes in order to
      decouple the ORM definitions from the RTTI - will allow definition of
      any class members, even if there is no RTTI generated or via custom
      properties attributes or a fluent interface
    - new TJSONSerializer.RegisterClassForJSON() methods, allowing recognition
      of class types from a new {"ClassName":"TMyObject" JSON field generated
      by ObjectToJSON(..[woStoreClassName]) new option: it will be recognized
      by JSONToObject() for TObjectList members, and by the new JSONToNewObject()
      method - all TSQLRecord classes of a model are automaticaly registered
    - new TJSONSerializer.RegisterCollectionForJSON() method, to register a
      TCollection/TCollectionItem pair and allow JSON serialization of any
      "plain" collection - may be a good alternative to TInterfacedCollection
    - interface-based services are now able to work with TObjectList parameters
    - new TSQLRest.Service<T: IInterface> method to retrieve a service instance
    - method-based services are now able to handle "304 Not Modified" optimized
      response to save bandwith, in TSQLRestServerCallBackParams.Returns/Results
    - ServiceContext threadvar will now be available also for optExecInMainThread
    - added TSQLRestClientURI.SessionID property
    - fixed TServiceFactoryClient.Get() not working properly in sicPerSession,
      sicPerUser or sicPerGroup modes - ticket [3fafb53be4]
    - added TServiceInstanceImplementation.sicPerThread mode - feature [cb76c866bb]
    - new function CurrentServiceContext, to be used from packages instead of
      direct ServiceContext threadvar access - circumvent Delphi RTL/compiler
      restriction (bug?) as reported by [155b09dc1b] 
    - introduced more readable "stored AS_UNIQUE" published property definition
      in TSQLRecord (via the explicit AS_UNIQUE=false constant)
    - introduced 32bit/64bit safe TSQLRecord.AsTSQLRecord property, to be used
      when assigning IDs to a TSQLRecord published property
    - introducing TInterfaceStub and TInterfaceMock classes to define
      high-performance interface stubbing and mocking via a fluent interface
    - integrated Windows Authentication to the mORMot Client-Server layer: in
      order to enable it, define a SSPIAUTH conditional and call
      TSQLRestClientURI.SetUser() with an empty user name, and ensure that
      TSQLAuthUser.LoginName contains a matching 'DomainName\UserName' value
    - TSQLRestServer.URI() method uses now one TSQLRestServerURIParams parameter
    - TSQLRestServer.URI() method will return "405 Method Not Allowed" error
      (HTML_NOTALLOWED) if the supplied URI does not match RestAccessRights
    - enhanced sllAuth session creation/deletion logged information
    - added TAuthSession.SentHeaders, RemoteIP and ConnectionID properties
    - added process of Variant and WideString types in TSQLRecord properties
    - added JSON serialization of Variant and WideString types in JSONToObject()
      / ObjectToJSON() functions and WriteObject method
    - added TTypeInfo.ClassCreate() method to create a TObject instance from RTTI
    - added ClassInstanceCreate() function calling any known virtual constructor
    - added TPropInfo.ClassFromJSON() to properly unserialize TObject properties
    - added TSQLPropInfo.SQLFieldTypeName property
    - fixed [f96cf0fc5d] and [221ee9c767] about TSQLRecordMany JSON serialization
    - fixed TInterfacedCollection.GetClass to be defined as a class function
    - TSQLRestClientURINamedPipe and TSQLRestClientURIMessage are now thread-safe
      (i.e. protected by a system mutex) therefore can be called from a
      multi-threaded process, e.g. TSQLRestServer instances as proxies
    - modified named pipe client side to avoid unexpected file not found errors
    - TInterfaceFactory instances are now shared among all interface-based
      features (e.g. services, callbacks or mocks/stubs), in a thread-safe cache
    - added dedicated EInterfaceFactoryException
    - TServiceFactoryServer.ExecuteInMainThread() method is now replaced by
      a more generic TServiceFactoryServer.SetOptions() method
    - new optFreeInMainThread execution options for the service, allowing server
      side service class instance release via Synchronize() - ticket [57bea48f30]
    - new TInterfaceFactory.CreateFakeInstance() method for easy mocking of
      any interface, via some event callbacks
    - stub creation speed-up by using a shared PAGE_EXECUTE_READWRITE buffer
    - added TServiceMethod.DefaultResult property, to be used for stubs/mocks
    - TServiceFactory.Create() and its children will now always have an optional
      aContractExpected parameter (for consistency with TServiceFactoryClient)
    - introduce smvVariant kind of parameter for interface-based services
    - new RawJSON string type to force no JSON serialization in interface-based
      services (to be used e.g. for transmitting TSQLTableJSON results)
    - safer TInterfacedObjectFake.FakeCall() stack use
    - TServiceFactoryServerInstance will now create instances server-side
      with a RefCount=1, to allow passing self as an interface in sub-methods
    - huge code refactoring of the ORM model implementation: a new dedicated
      TSQLModelRecordProperties will contain per-TSQLModel parameters, whereas
      shared information retrieved by RTTI remain in TSQLRecordProperties - this
      will allow use of the same TSQLRecord in several TSQLModel at once, with
      dedicated SQL auto-generation and external DB settings
    - added aExternalTableName/Database optional parameters to method
      TSQLModel.VirtualTableRegister()
    - added Owner, Actions, Events parameters to TSQLModel.Create() constructor
    - fixed issue in TSQLRestServer.Create() about authentication enabling
    - added TSQLModel.GetTableIndexExisting() method to raise an explicit
      EModelException if the table is not part of the model - used now by
      almost all CRUD Client and Server operations - ticket [aa0d6f1e90]
    - added TSQLModel.URIMatch() method to allow sub-domains generic matching
      at database model level (so that you can set root='/root/sub1' URIs)
    - moved SQLFromSelectWhere() from a global function to a TSQLModel method
      (to prepare "Table per class hierarchy" mapping in mORMot)
    - SQLParamContent() / ExtractInlineParameters() functions moved to SynCommons
    - TSQLAuthUser and TSQLAuthGroup have now "index ..." attributes to their
      RawUTF8 properties, to allow direct handling in external databases
    - new protected TSQLRestServer.InternalAdaptSQL method, extracted from URI()
      process to also be called by TSQLRestServer.InternalListJSON() for proper
      TSQLRestServerStatic.AdaptSQLForEngineList(SQL) call
    - new protected TSQLRestServer.InternalUpdateEvent virtual method, to allow
      a server-wide update notification, not coupled to OnUpdateEvent callback -
      see feature request [5688e97251]
    - TSQLRestServerStaticInMemory.AdaptSQLForEngineList() will now handle
      'select count(*') from TableName' statements directly
    - changed TSQLAccessRights and TSQLAuthGroup.SQLAccessRights CSV format
      to use 'first-last,' pattern to regroup set bits (reduce storage size)
    - added overloaded TSQLAccessRights.Edit() method using TSQLOccasions set
    - added reOneSessionPerUser kind of remote execution in TSQLAccessRight
    - introducing TSQLRestClientURI.InternalCheckOpen/InternalClose methods to
      properly handle remote connection and re-connection
    - added TSQLRestClientURI.LastErrorCode/LastErrorMessage/LastErrorException
      properties, to retrieve additional information about remote URL() execution
    - added TSQLRestClientURI.ServiceRegister() and ServiceRegisterClientDriven()
      methods for easier Client-side interface-based services initialization
    - added JSONFileToObject() and ObjectToJSONFile() functions
    - unit interface deep refactoring: e.g. now TSQLTable will refers explicitly
      to TSQLRecord classes and not to plain TClass (e.g. for QueryTables[])
    - added TSQLTable.SortFields() overloaded method, able to sort a TSQLTable
      row content by multiple fields - implements feature request [d277153f03]
    - added optional CustomCompare: TUTF8Compare param to TSQLTable.SortFields()
      to allow any kind of custom ordering - feature request [c6804d48a4]
    - speed up of TSQLTable.FieldIndex() method (using binary search)
    - added TSQLTable.ToObjectList() and ToObjectList<T: TSQLRecord>() methods
    - added TSQLTable.Step(), FieldBuffer() and Field() methods, handling a
      cursor at TSQLTable level, with optional late-binding column access
    - added TSQLTable.GetSynUnicode() method
    - added TSQLRecord.CreateAndFillPrepare(aJSON) overloaded method
    - added TSQLRestClientURI.ServerTimeStampSynchronize method to force time
      synchronization with the server - can be handy to test the connection 
    - added TSQLRest.TableHasRows/TableRowCount methods, and overriden direct
      implementation for TSQLRestServer/TSQLRestServerStaticInMemory (including
      SQL pattern recognition for TSQLRestServerStaticInMemory)
    - added TSQLRest.RetrieveList method to retrieve a TObjectList of TSQLRecord
    - "rowCount": is added in TSQLRestServerStaticInMemory.GetJSONValues,
      TSQLTable.GetJSONValues and in TSQLTableJSON.ParseAndConvert, at the end
      of the non expanded JSON content, if needed - improves client performance
    - UpdateBlobFields() and RetrieveBlobFields() methods are now defined at
      TSQLRest level, with dedicated implementation for TSQLRestClient* and
      TSQLRestServer* classes - implements feature request [34664934a9]
    - fixed TSQLRestServerStaticInMemory.UpdateBlobFields() to return true
      if no BLOB field is defined (as with TSQLRestServer) - ticket [bfa13889d5]
    - fixed issue in TSQLRestServerStaticInMemory.GetJSONValues(), and handle
      optional LIMIT clause in this very same method
    - fixed unexpected issue in TSQLRestClientURI.BatchSend() when nothing is
      to be sent
    - fix potential GDI handle resource leak in TSQLRestClientURIMessage.Create
    - added TInterfacedObjectWithCustomCreate kind of class, making easy to
      use virtual constructors for TSQLRestServer.ServiceRegister()
    - allow TSQLRestServer.ExportServerMessage to be started in conjunction
      with other protocols (like named pipes)
    - now TSQLRestServerStats.ClientsMax/ClientsCurrent will reflect session
      authentication process  
    - fixed potential errors JSON generation issue in TSQLRestServer.URI
      (ticket [b0e9116aeb])
    - fixed ticket [fdc1764f97]: GPF issue in TSQLRestServer.LaunchCallBack()
    - fixed ticket [a5e3564e48] about RecordRef typecast (and enhance comments)
    - fixed ticket [4f4dd18ad9] about TPropInfo.IsStored not handling methods
      callbacks, e.g. for TPersistent storage
    - fixed ticket [21c2d5ae96] when inserting/updating blob-only table content
    - fixed ticket [28545a4ce0] about TSQLRestServerStaticInMemory.EngineDelete
      not thread-safe when run directly on server side
    - added TSQLRecordProperties.SimpleFieldsCount[] array
    - added TSQLRecordProperties.SetCustomCollationForAllRawUTF8() +
      SetCustomCollation() methods, and TSQLModel.SetCustomCollationForAllRawUTF8()
      to implement ticket [bfdc198e70]
    - fixed issue in TSQLRecordProperties.SetSimpleFieldsExpandedJSONWriter()
      when the record contains some TCreateTime published field type
    - added TSQLTable.GetAsInt64() method (proposal [3bea5d89c6])
    - JSON parsing will now expect true, false or null to be in lowercase
      (as in json.org specifications)
    - SetWeakZero() function will now use a much faster per-class lock design
    - exposed StatusCodeToErrorMsg() function
    - extraction of TTestLowLevelTypes and TTestBasicClasses code into
      SynSelfTests.pas unit
    - allow only to delete its own session - security fix for ticket [7723fa7ebd]
    - fix TSQLRestClientURI.Commit/RollBack to work as expected

*)


{$I Synopse.inc} // define HASINLINE USETYPEINFO CPU32 CPU64

{.$define PUREPASCAL}  // define for debugg, not on production
{.$define USETYPEINFO} // define for debugg, not on production

{$ifdef MSWINDOWS}

  {.$define ANONYMOUSNAMEDPIPE}
  // if defined, the security attributes of the named pipe will use an
  // anonymous connection - it should allow access to a service initialized
  // named pipe on a remote computer.
  // - I tried to implement the code as detailed in this Microsoft article:
  // http://support.microsoft.com/kb/813414 but it didn't work as
  // expected: see our forum http://synopse.info/forum/viewtopic.php?id=43
  // - don't define it, because it's still buggy, and consider using HTTP
  // connection for remote access over the network
    {$define NOSECURITYFORNAMEDPIPECLIENTS}
    // define this may avoid issues with Delphi XE+ for obscure reasons


  {$define SSPIAUTH}
  // if defined, the Windows built-in authentication will be used
  // along with the usual one
  // - If you pass to TSQLRestClientURI.SetUser an empty string as user name,
  // the Windows authentication will be performed
  // - In this case, in table TSQLAuthUser should be an entry for the
  // windows user, with the LoginName in form 'DomainName\UserName'

{$endif}


interface

uses
{$ifdef MSWINDOWS}
  Windows,
  Messages,
{$endif}
{$ifdef LINUX} // for Kylix
  Libc,
  Types,
{$endif}
{$ifdef UNICODE}
  Generics.Collections,
{$endif}
  Classes,
  SynZip, // use crc32 for internal TDynArray hasher + TSQLRestClientURI.SetUser
{$ifdef USETYPEINFO}
  // some pure pascal version must handle the 64-bits ordinal values or
  // a not-Delphi RTTI layout of the underlying compiler (e.g. FPC)
  TypInfo,
{$endif}
{$ifndef LVCL}
  Contnrs, // for TObjectList
  {$ifdef USEVARIANTS}
    Variants,
  {$endif}
{$endif}
  SysUtils,
{$ifdef SSPIAUTH}
  SynSSPIAuth,
{$endif}
  SynCommons;



{ ************ low level types and constants for handling JSON and fields }

  { Why use JSON? (extracted from the main framework documentation)
    - The JavaScript Object Notation (JSON) is a lightweight computer data
     interchange format
    - Like XML, it's a text-based, human-readable format for representing
     simple data structures and associative arrays (called objects)
    - It's easier to read, quicker to implement and smaller in size than XML
    - It's a very efficient format for cache
    - It's natively supported by the JavaScript language, making it a perfect
     serialization format for any Ajax application
    - The JSON format is specified in http://tools.ietf.org/html/rfc4627
    - The default text encoding for both JSON and SQLite3 is UTF-8, which
     allows the full Unicode charset to be stored and communicated
    - It is the default data format used by ASP.NET AJAX services created in
     Windows Communication Foundation (WCF) since .NET framework 3.5
    - For binary blob transmission, we simply encode the binary data as hexa
     using the SQLite3 BLOB literals format : hexadecimal data preceded by
     a single "x" or "X" character (for example: X'53514C697465'), or Base64
     encoding - see BlobToTSQLRawBlob() function }


{.$define PUBLISHRECORD}
// - if defined, a sftBlobRecord will be defined in order to serialize published
// properties with some record type: but even if such properties can be defined,
// there is no RTTI generated for them: so it won't work :( see
// http://docwiki.embarcadero.com/RADStudio/en/Classes_and_Objects#Published_Members
// - should be defined globaly, e.g. in Synopse.inc

const
  /// maximum number of Tables in a Database Model
  // - this constant is used internaly to optimize memory usage in the
  // generated asm code
  // - you should not change it to a value lower than expected in an existing
  // database (e.g. as expected by TSQLAccessRights or such)
  MAX_SQLTABLES = 256;


type
  /// used to store bit set for all available Tables in a Database Model
  TSQLFieldTables = set of 0..MAX_SQLTABLES-1;

  /// a String used to store the BLOB content
  // - equals RawByteString for byte storage, to force no implicit charset
  // conversion, thatever the codepage of the resulting string is
  // - will identify a sftBlob field type, if used to define such a published
  // property
  // - by default, the BLOB fields are not retrieved or updated with raw
  // TSQLRest.Retrieve() method, that is "Lazy loading" is enabled by default
  // for blobs, unless TSQLRestClientURI.ForceBlobTransfert property is TRUE;
  // so use RetrieveBlob() methods for handling BLOB fields
  TSQLRawBlob = type RawByteString;

  /// a reference to another record in any table in the database Model
  // - stored as an 32 bits unsigned integer (i.e. a pointer=TObject)
  // - type cast any value of TRecordReference with the RecordRef object below
  // for easy access to its content
  // - use TSQLRest.Retrieve(Reference) to get a record value
  // - don't change associated TSQLModel tables order, since TRecordReference
  // depends on it to store the Table type in its highest bits
  TRecordReference = type PtrUInt;

  /// an Int64-encoded date and time of the latest update of a record
  // - can be used as published property field in TSQLRecord for sftModTime
  // - use internally for computation an abstract "year" of 16 months of 32 days
  // of 32 hours of 64 minutes of 64 seconds - same as Iso8601ToSeconds()
  // - type cast any value of TModTime/TCreateTime/TTimeLog with the Iso8601
  // object below for easy access to its content
  TModTime = type TTimeLog;

  /// an Int64-encoded date and time of the record creation 
  // - can be used as published property field in TSQLRecord for sftCreateTime
  // - use internally for computation an abstract "year" of 16 months of 32 days
  // of 32 hours of 64 minutes of 64 seconds - same as Iso8601ToSeconds()
  // - type cast any value of TModTime/TCreateTime/TTimeLog with the Iso8601
  // object below for easy access to its content
  TCreateTime = type TTimeLog;

  /// the available types for any SQL field property, as managed with the
  // database driver
  TSQLFieldType = (
    /// unknown or not defined field type
    sftUnknown,
    /// a WinAnsi encoded TEXT: force a NOCASE collation
    // (TSQLRecord Delphi property was declared as AnsiString or string before
    // Delphi 2009)
    sftAnsiText,
    /// UTF-8 encoded TEXT: force a SYSTEMNOCASE collation, i.e. using UTF8IComp()
    // (TSQLRecord property was declared as RawUTF8, RawUnicode or WideString -
    // or string in Delphi 2009+)
    sftUTF8Text,
    /// an INTEGER value corresponding to an index in any enumerate Delphi type
    // - storage is an INTEGER value (fast, easy and storage efficient)
    // - display convert this integer index into the left-trimed lowercased chars
    // of the enumerated type text conversion: TOpenType(1) = otDone -> 'Done'
    sftEnumerate,
    // an INTEGER value corresponding to a bitmaped set of enumeration
    // - storage is an INTEGER value (fast, easy and storage efficient)
    // - displayed as an integer by default
    // - sets with an enumeration type with up to 32 elements is allowed 
    sftSet,
    /// an INTEGER (Int64 precision, as expected by SQLite3) field
    sftInteger,
    /// an INTEGER field pointing to the ID/ROWID of another record of a table
    // defined by the class type of the TSQLRecord inherited property
    // - coherency is always ensured: after a delete, all values pointing to
    // it is reset to 0
    sftID,
    /// an INTEGER field pointing to the ID/ROWID of another record
    // (TRecordReference=PtrUInt Delphi property which can be typecasted to RecordRef)
    // - coherency is always ensured: after a delete, all values pointing to
    // it is reset to 0
    sftRecord,
    /// an INTEGER field for a boolean value: 0 is FALSE, anything else TRUE
    // (encoded as JSON 'true' or 'false' constants)
    sftBoolean,
    /// a FLOAT (floating point double precision, cf. SQLite3) field
    sftFloat,
    /// a ISO 8601 encoded TEXT field - SQLite3 compatible;
    // - a ISO8601 collation is forced 
	// - corresponds to a TDateTime Delphi property
    sftDateTime,
    /// an INTEGER field for coding a date and time - not SQLite3 compatible
    // - TTimeLog=Int64 Delphi property which can be typecasted to Iso8601
    sftTimeLog,
    /// a FLOAT containing a 4 decimals floating point value
    // (Currency Delphi property minimizes rounding errors in monetary
    // calculations which may occur with sftFloat type)
    sftCurrency,
    /// a TEXT containing an ObjectToJSON serialization
    // - able to handle published properties of any not TPersistent as JSON object,
    // TStrings or TRawUTF8List  as JSON arrays of strings, TCollection or
    // TObjectList as JSON arrays of JSON objects
    sftObject,
    {$ifdef USEVARIANTS}
    /// a TEXT containing a variant value encoded as JSON
    // - string values are stored between quotes, numerical values directly
    sftVariant,
    {$endif}
    /// a BLOB field (TSQLRawBlob Delphi property)
    // - not retrieved by default
    sftBlob,
    /// a dynamic array, stored as BLOB field
    // - is retrieved by default, i.e. is recognized as a "simple" field
    // - will use Base64 encoding in JSON content
    sftBlobDynArray,
    /// a custom property, stored as BLOB field
    // - defined by overriding TSQLRecord.InternalRegisterCustomProperties
    // virtual method, and adding a TSQLPropInfoCustom instance
    sftBlobCustom,
    /// a custom property, stored as TEXT field
    // - defined by overriding TSQLRecord.InternalRegisterCustomProperties
    // virtual method, and adding a TSQLPropInfoCustom instance
    sftUTF8Custom,
    {$ifdef PUBLISHRECORD}
    /// a Delphi record, stored as BLOB field
    // - is retrieved by default, i.e. is recognized as a "simple" field
    // - will use Base64 encoding in JSON content
    sftBlobRecord,
    {$endif PUBLISHRECORD}
    /// a 'many to many' field (TSQLRecordMany Delphi property)
    // - nothing is stored in the table row, but in a separate pivot table: so
    // there is nothing to retrieve here
    // - in contrast to other TSQLRecord properties, which contains an INTEGER
    // ID, the TSQLRecord.Create will instanciate a TSQLRecordMany instance
    // to handle this pivot table via its dedicated ManyAdd/FillMany/ManySelect methods
    sftMany,
    /// an INTEGER field containing the TModTime time of the record latest update
    // - TModTime=TCreateTime=TTimeLog=Int64 Delphi property which can be
    // typecasted to Iso8601
    // - the value of this field is automatically updated with the current
    // date and time each time a record is updated (with external DB, it will
    // use the Server time, as retrieved from SynDB) - see ComputeFieldsBeforeWrite
    // virtual method of TSQLRecord
    // - note only RESTful PUT/POST access will change this field value: manual
    // SQL statements (like 'UPDATE Table SET Column=0') won't change its content
    // - note also that this is automated on Delphi client side, so only within
    // TSQLRecord ORM use (an AJAX application should handle this explicitely)
    sftModTime,
    /// an INTEGER field containing the TCreateTime time of the record creation
    // - TModTime=TCreateTime=TTimeLog=Int64 Delphi property which can be
    // typecasted to Iso8601
    // - the value of this field is automatically updated with the current
    // date and time when the record is created (with external DB, it will
    // use the Server time, as retrieved from SynDB) - see ComputeFieldsBeforeWrite
    // virtual method of TSQLRecord
    // - note only RESTful PUT/POST access will set this field value: manual
    // SQL statements (like 'INSERT INTO Table ...') won't set its content
    // - note also that this is automated on Delphi client side, so only within
    // TSQLRecord ORM use (an AJAX application should handle this explicitely)
    sftCreateTime);

  /// set of available SQL field property types
  TSQLFieldTypes = set of TSQLFieldType;

  //// a fixed array of SQL field property types
  TSQLFieldTypeArray = array[0..MAX_SQLFIELDS] of TSQLFieldType;

  /// contains the parameters used for sorting
  // - FieldCount is 0 if was never sorted
  // - used to sort data again after a successfull data update with TSQLTableJSON.FillFrom()
  TSQLTableSortParams = record
    FieldCount, FieldIndex: integer;
    FieldType: TSQLFieldType;
    Asc: boolean;
  end;

  /// used to define the triggered Event types for TNotifySQLEvent
  // - some Events can be trigerred via TSQLRestServer.OnUpdateEvent when
  // a Table is modified, and actions can be authorized via overriding the
  // TSQLRest.RecordCanBeUpdated method
  // - OnUpdateEvent is called BEFORE deletion, and AFTER insertion or update; it
  // should be used only server-side, not to synchronize some clients: the framework
  // is designed around a stateless RESTful architecture (like HTTP/1.1), in which
  // clients ask the server for refresh (see TSQLRestClientURI.UpdateFromServer)
  // - is used also by TSQLRecord.ComputeFieldsBeforeWrite virtual method
  TSQLEvent = (
    seAdd,
    seUpdate,
    seDelete);

  /// used to defined the CRUD associated SQL statement of a command
  // - used e.g. by TSQLRecord.GetJSONValues methods and SimpleFieldsBits[] array
  // (in this case, soDelete is never used, since deletion is global for all fields)
  // - also used for cache content notification
  TSQLOccasion = (
    soSelect,
    soInsert,
    soUpdate,
    soDelete);

  /// used to defined a set of CRUD associated SQL statement of a command
  TSQLOccasions = set of TSQLOccasion;

const
  /// kind of fields not retrieved during normal query, update or adding
  NOT_SIMPLE_FIELDS: TSQLFieldTypes =
    [sftUnknown, sftBlob, sftMany];

  /// kind of fields which can be copied from one TSQLRecord instance to another
  COPIABLE_FIELDS: TSQLFieldTypes =
    [low(TSQLFieldType)..high(TSQLFieldType)] - [sftUnknown, sftMany];

  /// kind of fields which will contain TEXT content when converted to JSON
  TEXT_FIELDS: TSQLFieldTypes =
    [sftAnsiText, sftUTF8Text, sftDateTime, sftObject
      {$ifdef USEVARIANTS}, sftVariant{$endif}];

type
  TJSONObjectDecoderParams = (pInlined, pQuoted, pNonQuoted);
  
  /// record/object helper to handle JSON object decoding
  // - used e.g. by GetJSONObjectAsSQL() function
  TJSONObjectDecoder = {$ifdef UNICODE}record{$else}object{$endif}
    /// contains the decoded field names or value
    FieldNames, FieldValues: array[0..MAX_SQLFIELDS-1] of RawUTF8;
    /// Decode() will set a bit for each field set JSON null value
    FieldNull: TSQLFieldBits;
    /// number of fields decoded in FieldNames[] and FieldValues[]
    FieldCount: integer;
    /// size of the TEXT data (in bytes) in FieldValues[]
    FieldLen: integer;
    /// set to TRUE if parameters are to be :(...): inlined
    InlinedParams: boolean;
    /// internal pointer over field names to be used after Decode() call
    // - either FieldNames, either Fields[] array as defined in Decode()
    DecodedFieldNames: PRawUTF8Array;
    /// the ID=.. value as sent within the JSON object supplied to Decode()
    DecodedRowID: integer;
    /// decode the JSON object fields into FieldNames[] and FieldValues[]
    // - if Fields=nil, P should be a true JSON object, i.e. defined
    // as "COL1"="VAL1" pairs, stopping at '}' or ']'; otherwise, Fields[]
    // contains column names and expects a JSON array as "VAL1","VAL2".. in P
    // - P returns the next object start or nil on unexpected end of input
    // - if InlineParams is TRUE, FieldValues[] strings will be quoted
    // - if RowID is set, a RowID column will be added within the returned content
    procedure Decode(var P: PUTF8Char; const Fields: TRawUTF8DynArray;
      Params: TJSONObjectDecoderParams; RowID: integer=0; ReplaceRowIDWithID: Boolean=false); overload;
    /// decode the JSON object fields into FieldNames[] and FieldValues[]
    // - overloaded method expecting a RawUTF8 buffer, calling Decode(P: PUTF8Char)
    procedure Decode(JSON: RawUTF8; const Fields: TRawUTF8DynArray;
      Params: TJSONObjectDecoderParams; RowID: Integer=0; ReplaceRowIDWithID: Boolean=false); overload;
    /// encode as a SQL-ready INSERT or UPDATE statement
    // - after a successfull call to Decode()
    // - escape SQL strings, according to the official SQLite3 documentation
    // (i.e. ' inside a string is stored as '')
    // - if InlinedParams was TRUE, it will create prepared parameters like
    // 'COL1=:("VAL1"):, COL2=:(VAL2):'
    // - called by GetJSONObjectAsSQL() function
    function EncodeAsSQL(Update: boolean): RawUTF8;
    /// encode as a SQL-ready INSERT or UPDATE statement with ? as values
    // - after a successfull call to Decode()
    // - FieldValues[] content will be ignored
    // - Occasion can be only soInsert or soUpdate
    function EncodeAsSQLPrepared(const TableName: RawUTF8; Occasion: TSQLOccasion): RawUTF8;
    /// set the specified array to the fields names
    // - after a successfull call to Decode()
    procedure AssignFieldNamesTo(var Fields: TRawUTF8DynArray);
    /// returns TRUE if the specified array match the decoded fields names
    // - after a successfull call to Decode()
    function SameFieldNames(const Fields: TRawUTF8DynArray): boolean;
  end;

/// decode JSON fields object into an UTF-8 encoded SQL-ready statement
// - this function decodes in the P^ buffer memory itself (no memory allocation
// or copy), for faster process - so take care that it is an unique string
// - P contains the next object start or nil on unexpected end of input
// - if Fields is void, expects expanded "COL1"="VAL1" pairs in P^, stopping at '}' or ']'
// - otherwize, Fields[] contains the column names and expects "VAL1","VAL2".. in P^
// - returns 'COL1="VAL1", COL2=VAL2' if UPDATE is true (UPDATE SET format)
// - returns '(COL1, COL2) VALUES ("VAL1", VAL2)' otherwize (INSERT format)
// - escape SQL strings, according to the official SQLite3 documentation
// (i.e. ' inside a string is stored as '')
// - if InlinedParams is set, will create prepared parameters like
// 'COL1=:("VAL1"):, COL2=:(VAL2):'
// - if RowID is set, a RowID column will be added within the returned content
function GetJSONObjectAsSQL(var P: PUTF8Char; const Fields: TRawUTF8DynArray;
  Update, InlinedParams: boolean; RowID: Integer=0; ReplaceRowIDWithID: Boolean=false): RawUTF8; overload;

/// decode JSON fields object into an UTF-8 encoded SQL-ready statement
// - expect JSON expanded object as "COL1"="VAL1",...} pairs
// - make its own temporary copy of JSON data before calling GetJSONObjectAsSQL() above
// - returns 'COL1="VAL1", COL2=VAL2' if UPDATE is true (UPDATE SET format)
// - returns '(COL1, COL2) VALUES ("VAL1", VAL2)' otherwize (INSERT format)
// - if InlinedParams is set, will create prepared parameters like 'COL2=:(VAL2):'
// - if RowID is set, a RowID column will be added within the returned content
function GetJSONObjectAsSQL(JSON: RawUTF8; Update, InlinedParams: boolean;
  RowID: Integer=0; ReplaceRowIDWithID: Boolean=false): RawUTF8; overload;

/// get the FIRST field value of the FIRST row, from a JSON content
// - e.g. usefull to get an ID without converting a JSON content into a TSQLTableJSON
function UnJSONFirstField(var P: PUTF8Char): RawUTF8;

/// returns TRUE if the JSON content is in expanded format
// - i.e. as plain [{"ID":10,"FirstName":"John","LastName":"Smith"}...]
// - i.e. not as '{"fieldCount":3,"values":["ID","FirstName","LastName",...']}
function IsNotAjaxJSON(P: PUTF8Char): Boolean;

/// go to the end of a field name in a JSON '"FieldName":Value' pair
// - returns nil if P was not formatted as expected
// - returns the position of Value
function JSONIgnoreFieldName(P: PUTF8Char): PUTF8Char;

/// go to the end of a value in a JSON '"FieldName":Value,' pair
// - returns nil if P was not formatted as expected
// - returns the position of the expected ending ',' or '}' delimiter
function JSONIgnoreFieldValue(P: PUTF8Char): PUTF8Char;

/// go to the end of a JSON '{"Name":Value,....}' object
// - returns nil if P was not formatted as expected
// - returns the position after the expected ending '}' delimiter
function JSONIgnoreObject(P: PUTF8Char): PUTF8Char;

/// retrieve a JSON '{"Name":Value,....}' object
// - P is nil in return in case of an invalid object
// - returns the UTF-8 encoded JSON object, including first '{' and last '}'
// - if ExtractID is set, it will contain the "ID":203 field value, and this
// field won't be included in thre resulting UTF-8 encoded JSON object (will
// expect this "ID" property to be the FIRST in the "Name":Value pairs
function JSONGetObject(var P: PUTF8Char; ExtractID: PInteger;
  var EndOfObject: AnsiChar): RawUTF8;

/// fill a TSQLRawBlob from TEXT-encoded blob data
// - blob data can be encoded as SQLite3 BLOB literals (X'53514C697465' e.g.) or
// or Base-64 encoded content ('\uFFF0base64encodedbinary') or plain TEXT
function BlobToTSQLRawBlob(P: PUTF8Char): TSQLRawBlob;

/// create a TBytes from TEXT-encoded blob data
// - blob data can be encoded as SQLite3 BLOB literals (X'53514C697465' e.g.) or
// or Base-64 encoded content ('\uFFF0base64encodedbinary') or plain TEXT
function BlobToBytes(P: PUTF8Char): TBytes;

/// create a memory stream from TEXT-encoded blob data
// - blob data can be encoded as SQLite3 BLOB literals (X'53514C697465' e.g.) or
// or Base-64 encoded content ('\uFFF0base64encodedbinary') or plain TEXT
// - the caller must free the stream instance after use
function BlobToStream(P: PUTF8Char): TStream;

/// creates a TEXT-encoded version of blob data from a TSQLRawBlob
// - TEXT will be encoded as SQLite3 BLOB literals (X'53514C697465' e.g.)
function TSQLRawBlobToBlob(const RawBlob: TSQLRawBlob): RawUTF8; overload;
  {$ifdef HASINLINE}inline;{$endif}

/// creates a TEXT-encoded version of blob data from a memory data
// - same as TSQLRawBlob, but with direct memory access via a pointer/byte size pair
// - TEXT will be encoded as SQLite3 BLOB literals (X'53514C697465' e.g.)
function TSQLRawBlobToBlob(RawBlob: pointer; RawBlobLength: integer): RawUTF8; overload;

/// convert a Base64-encoded content into binary hexadecimal ready for SQL
// - returns e.g. X'53514C697465'
procedure Base64MagicToBlob(Base64: PUTF8Char; var result: RawUTF8);


/// return true if the TEXT is encoded as SQLite3 BLOB literals (X'53514C697465' e.g.)
function isBlobHex(P: PUTF8Char): boolean; {$ifdef HASINLINE}inline;{$endif}


/// guess the content type of an UTF-8 encoded field value, as used in TSQLTable.Get()
// - if P if nil or 'null', return sftUnknown
// - otherwize, guess its type from its value characters
// - sftBlob is returned if the field is encoded as SQLite3 BLOB literals
// (X'53514C697465' e.g.) or with '\uFFF0' magic code
// - since P is PUTF8Char, string type is sftUTF8Text only
// - sftFloat is returned for any floating point value, even if it was
// declared as sftCurrency type
// - sftInteger is returned for any INTEGER stored value, even if it was declared
// as sftEnumerate, sftSet, sftID, sftRecord, sftBoolean or
// sftModTime / sftCreateTime / sftTimeLog type
function UTF8ContentType(P: PUTF8Char): TSQLFieldType;


/// read an object properties, as saved by TINIWriter.WriteObject() method
// - i.e. only Integer, Int64, enumerates (including boolean), floating point,
// variant and (Ansi/Wide/Unicode)String properties (excluding shortstring)
// - read only the published properties of the current class level (do NOT
// read the properties content published in the parent classes)
// - "From" must point to the [section] containing the object properties
// - for integers and enumerates, if no value is stored in From (or From is ''),
// the default value from the property definition is set
procedure ReadObject(Value: TObject; From: PUTF8Char; const SubCompName: RawUTF8=''); overload;

/// read an object properties, as saved by TINIWriter.WriteObject() method
// - i.e. only Integer, Int64, enumerates (including boolean), floating point values
// and (Ansi/Wide/Unicode)String properties (excluding shortstring)
// - read only the published properties of the current class level (do NOT
// read the properties content published in the parent classes)
// - for integers, if no value is stored in FromContent, the default value is set
// - this version gets the appropriate section from [Value.ClassName]
// - this version doesn't handle embedded objects
procedure ReadObject(Value: TObject; const FromContent: RawUTF8;
  const SubCompName: RawUTF8=''); overload;

/// write an object properties, as saved by TINIWriter.WriteObject() method
// - i.e. only Integer, Int64, enumerates (including boolean), floating point values
// and (Ansi/Wide/Unicode)String properties (excluding shortstring)
// - write only the published properties of the current class level (do NOT
// write the properties content published in the parent classes)
// - direct update of INI-like content
// - for integers, value is always written, even if matches the default value
procedure WriteObject(Value: TObject; var IniContent: RawUTF8;
  const Section: RawUTF8; const SubCompName: RawUTF8=''); overload;

/// write an object properties, as saved by TINIWriter.WriteObject() method
// - i.e. only Integer, Int64, enumerates (including boolean), floating point values
// and (Ansi/Wide/Unicode)String properties (excluding shortstring)
// - write only the published properties of the current class level (do NOT
// write the properties content published in the parent classes)
// - return the properties as text Name=Values pairs, with no section
// - for integers, if the value matches the default value, it is not added to the result
function WriteObject(Value: TObject): RawUTF8; overload;

/// copy object properties
// - copy only Integer, Int64, enumerates (including boolean), object properties
// and (Ansi/Wide/Unicode)String properties (excluding shortstring)
// - TCollection items can be copied also, if they are of the same exact class
// - object properties instances are created in aTo if the objects are not
// TSQLRecord children (in this case, these are not class instances, but
// INTEGER reference to records, so only the integer value is copied), that is
// for regular Delphi classes
procedure CopyObject(aFrom, aTo: TObject);

{$ifndef LVCL}
/// copy two TCollection instances
// - will call CopyObject() in loop to repopulate the Dest collection 
procedure CopyCollection(Source, Dest: TCollection);
{$endif}

/// set any default integer or enumerates (including boolean) published
// properties values for an object
// - reset only the published properties of the current class level (do NOT
// reset the properties content published in the parent classes)
procedure SetDefaultValuesObject(Value: TObject);

/// will serialize any TObject into its UTF-8 JSON representation
/// - serialize as JSON the published integer, Int64, floating point values,
// TDateTime (stored as ISO 8601 text), string, variant and enumerate
// (e.g. boolean) properties of the object (and its parents)
// - won't handle shortstring properties
// - the enumerates properties are stored with their integer index value
// - will write also the properties published in the parent classes
// - nested properties are serialized as nested JSON objects
// - any TCollection property will also be serialized as JSON arrays
// - you can add some custom serializers for ANY Delphi class, via the
// TJSONSerializer.RegisterCustomSerializer() class method
// - call internaly TJSONSerializer.WriteObject() method
function ObjectToJSON(Value: TObject;
  Options: TTextWriterWriteObjectOptions=[woDontStoreDefault]): RawUTF8;

/// encode supplied parameters to be compatible with URI encoding
// - parameters must be supplied two by two, as Name,Value pairs, e.g.
// ! url := UrlEncodeFull(['select','*','where','ID=12','offset',23,'object',aObject]);
// - parameters can be either textual, integer or extended, or any TObject
// (standard UrlEncode() will only handle
// - TObject serialization into UTF-8 will be processed by the ObjectToJSON()
// function
function UrlEncode(const NameValuePairs: array of const): RawUTF8; overload;

/// read an object properties, as saved by ObjectToJSON function
// - ObjectInstance must be an existing TObject instance
// - the data inside From^ is modified (unescaped and transformed): don't call
// JSONToObject(pointer(JSONRawUTF8)) but makes a temporary copy of the
// JSONRawUTF8 text before calling this function
// - handle Integer, Int64, enumerate (including boolean), set, floating point,
// TDateTime, TCollection, TStrings, TRawUTF8List, variant, and string properties
// (excluding ShortString, but including WideString and UnicodeString under
// Delphi 2009+)
// - TList won't be handled since it may leak memory when calling TList.Clear
// - won't handle TObjectList (even if ObjectToJSON is able to serialize
// them) since has now way of knowing the object type to add (TCollection.Add
// is missing), unless: 1. you set the TObjectListItemClass property as expected,
// and provide a TObjectList object, or 2. woStoreClassName option has been
// used at ObjectToJSON() call and the corresponding classes have been previously
// registered by TJSONSerializer.RegisterClassForJSON() (or Classes.RegisterClass)
// - will clear any previous TCollection objects, and convert any null JSON
// basic type into nil - e.g. if From='null', will call FreeAndNil(Value)
// - you can add some custom (un)serializers for ANY Delphi class, via the
// TJSONSerializer.RegisterCustomSerializer() class method
// - set Valid=TRUE on success, Valid=FALSE on error, and the main function
// will point in From at the syntax error place (e.g. on any unknown property name)
// - caller should explicitely perform a SetDefaultValuesObject(Value) if
// the default values are expected to be set before JSON parsing
function JSONToObject(var ObjectInstance; From: PUTF8Char; var Valid: boolean;
  TObjectListItemClass: TClass=nil): PUTF8Char;

/// create a new object instance, as saved by ObjectToJSON(..woStoreClassName]);
// - JSON input should be either 'null', either '{"ClassName":"TMyClass",...}'
// - woStoreClassName option shall have been used at ObjectToJSON() call
// - and the corresponding class shall have been previously registered by
// TJSONSerializer.RegisterClassForJSON(), in order to retrieve the class type
// from it name - or, at least, by a Classes.RegisterClass() function call
function JSONToNewObject(var From: PUTF8Char; var Valid: boolean): TObject;

/// decode a specified parameter compatible with URI encoding into its original
// object contents
// - ObjectInstance must be an existing TObject instance
// - will call internaly JSONToObject() function to unserialize its content
// - UrlDecodeExtended('price=20.45&where=LastName%3D%27M%C3%B4net%27','PRICE=',P,@Next)
// will return Next^='where=...' and P=20.45
// - if Upper is not found, Value is not modified, and result is FALSE
// - if Upper is found, Value is modified with the supplied content, and result is TRUE
function UrlDecodeObject(U, Upper: PUTF8Char; var ObjectInstance; Next: PPUTF8Char=nil): boolean;

/// fill the object properties from a JSON file content 
// - ObjectInstance must be an existing TObject instance
// - this function will call RemoveCommentsFromJSON() before process
function JSONFileToObject(const JSONFile: TFileName; var ObjectInstance;
  TObjectListItemClass: TClass=nil): boolean;

/// persist a class instance into a JSON file
procedure ObjectToJSONFile(Value: TObject; const JSONFile: TFileName;
  Options: TTextWriterWriteObjectOptions=[woHumanReadable]);



{ ************ some RTTI and SQL mapping routines }

{ type definitions below were adapted from TypInfo.pas
 - this implementation doesn't require to include Variant.pas any more (which
  allow easy server-side compile with LVCL, e.g.)
 - some code was rewritten in an object orientation manner (declared as objects
  instead of records) to avoid use of global function/procedure
 - allows easy published properties enumeration with ClassProp()
 - if a property doesn't have a write attribute (i.e. no setter), its value
  is set using the field adress itself (from read f* getter)
 - some usefull but not implemented functions were added in optimized assembler }

type
{$ifdef FPC}
  /// available type families for Free Pascal RTTI values
  // - values differs from Delphi, and are taken from FPC typinfo.pp unit
  TTypeKind = (tkUnknown,tkInteger,tkChar,tkEnumeration,tkFloat,
    tkSet,tkMethod,tkSString,tkLString,tkAString,
    tkWString,tkVariant,tkArray,tkRecord,tkInterface,
    tkClass,tkObject,tkWChar,tkBool,tkInt64,tkQWord,
    tkDynArray,tkInterfaceRaw,tkProcVar,tkUString,tkUChar,tkHelper);
{$else}
  /// available type families for Delphi 6 up to XE values
  TTypeKind = (tkUnknown, tkInteger, tkChar, tkEnumeration, tkFloat,
    tkString, tkSet, tkClass, tkMethod, tkWChar, tkLString, tkWString,
    tkVariant, tkArray, tkRecord, tkInterface, tkInt64, tkDynArray
    {$ifdef UNICODE}, tkUString{$endif});
{$endif}

  /// specify ordinal (tkInteger and tkEnumeration) storage size and sign
  // - note: Int64 is stored as its own TTypeKind, not as tkInteger
  TOrdType = (otSByte, otUByte, otSWord, otUWord, otSLong, otULong);

  /// specify floating point (ftFloat) storage size and precision
  TFloatType = (ftSingle, ftDouble, ftExtended, ftComp, ftCurr);

  PPTypeInfo = ^PTypeInfo;

{$ifdef FPC}
{$ifdef FPC_REQUIRES_PROPER_ALIGNMENT}
{$PACKRECORDS C}
{$else}
{$A-}
{$endif}
{$else}
{$A-} { Delphi compiler use packed storage for this internal types, not aligned data }
{$endif}

  PPropInfo = ^TPropInfo;
  PMethodInfo = ^TMethodInfo;

  /// pointer to TClassProp
  PClassProp = ^TClassProp;
  /// a wrapper to published properties of a class
  // - start enumeration by getting a PClassProp with ClassProp()
  // - use PropCount, P := @PropList to get the first PPropInfo, and then P^.Next
  // - this enumeration is very fast and doesn't require any temporary memory,
  //  as in the TypInfo.GetPropInfos() PPropList usage
  // - for TSQLRecord, you should better use the RecordProps.Fields[] array,
  // which is faster and contains the properties published in parent classes
  {$ifndef ISDELPHI2010}
  TClassProp = object
  {$else}
  TClassProp = record
  {$endif}
    /// number of published properties in this object
    PropCount: Word;
    /// point to a TPropInfo packed array
    // - layout is as such, with variable TPropInfo storage size:
    // ! PropList: array[1..PropCount] of TPropInfo
    // - use TPropInfo.Next to get the next one:
    // ! P := @PropList;
    // ! for i := 1 to PropCount do begin
    // !   // ... do something with P
    // !   P := P^.Next;
    // ! end;
    PropList: record end;
    /// retrieve a Field property RTTI information from a Property Name
    function FieldProp(const PropName: shortstring): PPropInfo;
    /// return the total count of the published properties in this class
    // and all its parents
    function FieldCountWithParents: integer;
  end;

  PClassType = ^TClassType;
  /// a wrapper to class type information, as defined by the Delphi RTTI
  TClassType = {$ifndef ISDELPHI2010}object{$else}record{$endif}
     /// the class type
     ClassType: TClass;
     /// the parent class type information
     ParentInfo: PPTypeInfo;
     /// the number of published properties
     PropCount: SmallInt;
     /// the name (without .pas extension) of the unit were the class was defined
     // - then the PClassProp follows: use the method ClassProp to retrieve its
     // address
     UnitName: string[255];
     /// get the information about the published properties of this class
     // - stored after UnitName memory
     function ClassProp: PClassProp;
       {$ifdef HASINLINE}inline;{$endif}
     /// fast and easy find if this class inherits from a specific class type
     function InheritsFrom(AClass: TClass): boolean;
     /// return the size (in bytes) of this class type information
     // - can be used to create class types at runtime
     function RTTISize: integer;
  end;

  PEnumType = ^TEnumType;
  /// a wrapper to enumeration type information, as defined by the Delphi RTTI
  // - we use this to store the enumeration values as integer, but easily provide
  // a text equivalent, translated if necessary, from the enumeration type
  // definition itself
  TEnumType = {$ifndef ISDELPHI2010}object{$else}record{$endif}
    /// specify ordinal storage size and sign
    OrdType: TOrdType;
    /// first value of enumeration type, typicaly 0
    MinValue: Longint;
    /// same as ord(high(type)): not the enumeration count, but the highest index
    MaxValue: Longint;
    /// the base type of this enumeration
    /// - always use PEnumType(typeinfo(TEnumType))^.BaseType or more usefull
    // method PTypeInfo(typeinfo(TEnumType))^.EnumBaseType before calling
    // any of the methods below
    BaseType: PPTypeInfo;
    /// a concatenation of shortstrings, containing the enumeration names
    NameList: string[255];
    /// get the corresponding enumeration name
    // - return the first one if Value is invalid (>MaxValue)
    function GetEnumNameOrd(Value: Integer): PShortString;
    /// get the corresponding enumeration name
    // - return the first one if Value is invalid (>MaxValue)
    // - Value will be converted to the matching ordinal value (byte or word)
    function GetEnumName(const Value): PShortString;
       {$ifdef HASINLINE}inline;{$endif}
    /// get the corresponding enumeration ordinal value, from its name
    // - return -1 if not found (don't use directly this value to avoid any GPF)
    function GetEnumNameValue(const EnumName: ShortString): Integer; overload;
    /// get the corresponding enumeration ordinal value, from its name
    // - return -1 if not found (don't use directly this value to avoid any GPF)
    function GetEnumNameValue(Value: PUTF8Char): Integer; overload;
    /// get the corresponding enumeration name, without the first lowercase chars
    // (otDone -> 'Done')
    // - Value will be converted to the matching ordinal value (byte or word)
    function GetEnumNameTrimed(const Value): RawUTF8;
       {$ifdef HASINLINE}inline;{$endif}
    ///  get the corresponding caption name, without the first lowercase chars
    // (otDone -> 'Done')
    // - return "string" type, i.e. UnicodeString for Delphi 2009+
    // - internally call UnCamelCase() then System.LoadResStringTranslate() if available
    // - Value will be converted to the matching ordinal value (byte or word)
    function GetCaption(const Value): string;
    /// get all caption names, ready to be display, as lines separated by #13#10
    // - return "string" type, i.e. UnicodeString for Delphi 2009+
    // - if UsedValuesBits is not nil, only the corresponding bits set are added
    function GetCaptionStrings(UsedValuesBits: Pointer=nil): string;
    /// add caption names, ready to be display, to a TStrings class
    // - add pointer(ord(element)) as Objects[] value
    // - if UsedValuesBits is not nil, only the corresponding bits set are added
    // - can be used e.g. to populate a combo box as such:
    // ! PTypeInfo(TypeInfo(TMyEnum))^.EnumBaseType^.AddCaptionStrings(ComboBox.Items);
    procedure AddCaptionStrings(Strings: TStrings; UsedValuesBits: Pointer=nil);
    /// get the corresponding enumeration ordinal value, from its name without
    // its first lowercase chars ('Done' will find otDone e.g.)
    // - return -1 if not found (don't use directly this value to avoid any GPF)
    function GetEnumNameTrimedValue(const EnumName: ShortString): Integer; overload;
    /// get the corresponding enumeration ordinal value, from its name without
    // its first lowercase chars ('Done' will find otDone e.g.)
    // - return -1 if not found (don't use directly this value to avoid any GPF)
    function GetEnumNameTrimedValue(Value: PUTF8Char): Integer; overload;
  end;


{$A-} { Delphi and FPC compiler use packed storage for this internal type }
  TRecordField = packed record
    TypeInfo: PPTypeInfo;
    Offset: Cardinal;
  end;
  TRecordType = packed record
    Size: cardinal;
    Count: integer;
    Fields: array[word] of TRecordField;
  end;
  PRecordField = ^TRecordField;
  PRecordType = ^TRecordType;

{$A-} { Delphi and FPC compiler use packed storage for this internal type }
  PTypeInfo = ^TTypeInfo;
  /// a wrapper containing type information definition
  // - user types defined as an alias don't have this type information:
  // & type NewType = OldType;
  // - user types defined as new types have this type information:
  // & type NewType = type OldType;
  TTypeInfo = {$ifndef ISDELPHI2010}object{$else}record{$endif}
    /// the value type family
    Kind: TTypeKind;
    /// the declared name of the type ('String','Word','RawUnicode'...)
    Name: ShortString;
    /// get the class type information
    function ClassType: PClassType;
      {$ifdef FPC}inline;{$endif} {$ifdef PUREPASCAL} {$ifdef HASINLINE}inline;{$endif} {$endif}
    /// create an instance of the corresponding class
    // - will call TObject.Create, or TSQLRecord.Create virtual constructor
    // - will raise EParsingException if class cannot be constructed on the fly,
    // e.g. for a plain TCollectionItem class
    function ClassCreate: TObject;
    /// get the SQL type of this Delphi class type
    function ClassSQLFieldType: TSQLFieldType;
       {$ifdef HASINLINE}inline;{$endif}
    /// for ordinal types, get the storage size and sign
    function OrdType: TOrdType;
      {$ifdef HASINLINE}inline;{$endif}
    /// for set types, get the type information of the corresponding enumeration
    function SetEnumType: PEnumType;
    /// for gloating point types, get the storage size and procision
    function FloatType: TFloatType;
      {$ifdef HASINLINE}inline;{$endif}
    /// get the SQL type of this Delphi type, as managed with the database driver
    function SQLFieldType: TSQLFieldType;
     /// fast and easy find if a class type inherits from a specific class type
    function InheritsFrom(AClass: TClass): boolean;
    /// get the enumeration type information
    function EnumBaseType: PEnumType;
      {$ifdef FPC}inline;{$endif} {$ifdef PUREPASCAL} {$ifdef HASINLINE}inline;{$endif} {$endif}
    /// get the record type information
    function RecordType: PRecordType;
      {$ifdef FPC}inline;{$endif} {$ifdef PUREPASCAL} {$ifdef HASINLINE}inline;{$endif} {$endif}
  end;

{$A-} { Delphi and FPC compiler use packed storage for this internal type }
  {/ a wrapper containing a property definition, with GetValue() and SetValue()
    functions for direct Delphi / UTF-8 SQL type mapping/conversion:
    - handle byte, word, integer, cardinal, Int64 properties as INTEGER
    - handle boolean properties as INTEGER (0 is false, anything else is true)
    - handle enumeration properties as INTEGER, storing the ordinal value of the
      enumeration (i.e. starting at 0 for the first element)
    - handle enumerations set properties as INTEGER, each bit corresponding to
      an enumeration (therefore a set of up to 64 elements can be stored in such
      a field)
    - handle RawUTF8 properties as TEXT (UTF-8 encoded) - this is the preferred
      field type for storing some textual content in the ORM
    - handle WinAnsiString properties as TEXT (UTF-8 decoded in WinAnsi char set)
    - handle RawUnicode properties as TEXT (UTF-8 decoded as UTF-16 Win32 unicode)
    - handle Single, Double and Extended properties as FLOAT
    - handle TDateTime properties as ISO-8061 encoded TEXT
    - handle TTimeLog properties as properietary fast INTEGER date time
    - handle Currency property as FLOAT (safely converted to/from currency)
    - handle TSQLRecord descendant properties as INTEGER ROWID index to another record
     (warning: the value contains pointer(ROWID), not a valid object memory - you
     have to manually retrieve the record, using a integer(IDField) typecast)
    - handle TSQLRecordMany descendant properties as an "has many" instance (this
     is a particular case of TSQLRecord: it won't contain pointer(ID), but an object)
    - handle TRecordReference properties as INTEGER RecordRef-like value
      (use TSQLRest.Retrieve(Reference) to get a record content)
    - handle TSQLRawBlob properties as BLOB
    - handle dynamic arrays as BLOB, in the TDynArray.SaveTo binary format (is able
      to handle dynamic arrays of records, with records or strings within records)
    - handle records as BLOB, in the RecordSave binary format (our code is ready
      for that, but Delphi doesn't create the RTTI for records so it won't work)
    - WideString, shortstring, UnicodeString (i.e. Delphi 2009+ generic string),
      indexed properties are not handled yet (use faster RawUnicodeString instead
      of WideString and UnicodeString) - in fact, the generic string type is handled  }
  {$ifndef ISDELPHI2010}
  TPropInfo = object
  {$else}
  TPropInfo = record
  {$endif}
  public
    /// the type definition of this property
    PropType: PPTypeInfo;
    /// contains the offset of a field, or the getter method set by 'read' Delphi declaration
    GetProc: PtrInt;
    /// contains the offset of a field, or the setter method set by 'write' Delphi declaration
    // - if this field is nil (no 'write' was specified), SetValue() use GetProc to
    // get the field memory address to save into
    SetProc: PtrInt;
    /// contains the 'stored' boolean value/method (used in TPersistent saving)
    // - either integer(True) - the default, integer(False), reference to a Boolean
    // field, or reference to a parameterless method that returns a Boolean value
    // - if a property is marked as "stored AS_UNIQUE" (i.e. "stored false"),
    // it is created as UNIQUE in the SQL database and its bit is set in
    // Model.fIsUnique[]
    StoredProc: PtrInt;
    /// contains the index value of an indexed class data property
    // - outside SQLite3, this can be used to define a VARCHAR() length value
    // for the textual field definition (sftUTF8Text/sftAnsiText); e.g.
    // the following will create a NAME VARCHAR(40) field:
    // ! Name: RawUTF8 index 40 read fName write fName;
    // - is used by a dynamic array property for fast usage of the
    // TSQLRecord.DynArray(DynArrayFieldIndex) method
    Index: Integer;
    /// contains the default value (2147483648=$80000000 indicates nodefault)
    // when an ordinal or set property is saved as TPersistent
    Default: Longint;
    /// offset into the Name field where the property's name starts
    // - default name index value is 0
    NameIndex: SmallInt;
{$ifdef FPC}
    /// contains the type of the Get/Set/Storedproc, see also ptxxx
    // bit 0..1 GetProc
    //     2..3 SetProc
    //     4..5 StoredProc
    //     6 : true, constant index property
    PropProcs : Byte;
{$endif}
    /// the property definition Name
    Name: ShortString;

    /// get the next property information
    // - no range check: use ClassProp()^.PropCount to determine the properties count
    // - get the first PPropInfo with ClassProp()^.PropList
    function Next: PPropInfo;
      {$ifdef FPC}inline;{$else}{$ifdef HASINLINE}inline;{$endif} {$endif}
    /// return FALSE (AS_UNIQUE) if was marked as "stored AS_UNIQUE"
    //  (i.e. "stored false"), or TRUE by default
    // - if Instance=nil, will work only at RTTI level, not with field or method
    // (and will return TRUE if nothing is defined in the RTTI)
    function IsStored(Instance: TObject): boolean;
    /// convert UTF-8 encoded text into the published property value
    // - setter method (write Set*) is called if available
    // - if no setter exists (no write declaration), the getted field address is used
    // - handle UTF-8 SQL to Delphi values conversion
    // - expect BLOB fields encoded as SQlite3 BLOB literals ("x'01234'" e.g.)
    // or base-64 encoded stream for JSON ("\uFFF0base64encodedbinary") - i.e.
    // both format supported by BlobToTSQLRawBlob() function
    // - handle TPersistent, TCollection, TRawUTF8List or TStrings with JSONToObject
    procedure SetValue(Instance: TObject; Value: PUTF8Char);
    /// convert the published property value into an UTF-8 encoded text
    // - if ToSQL is true, result is on SQL form (false->'0' e.g.)
    // - if ToSQL is false, result is on JSON form (false->'false' e.g.)
    // - BLOB field returns SQlite3 BLOB literals ("x'01234'" e.g.) if ToSQL is
    // true, or base-64 encoded stream for JSON ("\uFFF0base64encodedbinary")
    // - getter method (read Get*) is called if available
    // - handle Delphi values into UTF-8 SQL conversion
    // - sftBlobDynArray, sftBlobCustom or sftBlobRecord are returned as BLOB
    // litterals ("X'53514C697465'") if ToSQL is true, or base-64 encoded stream
    // for JSON ("\uFFF0base64encodedbinary")
    // - handle TPersistent, TCollection, TRawUTF8List or TStrings with ObjectToJSON
    function GetValue(Instance: TObject; ToSQL: boolean; wasSQLString: PBoolean=nil): RawUTF8;
      {$ifdef HASINLINE}inline;{$endif}
    /// convert the published property value into an UTF-8 encoded text
    // - this method is the same as GetValue(), but avoid assigning the result
    // string variable (some speed up on multi-core CPUs, since avoid a CPU LOCK)
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean);
    /// append the published property value into a binary buffer
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter);
    /// read the published property value from a binary buffer
    // - returns next char in input buffer on success, or nil in case of invalid
    // content supplied e.g.
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
    /// copy a published property value from one instance to another
    // - this method use direct copy of the low-level binary content, and is
    // therefore faster than a SetValue(Dest,GetValue(Source)) call
    procedure CopyValue(Source, Dest: TObject);
    {$ifdef USEVARIANTS}
    /// retrieve the published property value into a Variant
    // - will set the Variant type to the best matching kind according to the
    // property type
    // - BLOB field returns SQlite3 BLOB textual literals ("x'01234'" e.g.)
    // - dynamic array field is returned as a variant array
    procedure GetVariant(Instance: TObject; var Dest: Variant);
    /// set the published property value from a Variant value
    // - dynamic array field must be set from a variant array
    // - will convert other properties from the variant type into UTF-8 text
    // before setting the value (so will work with any kind of Variant)
    // - expect BLOB fields encoded as SQlite3 BLOB literals ("x'01234'" e.g.)
    procedure SetVariant(Instance: TObject; const Source: Variant);
    {$endif}
    /// normalize the content of Value, so that GetValue(Object,true) should return the
    // same content (true for ToSQL format)
    procedure NormalizeValue(var Value: RawUTF8);
    /// retrieve an unsigned 32 bit hash of the corresponding property
    // - not all kind of properties are handled: only main types
    // - if CaseInsensitive is TRUE, will apply NormToUpper[] 8 bits uppercase,
    // handling RawUTF8 properties just like the SYSTEMNOCASE collation
    // - note that this method can return a hash value of 0
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
    /// compare the content of the property of two objects
    // - not all kind of properties are handled: only main types (like GetHash)
    // - if CaseInsensitive is TRUE, will apply NormToUpper[] 8 bits uppercase,
    // handling RawUTF8 properties just like the SYSTEMNOCASE collation
    function SameValue(Item1,Item2: TObject; CaseInsensitive: boolean): boolean;
    /// return true if this property is a valid simple field (INTEGER,FLOAT,TEXT)
    // but not a BLOB (TSQLRawBlob)
    // - use directly TSQLRecord.GetBit64(fJSONFields,i) if possible (faster)
    function IsSimpleField: boolean; {$ifdef HASINLINE}inline;{$endif}
    /// return true if this property is a BLOB (TSQLRawBlob)
    function IsBlob: boolean; {$ifdef HASINLINE}inline;{$endif}
    /// return Text+Name[+Optional]
    procedure AppendName(var Text: RawUTF8; const Optional: RawUTF8='');
    ///  get the corresponding caption name, from the property name
    // - return generic "string" type, i.e. UnicodeString for Delphi 2009+
    // - internally call UnCamelCase() then System.LoadResStringTranslate() if available
    function GetCaption: string;
    /// return the field value as SQL statement ready
    // - e.g. round strings with the ' character, and escape the text using
    // double quotes, according to the official SQLite3 documentation
    // - expect enumerates (and boolean) values already encoded as integer
    function GetSQLFromFieldValue(const FieldValue: RawUTF8): RawUTF8;

    /// low-level getter of the ordinal property value of a given instance
    // - this method will check if the corresponding property is ordinal
    // - return -1 on any error
    function GetOrdValue(Instance: TObject): Integer;
    /// low-level getter of the ordinal property value of a given instance
    // - this method will check if the corresponding property is ordinal
    // - ordinal properties smaller than tkInt64 will return an Int64-converted
    // value (e.g. tkInteger)
    // - return 0 on any error
    function GetInt64Value(Instance: TObject): Int64;
    /// low-level getter of the currency property value of a given instance
    // - this method will check if the corresponding property is exactly currency
    // - return 0 on any error
    function GetCurrencyValue(Instance: TObject): Currency;
    /// low-level getter of the floating-point property value of a given instance
    // - this method will check if the corresponding property is floating-point
    // - return 0 on any error
    function GetExtendedValue(Instance: TObject): Extended;
    /// low-level setter of the floating-point property value of a given instance
    // - this method will check if the corresponding property is floating-point
    procedure SetExtendedValue(Instance: TObject; const Value: Extended);
    /// low-level getter of the long string property value of a given instance
    // - this method will check if the corresponding property is a Long String,
    // and will return '' if it's not the case
    // - it will convert the property content into RawUTF8, for RawUnicode,
    // WinAnsiString, TSQLRawBlob and generic Delphi 6-2007 string property
    function GetLongStrValue(Instance: TObject): RawUTF8;
    /// low-level getter of the long string property content of a given instance
    // - just a wrapper around low-level GetLongStrProp() function
    // - call GetLongStrValue() method if you want a conversion into RawUTF8
    // - will work only for Kind=tkLString
    procedure GetRawByteStringValue(Instance: TObject; var Value: RawByteString);
    /// low-level setter of the ordinal property value of a given instance
    // - this method will check if the corresponding property is ordinal
    procedure SetOrdValue(Instance: TObject; Value: Integer);
    /// low-level setter of the ordinal property value of a given instance
    // - this method will check if the corresponding property is ordinal
    procedure SetInt64Value(Instance: TObject; Value: Int64);
    /// low-level setter of the long string property value of a given instance
    // - this method will check if the corresponding property is a Long String
    // - it will convert the property content into RawUTF8, for RawUnicode,
    // WinAnsiString, TSQLRawBlob and generic Delphi 6-2007 string property
    procedure SetLongStrValue(Instance: TObject; const Value: RawUTF8);
    /// low-level setter of the string property value of a given instance
    // - uses the generic string type: to be used within the VCL
    // - this method will check if the corresponding property is a Long String
    // or an UnicodeString (for Delphi 2009+), and will call the corresponding
    // SetLongStrValue() or SetUnicodeStrValue() method
    procedure SetGenericStringValue(Instance: TObject; const Value: string);
    /// low-level getter of the long string property value of a given instance
    // - uses the generic string type: to be used within the VCL
    // - this method will check if the corresponding property is a Long String,
    // or an UnicodeString (for Delphi 2009+),and will return '' if it's
    // not the case
    function GetGenericStringValue(Instance: TObject): string;
{$ifdef UNICODE}
    /// low-level setter of the Unicode string property value of a given instance
    // - this method will check if the corresponding property is a Unicode String
    procedure SetUnicodeStrValue(Instance: TObject; const Value: UnicodeString);
    /// low-level getter of the Unicode string property value of a given instance
    // - this method will check if the corresponding property is a Unicode String
    function GetUnicodeStrValue(Instance: TObject): UnicodeString;
{$endif}
    /// low-level getter of a dynamic array wrapper
    // - this method will NOT check if the property is a dynamic array: caller
    // must have already checked that PropType^^.Kind=tkDynArray
    function GetDynArray(Instance: TObject): TDynArray;
      {$ifdef HASINLINE}inline;{$endif}
    /// low-level getter of the field value memory pointer
    // - return NIL if both getter and setter are methods
    function GetFieldAddr(Instance: TObject): pointer;
      {$ifdef HASINLINE}inline;{$endif}
    /// low-level setter of the field value memory pointer
    // - return NIL if both getter and setter are methods
    function SetFieldAddr(Instance: TObject): pointer;
      {$ifdef HASINLINE}inline;{$endif}
    /// read an TObject published property, as saved by ObjectToJSON() function
    // - will use direct in-memory reference to the object, or call the corresponding
    // setter method (if any), creating a temporary instance via TTypeInfo.ClassCreate
    // - unserialize the JSON input buffer via a call to JSONToObject()
    function ClassFromJSON(Instance: TObject; From: PUTF8Char; var Valid: boolean): PUTF8Char;
  end;

  /// the available methods calling conventions
  // - this is by design only relevant to the x86 model
  // - Win64 has one unique calling convention
  TCallingConvention = (ccRegister, ccCdecl, ccPascal, ccStdCall, ccSafeCall);

  /// the available kind of method parameters
  TParamFlag = (pfVar, pfConst, pfArray, pfAddress, pfReference, pfOut, pfResult);

  /// a set of kind of method parameters
  TParamFlags = set of TParamFlag;

  PReturnInfo = ^TReturnInfo;
  PParamInfo  = ^TParamInfo;

{$A-} { Delphi and FPC compiler use packed storage for this internal type }
  {/ a wrapper around method returned result definition }
  TReturnInfo = {$ifndef ISDELPHI2010}object{$else}record{$endif}
    /// RTTI version
    // - 2 up to Delphi 2010, 3 for Delphi XE and up
    Version: byte;
    /// expected calling convention (only relevant for x86 mode)
    CallingConvention: TCallingConvention;
    /// the expected type of the returned function result
    // - is nil for procedure
    ReturnType: ^PTypeInfo;
    /// total size of data needed for stack parameters + 8 (ret-addr + pushed EBP)
    ParamSize: Word;
    /// number of expected parameters
    ParamCount: Byte;
    /// access to the first method parameter definition
    function Param: PParamInfo; {$ifdef HASINLINE}inline;{$endif}
  end;

{$A-} { Delphi and FPC compiler use packed storage for this internal type }
  {/ a wrapper around an individual method parameter definition }
  TParamInfo = {$ifndef ISDELPHI2010}object{$else}record{$endif}
    /// the kind of parameter
    Flags: TParamFlags;
    /// the parameter type information
    ParamType: PPTypeInfo;
    /// parameter offset
    // - 0 for EAX, 1 for EDX, 2 for ECX
    // - any value >= 8 for stack-based parameter
    Offset: Word;
    /// parameter name
    Name: ShortString;
    /// get the next parameter information
    // - no range check: use TReturnInfo.ParamCount to determine the appropriate count
    function Next: PParamInfo; {$ifdef HASINLINE}inline;{$endif}
  end;

{$A-} { Delphi and FPC compiler use packed storage for this internal type }
  {/ a wrapper around a method definition }
  TMethodInfo = {$ifndef ISDELPHI2010}object{$else}record{$endif}
    {$ifdef FPC}
    /// method name
    Name: PShortString;
    /// the associated method code address
    Addr: Pointer;
    {$else}
    /// size (in bytes) of this TMethodInfo block
    Len: Word;
    /// the associated method code address
    Addr: Pointer;
    /// method name
    Name: ShortString;
    {$endif}
    /// retrieve the associated return information
    function ReturnInfo: PReturnInfo; {$ifdef HASINLINE}inline;{$endif}
    /// wrapper returning nil and avoiding a GPF if @self=nil
    function MethodAddr: Pointer; {$ifdef HASINLINE}inline;{$endif}
  end;

{$ifdef FPC}
{$PACKRECORDS 8}
{$else}
{$A+} { default aligned data }
{$endif}

  TJSONSerializer = class;

  /// ORM attributes for a TSQLPropInfo definition
  TSQLPropInfoAttribute = (
    aIsUnique);

  /// set of ORM attributes for a TSQLPropInfo definition
  TSQLPropInfoAttributes = set of TSQLPropInfoAttribute;

  /// abstract parent class to store information about a published property
  // - property information could be retrieved from RTTI (TSQLPropInfoRTTI*),
  // or be defined by code (TSQLPropInfoCustom derivated classes)
  TSQLPropInfo = class
  protected
    fName: RawUTF8;
    fSQLFieldType: TSQLFieldType;
    fAttributes: TSQLPropInfoAttributes;
    fFieldWidth: integer;
    /// those two protected methods allow custom storage of binary content
    // as text
    // - default implementation is to use hexa (ToSQL=true) or Base64 encodings
    procedure BinaryToText(var Value: RawUTF8; ToSQL: boolean; wasSQLString: PBoolean); virtual;
    procedure TextToBinary(Value: PUTF8Char; var result: RawByteString); virtual;
    function GetSQLFieldTypeName: PShortString;
  public
    /// initialize the internal fields
    // - should not be called directly, but with dedicated class methods like
    // class function TSQLPropInfoRTTI.CreateFrom() or overriden constructors
    constructor Create(const aName: RawUTF8; aSQLFieldType: TSQLFieldType;
      aAttributes: TSQLPropInfoAttributes; aFieldWidth: integer); reintroduce; virtual;
    /// the property definition Name
    property Name: RawUTF8 read fName;
    /// the corresponding column type, as managed by the ORM layer
    property SQLFieldType: TSQLFieldType read fSQLFieldType;
    /// the corresponding column type name, as managed by the ORM layer and
    // retrieved by the RTTI
    property SQLFieldTypeName: PShortString read GetSQLFieldTypeName;
    /// the ORM attributes of this property
    // - contains aIsUnique e.g for TSQLRecord published properties marked as
    // ! property MyProperty: RawUTF8 stored AS_UNIQUE;
    // (i.e. "stored false")
    property Attributes: TSQLPropInfoAttributes read fAttributes;
    /// the optional width of this field, in external databases
    // - is set e.g. by index attribute of TSQLRecord published properties as
    // ! property MyProperty: RawUTF8 index 10;
    property FieldWidth: integer read fFieldWidth;
  public
    /// convert UTF-8 encoded text into the property value
    // - setter method (write Set*) is called if available
    // - if no setter exists (no write declaration), the getted field address is used
    // - handle UTF-8 SQL to Delphi values conversion
    // - expect BLOB fields encoded as SQlite3 BLOB literals ("x'01234'" e.g.)
    // or base-64 encoded stream for JSON ("\uFFF0base64encodedbinary") - i.e.
    // both format supported by BlobToTSQLRawBlob() function
    // - handle TPersistent, TCollection, TRawUTF8List or TStrings with JSONToObject
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); virtual; abstract;
    /// convert the property value into an UTF-8 encoded text
    // - if ToSQL is true, result is on SQL form (false->'0' e.g.)
    // - if ToSQL is false, result is on JSON form (false->'false' e.g.)
    // - BLOB field returns SQlite3 BLOB literals ("x'01234'" e.g.) if ToSQL is
    // true, or base-64 encoded stream for JSON ("\uFFF0base64encodedbinary")
    // - getter method (read Get*) is called if available
    // - handle Delphi values into UTF-8 SQL conversion
    // - sftBlobDynArray, sftBlobCustom or sftBlobRecord are returned as BLOB
    // litterals ("X'53514C697465'") if ToSQL is true, or base-64 encoded stream
    // for JSON ("\uFFF0base64encodedbinary")
    // - handle TPersistent, TCollection, TRawUTF8List or TStrings with ObjectToJSON
    function GetValue(Instance: TObject; ToSQL: boolean; wasSQLString: PBoolean=nil): RawUTF8;
      {$ifdef HASINLINE}inline;{$endif}
    /// convert the property value into an UTF-8 encoded text
    // - this method is the same as GetValue(), but avoid assigning the result
    // string variable (some speed up on multi-core CPUs, since avoid a CPU LOCK)
    // - this virtual method is the one to be overriden by the implementing classes
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); virtual; abstract;
    /// retrieve a field value into a custom TVarData sub type (not a true variant)
    // - the field values are available via some TVarData of type
    // varNull, varInt64, varDouble, varString (mapping a constant PUTF8Char),
    // and varAny (BLOB with size = VLongs[0])
    // - the temp RawByteString is used as a temporary storage for TEXT or BLOB
    // and should be available during all access to the TVarData content
    procedure GetFieldVarData(Instance: TObject; var aValue: TVarData;
      var temp: RawByteString); virtual;
    /// set a field value from a custom TVarData sub type (not a true variant)
    // - the field values are available via some TVarData of type
    // varNull, varInt64, varDouble, varString (mapping a constant PUTF8Char),
    // and varAny (BLOB with size = VLongs[0])
    function SetFieldVarData(Instance: TObject; const aValue: TVarData): boolean; virtual;
    /// append the property value into a binary buffer
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); virtual; abstract;
    /// read the property value from a binary buffer
    // - returns next char in input buffer on success, or nil in case of invalid
    // content supplied e.g.
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; virtual; abstract;
    /// copy a property value from one instance to another
    // - this method use direct copy of the low-level binary content, and is
    // therefore faster than a SetValue(Dest,GetValue(Source)) call
    procedure CopyValue(Source, Dest: TObject); virtual; abstract;
    {$ifdef USEVARIANTS}
    /// retrieve the property value into a Variant
    // - will set the Variant type to the best matching kind according to the
    // SQLFieldType type
    // - BLOB field returns SQlite3 BLOB textual literals ("x'01234'" e.g.)
    // - dynamic array field is returned as a variant array
    procedure GetVariant(Instance: TObject; var Dest: Variant); virtual;  
    /// set the property value from a Variant value
    // - dynamic array field must be set from a variant array
    // - will set the Variant type to the best matching kind according to the
    // SQLFieldType type
    // - expect BLOB fields encoded as SQlite3 BLOB literals ("x'01234'" e.g.)
    procedure SetVariant(Instance: TObject; const Source: Variant); virtual; 
    {$endif}
    /// compare the content of the property of two objects
    // - not all kind of properties are handled: only main types (like GetHash)
    // - if CaseInsensitive is TRUE, will apply NormToUpper[] 8 bits uppercase,
    // handling RawUTF8 properties just like the SYSTEMNOCASE collation
    // - this default implementation will call GetValueVar() for slow comparison
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; virtual;
    /// retrieve an unsigned 32 bit hash of the corresponding property
    // - not all kind of properties are handled: only main types
    // - if CaseInsensitive is TRUE, will apply NormToUpper[] 8 bits uppercase,
    // handling RawUTF8 properties just like the SYSTEMNOCASE collation
    // - note that this method can return a hash value of 0
    // - this default implementation will call GetValueVar() for slow computation
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; virtual;
    /// normalize the content of Value, so that GetValue(Object,true) should return the
    // same content (true for ToSQL format)
    procedure NormalizeValue(var Value: RawUTF8); virtual; abstract;
    /// add the JSON content corresponding to the given property
    // - this default implementation will call safe but slow GetValueVar() method
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); virtual;
    /// returns an untyped pointer to the field property memory in a given instance
    function GetFieldAddr(Instance: TObject): pointer; virtual; abstract;
  end;

  /// type of a TSQLPropInfo class
  TSQLPropInfoClass = class of TSQLPropInfo;

  /// parent information about a published property retrieved from RTTI
  TSQLPropInfoRTTI = class(TSQLPropInfo)
  protected
    fPropInfo: PPropInfo;
  public
    /// this meta-constructor will create an instance of the exact descendant
    // of the specified property RTTI
    // - it will raise an EORMException in case of an unhandled type
    class function CreateFrom(aPropInfo: PPropInfo): TSQLPropInfo;
    /// initialize the internal fields
    // - should not be called directly, but with dedicated class methods like
    // class function CreateFrom()
    constructor Create(aPropInfo: PPropInfo; aSQLFieldType: TSQLFieldType); reintroduce; virtual;
    /// generic way of implementing it
    function GetFieldAddr(Instance: TObject): pointer; override;
    /// corresponding RTTI information
    property PropInfo: PPropInfo read fPropInfo;
  end;

  /// type of a TSQLPropInfoRTTI class
  TSQLPropInfoRTTIClass = class of TSQLPropInfoRTTI;

  /// information about an ordinal Int32 published property
  TSQLPropInfoRTTIInt32 = class(TSQLPropInfoRTTI)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetFieldVarData(Instance: TObject; var aValue: TVarData;
      var temp: RawByteString); override;
    function SetFieldVarData(Instance: TObject; const aValue: TVarData): boolean; override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
    procedure CopyValue(Source, Dest: TObject); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
    procedure NormalizeValue(var Value: RawUTF8); override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
  end;

  /// information about a set published property
  TSQLPropInfoRTTISet = class(TSQLPropInfoRTTIInt32)
  protected
    fSetEnumType: PEnumType;
  public
    constructor Create(aPropInfo: PPropInfo; aSQLFieldType: TSQLFieldType); override;
    property SetEnumType: PEnumType read fSetEnumType;
  end;

  /// information about a enumeration published property
  // - can be either sftBoolean or sftEnumerate kind of property
  TSQLPropInfoRTTIEnum = class(TSQLPropInfoRTTIInt32)
  protected
    fEnumType: PEnumType;
  public
    constructor Create(aPropInfo: PPropInfo; aSQLFieldType: TSQLFieldType); override;
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure NormalizeValue(var Value: RawUTF8); override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
    property EnumType: PEnumType read fEnumType;
  end;

  /// information about a character published property
  TSQLPropInfoRTTIChar = class(TSQLPropInfoRTTIInt32)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure NormalizeValue(var Value: RawUTF8); override;
  end;

  /// information about an ordinal Int64 published property
  TSQLPropInfoRTTIInt64 = class(TSQLPropInfoRTTI)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetFieldVarData(Instance: TObject; var aValue: TVarData;
      var temp: RawByteString); override;
    function SetFieldVarData(Instance: TObject; const aValue: TVarData): boolean; override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
    procedure CopyValue(Source, Dest: TObject); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
    procedure NormalizeValue(var Value: RawUTF8); override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
  end;

  /// information about a TTimeLog published property
  // - stored as an Int64, but with a specific class
  TSQLPropInfoRTTITimeLog = class(TSQLPropInfoRTTIInt64);

  /// information about a floating-point Double published property
  TSQLPropInfoRTTIDouble = class(TSQLPropInfoRTTIInt64)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetFieldVarData(Instance: TObject; var aValue: TVarData;
      var temp: RawByteString); override;
    function SetFieldVarData(Instance: TObject; const aValue: TVarData): boolean; override;
    procedure NormalizeValue(var Value: RawUTF8); override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
  end;

  /// information about a fixed-decimal Currency published property
  TSQLPropInfoRTTICurrency = class(TSQLPropInfoRTTIDouble)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure NormalizeValue(var Value: RawUTF8); override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
  end;

  /// information about a TDateTime published property
  TSQLPropInfoRTTIDateTime = class(TSQLPropInfoRTTIInt64)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure NormalizeValue(var Value: RawUTF8); override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
  end;

  /// information about a AnsiString published property
  TSQLPropInfoRTTIAnsi = class(TSQLPropInfoRTTI)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
    procedure CopyValue(Source, Dest: TObject); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
    procedure NormalizeValue(var Value: RawUTF8); override;
  end;

  /// information about a RawUTF8 published property
  TSQLPropInfoRTTIRawUTF8 = class(TSQLPropInfoRTTIAnsi)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
  end;

  /// information about a WinAnsiString published property
  TSQLPropInfoRTTIWinAnsi = class(TSQLPropInfoRTTIAnsi)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
  end;

  /// information about a RawUnicode published property
  TSQLPropInfoRTTIRawUnicode = class(TSQLPropInfoRTTIAnsi)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
  end;

  /// information about a TSQLRawBlob published property
  TSQLPropInfoRTTIRawBlob = class(TSQLPropInfoRTTIAnsi)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetFieldVarData(Instance: TObject; var aValue: TVarData;
      var temp: RawByteString); override;
    function SetFieldVarData(Instance: TObject; const aValue: TVarData): boolean; override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
  end;

  /// information about a WideString published property
  TSQLPropInfoRTTIWide = class(TSQLPropInfoRTTI)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
    procedure CopyValue(Source, Dest: TObject); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
  end;

{$ifdef UNICODE}
  /// information about a UnicodeString published property
  TSQLPropInfoRTTIUnicode = class(TSQLPropInfoRTTI)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
    procedure CopyValue(Source, Dest: TObject); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
  end;
{$endif}

  /// information about a dynamic array published property
  TSQLPropInfoRTTIDynArray = class(TSQLPropInfoRTTI)
  protected
    function GetDynArray(Instance: TObject): TDynArray;
      {$ifdef HASINLINE}inline;{$endif}
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetFieldVarData(Instance: TObject; var aValue: TVarData;
      var temp: RawByteString); override;
    function SetFieldVarData(Instance: TObject; const aValue: TVarData): boolean; override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
    procedure CopyValue(Source, Dest: TObject); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
    procedure NormalizeValue(var Value: RawUTF8); override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
    {$ifdef USEVARIANTS}
    procedure GetVariant(Instance: TObject; var Dest: Variant); override;
    procedure SetVariant(Instance: TObject; const Source: Variant); override;
    {$endif}
    /// optional index of the dynamic array published property
    // - used e.g. for fast lookup by TSQLRecord.DynArray(DynArrayFieldIndex)
    property DynArrayIndex: integer read fFieldWidth;
  end;

{$ifdef USEVARIANTS}
  /// information about a variant published property
  TSQLPropInfoRTTIVariant = class(TSQLPropInfoRTTI)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
    procedure CopyValue(Source, Dest: TObject); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
    procedure NormalizeValue(var Value: RawUTF8); override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
    procedure GetVariant(Instance: TObject; var Dest: Variant); override;
    procedure SetVariant(Instance: TObject; const Source: Variant); override;
  end;
{$endif USEVARIANTS}

  /// optional event handler used by TSQLPropInfoRecord to handle textual storage
  // - by default, TSQLPropInfoRecord content will be stored as sftBlobCustom;
  // specify such a callback event to allow storage as UTF-8 textual field and
  // use a sftUTF8Custom kind of column
  // - event implementation shall convert data/datalen binary value into Text
  TOnSQLPropInfoRecord2Text = procedure(Data: pointer; DataLen: integer;
    var Text: RawUTF8);
  /// optional event handler used by TSQLPropInfoRecord to handle textual storage
  // - by default, TSQLPropInfoRecord content will be stored as sftBlobCustom;
  // specify such a callback event to allow storage as UTF-8 textual field and
  // use a sftUTF8Custom kind of column
  // - event implementaiton shall convert Text into Data binary value
  TOnSQLPropInfoRecord2Data = procedure(Text: PUTF8Char; var Data: RawByteString);

  /// abstract information about a record-like property defined directly in code
  // - do not use this class, but TSQLPropInfoRecordRTTI and TSQLPropInfoRecordFixedSize
  // - will store the content as BLOB by default, and SQLFieldType as sftBlobCustom
  // - if aData2Text/aText2Data are defined, use TEXT storage and sftUTF8Custom type
  TSQLPropInfoCustom = class(TSQLPropInfo)
  protected
    fOffset: PtrUInt;
    fData2Text: TOnSQLPropInfoRecord2Text;
    fText2Data: TOnSQLPropInfoRecord2Data;
    procedure BinaryToText(var Value: RawUTF8; ToSQL: boolean; wasSQLString: PBoolean); override;
    procedure TextToBinary(Value: PUTF8Char; var result: RawByteString); override;
  public
    /// define a custom property in code
    // - do not call this constructor directly, but one of its inherited classes
    constructor Create(const aName: RawUTF8; aSQLFieldType: TSQLFieldType;
      aAttributes: TSQLPropInfoAttributes; aFieldWidth: Integer; aProperty: pointer;
      aData2Text: TOnSQLPropInfoRecord2Text; aText2Data: TOnSQLPropInfoRecord2Data); reintroduce;
  public
    function GetFieldAddr(Instance: TObject): pointer; override;
  end;

  /// information about a record property defined directly in code
  // - Delphi does not publish RTTI for published record properties
  // - you can use this class to register a record property from its RTTI 
  // - will store the content as BLOB by default, and SQLFieldType as sftBlobCustom
  // - if aData2Text/aText2Data are defined, use TEXT storage and sftUTF8Custom type
  // - this class will use only binary RecordLoad/RecordSave methods
  TSQLPropInfoRecordRTTI = class(TSQLPropInfoCustom)
  protected
    fTypeInfo: PTypeInfo;
  public
    /// define a record property from its RTTI definition
    // - handle any kind of record with TypeInfo() generated
    // - aPropertyPointer shall be filled with the offset to the private
    // field within a nil object, e.g for
    // !  class TMainObject = class(TSQLRecord)
    // !    (...)
    // !    fFieldName: TMyRecord;
    // !  public
    // !    (...)
    // !    property FieldName: TMyRecord read fFieldName write fFieldName;
    // !  end;
    // you will have to register it as
    // ! aPropInfo := TSQLPropInfoCustom.Create(TypeInfo(TMyRecord),'FieldName',
    // !   @TMainObject(nil).fFieldName);
    // - optional aIsNotUnique parameter will be used
    // - implementation will use internally RecordLoad/RecordSave functions
    // - you can specify optional aData2Text/aText2Data callbacks to store
    // the content as textual values, and not as BLOB
    constructor Create(aRecordInfo: PTypeInfo; const aName: RawUTF8;
      aPropertyPointer: pointer; aAttributes: TSQLPropInfoAttributes=[];
      aFieldWidth: integer=0; aData2Text: TOnSQLPropInfoRecord2Text=nil;
      aText2Data: TOnSQLPropInfoRecord2Data=nil); reintroduce; overload;
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetFieldVarData(Instance: TObject; var aValue: TVarData;
      var temp: RawByteString); override;
    function SetFieldVarData(Instance: TObject; const aValue: TVarData): boolean; override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
    procedure CopyValue(Source, Dest: TObject); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
    procedure NormalizeValue(var Value: RawUTF8); override;
    {$ifdef USEVARIANTS}
    procedure GetVariant(Instance: TObject; var Dest: Variant); override;
    procedure SetVariant(Instance: TObject; const Source: Variant); override;
    {$endif}
  end;

  /// information about a fixed-size record property defined directly in code
  // - Delphi does not publish RTTI for published record properties
  // - you can use this class to register a record property with no RTTI (i.e.
  // a record with no reference-counted types within) 
  // - will store the content as BLOB by default, and SQLFieldType as sftBlobCustom
  // - if aData2Text/aText2Data are defined, use TEXT storage and sftUTF8Custom type
  TSQLPropInfoRecordFixedSize = class(TSQLPropInfoCustom)
  protected
    fTypeInfo: PTypeInfo;
    fRecordSize: integer;
  public
    /// define an unmanaged fixed-size record property
    // - simple kind of records (i.e. those not containing reference-counted
    // members) do not have RTTI generated, at least in older versions of Delphi:
    // use this constructor to define a direct property access
    // - main parameter is the record size, in bytes
    constructor Create(aRecordSize: cardinal; const aName: RawUTF8;
      aPropertyPointer: pointer; aAttributes: TSQLPropInfoAttributes=[];
      aFieldWidth: integer=0; aData2Text: TOnSQLPropInfoRecord2Text=nil;
      aText2Data: TOnSQLPropInfoRecord2Data=nil); reintroduce; overload;
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetFieldVarData(Instance: TObject; var aValue: TVarData;
      var temp: RawByteString); override;
    function SetFieldVarData(Instance: TObject; const aValue: TVarData): boolean; override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
    procedure CopyValue(Source, Dest: TObject); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
    procedure NormalizeValue(var Value: RawUTF8); override;
    {$ifdef USEVARIANTS}
    procedure GetVariant(Instance: TObject; var Dest: Variant); override;
    procedure SetVariant(Instance: TObject; const Source: Variant); override;
    {$endif}
  end;

  /// dynamic array of ORM fields information for published properties
  TSQLPropInfoDynArray = array of TSQLPropInfo;

  /// handle a read-only list of ORM fields information for published properties
  TSQLPropInfoList = class
  protected
    fList: TSQLPropInfoDynArray;
    fCount: integer;
    fOrderedByName: TIntegerDynArray;
    function GetItem(aIndex: integer): TSQLPropInfo;
    procedure QuickSortByName(L,R: PtrInt);
  public
    /// release internal list items
    destructor Destroy; override;
    /// add a TSQLPropInfo to the list
    function Add(aTable: TClass; aItem: TSQLPropInfo): integer;
    /// find an item in the list
    // - returns nil if not found
    function ByRawUTF8Name(const aName: RawUTF8): TSQLPropInfo; overload;
      {$ifdef HASINLINE}inline;{$endif}
    /// find an item in the list
    // - returns nil if not found
    function ByName(aName: PUTF8Char): TSQLPropInfo; overload;
      {$ifdef HASINLINE}inline;{$endif}
    /// find an item in the list
    // - returns -1 if not found
    function IndexByName(const aName: RawUTF8): integer; overload;
      {$ifdef HASINLINE}inline;{$endif}
    /// find an item in the list
    // - returns -1 if not found
    function IndexByName(aName: PUTF8Char): integer; overload;
    /// returns the number of TSQLPropInfo in the list
    property Count: integer read fCount;
    /// quick access to the TSQLPropInfo list
    // - note that length(List) may not equal Count, since is its capacity
    property List: TSQLPropInfoDynArray read fList;
    /// read-only retrieval of a TSQLPropInfo item
    // - will raise an exception if out of range
    property Items[aIndex: integer]: TSQLPropInfo read GetItem; //default;
  end;

  /// simple writer to a Stream, specialized for writing an object as INI
  // - resulting content will be UTF-8 encoded
  // - use an internal buffer, faster than string+string
  TINIWriter = class(TTextWriter)
    /// write the published integer, Int64, floating point values, (wide)string,
    // enumerates (e.g. boolean), variant properties of the object
    // - won't handle shortstring properties
    // - add a new INI-like section with [Value.ClassName] if WithSection is true
    // - the object must have been compiled with the $M+ define, i.e. must
    // inherit from TPersistent or TSQLRecord
    // - the enumerates properties are stored with their integer index value
    // - content can be read back using overloaded procedures ReadObject() 
    procedure WriteObject(Value: TObject; const SubCompName: RawUTF8='';
      WithSection: boolean=true); reintroduce;
  end;

  /// method prototype to be used for custom serialization of a class
  // - to be used with TJSONSerializer.RegisterCustomSerializer() method
  // - note that the generated JSON content is not required to start with '{',
  // as a normal JSON object (you may e.g. write a JSON string for some class) -
  // as a consequence, custom code could explicitely start with Add('{')
  // - implementation code shall follow function TJSONSerializer.WriteObject()
  // patterns, i.e. aSerializer.Add/AddInstanceName/AddJSONEscapeString...
  // - implementation code shall follow the same exact format for the
  // associated TJSONSerializerCustomReader callback
  TJSONSerializerCustomWriter = procedure(const aSerializer: TJSONSerializer;
    aValue: TObject; aOptions: TTextWriterWriteObjectOptions) of object;
  /// method prototype to be used for custom un-serialization of a class
  // - to be used with TJSONSerializer.RegisterCustomSerializer() method
  // - note that the read JSON content is not required to start with '{',
  // as a normal JSON object (you may e.g. read a JSON string for some class) -
  // as a consequence, custom code could explicitely start with "if aFrom^='{'..."
  // - implementation code shall follow function JSONToObject() patterns, i.e.
  // calling low-level GetJSONField() function to decode the JSON content
  // - implementation code shall follow the same exact format for the
  // associated TJSONSerializerCustomWriter callback
  TJSONSerializerCustomReader = function(const aValue: TObject; aFrom: PUTF8Char;
    var aValid: Boolean): PUTF8Char of object;

  /// simple writer to a Stream, specialized for writing an object as JSON
  // - resulting JSON content will be UTF-8 encoded
  // - use an internal buffer, faster than string+string
  TJSONSerializer = class(TJSONWriter)
  protected
    fHumanReadableLevel: integer;
    /// used by WriteObjectAsString method
    fInternalJSONWriter: TJSONWriter;
  public
    /// serialize as JSON the published integer, Int64, floating point values,
    // TDateTime (stored as ISO 8601 text), string and enumerate (e.g. boolean)
    // properties of the object
    // - won't handle shortstring properties
    // - the object must have been compiled with the $M+ define, i.e. must
    // inherit from TPersistent or TSQLRecord, or has been defined with a
    // custom serializer via RegisterCustomSerializer()
    // - will write also the properties published in the parent classes
    // - the enumerates properties are stored with their integer index value by
    // default, but will be written as text if woFullExpand option is set
    // - TList objects are not handled by default - they will be written only
    // if FullExpand is set to true (and JSONToObject won't be able to read it)
    // - nested properties are serialized as nested JSON objects
    // - any TCollection property will also be serialized as JSON array
    // - any TStrings or TRawUTF8List property will also be serialized as
    // JSON string array
    // - function ObjectToJSON() is just a wrapper over this method
    procedure WriteObject(Value: TObject;
      Options: TTextWriterWriteObjectOptions=[woDontStoreDefault]); override;
    /// same as WriteObject(), but will double all internal " and bound with "
    // - this implementation will avoid most memory allocations
    procedure WriteObjectAsString(Value: TObject;
      Options: TTextWriterWriteObjectOptions=[woDontStoreDefault]);
    /// override method, able to write sets using RTTI
    procedure AddTypedJSON(aTypeInfo: pointer; var aValue); {override;}
    /// relase all used memory and handles
    destructor Destroy; override;
    /// define a custom serialization for a given class
    // - by default, TSQLRecord, TPersistent, TStrings, TCollection classes
    // are processed: but you can specify here some callbacks to perform
    // the serialization process for any class
    // - any previous registration is overriden
    // - setting both aReader=aWriter=nil will return back to the default class
    // serialization (i.e. published properties serialization)
    // - note that any inherited classes will be serialized as the parent class
    class procedure RegisterCustomSerializer(aClass: TClass;
      aReader: TJSONSerializerCustomReader; aWriter: TJSONSerializerCustomWriter);
    /// let a given class be recognized by JSONToObject() from "ClassName":".."
    // - TObjectList item instances will be created corresponding to the
    // serialized class name field specified, and JSONToNewObject() can create a
    // new instance using the "ClassName":"..." field to identify the class type
    // - by default, all referenced TSQLRecord classes will be globally
    // registered when TSQLRecordProperties information is retrieved
    class procedure RegisterClassForJSON(aItemClass: TClass); overload;
    /// let a given class be recognized by JSONToObject() from "ClassName":".."
    // - TObjectList item instances will be created corresponding to the
    // serialized class name field specified, and JSONToNewObject() can create a
    // new instance using the "ClassName":"..." field to identify the class type
    // - by default, all referenced TSQLRecord classes will be globally
    // registered when TSQLRecordProperties information is retrieved
    class procedure RegisterClassForJSON(const aItemClass: array of TClass); overload;
{$ifndef LVCL}
    /// let a given TCollection be recognized during JSON serialization
    // - due to how TCollection instances are created, you can not create a
    // server-side instance of TCollection directly
    // - first workaround is to inherit from TInterfacedCollection
    // - this method allows to recognize the needed TCollectionItem class for
    // a given TCollection class, so allow to (un)serialize any TCollection,
    // without defining a new method and inherits from TInterfacedCollection
    // - note that both supplied classes will be registered for the internal
    // "ClassName":"..." RegisterClassForJSON() process
    class procedure RegisterCollectionForJSON(aCollection: TCollectionClass;
      aItem: TCollectionItemClass); 
{$endif}
  end;

/// retreive a Field property index from a Property Name
function ClassFieldIndex(ClassType: TClass; const PropName: shortstring): integer;

/// retrieve a Field property RTTI information from a Property Name
function ClassFieldProp(ClassType: TClass; const PropName: shortstring): PPropInfo;

/// retrieve a Field property RTTI information from a Property Name
// - this special version also search into parent properties (default is only current)
function ClassFieldPropWithParents(aClassType: TClass; const PropName: shortstring): PPropInfo;

/// retrieve a Field property RTTI information from a Property Name
// - this special version also search into parent properties (default is only current)
function ClassFieldPropWithParentsFromUTF8(aClassType: TClass; PropName: PUTF8Char): PPropInfo;

/// retrieve an object's component from its property name and class
// - usefull to set User Interface component, e.g.
function GetObjectComponent(Obj: TPersistent; const ComponentName: shortstring;
  ComponentClass: TClass): pointer;

/// retrieve the class property RTTI information for a specific class
function InternalClassProp(ClassType: TClass): PClassProp;
  {$ifdef FPC}inline;{$endif}

/// create an instance of the given class
// - will handle the custom virtual constructors of TSQLRecord or
// TCollection classes as expected, so is to be preferred to aClass.Create
function ClassInstanceCreate(aClass: TClass): TObject; overload;

/// create an instance of the given class from its registered class name
// - the class shall have been registered via TJSONSerializer.RegisterClassForJSON()
// or via the standard RegisterClass() function of Classes.pas unit
// - will handle the custom virtual constructors of TSQLRecord or
// TCollection classes as expected, so is to be preferred to aClass.Create
function ClassInstanceCreate(const aClassName: RawUTF8): TObject; overload;

/// retrieve a method RTTI information for a specific class
function InternalMethodInfo(aClassType: TClass; const aMethodName: ShortString): PMethodInfo;

/// retrieve the ready to be displayed text of an enumeration
// - will "uncamel" then translate into a generic VCL string
// - aIndex will be converted to the matching ordinal value (byte or word)
function GetEnumCaption(aTypeInfo: PTypeInfo; const aIndex): string;

/// get the corresponding enumeration name, without the first lowercase chars
// (otDone -> 'Done')
// - aIndex will be converted to the matching ordinal value (byte or word)
// - this will return the code-based English text; use GetEnumCaption() to
// retrieve the enumeration display text
function GetEnumNameTrimed(aTypeInfo: PTypeInfo; const aIndex): RawUTF8;


{$ifdef MSWINDOWS}
{$ifdef CONDITIONALEXPRESSIONS}
{$if CompilerVersion >= 22.0} // fix Delphi XE imcompatilibility
type
  TSecurityAttributes = packed record
    nLength: DWORD;
    lpSecurityDescriptor: Pointer;
    bInheritHandle: BOOL;
  end;

const
  SECURITY_DESCRIPTOR_REVISION = 1;
  SECURITY_DESCRIPTOR_MIN_LENGTH = 20;
{$ifend}
{$endif}
{$endif}

const
  /// HTML Status Code for "Success"
  HTML_SUCCESS = 200;
  /// HTML Status Code for "Created"
  HTML_CREATED = 201;
  /// HTML Status Code for "Not Modified"
  HTML_NOTMODIFIED = 304;
  /// HTML Status Code for "Bad Request"
  HTML_BADREQUEST = 400;
  /// HTML Status Code for "Forbidden"
  HTML_FORBIDDEN = 403;
  /// HTML Status Code for "Not Found"
  HTML_NOTFOUND = 404;
  // HTML Status Code for "Method Not Allowed"
  HTML_NOTALLOWED = 405;
  /// HTML Status Code for "Request Time-out"
  HTML_TIMEOUT = 408;
  /// HTML Status Code for "Internal Server Error"
  HTML_SERVERERROR = 500;
  /// HTML Status Code for "Not Implemented"
  HTML_NOTIMPLEMENTED = 501;
  /// HTML Status Code for "Service Unavailable"
  HTML_UNAVAILABLE = 503;

/// convert any HTML_* constant to a short English text
procedure StatusCodeToErrorMsg(Code: integer; var result: RawUTF8);



{ ************ main ORM / SOA classes and types }

const
  /// the used TAuthSession.IDCardinal value if the session not started yet
  // - i.e. if the session handling is still in its handshaking phase
  CONST_AUTHENTICATION_SESSION_NOT_STARTED = 0;

  /// the used TAuthSession.IDCardinal value if authentication mode is not set
  // - i.e. if TSQLRest.HandleAuthentication equals FALSE
  CONST_AUTHENTICATION_NOT_USED = 1;

  /// maximum number of the locked record in a Table (used in TSQLLocks)
  // - code is somewhat faster and easier with a fixed cache size
  // - 512 seems big enough on practice
  MAX_SQLLOCKS = 512;

  /// maximum handled dimension for TSQLRecordRTree
  // - this value is the one used by SQLite3 R-Tree virtual table
  RTREE_MAX_DIMENSION = 5;

  /// used as "stored AS_UNIQUE" published property definition in TSQLRecord
  AS_UNIQUE = false;

type
  /// exception raised in case of incorrect TSQLTable.Step / Field*() use
  ESQLTableException = class(ESynException);

  /// generic parent class of all custom Exception types of this unit
  EORMException = class(ESynException);

  /// exception raised in case of wrong Model definition
  EModelException = class(EORMException);

  /// exception raised in case of unexpected parsing error
  EParsingException = class(EORMException);

  /// exception raised in case of a Client-Server communication error
  ECommunicationException = class(EORMException);

  /// exception raised in case of an error in project implementation logic
  EBusinessLayerException = class(EORMException);

  /// exception raised in case of any authentication error
  ESecurityException = class(EORMException);

  /// exception dedicated to interface factory, e.g. services and mock/stubs
  EInterfaceFactoryException = class(ESynException);

  /// exception dedicated to interface based service implementation
  EServiceException = class(EORMException);

  TSQLModel = class;
  TSQLRest = class;
  TSQLRestClient = class;
  TSQLModelRecordProperties = class;
  TSQLTable = class;

{$M+} { we need the RTTI information to be compiled for the published
        properties of these classes and their children (like TPersistent),
        to enable ORM - must be defined at the forward definition level }
  TSQLRecord = class;      // published properties = ORM fields/columns
  TSQLRecordMany = class;
  TSQLAuthUser = class;
  TSQLRestServer = class;  // published methods = RESTful callbacks handlers
  TSQLRestClientURI = class;
{$M-}

  /// class-reference type (metaclass) of TSQLRecord
  TSQLRecordClass = class of TSQLRecord;

  PClass = ^TClass;
  PSQLRecordClass = ^TSQLRecordClass;

  /// a dynamic array used to store the TSQLRecord classes in a Database Model
  TSQLRecordClassDynArray = array of TSQLRecordClass;


  /// information about a TSQLRecord class property
  // - sftID for TSQLRecord properties, which are pointer(RecordID), not
  // any true class instance
  // - sftMany for TSQLRecordMany properties, for which no data is
  // stored in the table itself, but in a pivot table
  // - sftObject for e.g. TStrings TRawUTF8List TCollection instances
  {$ifdef CPU64}
  TSQLPropInfoRTTIInstance = class(TSQLPropInfoRTTIInt64){$else}
  TSQLPropInfoRTTIInstance = class(TSQLPropInfoRTTIInt32){$endif}
  protected
    fObjectClass: TClass;
  public
    /// will setup the corresponding RecordClass property
    constructor Create(aPropInfo: PPropInfo; aSQLFieldType: TSQLFieldType); override;
    /// direct access to the property class instance
    function GetInstance(Instance: TObject): TObject;
    /// direct access to the property class instance
    procedure SetInstance(Instance, Value: TObject);
    /// direct access to the property class
    // - can be used e.g. for TSQLRecordMany properties
    property ObjectClass: TClass read fObjectClass;
  end;

  /// information about a TSQLRecord class TSQLRecord property
  // - kind sftID, which are pointer(RecordID), not any true class instance
  // - will store the content just as an integer value
  TSQLPropInfoRTTIID = class(TSQLPropInfoRTTIInstance);

  /// information about a TSQLRecord class TStrings/TRawUTF8List/TCollection
  // property
  // - kind sftObject e.g. for TStrings TRawUTF8List TCollection TObjectList instances
  // - binary serialization will store textual JSON serialization of the
  // object, including custom serialization
  TSQLPropInfoRTTIObject = class(TSQLPropInfoRTTIInstance)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
    procedure CopyValue(Source, Dest: TObject); override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
    procedure NormalizeValue(var Value: RawUTF8); override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
  end;

  /// information about a TSQLRecord class TSQLRecordMany property
  // - kind sftMany, for which no data is stored in the table itself, but in
  // a separated pivot table
  TSQLPropInfoRTTIMany = class(TSQLPropInfoRTTIInstance)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
  end;

  /// class-refrence type (metaclass) for a TSynFilter or a TSynValidate
  TSynFilterOrValidateClass = class of TSynFilterOrValidate;

  /// the kind of SQlite3 (virtual) table
  // - TSQLRecordFTS3 will be associated with vFTS3, TSQLRecordFTS4 with vFTS4,
  // TSQLRecordRTree with vRTree, any native SQlite3 table as vSQLite3, and
  // a TSQLRecordVirtualTable*ID with rCustomForcedID/rCustomAutoID
  // - a plain TSQLRecord class can be defined as rCustomForcedID (e.g. for
  // TSQLRecordMany) after registration for an external DB via a call to
  // VirtualTableExternalRegister() from SQLite3DB unit
  TSQLRecordVirtualKind = (
    rSQLite3, rFTS3, rFTS4, rRTree, rCustomForcedID, rCustomAutoID);

  /// some information about a given TSQLRecord class properties
  // - used internaly by TSQLRecord, via a global cache handled by this unit:
  // you can access to each record's properties via TSQLRecord.RecordProps class
  // - such a global cache saves some memory for each TSQLRecord instance,
  // and allows faster access to most wanted RTTI properties
  TSQLRecordProperties = class
  protected
    fSQLFillPrepareMany: RawUTF8;
    fRecordManySourceProp: TSQLPropInfoRTTIInstance;
    fRecordManyDestProp: TSQLPropInfoRTTIInstance;
    fWeakZeroClass: TObject;
    /// the associated TSQLModel instances
    // - e.g. allow O(1) search of a TSQLRecordClass in a model
    fModel: array of record
      /// one associated model
      Model: TSQLModel;
      /// the index in the Model.Tables[] array
      TableIndex: integer;
      /// associated ORM parameters
      Properties: TSQLModelRecordProperties;
    end;
    fModelMax: integer;
    fCustomCollation: TRawUTF8DynArray;
    /// add an entry in fModel[] / fModelMax
    procedure InternalRegisterModel(aModel: TSQLModel;
      aTableIndex: integer; aProperties: TSQLModelRecordProperties);
    /// set the W.ColNames[] array content + W.AddColumns
    procedure SetJSONWriterColumnNames(W: TJSONSerializer; KnownRowsCount: integer);
  public
    /// the TSQLRecord class
    Table: TSQLRecordClass;
    {/ the Table name in the database, associated with this TSQLRecord class
     - 'TSQL' or 'TSQLRecord' chars are trimmed at the beginning of the ClassName
     - or the ClassName is returned as is, if no 'TSQL' or 'TSQLRecord' at first }
    SQLTableName: RawUTF8;
    {/ the Table name in the database in uppercase with a final '.'
     - e.g. 'TEST.' for TSQLRecordTest class
     - can be used with IdemPChar() for fast check of a table name }
    SQLTableNameUpperWithDot: RawUTF8;
    /// fast access to the RTTI properties attribute
    ClassProp: PClassProp;
    /// if this class has any BLOB or TSQLRecodMany fields
    // - i.e. some fields to be ignored
    HasNotSimpleFields: boolean;
    /// set of field types appearing in this record
    HasTypeFields: TSQLFieldTypes;
    /// list all fields, as retrieved from RTTI
    Fields: TSQLPropInfoList;
    /// list all "simple" fields of this TSQLRecord
    // - by default, the TSQLRawBlob and TSQLRecordMany fields are not included
    // into this set: they must be read specificaly (in order to spare
    // bandwidth for BLOBs)
    // - dynamic arrays belong to simple fields: they are sent with other
    // properties content
    SimpleFields: TSQLPropInfoDynArray;
    /// list all TSQLRecordMany fields of this TSQLRecord
    ManyFields: array of TSQLPropInfoRTTIMany;

    /// list of all sftBlobDynArray fields of this TSQLRecord
    DynArrayFields: array of TSQLPropInfoRTTIDynArray;
    /// list of all sftBlobCustom fields of this TSQLRecord
    // - have been defined e.g. as TSQLPropInfoCustom custom definition 
    BlobCustomFields: array of TSQLPropInfo;
    /// list all BLOB fields of this TSQLRecord
    // - i.e. generic sftBlob fields (not sftBlobDynArray, sftBlobCustom nor
    // sftBlobRecord)
    BlobFields: array of TSQLPropInfoRTTI;
    /// bit set to 1 for indicating fields to export, i.e. "simple" fields
    // - this array will handle special cases, like the TCreateTime fields
    // which shall not be included in soUpdate but soInsert and soSelect e.g.
    SimpleFieldsBits: array[TSQLOccasion] of TSQLFieldBits;
    /// number of fields to export, i.e. "simple" fields
    // - this array will handle special cases, like the TCreateTime fields
    // which shall not be included in soUpdate but soInsert and soSelect e.g.
    SimpleFieldsCount: array[TSQLOccasion] of integer;
    /// bit set to 1 for an unique field
    // - an unique field is defined as "stored AS_UNIQUE" (i.e. "stored false")
    // in its property definition
    IsUniqueFieldsBits: TSQLFieldBits;
    /// contains the main field index (e.g. mostly 'Name')
    // - the [boolean] is for [ReturnFirstIfNoUnique] version
    // - contains -1 if no field matches
    MainField: array[boolean] of integer;
    /// returns 'COL1,COL2' with all COL* set to simple field names 
    // - same value as SQLTableSimpleFields[false,false]
    // - this won't change depending on the ORM settings: so it can be safely
    // computed here and not in TSQLModelRecordProperties 
    SQLTableSimpleFieldsNoRowID: RawUTF8;
    /// returns 'COL1=?,COL2=?' with all BLOB columns names
    SQLTableUpdateBlobFields: RawUTF8;
    /// returns 'COL1,COL2' with all BLOB columns names
    SQLTableRetrieveBlobFields: RawUTF8;
    /// all TSynFilter or TSynValidate instances registered per each field
    // - since validation and filtering are used within some CPU-consuming
    // part of the framework (like UI edition), both filters and validation
    // rules are grouped in the same TObjectList - for TSynTableFieldProperties
    // there are separated Filters[] and Validates[] array, for better performance
    Filters: array of TObjectList;
    /// for a TSQLRecordMany class, points to the Source property RTTI
    property RecordManySourceProp: TSQLPropInfoRTTIInstance read fRecordManySourceProp;
    /// for a TSQLRecordMany class, points to the Dest property RTTI
    property RecordManyDestProp: TSQLPropInfoRTTIInstance read fRecordManyDestProp;

    /// initialize the properties content
    constructor Create(aTable: TSQLRecordClass);
    /// release associated used memory
    destructor Destroy; override;

    /// return TRUE if the given name is either ID/RowID, either a property name
    function IsFieldName(const PropName: RawUTF8): boolean;
    /// set all bits corresponding to the supplied field names
    // - returns TRUE on success, FALSE if any field name is not existing
    function FieldIndexsFromRawUTF8(const aFields: array of RawUTF8;
      var Bits: TSQLFieldBits): boolean;
    {/ retrieve a Field property RTTI information from a Property Name
      - this version returns nil if the property is not a BLOB field }
    function BlobFieldPropFromRawUTF8(const PropName: RawUTF8): PPropInfo;

    /// append a field name to a RawUTF8 Text buffer
    // - if FieldIndex=VIRTUAL_TABLE_ROWID_COLUMN (-1), appends 'RowID' or
    // 'ID' (if ForceNoRowID=TRUE) to Text
    // - on error (i.e. if FieldIndex is out of range) will return TRUE
    // - otherwise, will return FALSE and append the field name to Text
    function AppendFieldName(FieldIndex: Integer; var Text: RawUTF8; ForceNoRowID: boolean): boolean;
    {/ return the first unique property of kind RawUTF8
      - this property is mainly the "Name" property, i.e. the one with
        "stored AS_UNIQUE" (i.e. "stored false") definition on most TSQLRecord
      - if ReturnFirstIfNoUnique is TRUE and no unique property is found,
        the first RawUTF8 property is returned anyway
      - returns '' if no matching field was found }
    function MainFieldName(Table: TSQLRecordClass;
      ReturnFirstIfNoUnique: boolean=false): RawUTF8;
    /// return the SQLite3 field datatype for each specified field
    // - set to '' for fields with no column created in the database (e.g. sftMany)
    // - equals e.g. ' INTEGER, ' or ' TEXT COLLATE SYSTEMNOCASE, '
    function SQLFieldTypeToSQL(Fieldindex: integer): RawUTF8;
    /// set a custom SQlite3 text column collation for a specified field
    // - can be used e.g. to override the default COLLATE SYSTEMNOCASE of RawUTF8
    // - collations defined within our SynSQLite3 unit are named BINARY, NOCASE,
    // RTRIM and our custom SYSTEMNOCASE, ISO8601, WIN32CASE, WIN32NOCASE 
    // - do nothing if FieldIndex is not valid, and returns false
    // - to be set in overriden class procedure InternalRegisterCustomProperties()
    // so that it will be common to all database models, for both client and server
    function SetCustomCollation(FieldIndex: integer; const aCollationName: RawUTF8): boolean;
    /// set a custom SQlite3 text column collation for all RawUTF8 fields
    // - can be used e.g. to override ALL default COLLATE SYSTEMNOCASE of RawUTF8,
    // and let the generated SQLite3 file be available outside
    // - collations defined within our SynSQLite3 unit are named BINARY, NOCASE,
    // RTRIM and our custom SYSTEMNOCASE, ISO8601, WIN32CASE, WIN32NOCASE 
    // - to be set in overriden class procedure InternalRegisterCustomProperties()
    // so that it will be common to all database models, for both client and server
    procedure SetCustomCollationForAllRawUTF8(const aCollationName: RawUTF8);
    /// return the UTF-8 encoded SQL statement source to alter the table for
    //  adding the specified field
    function SQLAddField(FieldIndex: integer): RawUTF8;

    /// create a TJSONWriter, ready to be filled with TSQLRecord.GetJSONValues(W)
    function CreateJSONWriter(JSON: TStream; Expand: boolean; withID: boolean;
      const aFields: TSQLFieldBits; KnownRowsCount: integer): TJSONSerializer;
    /// initialize the JSON writer parameters with simple fields
    // - recreate especially the ColNames[] and other necessary properties
    // - is used e.g. in TSQLRestClientURI.BatchUpdate and BatchAdd methods
    procedure SetSimpleFieldsExpandedJSONWriter(W: TJSONWriter; withID: boolean;
      Occasion: TSQLOccasion);

    /// register a custom filter or validation rule to the class for a specified
    // field
    // - this will be used by TSQLRecord.Filter and TSQLRecord.Validate
    // methods (in default implementation)
    // - will return the specified associated TSynFilterOrValidate instance
    // - will return nil in case of an invalid field index
    function AddFilterOrValidate(aFieldIndex: integer;
      aFilter: TSynFilterOrValidate): TSynFilterOrValidate; overload;
    /// register a custom filter or Validate to the class for a specified field
    // - this will be used by TSQLRecord.Filter and TSQLRecord.Validate
    // methods (in default implementation)
    // - will return the specified associated TSynFilterOrValidate instance
    function AddFilterOrValidate(const aFieldName: RawUTF8;
      aFilter: TSynFilterOrValidate): TSynFilterOrValidate; overload;
      {$ifdef HASINLINE}inline;{$endif}
  end;

  TAuthSession = class;
  PSQLAccessRights = ^TSQLAccessRights;

  /// the available THTTP methods transmitted between client and server
  TSQLURIMethod = (mNone, mGET, mPOST, mPUT, mDELETE, mBEGIN, mEND,
    mABORT, mLOCK, mUNLOCK, mSTATE);

  /// store all parameters for a TSQLRestServer.URI() method call
  // - see TSQLRestClient to check how data is expected in our RESTful format
  TSQLRestServerURIParams = packed record
    /// input parameter containing the caller URI
    Url: RawUTF8;
    /// input parameter containing the caller method
    // - handle enhanced REST codes: LOCK/UNLOCK/BEGIN/END/ABORT
    Method: RawUTF8;
    /// input parameter containing the caller message headers
    InHead: RawUTF8;
    /// input parameter containing the caller message body
    // - e.g. some GET/POST/PUT JSON data can be specified here
    InBody: RawUTF8;
    /// output parameter to be set to the response message header
    OutHead: RawUTF8;
    /// output parameter to be set to the response message body
    OutBody: RawUTF8;
    /// output parameter to be set to the HTTP status integer code
    // - HTML_NOTFOUND=404 e.g. if the url doesn't start with Model.Root (caller
    // can try another TSQLRestServer)
    OutStatus: cardinal;
    /// output parameter to be set to the database internal state
    OutInternalState: cardinal;
    /// associated RESTful access rights
    // - AccessRights must be handled by the TSQLRestServer child, according
    // to the Application Security Policy (user logging, authentification and
    // rights management) - making access rights a parameter allows this method
    // to be handled as pure stateless, thread-safe and session-free
    RestAccessRights: PSQLAccessRights;
  end;

  /// used to map set of parameters for a TSQLRestServer.URI() method
  PSQLRestServerURIParams = ^TSQLRestServerURIParams;

  /// store calling context for a TSQLRestServerCallBack event handler
  // - having a dedicated record avoid changing the implementation methods
  // signature if the framework add some parameters to this structure
  // - see TSQLRestServerCallBack for general code use
  {$ifdef UNICODE}
  TSQLRestServerCallBackParams = record
  {$else}
  TSQLRestServerCallBackParams = object
  {$endif}
  private
    fInput: TRawUTF8DynArray;
    procedure FillInput;
    {$ifdef USEVARIANTS}
    function GetInput(const ParamName: RawUTF8): variant;
    {$endif}
    function GetInputInt(const ParamName: RawUTF8): Int64;
    function GetInputDouble(const ParamName: RawUTF8): Double;
    function GetInputUTF8(const ParamName: RawUTF8): RawUTF8;
  public
    /// the used Client-Server method (matching the corresponding HTTP Verb)
    // - this property will be set from incoming URI, even if RESTful
    // authentication is not enabled
    Method: TSQLURIMethod;
    /// same as Call.URI, but without the &session_signature=... ending
    URIWithoutSignature: RawUTF8;
    /// the URI address, excluding parameters
    // - can be either the table name (in RESTful protocol), or a service name
    URI: RawUTF8;
    /// the Table as specified at the URI level (if any)
    Table: TSQLRecordClass;
    /// the index in the Model of the Table specified at the URI level (if any)
    TableIndex: integer;
    /// the associated TSQLRecord.ID, as decoded from URI scheme
    // - this property will be set from incoming URI, even if RESTful
    // authentication is not enabled
    ID: integer;
    /// the index of the callback published method within the internal class list
    MethodIndex: integer;
    /// URI inlined parameters
    // - use UrlDecodeValue*() functions to retrieve the values
    Parameters: PUTF8Char;
    /// access to all input/output parameters at TSQLRestServer.URI() level
    // - process should better call Results() or Success() methods to set the
    // appropriate answer or Error() method in case of an error
    // - low-level access to the call parameters can be made via this pointer
    Call: PSQLRestServerURIParams;
    /// the corresponding session TAuthSession.IDCardinal value
    // - equals 0 (CONST_AUTHENTICATION_SESSION_NOT_STARTED) if the session
    // is not started yet - i.e. if still in handshaking phase
    // - equals 1 (CONST_AUTHENTICATION_NOT_USED) if authentication mode
    // is not enabled - i.e. if TSQLRestServer.HandleAuthentication = FALSE
    Session: cardinal;
    /// the corresponding TAuthSession.User.ID value
    // - is undefined if Session is 0 or 1 (no authentication running)
    SessionUser: integer;
    /// the corresponding TAuthSession.User.GroupRights.ID value
    // - is undefined if Session is 0 or 1 (no authentication running)
    SessionGroup: integer;
    {$ifdef WITHLOG}
    /// associated logging instance
    // - you can use it to log some process on the server side
    Log: ISynLog;
    {$endif}
    /// retrieve one input parameter from its URI name as Int64
    // - slower than the direct UrlDecodeValue*() process, but more
    // convenient to use
    // - raise an EParsingException if the parameter is not found
    property InputInt[const ParamName: RawUTF8]: Int64 read GetInputInt;
    /// retrieve one input parameter from its URI name as double
    // - slower than the direct UrlDecodeValue*() process, but more
    // convenient to use
    // - raise an EParsingException if the parameter is not found
    property InputDouble[const ParamName: RawUTF8]: double read GetInputDouble;
    /// retrieve one input parameter from its URI name as RawUTF8
    // - slower than the direct UrlDecodeValue*() process, but more
    // convenient to use
    // - raise an EParsingException if the parameter is not found
    property InputUTF8[const ParamName: RawUTF8]: RawUTF8 read GetInputUTF8;
    {$ifdef USEVARIANTS}
    /// retrieve one input parameter from its URI name as variant
    // - slower than the direct UrlDecodeValue*() process, but more
    // convenient to use
    // - if the parameter value is text, it is stored in the variant as
    // a generic VCL string content: so before Delphi 2009, you may loose
    // some characters at decoding from UTF-8 input buffer
    // - raise an EParsingException if the parameter is not found
    property Input[const ParamName: RawUTF8]: variant read GetInput;
    {$endif}
    /// use this method to send back directly a result value to the caller
    // - expects Status to be either HTML_SUCCESS or HTML_CREATED, and will
    // return as answer the supplied Result content with no transformation
    // - if Status is an error code, it will call Error() method
    // - CustomHeader optional parameter can be set e.g. to
    // TEXT_CONTENT_TYPE_HEADER if the default JSON_CONTENT_TYPE is not OK
    // - if Handle304NotModified is TRUE and Status is HTML_SUCCESS, the Result
    // content will be hashed (using crc32) and in case of no modification
    // will return HTML_NOTMODIFIED to the browser, without the actual result
    // content (to save bandwidth)
    procedure Returns(const Result: RawUTF8; Status: integer=HTML_SUCCESS;
      const CustomHeader: RawUTF8=''; Handle304NotModified: boolean=false); overload;
    /// use this method to send back a JSON object to the caller
    // - this method will encode the supplied values e.g. as
    // ! JSONEncode(['name','John','year',1972]) = '{"name":"John","year":1972}'
    // - implementation is just a wrapper around Returns(JSONEncode([]))
    // - note that cardinal values should be type-casted to Int64() (otherwise
    // the integer mapped value will be transmitted, therefore wrongly)
    // - expects Status to be either HTML_SUCCESS or HTML_CREATED
    // - caller can set Handle304NotModified=TRUE for Status=HTML_SUCCESS 
    procedure Returns(const NameValuePairs: array of const; Status: integer=HTML_SUCCESS;
      Handle304NotModified: boolean=false); overload;
    /// use this method to send back a JSON object with a "result" field
    // - this method will encode the supplied values as a {"result":"...}
    // JSON object, as such for one value:
    // $ {"result":"OneValue"}
    // (with one value, you can just call TSQLRestClientURI.CallBackGetResult
    // method to call and decode this value)
    // or as a JSON object containing an array of values:
    // $ {"result":["One","two"]}
    // - expects Status to be either HTML_SUCCESS or HTML_CREATED
    // - caller can set Handle304NotModified=TRUE for Status=HTML_SUCCESS 
    procedure Results(const Values: array of const; Status: integer=HTML_SUCCESS;
      Handle304NotModified: boolean=false);
    /// use this method if the caller expect no data, just a status
    // - just wrap the overloaded Returns() method with no result value
    // - if Status is an error code, it will call Error() method
    // - by default, calling this method will mark process as successfull
    procedure Success(Status: integer=HTML_SUCCESS); 
    /// use this method to send back an error to the caller
    // - expects Status to not be HTML_SUCCESS neither HTML_CREATED,
    // and will send back a JSON error message to the caller, with the
    // supplied error text
    // - if no ErrorMessage is specified, will return a default text
    // corresponding to the Status code
    procedure Error(const ErrorMessage: RawUTF8=''; Status: integer=HTML_BADREQUEST); overload;
    /// use this method to send back an error to the caller
    // - implementation is just a wrapper over Error(FormatUTF8(Format,Args))
    procedure Error(Format: PUTF8Char; const Args: array of const; Status: integer=HTML_BADREQUEST); overload;
  end;


  (*/ method prototype which must be used to implement the Server-Side
     ModelRoot/[TableName/ID/]MethodName RESTful GET/PUT request of the Framework
   - this mechanism is able to handle some custom Client/Server request, similar
     to the DataSnap technology, but in a KISS way; it's fully integrated in the
     Client/Server architecture of our framework
   - just add a published method of this type to any TSQLRestServer descendant
   - when TSQLRestServer.URI receive a request for ModelRoot/MethodName
     or ModelRoot/TableName/ID/MethodName, it will check for a published method
     in its self instance named MethodName which MUST be of TSQLRestServerCallBack
     type (not checked neither at compile time neither at runtime: beware!) and
     call it to handle the request
   - important warning: the method implementation MUST be thread-safe
   - when TSQLRestServer.URI receive a request for ModelRoot/MethodName,
     it calls the corresponding published method with aRecord set to nil
   - when TSQLRestServer.URI receive a request for ModelRoot/TableName/ID/MethodName,
     it calls the corresponding published method with aRecord pointing to a
     just created instance of the corresponding class,  with its field ID set;
     note that the only set field is ID: other fields of aRecord are not set, but
     must secificaly be retrieved on purpose
   - for ModelRoot/TableName/ID/MethodName, the just created instance will be
     freed by TSQLRestServer.URI when the method returns
   - Ctxt.Parameters values are set from incoming URI, and each parameter can be
     retrieved with a loop like this:
     !  if not UrlDecodeNeedParameters(Ctxt.Parameters,'SORT,COUNT') then
     !    exit;
     !  while Ctxt.Parameters<>nil do begin
     !    UrlDecodeValue(Ctxt.Parameters,'SORT=',aSortString);
     !    UrlDecodeValueInteger(Ctxt.Parameters,'COUNT=',aCountInteger,@Ctxt.Parameters);
     !  end;
   - Ctxt.Call is set with low-level incoming and outgoing data from client
     (e.g. Ctxt.Call.InBody contain POST/PUT data message) 
   - Ctxt.Session* will identify to the authentication session of the remote client
     (CONST_AUTHENTICATION_NOT_USED=1 if authentication mode is not enabled or
     CONST_AUTHENTICATION_SESSION_NOT_STARTED=0 if the session not started yet) -
     code may use SessionGetUser() protected method to retrieve the user details
   - Ctxt.Method will indicate the used HTTP verb (e.g. GET/POST/PUT..)
   - if process succeeded, implementation shall call Ctxt.Results([]) method to
     set a JSON response object with one "result" field name or Ctxt.Returns([])
     with a JSON object described in Name/Value pairs; if the returned value is
     not JSON_CONTENT_TYPE, use Ctxt.Returns() and its optional CustomHeader
     parameter can specify a custom header like TEXT_CONTENT_TYPE_HEADER
   - if process succeeded, and no data is expected to be returned to the caller,
     implementation shall call overloaded Ctxt.Success() method with the
     expected status (i.e. just Ctxt.Success will return HTML_SUCCESS)
   - if process failed, implementation shall call Ctxt.Error() method to
     set the corresponding error message and error code number
   - a typical implementation may be:
     ! procedure TSQLRestServerTest.Sum(var Ctxt: TSQLRestServerCallBackParams);
     ! var a,b: Extended;
     ! begin
     !   if UrlDecodeNeedParameters(Ctxt.Parameters,'A,B') then begin
     !     while Ctxt.Parameters<>nil do begin
     !       UrlDecodeExtended(Ctxt.Parameters,'A=',a);
     !       UrlDecodeExtended(Ctxt.Parameters,'B=',b,@Ctxt.Parameters);
     !     end;
     !     Ctxt.Results([a+b]);
     !     // same as: Ctxt.Returns(JSONEncode(['result',a+b]));
     !     // same as: Ctxt.Returns(['result',a+b]);
     !   end else
     !     Ctxt.Error('Missing Parameter');
     ! end;
   - Client-Side can be implemented as you wish. By convention, it could be
     appropriate to define in either TSQLRestServer (if to be called as
     ModelRoot/MethodName), either TSQLRecord (if to be called as
     ModelRoot/TableName/MethodName[/ID]) a custom public or protected method,
     calling TSQLRestClientURI.URL with the appropriate parameters, and named
     (by convention) as MethodName; TSQLRestClientURI has dedicated methods
     like CallBackGetResult, CallBackGet, and CallBackPut; see also
     TSQLModel.getURICallBack and JSONDecode function
     ! function TSQLRecordPeople.Sum(aClient: TSQLRestClientURI; a, b: double): double;
     ! var err: integer;
     ! begin
     !   val(aClient.CallBackGetResult('sum',['a',a,'b',b]),result,err);
     ! end; *)
  TSQLRestServerCallBack = procedure(var Ctxt: TSQLRestServerCallBackParams) of object;

  /// the possible options for handling table names
  TSQLCheckTableName = (ctnNoCheck,ctnMustExist,ctnTrimExisting);

  /// internal data used by TSQLRecord.FillPrepare()/FillPrepareMany() methods
  // - using a dedicated class will reduce memory usage for each TSQLRecord
  // instance (which won't need these properties most of the time)
  TSQLRecordFill = class
  protected
    /// associated table
    fTable: TSQLTable;
    /// current retrieved row
    fFillCurrentRow: integer;
    {/ number of used items in TableMap[] array
      - calculated in FillPrepare() or FillPrepareMany() methods }
    fTableMapCount: integer;
    /// set by TSQLRecord.FillPrepareMany() to release M.fDestID^ instances
    fTableMapRecordManyInstances: array of TSQLRecordMany;
    {/ map the published fields index
      - calculated in FillPrepare() or FillPrepareMany() methods
      - static array of MAX_SQLFIELDS items }
    fTableMap: array[0..MAX_SQLFIELDS-1] of record
      /// the class instance to be filled from the TSQLTable
      // - can be a TSQLRecordMany instance after FillPrepareMany() method call
      Dest: TSQLRecord;
      /// the published property RTTI to be filled from the TSQLTable
      // - is nil for the RowID/ID field
      DestField: TSQLPropInfo;
      /// the column index in TSQLTable
      TableIndex: integer;
    end;
    /// mark all mapped or TModTime fields
    fTableMapFields: TSQLFieldBits;
    /// index in RecordProps.Fields[] of latest mapped field
    fTableMapFieldsMax: integer;
    /// list all mapped or TModTime fields as in TJSONWriter.AddColumns
    fTableMapFieldsColNames: TRawUTF8DynArray;
    /// add a property to the fTableMap[] array
    // - aIndex is the column index in TSQLTable
    // - will log an explicit error message if fTableMap[] is full, but won't
    // raise any exception
    procedure AddMap(aRecord: TSQLRecord; aField: TSQLPropInfo; aIndex: integer); overload;
    /// add a property to the fTableMap[] array
    // - aIndex is the column index in TSQLTable
    // - will log an explicit error message if fTableMap[] is full, but won't
    // raise any exception
    procedure AddMap(aRecord: TSQLRecord; const aFieldName: RawUTF8; aIndex: integer); overload;
    /// initialize the JSON writer parameters with mapped fields, including ID
    // and any TModTime field
    // - recreate especially the ColNames[] and other necessary properties
    // - current implementation only handle FillPrepare() mapping (i.e. JOINed
    // FillPrepareMany mapping will raise an exception - method will check for
    // fTableMapRecordManyInstances to be [])
    // - is used e.g. in TSQLRestClientURI.BatchUpdate method
    procedure SetMappedFieldsExpandedJSONWriter(aClass: TSQLRecordClass; W: TJSONWriter);
  public
    /// finalize the mapping
    destructor Destroy; override;
    /// map all columns of a TSQLTable to a record mapping
    procedure Map(aRecord: TSQLRecord; aTable: TSQLTable; aCheckTableName: TSQLCheckTableName);
    /// reset the mapping
    // - is called e.g. by TSQLRecord.FillClose
    // - will free any previous Table if necessary
    // - will release TSQLRecordMany.Dest instances as set by TSQLRecord.FillPrepareMany()
    procedure UnMap;
    /// fill a TSQLRecord published properties from a TSQLTable row
    // - use the mapping prepared with Map() method
    function Fill(aRow: integer): Boolean; overload; {$ifdef HASINLINE}inline;{$endif}
    /// fill a TSQLRecord published properties from a TSQLTable row
    // - use the mapping prepared with Map() method
    // - aTableRow will point to the first column of the matching row
    procedure Fill(aTableRow: PPUtf8CharArray); overload;
    /// fill a TSQLRecord published properties from a TSQLTable row
    // - overloaded method using a specified destination record to be filled
    // - won't work with cross-reference mapping (FillPrepareMany)
    // - use the mapping prepared with Map() method
    // - aTableRow will point to the first column of the matching row
    procedure Fill(aTableRow: PPUtf8CharArray; aDest: TSQLRecord); overload;
    /// fill a TSQLRecord published properties from a TSQLTable row
    // - overloaded method using a specified destination record to be filled
    // - won't work with cross-reference mapping (FillPrepareMany)
    // - use the mapping prepared with Map() method
    function Fill(aRow: integer; aDest: TSQLRecord): Boolean; overload; {$ifdef HASINLINE}inline;{$endif}

    {/ the TSQLTable stated as FillPrepare() parameter
      - the internal temporary table is stored here for TSQLRecordMany
      - this instance is freed by TSQLRecord.Destroy if fTable.OwnerMustFree=true }
    property Table: TSQLTable read fTable;
    /// the current Row during a Loop
    property FillCurrentRow: integer read fFillCurrentRow;
  end;

  {/ root class for defining and mapping database records
   - inherits a class from TSQLRecord, and add published properties to describe
    the table columns (see TPropInfo for SQL and Delphi type mapping/conversion)
   - this published properties can be auto-filled from TSQLTable answer with
    FillPrepare() and FillRow(), or FillFrom() with TSQLTable or JSON data
   - this published properties can be converted back into UTF-8 encoded SQL
    source with GetSQLValues or GetSQLSet or into JSON format with GetJSONValues
   - BLOB fields are decoded to auto-freeing TSQLRawBlob }
  TSQLRecord = class(TObject)
  { note that every TSQLRecord has an Instance size of 20 bytes for private and
    protected fields (such as fID or fProps e.g.) }
  protected
    /// used by FillPrepare() and corresponding Fill*() methods
    fFill: TSQLRecordFill;
    /// internal properties getters (using fProps data for speed)
    function GetHasBlob: boolean;
    function GetSimpleFieldCount: integer; 
    function GetFillCurrentRow: integer;
    function GetTable: TSQLTable;
  protected
    fInternalState: cardinal;
    fID: integer;
  {$ifdef HASINLINE}public{$endif}
    /// trick to get the ID even in case of a sftID published property
    function GetID: integer; {$ifdef HASINLINE}inline;{$endif}
    /// trick to typecast the ID on 64 bit platform
    function GetIDAsPointer: pointer; {$ifdef HASINLINE}inline;{$endif}
    /// virtual method to be overriden to register some custom properties
    // - do nothing by default, but allow inherited classes to define some
    // properties, by adding some TSQLPropInfo instances to Props.Fields list
    // - can also be used to specify a custom text collation, by calling
    // Props.SetCustomCollationForAllRawUTF8() or SetCustomCollation() methods
    class procedure InternalRegisterCustomProperties(Props: TSQLRecordProperties); virtual;
  public
    /// direct access to the TSQLRecord properties from RTTI
    // - TSQLRecordProperties is faster than e.g. the class function FieldProp()
    // - use internal the unused vmtAutoTable VMT entry to fast retrieve of a
    // class variable which is unique for each class ("class var" is unique only
    // for the class within it is defined, and we need a var for each class:
    // so even Delphi XE syntax is not powerful enough for our purpose, and the
    // vmtAutoTable trick if very fast, and works with all versions of Delphi -
    // including 64 bit target)
    class function RecordProps: TSQLRecordProperties;
      {$ifdef PUREPASCAL}{$ifdef HASINLINE}inline;{$endif}{$endif}
    {/ the Table name in the database, associated with this TSQLRecord class
     - 'TSQL' or 'TSQLRecord' chars are trimmed at the beginning of the ClassName
     - or the ClassName is returned as is, if no 'TSQL' or 'TSQLRecord' at first
     - is just a wrapper around RecordProps.SQLTableName }
    class function SQLTableName: RawUTF8; {$ifdef HASINLINE}inline;{$endif}
    /// register a custom filter or Validate to the class for a specified field
    // - this will be used by TSQLRecord.Filter and TSQLRecord.Validate
    // methods (in default implementation)
    // - will return the specified associated TSynFilterOrValidate instance
    // - this function is just a wrapper around RecordProps.AddFilterOrValidate
    class function AddFilterOrValidate(const aFieldName: RawUTF8;
      aFilter: TSynFilterOrValidate): TSynFilterOrValidate; {$ifdef HASINLINE}inline;{$endif}

    {/ get the captions to be used for this class
     - if Action is nil, return the caption of the table name
     - if Action is not nil, return the caption of this Action (lowercase left-trimed)
     - return "string" type, i.e. UnicodeString for Delphi 2009+
     - internally call UnCamelCase() then System.LoadResStringTranslate() if available
     - ForHint is set to TRUE when the record caption name is to be displayed inside
       the popup hint of a button (i.e. the name must be fully qualified, not
       the default short version)
     - is not part of TSQLRecordProperties because has been declared as virtual }
    class function CaptionName(Action: PRawUTF8=nil; ForHint: boolean=false): string; virtual; 
    {/ get the captions to be used for this class
     - just a wrapper calling CaptionName() virtual method }
    class function CaptionNameFromRTTI(Action: PShortString): string;
    {/ virtual method called when the associated table is created in the database
      - if FieldName is '', initialization regarding all fields must be made;
        if FieldName is specified, initialization regarding this field must be processed
      - override this method in order to initialize indexs or create default records
      - by default, create indexes for all TRecordReference properties, and
        for all TSQLRecord inherited properties (i.e. of sftID type, that is
        an INTEGER field containing the ID of the pointing record)
     - is not part of TSQLRecordProperties because has been declared as virtual }
    class procedure InitializeTable(Server: TSQLRestServer; const FieldName: RawUTF8); virtual;

    {/ filter the specified fields values of the current TSQLRecord instance
    - by default, this will perform all TSynFilter as registered by
      [RecordProps.]AddFilterOrValidate()
    - inherited classes may add some custom filtering here, if it's not needed
      nor mandatory to create a new TSynFilter class type: in this case, the
      function has to return TRUE if the filtering took place, and FALSE if
      any default registered TSynFilter must be processed
    - the default aFields parameter will process all fields }
    function Filter(const aFields: TSQLFieldBits=[0..MAX_SQLFIELDS-1]): boolean; overload; virtual;
    {/  filter the specified fields values of the current TSQLRecord instance
    - this version will call the overloaded Filter() method above
    - return TRUE if all field names were correct and processed, FALSE otherwise }
    function Filter(const aFields: array of RawUTF8): boolean; overload;
    {/ validate the specified fields values of the current TSQLRecord instance
    - by default, this will perform all TSynValidate as registered by
      [RecordProps.]AddFilterOrValidate()
    - it will also check if any UNIQUE field value won't be duplicated
    - inherited classes may add some custom validation here, if it's not needed
      nor mandatory to create a new TSynValidate class type: in this case, the
      function has to return an explicit error message (as a generic VCL string)
      if the custom validation failed, or '' if the validation was successful:
      in this later case, all default registered TSynValidate are processed
    - the default aFields parameter will process all fields
    - if aInvalidFieldIndex is set, it will contain the first invalid field
      index found
     - caller SHOULD always call the Filter() method before calling Validate() }
    function Validate(aRest: TSQLRest; const aFields: TSQLFieldBits=[0..MAX_SQLFIELDS-1];
      aInvalidFieldIndex: PInteger=nil): string; overload; virtual;
    {/  validate the specified fields values of the current TSQLRecord instance
    - this version will call the overloaded Validate() method above
    - returns '' if all field names were correct and processed, or an
      explicit error message (translated in the current language) on error
    - if aInvalidFieldIndex is set, it will contain the first invalid field
      index }
    function Validate(aRest: TSQLRest; const aFields: array of RawUTF8;
      aInvalidFieldIndex: PInteger=nil): string; overload;
    /// should modify the record content before writing to the Server
    // - this default implementation will update any sftModTime / TModTime and
    // sftCreateTime / TCreateTime properties content with the exact server time stamp
    // - you may override this method e.g. for custom calculated fields
    // - note that this is computed only on the Client side, before sending
    // back the content to the remote Server: therefore, TModTime / TCreateTime
    // fields are a pure client ORM feature - it won't work directly at REST level
    procedure ComputeFieldsBeforeWrite(aRest: TSQLRest; aOccasion: TSQLEvent); virtual;

    /// this constructor initializes the record
    // - auto-instanciate any TSQLRecordMany instance defined in published properties
    // - override this method if you want to use some internal objects (e.g. 
    // TStringList or TCollection as published property)
    constructor Create; overload; virtual;
    {/ this constructor initializes the object as above, and fills its content
      from a client or server connection
     - if ForUpdate is true, the REST method is LOCK and not GET: it tries to lock
      the corresponding record, then retrieve its content; caller has to call
      UnLock() method after Value usage, to release the record }
    constructor Create(aClient: TSQLRest; aID: integer;
      ForUpdate: boolean=false); overload;
    {/ this constructor initializes the object and fills its content from a client
      or server connection, from a TSQLRecord published property content
     - is just a wrapper around Create(aClient,PtrInt(aPublishedRecord))
       or Create(aClient,aPublishedRecord.ID)
     - a published TSQLRecord property is not a class instance, but a typecast to
       TObject(RecordID) - you can also use its ID property
     - if ForUpdate is true, the REST method is LOCK and not GET: it tries to lock
      the corresponding record, then retrieve its content; caller has to call
      UnLock() method after Value usage, to release the record }
    constructor Create(aClient: TSQLRest; aPublishedRecord: TSQLRecord;
      ForUpdate: boolean=false); overload;
    /// this constructor initializes the object as above, and fills its content
    //  from a client or server connection, using a specified WHERE clause
    //  - the WHERE clause should use inlined parameters (like 'Name=:('Arnaud'):')
    //  for better server speed - note that you can use FormatUTF8() as such:
    //  ! aRec := TSQLMyRec.Create(Client,FormatUTF8('Salary>? AND Salary<?',[],[1000,2000]));
    //  or call the overloaded contructor with BoundsSQLWhere array of parameters 
    constructor Create(aClient: TSQLRest; const aSQLWhere: RawUTF8); overload;
    {/ this constructor initializes the object as above, and fills its content
      from a client or server connection, using a specified WHERE clause
      with parameters
    - for better server speed, the WHERE clause should use bound parameters
      identified as '?' in the FormatSQLWhere statement, which is expected to
      follow the order of values supplied in BoundsSQLWhere open array - use
      DateToSQL/DateTimeToSQL for TDateTime, or directly any integer / double /
      currency / RawUTF8 values to be bound to the request as parameters
    - note that this method prototype changed with revision 1.17 of the
      framework: array of const used to be ParamsSQLWhere and '%' in the
      FormatSQLWhere statement, whereas it now expects bound parameters as '?' }
    constructor Create(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
      const BoundsSQLWhere: array of const); overload;
    {/ this constructor initializes the object as above, and fills its content
      from a client or server connection, using a specified WHERE clause
      with parameters
      - the FormatSQLWhere clause will replace all '%' chars with the supplied
      ParamsSQLWhere[] values, and all '?' chars with BoundsSQLWhere[] values,
      as :(...): inlined parameters - you should either call:
      ! Rec := TSQLMyRecord.Create(aClient,'Count=:(%):'[aCount],[]);
      or (letting the inlined parameters being computed by FormatUTF8)
      !  Rec := TSQLMyRecord.Create(aClient,'Count=?',[],[aCount]);
      or even better, using the other Create overloaded constructor:
      !  Rec := TSQLMyRecord.Create(aClient,'Count=?',[aCount]);
      - using '?' and BoundsSQLWhere[] is perhaps more readable in your code, and
      will in all case create a request with :(..): inline parameters, with
      automatic RawUTF8 quoting if necessary }
    constructor Create(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
      const ParamsSQLWhere, BoundsSQLWhere: array of const); overload;
    {/ this constructor initializes the object as above, and prepares itself to
      loop through a statement using a specified WHERE clause
      - this method creates a TSQLTableJSON, retrieves all records corresponding
        to the WHERE clause, then call FillPrepare - previous Create(aClient)
        methods retrieve only one record, this one more multiple rows
      - you should then loop for all rows using 'while Rec.FillOne do ...'
      - the TSQLTableJSON will be freed by TSQLRecord.Destroy
      - the WHERE clause should use inlined parameters (like 'Name=:('Arnaud'):')
        for better server speed - note that you can use FormatUTF8() as such:
        ! aRec := TSQLMyRec.CreateAndFillPrepare(Client,FormatUTF8('Salary>? AND Salary<?',[],[1000,2000]));
        or call the overloaded CreateAndFillPrepare() contructor directly with
        BoundsSQLWhere array of parameters
      - aCustomFieldsCSV can be used to specify which fields must be retrieved
        (default is to retrieve all table fields, but you may need to access only
        one or several fields, and will save remote bandwidth by specifying the
        needed fields): notice that you should not use this optional parameter
        if you want to Update the retrieved record content later, since the
        missing fields will be left with previous values - but BatchUpdate() will
        set only ID, TModTime and mapped fields }
    constructor CreateAndFillPrepare(aClient: TSQLRest; const aSQLWhere: RawUTF8;
      const aCustomFieldsCSV: RawUTF8=''); overload;
    {/ this constructor initializes the object as above, and prepares itself to
      loop through a statement using a specified WHERE clause
      - this method creates a TSQLTableJSON, retrieves all records corresponding
        to the WHERE clause, then call FillPrepare - previous Create(aClient)
        methods retrieve only one record, this one more multiple rows
      - you should then loop for all rows using 'while Rec.FillOne do ...'
      - the TSQLTableJSON will be freed by TSQLRecord.Destroy
      - for better server speed, the WHERE clause should use bound parameters
        identified as '?' in the FormatSQLWhere statement, which is expected to
        follow the order of values supplied in BoundsSQLWhere open array - use
        DateToSQL/DateTimeToSQL for TDateTime, or directly any integer / double /
        currency / RawUTF8 values to be bound to the request as parameters
      - note that this method prototype changed with revision 1.17 of the
        framework: array of const used to be ParamsSQLWhere and '%' in the
        FormatSQLWhere statement, whereas it now expects bound parameters as '?'
      - aCustomFieldsCSV can be used to specify which fields must be retrieved
        (default is to retrieve all table fields, but you may need to access only
        one or several fields, and will save remote bandwidth by specifying the
        needed fields): notice that you should not use this optional parameter
        if you want to Update the retrieved record content later, since the
        missing fields will be left with previous values - but BatchUpdate() will
        set only ID, TModTime and mapped fields}
    constructor CreateAndFillPrepare(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
      const BoundsSQLWhere: array of const; const aCustomFieldsCSV: RawUTF8=''); overload;
    {/ this constructor initializes the object as above, and prepares itself to
      loop through a statement using a specified WHERE clause
      - this method creates a TSQLTableJSON, retrieves all records corresponding
        to the WHERE clause, then call FillPrepare - previous Create(aClient)
        methods retrieve only one record, this one more multiple rows
      - you should then loop for all rows using 'while Rec.FillOne do ...'
      - the TSQLTableJSON will be freed by TSQLRecord.Destroy
      - the FormatSQLWhere clause will replace all '%' chars with the supplied
        ParamsSQLWhere[] supplied values, and bind all '?' chars as parameters
        with BoundsSQLWhere[] values
      - aCustomFieldsCSV can be used to specify which fields must be retrieved
        (default is to retrieve all table fields, but you may need to access only
        one or several fields, and will save remote bandwidth by specifying the
        needed fields): notice that you should not use this optional parameter
        if you want to Update the retrieved record content later, since the
        missing fields will be left with previous values - but BatchUpdate() will
        set only ID, TModTime and mapped fields }
    constructor CreateAndFillPrepare(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
      const ParamsSQLWhere, BoundsSQLWhere: array of const;
      const aCustomFieldsCSV: RawUTF8=''); overload;
    {/ this constructor initializes the object as above, and prepares itself to
      loop through a given list of IDs
      - this method creates a TSQLTableJSON, retrieves all records corresponding
        to the specified IDs, then call FillPrepare - previous Create(aClient)
        methods retrieve only one record, this one more multiple rows
      - you should then loop for all rows using 'while Rec.FillOne do ...'
      - the TSQLTableJSON will be freed by TSQLRecord.Destroy
      - aCustomFieldsCSV can be used to specify which fields must be retrieved
        (default is to retrieve all table fields, but you may need to access only
        one or several fields, and will save remote bandwidth by specifying the
        needed fields): notice that you should not use this optional parameter
        if you want to Update the retrieved record content later, since the
        missing fields will be left with previous values - but BatchUpdate() will
        set only ID, TModTime and mapped fields }
    constructor CreateAndFillPrepare(aClient: TSQLRest; const aIDs: TIntegerDynArray;
      const aCustomFieldsCSV: RawUTF8=''); overload;
    {/ this constructor initializes the object, and prepares itself to loop
       through a specified JSON table
      - this method creates a TSQLTableJSON, fill it with the supplied JSON buffer,
        then call FillPrepare - previous Create(aClient) methods retrieve only
        one record, this one more multiple rows
      - you should then loop for all rows using 'while Rec.FillOne do ...'
      - the TSQLTableJSON will be freed by TSQLRecord.Destroy }
    constructor CreateAndFillPrepare(const aJSON: RawUTF8); overload;
    {/ this constructor initializes the object including all TSQLRecordMany properties,
      and prepares itself to loop through a JOINed statement
      - the created instance will have all its TSQLRecordMany Dest property allocated
        with proper instance (and not only pointer(DestID) e.g.), ready to be
        consumed during a while FillOne do... loop (those instances will be
        freed by TSQLRecord.FillClose or Destroy) - and the Source property
        won't contain pointer(SourceID) but the main TSQLRecord instance
      - the aFormatSQLJoin clause will define a WHERE clause for an automated
        JOINed statement, including TSQLRecordMany published properties (and
        their nested properties)
      - a typical use could be the following:
        ! aProd := TSQLProduct.CreateAndFillPrepareMany(Database,
        !   'Owner=? and Categories.Dest.Name=? and (Sizes.Dest.Name=? or Sizes.Dest.Name=?)',[],
        !   ['mark','for boy','small','medium']);
        ! if aProd<>nil then
        ! try
        !   while aProd.FillOne do
        !     // here e.g. aProd.Categories.Dest are instantied (and Categories.Source=aProd)
        !     writeln(aProd.Name,' ',aProd.Owner,' ',aProd.Categories.Dest.Name,' ',aProd.Sizes.Dest.Name);
        !   // you may also use aProd.FillTable to fill a grid, e.g.
        !   // (do not forget to set aProd.FillTable.OwnerMustFree := false)
        ! finally
        !   aProd.Free; // will also free aProd.Categories/Sizes instances
        ! end;
        this will execute a JOINed SELECT statement similar to the following:
        $ select p.*, c.*, s.*
        $ from Product p, Category c, Categories cc, Size s, Sizes ss
        $ where c.id=cc.dest and cc.source=p.id and
        $  s.id=ss.dest and ss.source=p.id and
        $  p.Owner='mark' and c.Name='for boy' and (s.Name='small' or s.Name='medium')
      - you SHALL call explicitely the FillClose method before using any
        methods of nested TSQLRecordMany instances which may override the Dest
        instance content (e.g. ManySelect) to avoid any GPF
      - the aFormatSQLJoin clause will replace all '%' chars with the supplied
        aParamsSQLJoin[] supplied values, and bind all '?' chars as bound
        parameters with aBoundsSQLJoin[] values }
    constructor CreateAndFillPrepareMany(aClient: TSQLRest; aFormatSQLJoin: PUTF8Char;
      const aParamsSQLJoin, aBoundsSQLJoin: array of const);
    {/ this method create a clone of the current record, with same ID and properties
      - copy all COPIABLE_FIELDS, i.e. all fields excluding tftMany (because
        those fields don't contain any data, but a TSQLRecordMany instance
        which allow to access to the pivot table data) }
    function CreateCopy: TSQLRecord;
    /// release the associated memory
    // - in particular, release all TSQLRecordMany instance created by the
    // constructor of this TSQLRecord
    destructor Destroy; override;

    {/ return the UTF-8 encoded SQL source to create the table containing the
      published fields of a TSQLRecord child
     - a 'ID INTEGER PRIMARY KEY' field is always created first (mapping
       SQLite3 RowID)
     - AnsiString are created as TEXT COLLATE NOCASE (fast SQLite3 7bits compare)
     - RawUnicode and RawUTF8 are created as TEXT COLLATE SYSTEMNOCASE
       (i.e. use our fast UTF8IComp() for comparaison)
     - TDateTime are created as TEXT COLLATE ISO8601
      (which calls our very fast ISO TEXT to Int64 conversion routine)
     - an individual bit set in UniqueField forces the corresponding field to
      be marked as UNIQUE (an unique index is automaticaly created on the specified
      column); use TSQLModel fIsUnique[] array, which set the bits values
      to 1 if a property field was published with "stored AS_UNIQUE"
      (i.e. "stored false")
     - this method will handle TSQLRecordFTS* classes like FTS* virtual tables,
       TSQLRecordRTree as RTREE virtual table, and TSQLRecordVirtualTable*ID
       classes as corresponding Delphi designed virtual tables
     - is not part of TSQLRecordProperties because has been declared as virtual
       so that you could specify a custom SQL statement, per TSQLRecord type
     - anyway, don't call this method directly, but use TSQLModel.GetSQLCreate()
     - the aModel parameter is used to retrieve the Virtual Table module name,
       and can be ignored for regular (not virtual) tables }
    class function GetSQLCreate(aModel: TSQLModel): RawUTF8; virtual;
    {/ return the Class Type of the current TSQLRecord }
    function RecordClass: TSQLRecordClass;
      {$ifdef PUREPASCAL} {$ifdef HASINLINE}inline;{$endif} {$endif}
    {/ return the RTTI property information for this record }
    function ClassProp: PClassProp;
      {$ifdef PUREPASCAL} {$ifdef HASINLINE}inline;{$endif} {$endif}
    {/ return the TRecordReference pointing to this record }
    function RecordReference(Model: TSQLModel): TRecordReference;

    {/ return the UTF-8 encoded SQL source to INSERT the values contained
      in the current published fields of a TSQLRecord child
      - only simple fields name (i.e. not TSQLRawBlob/TSQLRecordMany) are updated:
        BLOB fields are ignored (use direct update via dedicated methods instead)
      - format is '(COL1, COL2) VALUES ('VAL1', 'VAL2')' if some column was ignored (BLOB e.g.)
      - format is 'VALUES ('VAL1', 'VAL2')' if all columns values are available
      - is not used by the ORM (do not use prepared statements) - only here
        for conveniency }
    function GetSQLValues: RawUTF8;
    {/ return the UTF-8 encoded SQL source to UPDATE the values contained
      in the current published fields of a TSQLRecord child
      - only simple fields name (i.e. not TSQLRawBlob/TSQLRecordMany) are retrieved:
        BLOB fields are ignored (use direct access via dedicated methods instead)
      - format is 'COL1='VAL1', COL2='VAL2''
      - is not used by the ORM (do not use prepared statements) - only here
        for conveniency }
    function GetSQLSet: RawUTF8;
    (** return the UTF-8 encoded JSON objects for the values contained
      in the current published fields of a TSQLRecord child
      - only simple fields (i.e. not TSQLRawBlob/TSQLRecordMany) are retrieved:
        BLOB fields are ignored (use direct access via dedicated methods instead)
      - if Expand is true, JSON data is an object, for direct use with any Ajax or .NET client:
      ! {"col1":val11,"col2":"val12"}
      - if Expand is false, JSON data is serialized (as used in TSQLTableJSON)
      ! { "fieldCount":1,"values":["col1","col2",val11,"val12",val21,..] }
      - if withID is true, then the first ID field value is included *)
    procedure GetJSONValues(JSON: TStream; Expand: boolean; withID: boolean;
      Occasion: TSQLOccasion); overload;
    /// same as above, but returning result into a RawUTF8
    // - if UsingStream is not set, it will use a temporary THeapMemoryStream instance
    function GetJSONValues(Expand: boolean; withID: boolean; Occasion: TSQLOccasion;
      UsingStream: TCustomMemoryStream=nil): RawUTF8; overload;
    /// same as above, but in a TJSONWriter (called by the first two overloaded
    // functions)
    procedure GetJSONValues(W: TJSONSerializer); overload;
    /// write the field values into the binary buffer
    // - won't write the ID field (should be stored before, with the Count e.g.)
    procedure GetBinaryValues(W: TFileBufferWriter);
    /// set the field values from a binary buffer
    // - won't read the ID field (should be read before, with the Count e.g.)
    // - returns true on success, or false in case of invalid content in P e.g.
    // - P is updated to the next pending content after the read values
    function SetBinaryValues(var P: PAnsiChar): Boolean;
    /// set all field values from a supplied array of TVarData sub type
    // - the field values are available via some TVarData of type
    // varNull, varInt64, varDouble, varString (mapping a constant PUTF8Char),
    // and varAny (BLOB with size = VLongs[0])
    // - Values[] array must match the RecordProps.Field[] order: will return
    // false if the Values[].VType does not match RecordProps.FieldType[]
    function SetFieldVarDatas(const Values: TVarDataDynArray): boolean;
    {/ retrieve a field value from a given property name, as encoded UTF-8 text
      - you should use strong typing and direct property access, following
        the ORM approach of the framework; but in some cases (a custom Grid
        display, for instance), it could be usefull to have this method available
      - will return '' in case of wrong property name
      - BLOB and dynamic array fields are returned as '\uFFF0base64encodedbinary'  }
    function GetFieldValue(const PropName: RawUTF8): RawUTF8;
    {/ set a field value of a given property name, from some encoded UTF-8 text
      - you should use strong typing and direct property access, following
        the ORM approach of the framework; but in some cases (a custom Grid
        display, for instance), it could be usefull to have this method available
       - won't do anything in case of wrong property name 
       - expect BLOB and dynamic array fields encoded as SQlite3 BLOB literals
        ("x'01234'" e.g.) or '\uFFF0base64encodedbinary' }
    procedure SetFieldValue(const PropName: RawUTF8; Value: PUTF8Char);
    {$ifdef USEVARIANTS}
    /// retrieve the published property value into a Variant
    // - will set the Variant type to the best matching kind according to the
    // property type
    // - will return a null variant in case of wrong property name
    // - BLOB fields are returned as SQlite3 BLOB literals ("x'01234'" e.g.)
    // - dynamic array fields are returned as a Variant array
    function GetFieldVariant(const PropName: string): Variant;
    /// set the published property value from a Variant value
    // - will convert from the variant type into UTF-8 text before setting the
    // value (so will work with any kind of Variant)
    // - won't do anything in case of wrong property name
    // - expect BLOB fields encoded as SQlite3 BLOB literals ("x'01234'" e.g.)
    procedure SetFieldVariant(const PropName: string; const Source: Variant);
    {$endif}

    {/ prepare to get values from a TSQLTable result
     - then call FillRow() to get Table.RowCount row values
     - you can also loop through all rows with
     ! while Rec.FillOne do
     !   dosomethingwith(Rec);
     - the specified TSQLTable is stored in an internal fTable protected field
     - set aCheckTableName if you want e.g. the Field Names from the Table
       any pending 'TableName.' trimmed before matching to the current record }
    procedure FillPrepare(Table: TSQLTable; aCheckTableName: TSQLCheckTableName=ctnNoCheck); overload;
    {/ prepare to get values from a SQL where statement
     - returns true in case of success, false in case of an error during SQL request
     - then call FillRow() to get Table.RowCount row values
     - you can also loop through all rows with
     ! while Rec.FillOne do
     !   dosomethingwith(Rec);
     - a temporary TSQLTable is created then stored in an internal fTable protected field
     - if aSQLWhere is left to '', all rows are retrieved as fast as possible
       (e.g. by-passing SQLite3 virtual table modules for external databases)
     - the WHERE clause should use inlined parameters (like 'Name=:('Arnaud'):')
       for better server speed - note that you can use FormatUTF8() as such:
       ! aRec.FillPrepare(Client,FormatUTF8('Salary>? AND Salary<?',[],[1000,2000]));
       or call the overloaded FillPrepare() method directly with  BoundsSQLWhere
       array of parameters
     - aCustomFieldsCSV can be used to specify which fields must be retrieved
       (default is to retrieve all table fields, but you may need to access only
       one or several fields, and will save remote bandwidth by specifying the
       needed fields): notice that you should not use this optional parameter
       if you want to Update the retrieved record content later, since the
       missing fields will be left with previous values - but BatchUpdate() can be
       safely used after FillPrepare (will set only ID, TModTime and mapped fields) }
    function FillPrepare(aClient: TSQLRest; const aSQLWhere: RawUTF8='';
      const aCustomFieldsCSV: RawUTF8=''; aCheckTableName: TSQLCheckTableName=ctnNoCheck): boolean; overload;
    {/ prepare to get values using a specified WHERE clause with '%' parameters
     - returns true in case of success, false in case of an error during SQL request
     - then call FillRow() to get Table.RowCount row values
     - you can also loop through all rows with
     ! while Rec.FillOne do
     !   dosomethingwith(Rec);
     - a temporary TSQLTable is created then stored in an internal fTable protected field
     - for better server speed, the WHERE clause should use bound parameters
       identified as '?' in the FormatSQLWhere statement, which is expected to
       follow the order of values supplied in BoundsSQLWhere open array - use
       DateToSQL/DateTimeToSQL for TDateTime, or directly any integer / double /
       currency / RawUTF8 values to be bound to the request as parameters
     - note that this method prototype changed with revision 1.17 of the
       framework: array of const used to be ParamsSQLWhere and '%' in the
       FormatSQLWhere statement, whereas it now expects bound parameters as '?'
     - aCustomFieldsCSV can be used to specify which fields must be retrieved
       (default is to retrieve all table fields, but you may need to access only
       one or several fields, and will save remote bandwidth by specifying the
       needed fields): notice that you should not use this optional parameter
       if you want to Update the retrieved record content later, since the
       missing fields will be left with previous values - but BatchUpdate() will
       set only ID, TModTime and mapped fields }
    function FillPrepare(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
      const BoundsSQLWhere: array of const; const aCustomFieldsCSV: RawUTF8=''): boolean; overload;
    {/ prepare to get values using a specified WHERE clause with '%' and '?' parameters
     - returns true in case of success, false in case of an error during SQL request
     - then call FillRow() to get Table.RowCount row values
     - you can also loop through all rows with
     ! while Rec.FillOne do
     !   dosomethingwith(Rec);
     - a temporary TSQLTable is created then stored in an internal fTable
       protected field
     - the FormatSQLWhere clause will replace all '%' chars with the supplied
       ParamsSQLWhere[] supplied values, and bind all '?' chars as bound
       parameters with BoundsSQLWhere[] values
     - aCustomFieldsCSV can be used to specify which fields must be retrieved
       (default is to retrieve all table fields, but you may need to access only
       one or several fields, and will save remote bandwidth by specifying the
       needed fields): notice that you should not use this optional parameter
       if you want to Update the retrieved record content later, since the
       missing fields will be left with previous values - but BatchUpdate() will
       set only ID, TModTime and mapped fields }
    function FillPrepare(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
      const ParamsSQLWhere, BoundsSQLWhere: array of const;
      const aCustomFieldsCSV: RawUTF8=''): boolean; overload;
    {/ prepare to get values from a list of IDs
     - returns true in case of success, false in case of an error during SQL request
     - then call FillRow() to get Table.RowCount row values
     - you can also loop through all rows with
     ! while Rec.FillOne do
     !   dosomethingwith(Rec);
     - a temporary TSQLTable is created then stored in an internal fTable protected field
     - aCustomFieldsCSV can be used to specify which fields must be retrieved
       (default is to retrieve all table fields, but you may need to access only
       one or several fields, and will save remote bandwidth by specifying the
       needed fields): notice that you should not use this optional parameter
       if you want to Update the retrieved record content later, since the
       missing fields will be left with previous values - but BatchUpdate() will
       set only ID, TModTime and mapped fields }
    function FillPrepare(aClient: TSQLRest; const aIDs: TIntegerDynArray;
      const aCustomFieldsCSV: RawUTF8=''): boolean; overload;
    {/ prepare to loop through a JOINed statement including TSQLRecordMany fields
     - all TSQLRecordMany.Dest published fields will now contain a true TSQLRecord
       instance, ready to be filled with the JOINed statement results (these
       instances will be released at FillClose) - the same for Source which will
       point to the self instance
     - the aFormatSQLJoin clause will define a WHERE clause for an automated
       JOINed statement, including TSQLRecordMany published properties (and
       their nested properties)
     - returns true in case of success, false in case of an error during SQL request
     - a typical use could be the following:
       ! if aProd.FillPrepareMany(Database,
       !    'Owner=? and Categories.Dest.Name=? and (Sizes.Dest.Name=? or Sizes.Dest.Name=?)',[],
       !    ['mark','for boy','small','medium']) then
       !   while aProd.FillOne do
       !     // here e.g. aProd.Categories.Dest are instantied (and Categories.Source=aProd)
       !     writeln(aProd.Name,' ',aProd.Owner,' ',aProd.Categories.Dest.Name,' ',aProd.Sizes.Dest.Name);
       !   // you may also use aProd.FillTable to fill a grid, e.g.
       !   // (do not forget to set aProd.FillTable.OwnerMustFree := false)
       this will execute a JOINed SELECT statement similar to the following:
       $ select p.*, c.*, s.*
       $ from Product p, Category c, Categories cc, Size s, Sizes ss
       $ where c.id=cc.dest and cc.source=p.id and
       $  s.id=ss.dest and ss.source=p.id and
       $  p.Owner='mark' and c.Name='for boy' and (s.Name='small' or s.Name='medium')
     - the FormatSQLWhere clause will replace all '%' chars with the supplied
       ParamsSQLWhere[] supplied values, and bind all '?' chars as parameters
       with BoundsSQLWhere[] values
     - you SHALL call explicitely the FillClose method before using any
       methods of nested TSQLRecordMany instances which may override the Dest
       instance content (e.g. ManySelect) to avoid any GPF
     - is used by TSQLRecord.CreateAndFillPrepareMany constructor }
    function FillPrepareMany(aClient: TSQLRest; aFormatSQLJoin: PUTF8Char;
      const aParamsSQLJoin, aBoundsSQLJoin: array of const): boolean;
    {/ fill all published properties of an object from a TSQLTable prepared row
      - FillPrepare() must have been called before
      - if Dest is nil, this object values are filled
      - if Dest is not nil, this object values will be filled, but it won't
        work with TSQLRecordMany properties (i.e. after FillPrepareMany call)
      - ID field is updated if first Field Name is 'ID'
      - Row number is from 1 to Table.RowCount
      - setter method (write Set*) is called if available
      - handle UTF-8 SQL to Delphi values conversion (see TPropInfo mapping)
      - this method has been made virtual e.g. so that a calculated value can be
        used in a custom field }
    procedure FillRow(aRow: integer; aDest: TSQLRecord=nil); virtual;
    {/ fill all published properties of this object from the next available
      TSQLTable prepared row
      - FillPrepare() must have been called before
      - the Row number is taken from property FillCurrentRow
      - return true on success, false if no more Row data is available
      - call FillRow() to update published properties values }
    function FillOne: boolean;
    {/ go to the first prepared row, ready to loop through all rows with FillRow()
      - the Row number (property FillCurrentRow) is reset to 1
      - return true on success, false if no Row data is available }
    function FillRewind: boolean;
    {/ close any previous FillPrepare..FillOne loop
     - is called implicitely by FillPrepare() call to release any previous loop
     - release the internal hidden TSQLTable instance if necessary
     - is not mandatory if the TSQLRecord is released just after, since
       TSQLRecord.Destroy will call it
     - used e.g. by FillFrom methods below to avoid any GPF/memory confusion }
    procedure FillClose;

    {/ fill all published properties of this object from a TSQLTable result row
      - call FillPrepare() then FillRow() }
    procedure FillFrom(Table: TSQLTable; Row: integer); overload;
    {/ fill all published properties of this object from a JSON result row
     - create a TSQLTable from the JSON data
     - call FillPrepare() then FillRow() }
    procedure FillFrom(const JSONTable: RawUTF8; Row: integer); overload;
    {/ fill all published properties of this object from a JSON object result
      - use JSON data, as exported by GetJSONValues()
      - JSON data may be expanded or not
      - make an internal copy of the JSONTable RawUTF8 before calling
       FillFrom() below}
    procedure FillFrom(const JSONRecord: RawUTF8); overload;
    {/ fill all published properties of this object from a JSON result
      - the data inside P^ is modified (unescaped and transformed): don't call
       FillFrom(pointer(JSONRecordUTF8)) but FillFrom(JSONRecordUTF8) which makes
       a temporary copy of the JSONRecordUTF8 text
      - use JSON data, as exported by GetJSONValues()
      - JSON data may be expanded or not }
    procedure FillFrom(P: PUTF8Char); overload;
    {/ fill all published properties of this object from another object
      - source object must be a parent or of the same class as the current record 
      - copy all COPIABLE_FIELDS, i.e. all fields excluding tftMany (because
        those fields don't contain any data, but a TSQLRecordMany instance
        which allow to access to the pivot table data) }
    procedure FillFrom(aRecord: TSQLRecord); overload;
    {/ fill a published property value of this object from a UTF-8 encoded value
     - see TPropInfo about proper Delphi / UTF-8 type mapping/conversion
     - use this method to fill a BLOB property, i.e. a property defined with
       type TSQLRawBlob, since by default all BLOB properties are not
       set by the standard Retrieve() method (to save bandwidth) }
    procedure FillValue(PropName, Value: PUTF8Char; wasString: boolean);

    {/ return true if all published properties values in Other are identical to
     the published properties of this object
      - work with different classes: Reference properties name must just be
      present in the calling object
      - only simple fields (i.e. not TSQLRawBlob/TSQLRecordMany) are compared
      - compare the text representation of the values: fields may be of different
      type, encoding or precision, but still have same values }
    function SameValues(Reference: TSQLRecord): boolean;
    {/ return true if all published properties values in Other are identical to
      the published properties of this object
      - instances must be of the same class type
      - only simple fields (i.e. not TSQLRawBlob/TSQLRecordMany) are compared 
      - comparaison is much faster than SameValues() above }
    function SameRecord(Reference: TSQLRecord): boolean;
    /// clear the values of all published properties, and also the ID property
    procedure ClearProperties;
    /// set the simple fields with the supplied values
    // - the aSimpleFields parameters must follow explicitely the order of published
    // properties of the supplied aTable class, excepting the TSQLRawBlob and
    // TSQLRecordMany kind (i.e. only so called "simple fields") - in particular,
    // parent properties must appear first in the list
    // - the aSimpleFields must have exactly the same count of parameters as there are
    // "simple fields" in the published properties
    // - return true on success, but be aware that the field list must match
    // the field layout, otherwise if may return true but will corrupt data
    function SimplePropertiesFill(const aSimpleFields: array of const): boolean;
    /// initialize a TDynArray wrapper to map dynamic array property values
    // - if the field name is not existing or not a dynamic array, result.IsVoid
    // will be TRUE
    function DynArray(const DynArrayFieldName: RawUTF8): TDynArray; overload;
    /// initialize a TDynArray wrapper to map dynamic array property values
    // - this overloaded version expect the dynamic array to have been defined
    // with a not null index attribute, e.g.
    // ! published
    // !   property Ints: TIntegerDynArray index 1 read fInts write fInts;
    // !   property Currency: TCurrencyDynArray index 2 read fCurrency write fCurrency;
    // - if the field index is not existing or not a dynamic array, result.IsVoid
    // will be TRUE
    function DynArray(DynArrayFieldIndex: integer): TDynArray; overload;

    {/ this property stores the record's integer ID
      - if this TSQLRecord is not a instance, but a field value in a published
        property of type sftID (i.e. TSQLRecord(aID)), this method will try
        to retrieve it; but prefered method is to typecast it via PtrInt(aProperty),
        because GetID() relies on some low-level Windows memory mapping trick, and
        will recognize an ID value up to 1,048,576 (i.e. $100000)
      - notice: the Setter should not be used usualy; you should not have to write
        aRecord.ID := someID in your code, since the ID is set during Retrieve or
        Add of the record }
    property ID: integer read GetID write fID;
    /// this read-only property can be used to retrieve the ID as a TSQLRecord object
    // - published properties of type TSQLRecord (one-to-many relationship) do not
    // store real class instances (only exception is if they inherit from
    // TSQLRecordMany) - you can use this value to assign a TSQLRecord instance
    // to a published property, as such:
    // ! Main := TSQLRecordMain.Create;
    // ! Client.Add(Main);
    // ! Detail := TSQLRecordDetail.Create;
    // ! Detail.Main := Main.AsTSQLRecord; // will store Main.ID in MAIN column
    // ! Client.Add(Detail);
    // - is especially useful on 64 bit plaform, since on 32 bit:
    // ! Detail.Main := pointer(Main.ID)
    // compiles (whereas it won't on 64 bit) and is the same than platform-independent
    // ! Detail.Main := Main.AsTSQLRecord;
    // - using Main.AsTSQLRecord will ensure that the ID is retrieved, even
    // if Main itself is not a true instance
    property AsTSQLRecord: pointer read GetIDAsPointer;
    {/ this property is set to true, if any published property is a BLOB (TSQLRawBlob) }
    property HasBlob: boolean read GetHasBlob;
    {/ this property returns the published property count with any valid
      database field except TSQLRawBlob/TSQLRecordMany
    - by default, the TSQLRawBlob (BLOB) fields are not included into this set:
      they must be read specificaly (in order to spare bandwidth)
    - TSQLRecordMany fields are not accessible directly, but as instances
      created by TSQLRecord.Create }
    property SimpleFieldCount: integer read GetSimpleFieldCount;
    {/ this property contains the TSQLTable after a call to FillPrepare() }
    property FillTable: TSQLTable read GetTable;
    {/ this property contains the current row number (beginning with 1),
      initialized to 1 by FillPrepare(), which will be read by FillOne }
    property FillCurrentRow: integer read GetFillCurrentRow;
    {/ this property contains the internal state counter of the server database
      when the data was retrieved from it
      - may be used to check if retrieved data may be out of date }
    property InternalState: cardinal read fInternalState;
  published
    { published properties in inherited classes will be interpreted as SQL fields }
  end;

  /// wrapper to an ORM result table, staticaly stored as UTF-8 text
  // - contain all result in memory, until destroyed
  // - first row contains the field names
  // - following rows contains the data itself
  // - GetA() or GetW() can be used in a TDrawString
  // - will be implemented as TSQLTableDB for direct SQLite3 database engine call,
  //  or as TSQLTableJSON for remote access through optimized JSON messages
  TSQLTable = class
  private
    fQueryTables: TSQLRecordClassDynArray;
    fQuerySQL: RawUTF8;
    fFieldLengthMean: TIntegerDynArray;
    fFieldLengthMeanSum: integer;
  protected
    fRowCount,
    fFieldCount: integer;
    /// contains the data, as returned by sqlite3_get_table()
    fResults: PPUTF8CharArray;
    /// contains the TSQLFieldType and TypeInfo(enumerate), after calculation
    // from the fQueryTables values
    fFieldType: array of record
      // the field kind
      ContentType: TSQLFieldType;
      // initialized for both sftEnumerate and sftSet field kinds
      EnumTypeInfo: pointer;
      // the corresponding index in fQueryTables[]
      TableIndex: integer;
    end;
    /// used by FieldIndex() for fast binary searcg
    fFieldNameOrder: TCardinalDynArray;
    /// contain the fResults[] pointers, after a IDColumnHide() call
    fIDColumn, fNotIDColumn: array of PUTF8Char;
    /// bit set at parsing to mark was a string value (e.g. "..." in JSON)
    fFieldParsedAsString: set of 0..255;
    /// index of a 'ID' field, -1 if none (e.g. after IDColumnHide method call)
    fFieldIndexID: integer;
    /// the internal state counter of the database when the data was retrieved
    fInternalState: cardinal;
    /// contains the parameters used for sorting
    fSortParams: TSQLTableSortParams;
    /// contains the TSQLRecord instances created by NewRecord method
    fOwnedRecords: TObjectList;
    /// if the TSQLRecord is the owner of this table, i.e. if it must free it
    fOwnerMustFree: Boolean;
    /// current cursor row (1..RowCount), as set by the Step() method
    fStepRow: integer;
    /// fill the fFieldType[] array (from fQueryTables[] or fResults[] content)
    procedure InitFieldTypes;
  public
    /// initialize the result table
    // - you can optionaly associate the corresponding TSQLRecordClass types,
    // by which the results were computed (it will use RTTI for column typing)
    constructor Create(const Tables: array of TSQLRecordClass; const aSQL: RawUTF8);
    /// free associated memory and owned records
    destructor Destroy; override;
    {/ read-only access to a particular field value, as UTF-8 encoded buffer
     - points to memory buffer allocated by Init() }
    function Get(Row,Field: integer): PUTF8Char;
    {/ read-only access to a particular field value, as RawUTF8 text }
    function GetU(Row,Field: integer): RawUTF8;
    {/ read-only access to a particular field value, as Win Ansi text }
    function GetA(Row,Field: integer): WinAnsiString;
    {/ read-only access to a particular field value, as Win Ansi text shortstring}
    function GetS(Row,Field: integer): shortstring;
    {$ifdef USEVARIANTS}
    {/ read-only access to a particular field value, as a Variant
     - will try to use the most approriate Variant type for conversion (will
       use e.g. TDateTime for sftDateTime or sftTimeLog, Extended for sftFloat...)
     - will handle any necessary conversion to VCL string text, ready to be displayed
     - the global UTF8ToString() function will be used for the conversion:
       for proper i18n handling before Delphi 2009, you should use the
       overloaded method with aUTF8ToString=Language.UTF8ToString }
    function GetVariant(Row,Field: integer; Client: TObject): variant; overload;
    {/ read-only access to a particular field value, as a Variant
     - will try to use the most approriate Variant type for conversion (will
       use e.g. TDateTime for sftDateTime or sftTimeLog, Extended for sftFloat...)
     - will handle any necessary conversion to VCL string text, ready to be displayed
     - the global UTF8ToString() function will be used for the conversion:
       for proper i18n handling before Delphi 2009, you should use the
       overloaded method with aUTF8ToString=Language.UTF8ToString }
    procedure GetVariant(Row,Field: integer; Client: TObject; var result: variant); overload;
    {$endif}
    {/ read-only access to a particular field value, as VCL string text
     - the global UTF8ToString() function will be used for the conversion:
     for proper i18n handling before Delphi 2009, you should use the
     overloaded method with aUTF8ToString=Language.UTF8ToString }
    function GetString(Row,Field: integer): string;
    /// read-only access to a particular field value, as fast Unicode string text
    // - SynUnicode is either WideString, either UnicodeString, depending on the
    // Delphi compiler revision, to ensure fastest native Unicode process available
    function GetSynUnicode(Row,Field: integer): SynUnicode;
    {/ fill a unicode buffer with a particular field value
      - return number of wide characters written in Dest^ }
    function GetWP(Row,Field: integer; Dest: PWideChar; MaxDestChars: cardinal): integer;
    {/ read-only access to a particular field value, as UTF-16 Unicode text
      - Raw Unicode is WideChar(zero) terminated
      - its content is allocated to contain all WideChars (not trimed to 255,
        like GetWP() above }
    function GetW(Row,Field: integer): RawUnicode;
    {/ read-only access to a particular field value, as integer value }
    function GetAsInteger(Row,Field: integer): integer;
      {$ifdef HASINLINE}inline;{$endif}
    {/ read-only access to a particular field value, as Int64 value }
    function GetAsInt64(Row,Field: integer): Int64;
      {$ifdef HASINLINE}inline;{$endif}
    {/ read-only access to a particular field value, ready to be displayed
      - mostly used with Row=0, i.e. to get a display value from a field name
      - use "string" type, i.e. UnicodeString for Delphi 2009+
      - value is first un-camel-cased: 'OnLine' value will return 'On line' e.g.
      - then System.LoadResStringTranslate() is called if available }
    function GetCaption(Row,Field: integer): string;
    {/ read-only access to a particular Blob value
     - a new TSQLRawBlob is created
     - Blob data is converted from SQLite3 BLOB literals (X'53514C697465' e.g.)
       or Base-64 encoded content ('\uFFF0base64encodedbinary')
     - prefered manner is to directly use REST protocol to retrieve a blob field }
    function GetBlob(Row,Field: integer): TSQLRawBlob;
    {/ read-only access to a particular Blob value
     - a new TBytes is created
     - Blob data is converted from SQLite3 BLOB literals (X'53514C697465' e.g.)
       or Base-64 encoded content ('\uFFF0base64encodedbinary')
     - prefered manner is to directly use REST protocol to retrieve a blob field }
    function GetBytes(Row,Field: integer): TBytes;
    {/ read-only access to a particular Blob value
     - a new TCustomMemoryStream is created - caller shall free its instance
     - Blob data is converted from SQLite3 BLOB literals (X'53514C697465' e.g.)
       or Base-64 encoded content ('\uFFF0base64encodedbinary')
     - prefered manner is to directly use REST protocol to retrieve a blob field }
    function GetStream(Row,Field: integer): TStream;
    {/ read-only access to a particular field value, as VCL text
     - Client is one TSQLClient instance (used to display TRecordReference via
       the associated TSQLModel)
     - returns the Field Type
     - return generic string Text, i.e. UnicodeString for Delphi 2009+,
       ready to be displayed to the VCL, for sftEnumerate, sftTimeLog
       and sftRecord/sftID
     - returns '' as string Text, if text can by displayed directly
       with Get*() methods above
     - returns '' for other properties kind, if UTF8ToString is nil,
       or the ready to be displayed value if UTF8ToString event is set
       (to be used mostly with Language.UTF8ToString) }
    function ExpandAsString(Row,Field: integer; Client: TObject; out Text: string): TSQLFieldType;
    {/ read-only access to a particular field value, as VCL text
     - this method is just a wrapper around ExpandAsString method, returning
       the content as a SynUnicode string type (i.e. UnicodeString since Delphi
       2009, and WideString for non Unicode versions of Delphi)
     - it is used by the reporting layers of the framework (e.g. TSQLRibbon.AddToReport) }
    function ExpandAsSynUnicode(Row,Field: integer; Client: TObject; out Text: SynUnicode): TSQLFieldType;
    {/ read-only access to a particular DateTime field value
     - expect SQLite3 TEXT field in ISO 8601 'YYYYMMDD hhmmss' or
      'YYYY-MM-DD hh:mm:ss' format }
    function GetDateTime(Row,Field: integer): TDateTime;
      {$ifdef PUREPASCAL} {$ifdef HASINLINE}inline;{$endif} {$endif}
    {/ read-only access to a particular TTimeLog field value
      - return the result as Iso8601.Text() Iso-8601 encoded text }
    function GetTimeLog(Row,Field: integer; Expanded: boolean; FirstTimeChar: AnsiChar = 'T'): RawUTF8;
    {/ widechar length (UTF-8 decoded) of a particular field value }
    function LengthW(Row,Field: integer): integer;
    {/ get all values for a specified field into a dynamic RawUTF8 array
     - don't perform any conversion, but just create an array of raw PUTF8Char data }
    procedure GetRowValues(Field: integer; out Values: TRawUTF8DynArray); overload;
    {/ get all values for a specified field into a dynamic Integer array }
    procedure GetRowValues(Field: integer; out Values: TIntegerDynArray); overload;
    {/ get all values for a specified field as CSV
     - don't perform any conversion, but create a CSV from raw PUTF8Char data }
    function GetRowValues(Field: integer; Sep: AnsiChar=','): RawUTF8; overload;

    /// save the table values in JSON format
    // - JSON data is added to TStream, with UTF-8 encoding
    // - if Expand is true, JSON data is an array of objects, for direct use
    // with any Ajax or .NET client:
    // & [ {"col1":val11,"col2":"val12"},{"col1":val21,... ]
    // - if Expand is false, JSON data is serialized (used in TSQLTableJSON)
    // & { "fieldCount":1,"values":["col1","col2",val11,"val12",val21,..] }
    // - RowFirst and RowLast can be used to ask for a specified row extent
    // of the returned data (by default, all rows are retrieved)
    procedure GetJSONValues(JSON: TStream; Expand: boolean;
      RowFirst: integer=0; RowLast: integer=0); overload;
    /// same as above, but returning result into a RawUTF8
    function GetJSONValues(Expand: boolean): RawUTF8; overload;
    /// save the table in CSV format
    // - if Tab=TRUE, will use TAB instead of ',' between columns
    // - you can customize the ',' separator - use e.g. the global ListSeparator
    // variable (from SysUtils) to reflect the current system definition (some
    // country use ',' as decimal separator, for instance our "douce France")
    // - AddBOM will add a UTF-8 Byte Order Mark at the beginning of the content
    procedure GetCSVValues(Dest: TStream; Tab: boolean; CommaSep: AnsiChar=',';
      AddBOM: boolean=false);

    {/ get the Field index of a FieldName
     - return -1 if not found, index (0..FieldCount-1) if found }
    function FieldIndex(FieldName: PUTF8Char): integer; overload;
    {/ get the Field index of a FieldName
     - return -1 if not found, index (0..FieldCount-1) if found }
    function FieldIndex(const FieldName: RawUTF8): integer; overload;
      {$ifdef HASINLINE}inline;{$endif}
    {/ get the Field content (encoded as UTF-8 text) from a property name
     - return nil if not found }
    function FieldValue(const FieldName: RawUTF8; Row: integer): PUTF8Char;
    {/ sort result Rows, according to a specific field
     - default is sorting by ascending order (Asc=true)
     - you can specify a Row index to be updated during the sort in PCurrentRow
     - sort is very fast, even for huge tables (more faster than any indexed
       SQL query): 500,000 rows are sorted instantly
     - this optimized sort implementation does the comparaison first by the
     designed field, and, if the field value is identical, the ID value is
     used (it will therefore sort by time all identical values) }
    procedure SortFields(Field: integer; Asc: boolean=true;
      PCurrentRow: PInteger=nil; FieldType: TSQLFieldType=sftUnknown;
      CustomCompare: TUTF8Compare=nil); overload;
    /// sort result Rows, according to some specific fields
    // - is able to make multi-field sort
    // - both Fields[] and Asc[] array should have the same count, otherwise
    // default Asc[]=true value will be assumed
    // - set any Fields[]=-1 to identify the ID column (even if is hidden)
    procedure SortFields(const Fields: array of integer;
      const Asc: array of boolean); overload;
    {/ sort result Rows, according to the Bits set to 1 first }
    procedure SortBitsFirst(var Bits);
    {/ guess the field type from first non null data row
     - if QueryTables[] are set, exact field type and enumerate TypeInfo() is
       retrieved from the Delphi RTTI; otherwize, get from the cells content
     - return sftUnknown is all data fields are null
     - sftBlob is returned if the field is encoded as SQLite3 BLOB literals
       (X'53514C697465' e.g.)
     - since TSQLTable data is PUTF8Char, string type is sftUTF8Text only }
    function FieldType(Field: integer; EnumTypeInfo: PPointer): TSQLFieldType;
    {/ get the appropriate Sort comparaison function for a field,
      nil if not available (bad field index or field is blob)
      - field type is guessed from first data row }
    function SortCompare(Field: integer): TUTF8Compare;
    /// get the mean of characters length of all fields
    // - the character length is for the first line of text only (stop counting
    // at every newline character, i.e. #10 or #13 char)
    // - return the sum of all mean of character lengths
    function CalculateFieldLengthMean(var aResult: TIntegerDynArray;
      FromDisplay: boolean=false): integer;
    /// get the mean of characters length of this field
    // - the character length is for the first line of text only (stop counting
    // at every newline character, i.e. #10 or #13 char)
    // - very fast: calculated only once for all fields
    function FieldLengthMean(Field: integer): cardinal;
    /// get the sum of all mean of characters length of all fields
    // - very fast: calculated only once for all fields
    function FieldLengthMeanSum: cardinal;
    /// get the maximum number of characters of this field
    function FieldLengthMax(Field: integer; NeverReturnsZero: boolean=false): cardinal;
    /// get the record class (i.e. the table) associated to a field
    // - is nil if this table has no QueryTables property
    // - very fast: calculated only once for all fields
    function FieldTable(Field: integer): TClass;
    /// force the mean of characters length for every field
    // - expect as many parameters as fields in this table
    // - override internal fFieldLengthMean[] and fFieldLengthMeanSum values
    procedure SetFieldLengthMean(const Lengths: array of cardinal);
    /// increase a particular Field Length Mean value
    // - to be used to customize the field appareance (e.g. for adding of left
    // checkbox for Marked[] fields)
    procedure FieldLengthMeanIncrease(aField, aIncrease: integer);

    {/ copy the parameters of a TSQLTable into this instance
     - the fResults remain in the source TSQLTable: source TSQLTable has not to
      be destroyed before this TSQLTable }
    procedure Assign(source: TSQLTable);

    /// search a text value inside the table data in a specified field
    // - the text value must already be uppercased 7-bits ANSI encoded
    // - return the Row on success, 0 on error
    // - search only in the content of FieldIndex data
    // - you can specify a Soundex pronunciation to use, or leave as sndxNone for
    // standard case insensitive character match; aUpperValue can optional
    // indicate a Soundex search, by predeceding the searched text with % for
    // English, %% for French or %%% for Spanish (only works with WinAnsi
    // char set - i.e. code page 1252)
    // - if UnicodeComparison is set to TRUE, search will use low-level Windows
    // API for Unicode-level conversion - it will be much slower, but accurate
    // for the whole range of UTF-8 encoding
    // - if UnicodeComparison is left to FALSE, UTF-8 decoding will be done only
    // if necessary: it will work only with standard western-occidental alphabet
    // (i.e. WinAnsi - code page 1252), but it will be very fast
    function SearchValue(const aUpperValue: RawUTF8; StartRow, FieldIndex: integer;
      Client: TObject; Lang: TSynSoundExPronunciation=sndxNone;
      UnicodeComparison: boolean=false): integer; overload;
    /// search a text value inside the table data in all fields
    // - the text value must already be uppercased 7-bits ANSI encoded
    // - return the Row on success, 0 on error
    // - search on all fields, returning field found in FieldIndex (if not nil)
    // - you can specify a Soundex pronunciation to use, or leave as sndxNone for
    // standard case insensitive character match; aUpperValue can optional
    // indicate a Soundex search, by predeceding the searched text with % for
    // English, %% for French or %%% for Spanish (only works with WinAnsi
    // char set - i.e. code page 1252)
    // - if UnicodeComparison is set to TRUE, search will use low-level Windows
    // API for Unicode-level conversion - it will be much slower, but accurate
    // for the whole range of UTF-8 encoding
    // - if UnicodeComparison is left to FALSE, UTF-8 decoding will be done only
    // if necessary: it will work only with standard western-occidental alphabet
    // (i.e. WinAnsi - code page 1252), but it will be very fast
    function SearchValue(const aUpperValue: RawUTF8; StartRow: integer;
      FieldIndex: PInteger; Client: TObject; Lang: TSynSoundExPronunciation=sndxNone;
      UnicodeComparison: boolean=false): integer; overload;
    /// search for a value inside the raw table data
    // - returns 0 if not found, or the matching Row number otherwise
    function SearchFieldEquals(const aValue: RawUTF8; FieldIndex: integer): integer;

    /// if the ID column is available, hides it from fResults[]
    // - usefull for simplier UI, with a hidden ID field
    // - use IDColumnHiddenValue() to get the ID of a specific row
    // - return true is ID was succesfully hidden, false if not possible
    function IDColumnHide: boolean;
    /// return the (previously hidden) ID value, 0 on error
    function IDColumnHiddenValue(Row: integer): integer;
    /// return all (previously hidden) ID values
    procedure IDColumnHiddenValues(var IDs: TIntegerDynArray);
    /// get all IDs where individual bit in Bits are set
    procedure IDArrayFromBits(const Bits; var IDs: TIntegerDynArray);
    /// get all individual bit in Bits corresponding to the supplied IDs
    // - warning: IDs integer array will be sorted within this method call
    procedure IDArrayToBits(var Bits; var IDs: TIntegerDynArray);
    /// get the Row index corresponding to a specified ID
    // - return the Row number, from 1 to RowCount
    // - return RowCount (last row index) if this ID was not found or no
    // ID field is available
    function RowFromID(aID: integer): integer;

    /// delete the specified data Row from the Table
    // - only overwrite the internal fResults[] pointers, don't free any memory,
    // nor modify the internal DataSet
    procedure DeleteRow(Row: integer);
    /// delete the specified Column text from the Table
    // - don't delete the Column: only delete UTF-8 text in all rows for this
    // field
    procedure DeleteColumnValues(Field: integer);

    /// retrieve QueryTables[0], if existing
    function QueryRecordType: TSQLRecordClass;

    /// create a new TSQLRecord instance for a specific Table
    // - use the specified TSQLRecord class or create one instance
    // of the first associated record class (from internal QueryTables[])
    // - use this method to create a working copy of a table's record, e.g.
    // - the record will be freed when the TSQLTable will be destroyed:
    // you don't need to make a Try..Finally..Free..end block with it
    function NewRecord(RecordType: TSQLRecordClass=nil): TSQLRecord;
    /// create a TObjectList with TSQLRecord instances corresponding to this
    // TSQLTable result set
    // - use the specified TSQLRecord class or create instances
    // of the first associated record class (from internal QueryTables[])
    // - always returns an instance, even if the TSQLTable is nil or void
    function ToObjectList(RecordType: TSQLRecordClass=nil): TObjectList; overload;
    /// fill an existing TObjectList with TSQLRecord instances corresponding
    // to this TSQLTable result set
    // - use the specified TSQLRecord class or create instances
    // of the first associated record class (from internal QueryTables[])
    procedure ToObjectList(DestList: TObjectList; RecordType: TSQLRecordClass=nil); overload;
    {$ifdef ISDELPHI2010} // Delphi 2009 generics are buggy
    /// create a TObjectList<TSQLRecord> with TSQLRecord instances corresponding
    // to this TSQLTable result set
    // - use the specified TSQLRecord class or create instances
    // of the first associated record class (from internal QueryTables[])
    // - always returns an instance, even if the TSQLTable is nil or void
    function ToObjectList<T: TSQLRecord>: TObjectList<T>; overload;
    {$endif}

    {/ After a TSQLTable has been initialized, this method can be called
      one or more times to iterate through all data rows
     - you shall call this method before calling FieldBuffer()/Field() methods
     - return TRUE on success, with data ready to be retrieved by Field*()
     - return FALSE if no more row is available (i.e. exceeded RowCount)
     - if SeekFirst is TRUE, will put the cursor on the first row of results,
       otherwise, it will fetch one row of data, to be called within a loop
     - you can specify a variant instance (e.g. allocated on the stack) in
       optional RowVariant parameter, to access field values using late binding
     - typical use may be:
       ! while TableCustomers.Step do
       !   writeln(Field('name'));
     - or, when using a variant and late-binding:
       ! var customer: variant;
       ! ...
       !   while TableCustomers.Step(false,@customer) do
       !     writeln(customer.Name);
     }
    function Step(SeekFirst: boolean=false; RowVariant: PVariant=nil): boolean;
    /// read-only access to a particular field value, as UTF-8 encoded buffer
    // - raise an ESQLTableException if called outside valid Step() sequence
    // - similar to Get() method, but for the current Step
    function FieldBuffer(FieldIndex: Integer): PUTF8Char; overload;
    /// read-only access to a particular field value, as UTF-8 encoded buffer
    // - raise an ESQLTableException if called outside valid Step() sequence
    // - similar to Get() method, but for the current Step
    function FieldBuffer(const FieldName: RawUTF8): PUTF8Char; overload;
    {$ifdef USEVARIANTS}
    /// read-only access to a particular field value, as a variant
    // - raise an ESQLTableException if called outside valid Step() sequence
    // - will call GetVariant() method for appropriate data conversion
    function Field(FieldIndex: integer): variant; overload;
    /// read-only access to a particular field value, as a variant
    // - raise an ESQLTableException if called outside valid Step() sequence
    // - will call GetVariant() method for appropriate data conversion
    function Field(const FieldName: RawUTF8): variant; overload;
    {$endif}

    /// contains the associated record class on Query
    property QueryTables: TSQLRecordClassDynArray read fQueryTables;
    /// contains the associated SQL statement on Query
    property QuerySQL: RawUTF8 read fQuerySQL;
    {/ read-only access to the number of data Row in this table
     - first row contains field name
     - then 1..RowCount rows contain the data itself }
    property RowCount: integer read fRowCount;
    {/ read-only access to the number of fields for each Row in this table }
    property FieldCount: integer read fFieldCount;
    /// read-only acccess to the current Row number, after a Step() call
    // - contains 0 if accessed outside valid Step() sequence call
    // - contains 1..RowCount after a valid Step() iteration
    property StepRow: integer read fStepRow;
    {/ this property contains the internal state counter of the server database
      when the data was retrieved from it
      - can be used to check if retrieved data may be out of date }
    property InternalState: cardinal read fInternalState write fInternalState;
    /// if the TSQLRecord is the owner of this table, i.e. if it must free it
    property OwnerMustFree: Boolean read fOwnerMustFree write fOwnerMustFree;
  end;

{$ifdef USEVARIANTS}
  /// a custom variant type used to have direct access to TSQLTable content
  // - use TSQLTable.Step(..,@Data) method to initialize such a Variant
  // - the variant members/fields are read-only by design 
  TSQLTableRowVariantType = class(TSynInvokeableVariantType)
  protected
    procedure IntGet(var Dest: TVarData; const V: TVarData; Name: PAnsiChar); override;
    procedure IntSet(const V, Value: TVarData; Name: PAnsiChar); override;
  end;
{$endif USEVARIANTS}


  /// get a SQL result from a JSON message, and store it into its own memory
  TSQLTableJSON = class(TSQLTable)
  protected
    /// used if a private copy of the JSON buffer is needed
    fPrivateCopy: RawUTF8;
    /// contains the pointers of start of every field value in JSONData
    fJSONResults: array of PUTF8Char;
    /// contain the hash value of the last JSON data sent to ContentChanged()
    // - used to don't repeat parsing if data has not been changed
    fPrivateCopyHash: cardinal;
    /// fill the result table content from a JSON-formated Data message
    // - returns TRUE on parsing success
    // - returns FALSE if no valid JSON data was found
    // - update all content fields (fResults[], fRowCount, fFieldCount, etc...)
    // - expect the UTF-8 Buffer in either TSQLRequest.EngineExecute(DB,SQL,JSON)
    // format (i.e. expanded) or either in a not expanded format (as an
    // AJAX-ready array of objects)
    // - the conversion into PPUTF8CharArray is made inplace and is very fast
    // (no additional memory buffer is allocated)
    function ParseAndConvert(Buffer: PUTF8Char; BufferLen: integer): boolean;
    /// will check then set (if needed) internal fPrivateCopy[Hash] values
    // - returns TRUE if content changed (then fPrivateCopy+fPrivateCopyHash
    // will be updated)
    function PrivateCopyChanged(aJSON: PUTF8Char; aLen: integer): boolean;
  public
    /// create the result table from a JSON-formated Data message
    // - the JSON data is parsed and formatted in-place
    // - please note that the supplied JSON buffer content will be changed:
    // if you want to reuse this JSON content, you shall make a private copy
    // before calling this constructor and you shall NOT release the corresponding
    // variable (fResults/JSONResults[] will point inside this memory buffer):
    // use instead the overloaded Create constructor expecting aJSON parameter
    // making a private copy of the data
    constructor Create(const Tables: array of TSQLRecordClass; const aSQL: RawUTF8;
      JSONBuffer: PUTF8Char; JSONBufferLen: integer); overload;
    /// create the result table from a JSON-formated Data message
    // - the JSON data is parsed and formatted in-place, after having been
    // copied in the protected fPrivateCopy variable
    constructor Create(const Tables: array of TSQLRecordClass; const aSQL, aJSON: RawUTF8); overload;
    /// update the result table content from a JSON-formated Data message
    // - return true on parsing success, false if no valid JSON data was found
    // - set Refreshed to true if the content changed
    // - update all content fields (fResults[], fRowCount, fFieldCount, etc...)
    // - call SortFields() or IDColumnHide if was already done for this TSQLTable
    // - the conversion into PPUTF8CharArray is made inplace and is very fast
    // (only one memory buffer is allocated for the whole data)
    function UpdateFrom(const aJSON: RawUTF8; var Refreshed: boolean;
      PCurrentRow: PInteger): boolean;
    /// the private copy of the processed data buffer
    // - available e.g. for Create constructor using aJSON parameter,
    // or after the UpdateFrom() process
    // - this buffer is not to be access directly: this won't be a valid JSON
    // content, but a processed buffer, on which fResults[] elements point to
    property PrivateInternalCopy: RawUTF8 read fPrivateCopy;
  end;

  PSQLLocks = ^TSQLLocks;
  /// used to store the locked record list, in a specified table
  // - the maximum count of the locked list if fixed to 512 by default,
  // which seems correct for common usage
  TSQLLocks = {$ifndef ISDELPHI2010}object{$else}record{$endif}
    /// the number of locked records stored in this object
    Count: integer;
    /// contains the locked record ID
    // - an empty position is marked with 0 after UnLock()
    ID: array[0..MAX_SQLLOCKS-1] of integer;
    /// contains the time and date of the lock
    // - filled internally by the very fast GetTickCount function (faster than
    // TDateTime or TSystemTime/GetLocalTime)
    // - used to purge to old entries - see PurgeOlderThan() method below
    Ticks: array[0..MAX_SQLLOCKS-1] of cardinal;
    /// lock a record, specified by its ID
    // - returns true on success, false if was already locked
    function Lock(aID: integer): boolean;
    /// unlock a record, specified by its ID
    // - returns true on success, false if was not already locked
    function UnLock(aID: integer): boolean;
    /// return true if a record, specified by its ID, is locked
    function isLocked(aID: integer): boolean;
    /// delete all the locked IDs entries, after a specified time
    // - to be used to release locked records if the client crashed
    // - default value is 30 minutes, which seems correct for common database usage
    // - also purge values where GetTickCount wrapped around to zero after 49.7 days
    // (for consistency)
    procedure PurgeOlderThan(MinutesFromNow: cardinal=30);
  end;

  TSQLLocksDynArray = array of TSQLLocks;

  /// UI Query comparison operators
  // - these operators are e.g. used to mark or unmark some lines in a UI Grid
  // or for TInterfaceStub.ExpectsCount() methods
  TSQLQueryOperator =
    (qoNone,
     qoEqualTo,
     qoNotEqualTo,
     qoLessThan,
     qoLessThanOrEqualTo,
     qoGreaterThan,
     qoGreaterThanOrEqualTo,
     qoEqualToWithCase,
     qoNotEqualToWithCase,
     qoContains,
     qoBeginWith,
     qoSoundsLikeEnglish,
     qoSoundsLikeFrench,
     qoSoundsLikeSpanish);

  /// set of UI Query comparison operators
  TSQLQueryOperators = set of TSQLQueryOperator;

  /// User Interface Query action evaluation function prototype
  // - Operator is ord(TSQLQueryOperator) by default (i.e. for class function
  // TSQLRest.QueryIsTrue), or is a custom enumeration index for custom queries
  // (see TSQLQueryCustom.EnumIndex below, and TSQLRest.QueryAddCustom() method)
  // - for default Operator as ord(TSQLQueryOperator), qoContains and qoBeginWith
  // expect the Reference to be already uppercase
  // - qoEqualTo to qoGreaterThanOrEqualTo apply to all field kind (work with
  // either numeric either UTF-8 values)
  // - qoEqualToWithCase to qoSoundsLikeSpanish handle the field as UTF-8 text,
  // and make the comparison using the phonetic algorithm corresponding to
  // a language family
  // - for default Operator as ord(TSQLQueryOperator), qoSoundsLike* operators
  // expect the Reference not to be a PUTF8Char, but a typecast of a prepared
  // TSynSoundEx object instance (i.e. pointer(@SoundEx)) by the caller
  // - for custom query (from TSQLQueryCustom below), the event must
  // handle a special first call with Value=nil to select if this custom
  // Operator/Query is available for the specified aTable: in this case,
  // returning true indicates that this custom query is available for this table
  // - for custom query (from TSQLQueryCustom below), the event is called with
  // FieldType := TSQLFieldType(TSQLQueryCustom.EnumIndex)+64
  TSQLQueryEvent = function(aTable: TSQLRecordClass; aID: integer;
    FieldType: TSQLFieldType; Value: PUTF8Char; Operator: integer;
    Reference: PUTF8Char): boolean of object;

  /// store one custom query parameters
  // - add custom query by using the TSQLRest.QueryAddCustom() method
  // - use EnumType^.GetCaption(EnumIndex) to retrieve the caption associated
  // to this custom query
  TSQLQueryCustom = record
    /// the associated enumeration type
    EnumType: PEnumType;
    /// the associated enumeration index in EnumType
    // - will be used to fill the Operator parameter for the Event call
    EnumIndex: integer;
    /// the associated evaluation Event handler
    // - the Operator parameter will be filled with the EnumIndex value
    Event: TSQLQueryEvent;
    /// User Interface Query action operators
    Operators: TSQLQueryOperators;
  end;

  /// standard actions for User Interface generation
  TSQLAction = (
    /// action not defined
    actNoAction,
    /// Mark rows (standard action)
    // - display sub-menu with actmarkAllEntries..actmarkBeforeOneYear items
    actMark,
    /// UnMark all rows (standard action)
    actUnmarkAll,
    /// Mark all rows
    actmarkAllEntries,
    /// Mark rows After one day
    actmarkOlderThanOneDay,
    /// Mark rows older than one week
    actmarkOlderThanOneWeek,
    /// Mark rows older than one month
    actmarkOlderThanOneMonth,
    /// Mark rows older than one half year
    actmarkOlderThanSixMonths,
    /// Mark rows older than one year
    actmarkOlderThanOneYear,
    /// Inverse Mark values (ON->OFF, OFF->ON)
    actmarkInverse);

  /// set of standard actions for User Interface generation
  TSQLActions = set of TSQLAction;

  /// defines the way the TDrawGrid is displayed by User Interface generation
  TSQLListLayout = (llLeft, llUp, llClient, llLeftUp);

  PSQLRibbonTabParameters = ^TSQLRibbonTabParameters;

  /// defines the settings for a Tab for User Interface generation
  // - used in mORMotToolBar.pas unit and TSQLModel.Create() overloaded method
  TSQLRibbonTabParameters = object
  public
    /// the Table associated to this Tab
    Table: TSQLRecordClass;
    /// the caption of the Tab, to be translated on the screen
    // - by default, Tab name is taken from TSQLRecord.Caption(nil) method
    // - but you can override this value by setting a pointer to a resourcestring
    CustomCaption: PResStringRec;
    /// the hint type of the Tab, to be translated on the screen
    // - by default, hint will replace all %s instance by the Tab name, as taken
    // from TSQLRecord.Caption(nil) method
    // - but you can override this value by setting a pointer to a resourcestring
    CustomHint: PResStringRec;
    /// SQL fields to be displayed on the data lists
    // 'ID,' is always added at the beginning
    Select: RawUTF8;
     /// Tab Group number (index starting at 0)
    Group: integer;
    /// displayed field length mean, one char per field (A=1,Z=26)
    // - put lowercase character in order to center the field data
    FieldWidth: RawUTF8;
    /// if set, the ID column is shown
    ShowID: boolean;
    /// index of field used for displaying order
    OrderFieldIndex: integer;
    /// if set, the list is displayed in reverse order (i.e. decreasing)
    ReverseOrder: boolean;
    /// layout of the List, below the ribbon
    Layout: TSQLListLayout;
    /// width of the List, in percent of the client area
    // - default value (as stated in TSQLRibbonTab.Create) is 30%  
    ListWidth: integer;
    /// by default, the detail are displayed as a report (TGDIPages component)
    // - set this property to true to customize the details display
    // - this property is ignored if Layout is llClient (i.e. details hidden)
    NoReport: boolean;
    /// by default, the screens are not refreshed automaticaly
    // - but you can enable the auto-refresh feature by setting this
    // property to TRUE, and creating a WM_TIMER message handler for the form,
    // which will handle both WM_TIMER_REFRESH_SCREEN and WM_TIMER_REFRESH_REPORT
    // timers:
    // !procedure TMainForm.WMRefreshTimer(var Msg: TWMTimer);
    // !begin
    // !  Ribbon.WMRefreshTimer(Msg);
    // !end;
    AutoRefresh: boolean;
    /// the associated hints to be displayed during the edition of this table
    // - every field hint must be separated by a '|' character
    // (e.g. 'The First Name|Its Company Name')
    // - all fields need to be listed in this text resource, even if it won't
    // be displayed on screen (enter a void item like ||)
    // - you can define some value by setting a pointer to a resourcestring
    EditFieldHints: PResStringRec;
    /// write hints above field during the edition of this table
    // - if EditExpandFieldHints is TRUE, the hints are written as text on the
    // dialog, just above the field content; by default, hints are displayed as
    // standard delayed popup when the mouse hover the field editor
    EditExpandFieldHints: boolean;
    /// the associated field name width (in pixels) to be used for creating
    // the edition dialog for this table
    EditFieldNameWidth: integer;
    /// a CSV list of field names to be hidden in both editor and default report
    // - handy to hide fields containing JSON data or the name of another
    // sftRecord/sftID (i.e. TRecordReference/TSQLRecord published propet) fields
    // - list is to be separated by commas (e.g. "RunLogJSON,OrdersJSON" or
    // "ConnectionName")
    EditFieldNameToHideCSV: RawUTF8;
    /// if the default report must contain the edit field hints
    // - i.e. if the resourcestring pointed by EditFieldHints must be used
    // to display some text above every property value on the reports
    EditFieldHintsToReport: boolean;
  end;

  /// parent of all virtual classes
  // - you can define a plain TSQLRecord class as virtual if needed  - e.g.
  // inheriting from TSQLRecordMany then calling VirtualTableExternalRegister() -
  // but using this class will seal its state to be virtual
  TSQLRecordVirtual = class(TSQLRecord);

  TSQLVirtualTable = class;
  TSQLVirtualTableClass = class of TSQLVirtualTable;

  /// ORM properties associated to a TSQLRecord within a given model
  // - "stable" properties derivated from RTTI are shared in TSQLRecordProperties
  // - since the same TSQLRecord can be defined in several models, with diverse
  // implementation patterns (e.g. internal in one, external in another),
  // this class is used to regroup all model-specific settings, like SQL
  // pre-generated patterns or external DB properties 
  TSQLModelRecordProperties = class
  protected
    fProps: TSQLRecordProperties;
    fKind: TSQLRecordVirtualKind;
    fModel: TSQLModel;
    procedure SetKind(Value: TSQLRecordVirtualKind);
  public                                               
    SQL: record
      {/ the simple field names in a SQL SELECT compatible format: 'COL1,COL2' e.g.
       - format is
       ! SQLTableSimpleFields[withID: boolean; withTableName: boolean]
       - returns '*' if no field is of TSQLRawBlob/TSQLRecordMany kind
       - returns 'COL1,COL2' with all COL* set to simple field names if withID is false
       - returns 'ID,COL1,COL2' with all COL* set to simple field names if withID is true
       - returns 'Table.ID,Table.COL1,Table.COL2' if withTableName and withID are true }
      TableSimpleFields: array[boolean,boolean] of RawUTF8;
      /// the SQL statement for reading all simple fields
      // - SQLSelectAll[false] with RowID (i.e. SQLFromSelectWhere('*','') content)
      // - SQLSelectAll[true] with ID and potentialy external table name
      // - to be checked if we may safely call EngineList()
      SelectAll: array[boolean] of RawUTF8;
      /// the updated fields exposed as 'COL1=?,COL2=?'
      // - SQLUpdateSet[false]=simple fields, SQLUpdateSet[true]=all fields
      // excluding ID (but including TCreateTime fields - as used in
      // TSQLVirtualTableExternal.Update method)
      // - to be used e.g. for UPDATE statements
      UpdateSet: array[boolean] of RawUTF8;
      /// all fields, excluding the ID field, exposed as 'COL1,COL2'
      // - to be used e.g. for INSERT statements
      InsertSet: RawUTF8;
    end;
    /// opaque structure used on the Server side to specify e.g. the DB connection
    // - will define such a generic TObject, to avoid any unecessary dependency
    // to the SynDB unit in mORMot.pas
    // - in practice, will be assigned by VirtualTableExternalRegister() to
    // a TSQLDBConnectionProperties instance
    ExternalDatabase: TObject;
    /// used on the Server side to specify the external DB table name
    // - e.g. for including a schema name or an existing table name, with an
    // OleDB/MSSQL/Oracle/Jet/SQLite3 backend
    // - equals SQLTableName by default (may be overriden e.g. by SQLite3DB's
    // VirtualTableExternalRegister procedure)
    ExternalTableName: RawUTF8;

    /// initialize the ORM properties from the TSQLRecord RTTI and the supplied
    // TSQLModel
    constructor Create(aModel: TSQLModel; aTable: TSQLRecordClass; aKind: TSQLRecordVirtualKind);
    /// clone ORM properties from an existing TSQLModelRecordProperties to
    // another model
    constructor CreateFrom(aModel: TSQLModel; aSource: TSQLModelRecordProperties);

    /// compute the SQL statement to be executed for a specific SELECT
    // - non simple fields (e.g. BLOBs) will be excluded if SQLSelect='*'
    function SQLFromSelectWhere(const SQLSelect, SQLWhere: RawUTF8): RawUTF8; 

    /// the shared TSQLRecordProperties information of this TSQLRecord
    // - as retrieved from RTTI
    property Props: TSQLRecordProperties read fProps;
    /// define if is a normal table (rSQLite3), an FTS3/FTS4/R-Tree virtual
    // table or a custom TSQLVirtualTable*ID (rCustomForcedID/rCustomAutoID)
    // - when set, all internal SQL statements will be (re)created, depending of
    // the expected ID/RowID column name expected (i.e. SQLTableSimpleFields[]
    // and SQLSelectAll[] - SQLUpdateSet and SQLInsertSet do not include ID)
    property Kind: TSQLRecordVirtualKind read fKind write SetKind;
  end;

  TSQLModelRecordPropertiesDynArray = array of TSQLModelRecordProperties;

  /// a Database Model (in a MVC-driven way), for storing some tables types
  // as TSQLRecord classes
  // - share this Model between TSQLRest Client and Server
  // - use this class to access the table properties: do not rely on the
  // low-level database methods (e.g. TSQLDataBase.GetTableNames), since the
  // tables may not exist in the main SQLite3 database, but in-memory or external
  // - don't modify the order of Tables inside this Model, if you publish
  // some TRecordReference property in any of your tables
  TSQLModel = class(TObject)
  private
    fTables: TSQLRecordClassDynArray;
    fRoot: RawUTF8;
    fRootUpper: RawUTF8;
    fTablesMax: integer;
    fActions: PEnumType;
    fEvents: PEnumType;
    fTableProps: TSQLModelRecordPropertiesDynArray;
    fCustomCollationForAllRawUTF8: RawUTF8;
    /// contains the caller of CreateOwnedStream()
    fRestOwner: TSQLRest;
    /// for every table, contains a locked record list
    // - very fast, thanks to the use of a dynamic array with one entry by table
    fLocks: TSQLLocksDynArray;
    /// for fastest SQL Table name lookup via binary search
    fSortedTablesName: TRawUTF8DynArray;
    fSortedTablesNameIndex: TIntegerDynArray;
    /// will contain the registered virtual table modules
    fVirtualTableModule: array of TSQLVirtualTableClass;
    /// this array contain all TRecordReference and TSQLRecord properties
    // existing in the database model
    // - used in TSQLRestServer.Delete() to enforce relational database coherency
    // after deletion of a record: all other records pointing to it will be
    // reset to 0 by TSQLRestServer.AfterDeleteForceCoherency
    fRecordReferences: array of record
      TableIndex: integer;
      FieldType: TSQLPropInfoRTTIInstance;
    end;
    procedure SetTableProps(aIndex: integer);
    function GetTableProps(aClass: TSQLRecordClass): TSQLModelRecordProperties;
    /// get the enumerate type information about the possible actions to be
    function GetLocks(aTable: TSQLRecordClass): PSQLLocks;
    function GetTable(const SQLTableName: RawUTF8): TSQLRecordClass;
    function GetTableExactIndex(const TableName: RawUTF8): integer;
    function GetTableExactClass(const TableName: RawUTF8): TSQLRecordClass;
    function getURI(aTable: TSQLRecordClass): RawUTF8;
    function getURIID(aTable: TSQLRecordClass; aID: integer): RawUTF8;
    function getURICallBack(const aMethodName: RawUTF8; aTable: TSQLRecordClass; aID: integer): RawUTF8;
  public
    /// initialize the Database Model
    // - set the Tables to be associated with this Model, as TSQLRecord classes
    // - set the optional Root URI path of this Model
    // - initialize the fIsUnique[] array from "stored AS_UNIQUE" (i.e. "stored
    // false") published properties of every TSQLRecordClass
    constructor Create(const Tables: array of TSQLRecordClass; const aRoot: RawUTF8='root'); reintroduce; overload;
    /// clone an existing Database Model
    // - all supplied classes won't be redefined as non-virtual:
    // VirtualTableExternalRegister explicit calls are not mandatory here
    constructor Create(CloneFrom: TSQLModel); overload;
    /// initialize the Database Model from an User Interface parameter structure
    // - this constructor will reset all supplied classes to be defined as
    // non-virtual (i.e. Kind=rSQLite3): VirtualTableExternalRegister explicit
    // calls are to be made if tables should be managed as external
    constructor Create(Owner: TSQLRest; TabParameters: PSQLRibbonTabParameters;
      TabParametersCount, TabParametersSize: integer;
      const NonVisibleTables: array of TSQLRecordClass;
      Actions: PTypeInfo=nil; Events: PTypeInfo=nil;
      const aRoot: RawUTF8='root'); overload;
    /// release associated memory
    destructor Destroy; override;
    /// add the class if it doesn't exist yet
    // - return index in Tables[] if not existing yet and successfully added (in this case,
    // aTableIndexCreated^ is set to the newly created index in Tables[])
    // - supplied class will be redefined as non-virtual: VirtualTableExternalRegister
    // explicit call is to be made if table should be managed as external
    function AddTable(aTable: TSQLRecordClass; aTableIndexCreated: PInteger=nil): boolean;
    /// get the index of aTable in Tables[]
    // - returns -1 if the table is not in the model
    function GetTableIndex(aTable: TSQLRecordClass): integer; overload;
    /// get the index of aTable in Tables[]
    // - raise an EModelException if the table is not in the model
    function GetTableIndexExisting(aTable: TSQLRecordClass): integer;
    /// get the index of a table in Tables[]
    // - expects SQLTableName to be SQL-like formated (i.e. without TSQL[Record])
    function GetTableIndex(const SQLTableName: RawUTF8): integer; overload;
    /// get the index of a table in Tables[]
    // - expects SQLTableName to be SQL-like formated (i.e. without TSQL[Record])
    function GetTableIndex(SQLTableName: PUTF8Char): integer; overload;
    /// return the UTF-8 encoded SQL source to create the table
    function GetSQLCreate(aTableIndex: integer): RawUTF8;
    /// return the UTF-8 encoded SQL source to add the corresponding field
    // via a "ALTER TABLE" statement
    function GetSQLAddField(aTableIndex, aFieldIndex: integer): RawUTF8;
    {/ return the TRecordReference pointing to the specified record }
    function RecordReference(Table: TSQLRecordClass; ID: integer): TRecordReference;
    /// return TRUE if the specified field of this class was marked as unique
    // - an unique field is defined as "stored AS_UNIQUE" (i.e. "stored false")
    // in its property definition
    // - reflects the internal private fIsUnique propery
    function GetIsUnique(aTable: TSQLRecordClass; aFieldIndex: integer): boolean;
    /// try to retrieve a table index from a SQL statement
    // - naive search of '... FROM TableName' pattern in the supplied SQL
    // - if EnsureUniqueTableInFrom is TRUE, it will check that only one Table
    // is in the FROM clause, otherwise it will return the first Table specified
    function GetTableIndexFromSQLSelect(const SQL: RawUTF8; EnsureUniqueTableInFrom: boolean): integer;
    /// returns TRUE if the supplied URI matches the model's Root property
    // - allows sub-domains, e.g. if Root='root/sub1', then '/root/sub1/toto' and
    // '/root/sub1?n=1' will match, whereas '/root/sub1nope/toto' won't 
    function URIMatch(const URI: RawUTF8): boolean;

    /// compute the SQL statement to be executed for a specific SELECT on Tables
    // - you can set multiple Table class in Tables: the statement will contain the
    // table name ('SELECT T1.F1,T1.F2,T1.F3,T2.F1,T2.F2 FROM T1,T2 WHERE ..' e.g.)
    function SQLFromSelectWhere(const Tables: array of TSQLRecordClass;
      const SQLSelect, SQLWhere: RawUTF8): RawUTF8;
    /// set a custom SQlite3 text column collation for all RawUTF8 fields of
    // all TSQLRecord of this model
    // - can be used e.g. to override ALL default COLLATE SYSTEMNOCASE of RawUTF8,
    // and let the generated SQLite3 file be available outside
    // - collations defined within our SynSQLite3 unit are named BINARY, NOCASE,
    // RTRIM and our custom SYSTEMNOCASE, ISO8601, WIN32CASE, WIN32NOCASE: if
    // you want to use the slow but Unicode ready Windows API, set for each model:
    // ! SetCustomCollationForAllRawUTF8('WIN32CASE');
    // - shall be set on both Client and Server sides, otherwise some issues
    // may occur
    procedure SetCustomCollationForAllRawUTF8(const aCollationName: RawUTF8);
    
    /// assign an enumeration type to the possible actions to be performed
    // with this model
    // - call with the TypeInfo() pointer result of an enumeration type
    // - actions are handled by TSQLRecordForList in the mORMotToolBar.pas unit
    procedure SetActions(aActions: PTypeInfo);
    /// assign an enumeration type to the possible events to be triggered
    // with this class model
    // - call with the TypeInfo() pointer result of an enumeration type
    procedure SetEvents(aEvents: PTypeInfo);
    /// get the text conversion of a given Action, ready to be displayed
    function ActionName(const Action): string;
    /// get the text conversion of a given Event, ready to be displayed
    function EventName(const Event): string;

    /// register a Virtual Table module for a specified class
    // - to be called server-side only (Client don't need to know the virtual
    // table implementation details, and it will increase the code size)
    // - aClass parameter could be either a TSQLRecordVirtual class, either
    // a TSQLRecord class which has its kind set to rCustomForcedID or
    // rCustomAutoID (e.g. TSQLRecordMany calling VirtualTableExternalRegister)
    // - optional aExternalTableName and aExternalDataBase can be used to
    // specify e.g. connection parameters as expected by SQLite3DB
    // - call it before TSQLRestServer.Create()
    function VirtualTableRegister(aClass: TSQLRecordClass;
      aModule: TSQLVirtualTableClass; const aExternalTableName: RawUTF8='';
      aExternalDataBase: TObject=nil): boolean;
    /// retrieve a Virtual Table module associated to a class
    function VirtualTableModule(aClass: TSQLRecordClass): TSQLVirtualTableClass;

    /// create a New TSQLRecord instance for a specific Table
    // - expects SQLTableName to be SQL-like formated (i.e. without TSQL[Record])
    // - use this to create a working copy of a table's record, e.g.
    // - don't forget to Free it when not used any more (use a try...finally
    // block)
    // - it's prefered in practice to directly call TSQLRecord*.Create()
    // in your code
    function NewRecord(const SQLTableName: RawUTF8): TSQLRecord;

    /// lock a record
    // - returns true on success, false if was already locked or if there's no
    // place more in the lock table (as fixed by MAX_SQLLOCKS contst, i.e. 512)
    function Lock(aTable: TSQLRecordClass; aID: integer): boolean; overload;
    /// lock a record
    // - returns true on success, false if was already locked or if there's no
    // place more in the lock table (as fixed by MAX_SQLLOCKS contst, i.e. 512)
    function Lock(aTableIndex, aID: integer): boolean; overload;
    /// lock a record
    // - returns true on success, false if was already locked or if there's no
    // place more in the lock table (as fixed by MAX_SQLLOCKS contst, i.e. 512)
    function Lock(aRec: TSQLRecord): boolean; overload;
    /// unlock a specified record
    // - returns true on success, false if was not already locked
    function UnLock(aTable: TSQLRecordClass; aID: integer): boolean; overload;
    /// unlock a specified record
    // - returns true on success, false if was not already locked
    function UnLock(aTableIndex: integer; aID: integer): boolean; overload;
    /// unlock a specified record
    // - returns true on success, false if was not already locked
    function UnLock(aRec: TSQLRecord): boolean; overload;
    /// unlock all previously locked records
    procedure UnLockAll;
    /// return true if a specified record is locked
    function isLocked(aTable: TSQLRecordClass; aID: integer): boolean; overload;
    /// return true if a specified record is locked
    function isLocked(aRec: TSQLRecord): boolean; overload;
    /// delete all the locked IDs entries, after a specified time
    // - to be used to release locked records if the client crashed
    // - default value is 30 minutes, which seems correct for common usage
    procedure PurgeOlderThan(MinutesFromNow: cardinal=30);

    /// the Root URI path of this Database Model
    property Root: RawUTF8 read fRoot;
    /// get the classes list (TSQLRecord descendent) of all available tables
    property Tables: TSQLRecordClassDynArray read fTables;
    /// get a class from a table name
    // - expects SQLTableName to be SQL-like formated (i.e. without TSQL[Record])
    property Table[const SQLTableName: RawUTF8]: TSQLRecordClass read GetTable; default;
    /// get a class from a table TableName (don't truncate TSQLRecord* if necessary)
    property TableExact[const TableName: RawUTF8]: TSQLRecordClass read GetTableExactClass;
    /// get the URI for a class in this Model, as 'ModelRoot/SQLTableName'
    property URI[aClass: TSQLRecordClass]: RawUTF8 read getURI;
    /// the associated ORM information for a given TSQLRecord class
    // - raise an EModelException if aClass is not declared within this model
    // - returns the corresponding TableProps[] item if the class is known
    property Props[aClass: TSQLRecordClass]: TSQLModelRecordProperties read GetTableProps;
    /// the associated ORM information about all handled TSQLRecord class properties
    // - this TableProps[] array will map the Tables[] array, and will allow
    // fast direct access to the Tables[].RecordProps values
    property TableProps: TSQLModelRecordPropertiesDynArray read fTableProps;
    // performed with this model
    // - Actions are e.g. linked to some buttons in the User Interface
    property Actions: PEnumType read fActions;
    /// get the enumerate type information about the possible Events to be
    // performed with this model
    // - Events can be linked to actions and custom status, to provide a
    // centralized handling of logging (e.g. in an Audit Trail table)
    property Events: PEnumType read fEvents;
    /// this property value is used to auto free the database Model class
    // - set this property after Owner.Create() in order to have
    // Owner.Destroy autofreeing it
    property Owner: TSQLRest read fRestOwner write fRestOwner;
    /// for every table, contains a locked record list
    // - very fast, thanks to the use one TSQLLocks entry by table
    property Locks: TSQLLocksDynArray read fLocks;
  end;

  PRecordRef = ^RecordRef;
  
  /// usefull object to type cast TRecordReference type value into explicit
  // TSQLRecordClass and ID
  // - use RecordRef(Reference).TableIndex/Table/ID/Text methods to retrieve
  // the details of a TRecordReference encoded value
  // - use TSQLRest.Retrieve(Reference) to get a record content from DB
  // - but since Value is a copied member, do not use RecordRef(Reference).From()
  // but rather TSQLRecord.RecordReference(Model) or TSQLModel.RecordReference()
  // methods or RecordReference() function to encode the value
  // - don't change associated TSQLModel tables order, since TRecordReference
  // depends on it to store the Table type
  // - since 6 bits are used for the table index, the corresponding table
  // MUST appear in the first 64 items of the associated TSQLModel.Tables[]
  RecordRef = {$ifndef ISDELPHI2010}object{$else}record{$endif}
  public
    /// the value itself
    // - (value and 63) is the TableIndex in the current database Model
    // - (value shr 6) is the ID of the record in this table
    // - value=0 means no reference stored
    // - we use this coding and not the opposite (Table in MSB) to minimize
    // integer values; but special UTF8CompareRecord() function has to be used
    // for sorting
    // - type definition matches TRecordReference (i.e. PtrUInt) to allow
    // typecast as such:
    // ! aClass := RecordRef(Reference).Table(Model);
    Value: PtrUInt;
    /// return the index of the content Table in the TSQLModel
    function TableIndex: integer;
    /// return the class of the content in a specified TSQLModel
    function Table(Model: TSQLModel): TSQLRecordClass;
    /// return the ID of the content
    function ID: integer;
    /// fill Value with the corresponding parameters
    // - since 6 bits are used for the table index, aTable MUST appear in the
    // first 64 items of the associated TSQLModel.Tables[] array
    procedure From(Model: TSQLModel; aTable: TSQLRecordClass; aID: integer);
    /// get a ready to be displayed text from the stored Table and ID
    // - display 'Record 2301' e.g.
    function Text(Model: TSQLModel): RawUTF8; overload;
    /// get a ready to be displayed text from the stored Table and ID
    // - display 'Record "RecordName"' e.g.
    function Text(Rest: TSQLRest): RawUTF8; overload;
  end;

  /// this kind of record array can be used for direct coordinates storage
  TSQLRecordTreeCoords = array[0..RTREE_MAX_DIMENSION-1] of packed record
    min, max: double; end;

  {/ a base record, corresponding to an R-Tree table
    - an R-Tree is a special index that is designed for doing range queries.
      R-Trees are most commonly used in geospatial systems where each entry is a
      rectangle with minimum and maximum X and Y coordinates. Given a query
      rectangle, an R-Tree is able to quickly find all entries that are contained
      within the query rectangle or which overlap the query rectangle. This idea
      is easily extended to three dimensions for use in CAD systems. R-Trees also
      find use in time-domain range look-ups. For example, suppose a database
      records the starting and ending times for a large number of events. A R-Tree
      is able to quickly find all events, for example, that were active at any
      time during a given time interval, or all events that started during a
      particular time interval, or all events that both started and ended within
      a given time interval. And so forth. See http://www.sqlite.org/rtree.html
    - any record which inherits from this class must have only sftFloat
      (double) fields, grouped by pairs, each as minimum- and maximum-value,
      up to 5 dimensions (i.e. 11 columns, including the ID property)
    - the ID: integer property must be set before adding a TSQLRecordRTree to
      the database, e.g. to link a R-Tree representation to a regular
      TSQLRecord table
    - queries against the ID or the coordinate ranges are almost immediate: so
      you can e.g. extract some coordinates box from the regular TSQLRecord
      table, then use a TSQLRecordRTree joined query to make the process faster;
      this is exactly what the TSQLRestClient.RTreeMatch method offers }
  TSQLRecordRTree = class(TSQLRecordVirtual)
  public
    { override this class function to implement a custom box coordinates
      from a given BLOB content
      - by default, the BLOB array will contain a simple array of double
      - but you can override this method to handle a custom BLOB field content,
        intended to hold some kind of binary representation of the precise
        boundaries of the object, and convert it into box coordinates as
        understood by the ContainedIn() class function
      - the number of pairs in OutCoord will be taken from the current number
        of published double properties
      - used e.g. by the TSQLRestClient.RTreeMatch method }
    class procedure BlobToCoord(const InBlob; var OutCoord: TSQLRecordTreeCoords); virtual;
    { override this class function to implement a custom SQL *_in() function
      - by default, the BLOB array will be decoded via the BlobToCoord class
        procedure, and will create a SQL function from the class name 
      - for instance, the following class will define a 2 dimensional
        MapBox_in() function
      ! TSQLRecordMapBox = class(TSQLRecordTree)
      ! protected
      !   fMinX, fMaxX, fMinY, fMaxY: double;
      ! published
      !   property MinX: double read fMinX write fMinX;
      !   property MaxX: double read fMaxX write fMaxX;
      !   property MinY: double read fMinY write fMinY;
      !   property MaxY: double read fMaxY write fMaxY;
      ! end;
      - used e.g. by the TSQLRestClient.RTreeMatch method   }
    class function ContainedIn(const BlobA,BlobB): boolean; virtual;
    /// will return 'MapBox_in' e.g. for TSQLRecordMapBox
    class function RTreeSQLFunctionName: RawUTF8;
  end;

  {/ a base record, corresponding to a FTS3 table, i.e. implementing full-text
    - FTS3/FTS4 table are SQLite virtual tables which allow users to perform
      full-text searches on a set of documents. The most common (and effective)
      way to describe full-text searches is "what Google, Yahoo and Altavista do
      with documents placed on the World Wide Web". Users input a term, or
      series of terms, perhaps connected by a binary operator or grouped together
      into a phrase, and the full-text query system finds the set of documents
      that best matches those terms considering the operators and groupings the
      user has specified. See http://sqlite.org/fts3.html
    - any record which inherits from this class must have only sftUTF8Text
      (RawUTF8) fields - with Delphi 2009+, you can have string fields
    - this record has its fID: integer property which may be published
      as DocID, to be consistent with SQLite3 praxis, and reflect that it
      points to an ID of another associated TSQLRecord
    - a good approach is to store your data in a regular TSQLRecord table, then
      store your text content in a separated FTS3 table, associated to this
      TSQLRecordFTS3 table via its ID/DocID
    - the ID/DocID property can be set when the record is added, to retrieve any
      associated TSQLRecord (note that for a TSQLRecord record,
      the ID property can't be set at adding, but is calculated by the engine)
    - static tables don't handle TSQLRecordFTS3 classes
    - by default, the FTS3 engine ignore all characters >= #80, but handle
      low-level case insentivity (i.e. 'A'..'Z') so you must keep your
      request with the same range for upper case
    - by default, the "simple" tokenizer is used, but you can inherits from
      TSQLRecordFTS3Porter class if you want a better English matching, using
      the Porter Stemming algorithm - see http://sqlite.org/fts3.html#tokenizer
    - you can select either the FTS3 engine, or the more efficient (and new)
      FTS4 engine (available since version 3.7.4), by using the TSQLRecordFTS4 type
    - in order to make FTS3/FTS4 queries, use the dedicated TSQLRest.FTSMatch
      method, with the MATCH operator (you can use regular queries, but you must
      specify 'RowID' instead of 'DocID' or 'ID' because of FTS3 Virtual
      table specificity):
       ! var IDs: TIntegerDynArray;
       ! if FTSMatch(TSQLMyFTS3Table,'text MATCH "linu*"',IDs) then
       !  // you've all matching IDs in IDs[]  }
  TSQLRecordFTS3 = class(TSQLRecordVirtual)
  public
     {/ optimize the FTS3 virtual table
     - this causes FTS3 to merge all existing index b-trees into a single large
       b-tree containing the entire index. This can be an expensive operation,
       but may speed up future queries. See http://sqlite.org/fts3.html#section_1_2
     - this method must be called server-side
     - returns TRUE on success }
     class function OptimizeFTS3Index(Server: TSQLRestServer): boolean;
     /// this DocID property map the internal Row_ID property
     // - but you can set a value to this property before calling the Add()
     // method, to associate this TSQLRecordFTS3 to another TSQLRecord
     // - ID property is read-only, but this DocID property can be written/set
     // - internaly, we use RowID in the SQL statements, which is compatible
     // with both TSQLRecord and TSQLRecordFTS3 kind of table
     property DocID: integer read GetID write fID;
  end;

  /// this base class will create a FTS3 table using the Porter Stemming algorithm
  // - see http://sqlite.org/fts3.html#tokenizer
  TSQLRecordFTS3Porter = class(TSQLRecordFTS3);

  TSQLRecordFTS3Class = class of TSQLRecordFTS3;

  TSQLRecordRTreeClass = class of TSQLRecordRTree;

  {/ a base record, corresdonding to a FTS4 table, which is an enhancement to FTS3
  - FTS3 and FTS4 are nearly identical. They share most of their code in common,
   and their interfaces are the same. The only difference is that FTS4 stores
   some additional information about the document collection in two of new FTS
   shadow tables. This additional information allows FTS4 to use certain
   query performance optimizations that FTS3 cannot use. And the added information
   permits some additional useful output options in the matchinfo() function.
  - For newer applications, TSQLRecordFTS4 is recommended; though if minimal disk
   usage or compatibility with older versions of SQLite are important, then
   TSQLRecordFTS3 will usually serve just as well.
  - see http://sqlite.org/fts3.html#section_1_1 }
  TSQLRecordFTS4 = class(TSQLRecordFTS3);
  /// this base class will create a FTS4 table using the Porter Stemming algorithm
  // - see http://sqlite.org/fts3.html#tokenizer
  TSQLRecordFTS4Porter = class(TSQLRecordFTS4);

  /// the kind of fields to be available in a Table resulting of
  // a TSQLRecordMany.DestGetJoinedTable() method call
  // - Source fields are not available, because they will be always the same for
  // a same SourceID, and they should be available from the TSQLRecord which
  // hold the TSQLRecordMany instance
  // - jkDestID and jkPivotID will retrieve only DestTable.ID and PivotTable.ID
  // - jkDestFields will retrieve DestTable.* simple fields, or the fields
  // specified by aCustomFieldsCSV (the Dest table name will be added: e.g.
  // for aCustomFieldsCSV='One,Two', will retrieve DestTable.One, DestTable.Two)
  // - jkPivotFields will retrieve PivotTable.* simple fields, or the fields
  // specified by aCustomFieldsCSV (the Pivot table name will be added: e.g.
  // for aCustomFieldsCSV='One,Two', will retrieve PivotTable.One, PivotTable.Two)
  // - jkPivotAndDestAllFields for PivotTable.* and DestTable.* simple fields,
  // or will retrieve the specified aCustomFieldsCSV fields (with
  // the table name associated: e.g. 'PivotTable.One, DestTable.Two')
  TSQLRecordManyJoinKind = (
    jkDestID, jkPivotID, jkDestFields, jkPivotFields, jkPivotAndDestFields);

  {/ handle "has many" and "has many through" relationships
   - many-to-many relationship is tracked using a table specifically for that
     relationship, turning the relationship into two one-to-many relationships
     pointing in opposite directions
   - by default, only two TSQLRecord (i.e. INTEGER) fields must be created,
     named "Source" and "Dest", the first pointing to the source record (the one
     with a TSQLRecordMany published property) and the second to the destination record
   - you should first create a type inheriting from TSQLRecordMany, which
     will define the pivot table, providing optional "through" parameters if needed
     ! TSQLDest = class(TSQLRecord);
     ! TSQLSource = class;
     ! TSQLDestPivot = class(TSQLRecordMany)
     ! private
     !  fSource: TSQLSource;
     !  fDest: TSQLDest;
     !  fTime: TDateTime;
     ! published
     !   property Source: TSQLSource read fSource; // map Source column
     !   property Dest: TSQLDest read fDest; // map Dest column
     !   property AssociationTime: TDateTime read fTime write fTime;
     ! end;
     ! TSQLSource = class(TSQLRecord)
     ! private
     !   fDestList: TSQLDestPivot;
     ! published
     !   DestList: TSQLDestPivot read fDestList;
     ! end;
   - in all cases, at leat two 'Source' and 'Dest' published properties must
     be declared as TSQLRecord children in any TSQLRecordMany descendant
     because they will always be needed for the 'many to many' relationship
   - when a TSQLRecordMany published property exists in a TSQLRecord, it is
     initialized automaticaly by TSQLRecord.Create
   - to add some associations to the pivot table, use the ManyAdd() method
   - to retrieve an association, use the ManySelect() method
   - to delete an association, use the ManyDelete() method
   - to read all Dest records IDs, use the DestGet() method
   - to read the Dest records and the associated "through" fields content, use
     FillMany then FillRow, FillOne and FillRewind methods to loop through records
   - to read all Source records and the associaed "through" fields content,
     FillManyFromDest then FillRow, FillOne and FillRewind methods
   - to read all Dest IDs after a join to the pivot table, use DestGetJoined }
  TSQLRecordMany = class(TSQLRecord)
  protected
    // internal fields initialized during TSQLRecord.Create
    // - map to the Source and Dest properties field values in TSQLRecord values
    fSourceID: PPtrInt;
    fDestID: PPtrInt;
    /// retrieve the TSQLRecordMany ID from a given source+dest IDs pair
    function InternalIDFromSourceDest(aClient: TSQLRest; aSourceID, aDestID: integer): integer;
    function InternalFillMany(aClient: TSQLRest; aID: integer;
      const aAndWhereSQL: RawUTF8; isDest: boolean): integer;
  public
    /// initialize this instance, and needed internal fields
    // - will set protected fSourceID/fDestID fields
    constructor Create; override;
    /// retrieve all records associated to a particular source record, which
    // has a TSQLRecordMany property
    // - returns the Count of records corresponding to this aSource record
    // - the records are stored in an internal TSQLTable, refered in the private
    // fTable field, and initialized via a FillPrepare call: all Dest items
    // are therefore accessible with standard FillRow, FillOne and FillRewind methods
    // - use a "for .." loop or a "while FillOne do ..." loop to iterate
    // through all Dest items, getting also any additional 'through' columns
    // - if source ID parameter is 0, the ID is taken from the fSourceID field
    // (set by TSQLRecord.Create)
    // - note that if the Source record has just been added, fSourceID is not
    // set, so this method will fail: please specify aSourceID parameter with
    // the one just added/created
    // - the optional aAndWhereSQL parameter can be used to add any additional
    // condition to the WHERE statement (e.g. 'Salary>:(1000): AND Salary<:(2000):')
    // according to TSQLRecordMany properties - note that you should better use
    // inlined parameters for faster processing on server, so you may call e.g.
    // ! aRec.FillMany(Client,0,FormatUTF8('Salary>? AND Salary<?',[],[1000,2000]));
    function FillMany(aClient: TSQLRest; aSourceID: integer=0;
      const aAndWhereSQL: RawUTF8=''): integer;
    /// retrieve all records associated to a particular Dest record, which
    // has a TSQLRecordMany property
    // - returns the Count of records corresponding to this aSource record
    // - use a "for .." loop or a "while FillOne do ..." loop to iterate
    // through all Dest items, getting also any additional 'through' columns
    // - the optional aAndWhereSQL parameter can be used to add any additional
    // condition to the WHERE statement (e.g. 'Salary>:(1000): AND Salary<:(2000):')
    // according to TSQLRecordMany properties - note that you should better use
    // inlined parameters for faster processing on server, so you may call e.g.
    // ! aRec.FillManyFromDest(Client,DestID,FormatUTF8('Salary>? AND Salary<?',[],[1000,2000]));
    function FillManyFromDest(aClient: TSQLRest; aDestID: integer;
      const aAndWhereSQL: RawUTF8=''): integer;
    /// retrieve all Dest items IDs associated to the specified Source
    function DestGet(aClient: TSQLRest; aSourceID: integer; out DestIDs: TIntegerDynArray): boolean; overload;
    /// retrieve all Dest items IDs associated to the current Source ID
    // - source ID is taken from the fSourceID field (set by TSQLRecord.Create)
    // - note that if the Source record has just been added, fSourceID is not
    // set, so this method will fail: please call the other overloaded method
    function DestGet(aClient: TSQLRest; out DestIDs: TIntegerDynArray): boolean; overload;
    /// retrieve all Source items IDs associated to the specified Dest ID
    function SourceGet(aClient: TSQLRest; aDestID: integer; out SourceIDs: TIntegerDynArray): boolean;
    /// retrieve all Dest items IDs associated to the current or
    // specified Source ID, adding a WHERE condition against the Dest rows
    // - if aSourceID is 0, the value is taken from current fSourceID field
    // (set by TSQLRecord.Create)
    // - aDestWhereSQL can specify the Dest table name in the statement, e.g.
    //  'Salary>:(1000): AND Salary<:(2000):' - note that you should better use
    // inlined parameters for faster processing on server, so you may use the
    // more convenient function
    // ! FormatUTF8('Salary>? AND Salary<?',[],[1000,2000])
    // - this is faster than a manual FillMany() then loading each Dest,
    // because the condition is executed in the SQL statement by the server
    function DestGetJoined(aClient: TSQLRest; const aDestWhereSQL: RawUTF8;
      aSourceID: Integer; out DestIDs: TIntegerDynArray): boolean; overload;
    /// create a Dest record, then FillPrepare() it to retrieve all Dest items
    // associated to the current or specified Source ID, adding a WHERE condition
    // against the Dest rows
    // - if aSourceID is 0, the value is taken from current fSourceID field
    // (set by TSQLRecord.Create)
    // - aDestWhereSQL can specify the Dest table name in the statement, e.g.
    // 'Salary>:(1000): AND Salary<:(2000):') according to TSQLRecordMany
    // properties - note that you should better use such inlined parameters as
    // ! FormatUTF8('Salary>? AND Salary<?',[],[1000,2000])
    function DestGetJoined(aClient: TSQLRest; const aDestWhereSQL: RawUTF8;
      aSourceID: Integer): TSQLRecord; overload;
    /// create a TSQLTable, containing all specified Fields, after a JOIN
    // associated to the current or specified Source ID
    // - the Table will have the fields specified by the JoinKind parameter
    // - aCustomFieldsCSV can be used to specify which fields must be retrieved
    // (for jkDestFields, jkPivotFields, jkPivotAndDestFields) - default is all
    // - if aSourceID is 0, the value is taken from current fSourceID field
    // (set by TSQLRecord.Create)
    // - aDestWhereSQL can specify the Dest table name in the statement, e.g.
    // 'Salary>:(1000): AND Salary<:(2000):') according to TSQLRecordMany
    // properties - note that you should better use such inlined parameters as
    // ! FormatUTF8('Salary>? AND Salary<?',[],[1000,2000])
    function DestGetJoinedTable(aClient: TSQLRest; const aDestWhereSQL: RawUTF8;
      aSourceID: Integer; JoinKind: TSQLRecordManyJoinKind;
      const aCustomFieldsCSV: RawUTF8=''): TSQLTable;
    /// add a Dest record to the Source record list
    // - returns TRUE on success, FALSE on error
    // - if NoDuplicates is TRUE, the existence of this Source/Dest ID pair
    // is first checked
    // - current Source and Dest properties are filled with the corresponding
    // TRecordReference values corresponding to the supplied IDs
    // - any current value of the additional fields are used to populate the
    // newly created content (i.e. all published properties of this record)
    function ManyAdd(aClient: TSQLRest; aSourceID, aDestID: Integer;
      NoDuplicates: boolean=false): boolean; overload;
    /// add a Dest record to the current Source record list
    // - source ID is taken from the fSourceID field (set by TSQLRecord.Create)
    // - note that if the Source record has just been added, fSourceID is not
    // set, so this method will fail: please call the other overloaded method
    function ManyAdd(aClient: TSQLRest; aDestID: Integer;
      NoDuplicates: boolean=false): boolean; overload;
    /// will delete the record associated with a particular Source/Dest pair
    // - will return TRUE if the pair was found and successfully deleted
    // - if aUseBatchMode is TRUE, it will use aClient.BatchDelete() instead
    // of the slower aClient.Delete() method - but you shall call it within
    // a BatchStart / BatchSend block
    function ManyDelete(aClient: TSQLRest; aSourceID, aDestID: Integer;
      aUseBatchMode: boolean=false): boolean; overload;
    /// will delete the record associated with the current source and a specified Dest
    // - source ID is taken from the fSourceID field (set by TSQLRecord.Create)
    // - note that if the Source record has just been added, fSourceID is not
    // set, so this method will fail: please call the other overloaded method
    // - if aUseBatchMode is TRUE, it will use aClient.BatchDelete() instead
    // of the slower aClient.Delete() method - but you shall call it within
    // a BatchStart / BatchSend block
    function ManyDelete(aClient: TSQLRest; aDestID: Integer;
      aUseBatchMode: boolean=false): boolean; overload;
    /// will retrieve the record associated with a particular Source/Dest pair
    // - will return TRUE if the pair was found
    // - in this case, all "through" columns are available in the TSQLRecordMany
    // field instance
    function ManySelect(aClient: TSQLRest; aSourceID, aDestID: Integer): boolean; overload;
    /// will retrieve the record associated with the current source and a specified Dest
    // - source ID is taken from the fSourceID field (set by TSQLRecord.Create)
    // - note that if the Source record has just been added, fSourceID is not
    // set, so this method will fail: please call the other overloaded method
    function ManySelect(aClient: TSQLRest; aDestID: Integer): boolean; overload;

    // get the SQL WHERE statement to be used to retrieve the associated
    // records according to a specified ID
    // - search for aID as Source ID if isDest is FALSE
    // - search for aID as Dest ID if isDest is TRUE
    // - the optional aAndWhereSQL parameter can be used to add any additional
    // condition to the WHERE statement (e.g. 'Salary>:(1000): AND Salary<:(2000):')
    // according to TSQLRecordMany properties - note that you should better use
    // such inlined parameters e.g. calling
    // ! FormatUTF8('Salary>? AND Salary<?',[],[1000,2000])
    function IDWhereSQL(aClient: TSQLRest; aID: integer; isDest: boolean;
      const aAndWhereSQL: RawUTF8=''): RawUTF8;
  end;

  /// a base record, with a JSON-logging capability
  // - used to store a log of events into a JSON text, easy to be displayed
  // with a TSQLTableToGrid
  // - this log can then be stored as a RawUTF8 field property into a result
  // record, e.g.
  TSQLRecordLog = class(TSQLRecord)
  protected
    /// store the Log Table JSON content
    fLogTableStorage: TMemoryStream;
    /// used by Log() to add the value of OneLog to fLogTableStorage
    fLogTableWriter: TJSONSerializer;
    /// current internal row count
    fLogTableRowCount: integer;
    /// maximum rows count
    fMaxLogTableRowCount: integer;
  public
    /// initialize the internal storage with a supplied JSON content
    // - this JSON content must follow the format retrieved by
    // LogTableJSON and LogTableJSONFrom methods
    constructor CreateFrom(OneLog: TSQLRecord; const aJSON: RawUTF8);
    /// release the private fLogTableWriter and fLogTableStorage objects
    destructor Destroy; override;
    /// add the value of OneLog to the Log Table JSON content
    // - the ID property of the supplied OneLog record is incremented before adding
    procedure Log(OneLog: TSQLRecord);
    /// returns the JSON data as added by previous call to Log()
    // - JSON data is in not-expanded format
    // - this function can be called multiple times
    function LogTableJSON: RawUTF8;
    /// returns the internal position of the Log content
    // - use this value to later retrieve a log range with LogTableJSONFrom()
    function LogCurrentPosition: integer;
    /// returns the log JSON data from a given start position
    // - StartPosition was retrieved previously with LogCurrentPosition
    // - if StartPosition=0, the whole Log content is returned
    // - multiple instances of LogCurrentPosition/LogTableJSONFrom() can be
    // used at once
    function LogTableJSONFrom(StartPosition: integer): RawUTF8;
    /// the current associated Log Table rows count value
    // - is incremented every time Log() method is called
    // - will be never higher than MaxLogTableRowCount below (if set)
    property LogTableRowCount: integer read fLogTableRowCount;
    /// if the associated Log Table rows count reachs this value, the
    // first data row will be trimed
    // - do nothing is value is left to 0 (which is the default)
    // - total rows count won't never be higher than this value
    // - used to spare memory usage
    property MaxLogTableRowCount: integer read fMaxLogTableRowCount;
  end;

  /// common ancestor for tables with digitally signed RawUTF8 content
  // - content is signed according to a specific User Name and the digital
  // signature date and time
  // - internaly uses the very secure SHA-256 hashing algorithm for performing
  // the digital signature
  TSQLRecordSigned = class(TSQLRecord)
  protected
    /// time and date of signature
    fSignatureTime: TTimeLog;
    /// hashed signature
    fSignature: RawUTF8;
  public
    /// time and date of signature
    // - if the signature is invalid, this field will contain numerical 1 value
    // - this property is defined here to allow inherited to just declared the name
    // in its published section:
    // ! property SignatureTime;
    property SignatureTime: TTimeLog read fSignatureTime write fSignatureTime;
    /// as the Content of this record is added to the database,
    // its value is hashed and stored as 'UserName/03A35C92....' into this property
    // - very secured SHA-256 hashing is used internaly
    // - digital signature is allowed only once: this property is written only once
    // - this property is defined here to allow inherited to just declared the name
    // in its published section:
    // ! property SignatureTime;
    property Signature: RawUTF8 read fSignature write fSignature;
  public
    /// use this procedure to sign the supplied Content of this record for a
    // specified UserName, with the current Date and Time  (SHA-256 hashing is used
    // internaly)
    // - returns true if signed successfully (not already signed)
    function SetAndSignContent(const UserName: RawUTF8;
      const Content: RawByteString; ForcedSignatureTime: Int64=0): boolean;
    /// returns true if this record content is correct according to the
    // stored digital Signature
    function CheckSignature(const Content: RawByteString): boolean;
    /// retrieve the UserName who digitally signed this record
    // - returns '' if was not digitally signed
    function SignedBy: RawUTF8;
    /// reset the stored digital signature
    // - SetAndSignContent() can be called after this method
    procedure UnSign;
  end;

  /// the possible Server-side instance implementation patterns for Services
  // - each interface-based service will be implemented by a corresponding
  // class instance on the server: this parameter is used to define how
  // class instances are created and managed
  // - on the Client-side, each instance will be handled depending on the
  // server side implementation (i.e. with sicClientDriven behavior if necessary)
  // - sicSingle: one object instance is created per call - this is the
  // most expensive way of implementing the service, but is safe for simple
  // workflows (like a one-type call); this is the default setting for
  // TSQLRestServer.ServiceRegister method
  // - sicShared: one object instance is used for all incoming calls and is
  // not recycled subsequent to the calls - the implementation should be
  // thread-safe on the server side
  // - sicClientDriven: one object instance will be created in synchronization
  // with the client-side lifetime of the corresponding interface: when the
  // interface will be released on client, it will be released on the server
  // side - a numerical identifier will be transmitted for all JSON requests
  // - sicPerSession, sicPerUser and sicPerGroup modes will maintain one
  // object instance per running session / user / group (only working if
  // RESTful authentication is enabled) - since it may be shared among users or
  // groups, the sicPerUser and sicPerGroup implementation should be thread-safe
  // - sicPerThread will maintain one object instance per calling thread - it
  // may be usefull instead of sicShared mode if the service process expects
  // some per-heavy thread initialization, for instance
  TServiceInstanceImplementation = (
    sicSingle, sicShared, sicClientDriven, sicPerSession, sicPerUser, sicPerGroup,
    sicPerThread);

  /// interface-based service will transmit this variable content without
  // any serialization
  // - e.g. for efficient and AJAX-ready transmission of TSQLTableJSON result
  RawJSON = type RawUTF8;

  /// handled kind of parameters for a service provider method
  // - we do not handle all kind of Delphi variables, but provide some
  // enhanced types handled by JSONToObject/ObjectToJSON functions (smvObject)
  // or TDynArray.LoadFromJSON / TTextWriter.AddDynArrayJSON methods (smvDynArray)
  // - records will be serialized as Base64 string, with our RecordSave/RecordLoad
  // low-level format by default, or as true JSON objects, after registration
  // via a TTextWriter.RegisterCustomJSONSerializer call
  // - smvRawJSON will transmit the raw JSON content, without serialization
  TServiceMethodValueType = (
    smvNone,
    smvSelf,
    smvBoolean,
    smvEnum,
    smvSet,
    smvInteger,
    smvCardinal,
    smvInt64,
    smvDouble,
    smvDateTime,
    smvCurrency,
    smvRawUTF8,
    smvString,
    smvWideString,
    smvRecord,
    {$ifdef USEVARIANTS}
    smvVariant,
    {$endif}
    smvObject,
    smvRawJSON,
    smvDynArray);

  /// handled kind of parameters internal variables
  // - reference-counted variables will have their own storage
  // - all non referenced-counted variables are stored within some 64 bit content
  // - smvVariant kind of parameter will be handled as a special smvvRecord
  TServiceMethodValueVar = (
    smvvNone, smvvSelf, smvv64, smvvRawUTF8, smvvString, smvvWideString,
    smvvRecord, smvvObject, smvvDynArray);

  /// set of parameters for a service provider method
  TServiceMethodValueTypes = set of TServiceMethodValueType;

  /// handled kind of parameters direction for a service provider method
  // - IN, IN/OUT, OUT directions can be applied to arguments, and will
  // be available through our JSON-serialized remote access: smdVar and smdOut
  // kind of parameters will be returned within the "result": JSON array
  // - smdResult is used for a function method, to handle the returned value
  TServiceMethodValueDirection = (
    smdConst,
    smdVar,
    smdOut,
    smdResult);

  /// describe a service provider method argument
  TServiceMethodArgument = {$ifndef ISDELPHI2010}object{$else}record{$endif}
  public
    /// the argument name, as declared in Delphi
    ParamName: PShortString;
    /// the type name, as declared in Delphi
    TypeName: PShortString;
    /// the low-level RTTI information of this argument
    TypeInfo: PTypeInfo;
    /// we do not handle all kind of Delphi variables
    ValueType: TServiceMethodValueType;
    /// how the variable may be stored
    ValueVar: TServiceMethodValueVar;
    /// the variable direction as defined at code level
    ValueDirection: TServiceMethodValueDirection;
    /// how the variable is to be passed at asm level
    // - vIsString is included for smvRawUTF8, smvString and smvWideString
    // kind of parameter (smvRecord has it to false, even if they are Base-64
    // encoded within the JSON content, and also smvVariant/smvRawJSON)
    // - vPassedByReference is included if the parameter is passed as reference
    // (i.e. defined as var/out, or is a record or a reference-counted type result)
    ValueKindAsm: set of (vIsString, vPassedByReference);
    /// byte offset in the CPU stack of this argument
    // - may be -1 if pure register parameter with no backup on stack (x86) 
    InStackOffset: integer;
    /// used to specify if the argument is passed as register
    // - contains 0 if parameter is not a register
    // - contains 1 for EAX, 2 for EDX and 3 for ECX registers (for x86)
    // - contains 1 for RCX/XMM0L, 2 for RDX/XMM1L, 3 for R8/XMM2L, and
    // 4 for R9/XMM3L, with a backing store on the stack (for x64)
    RegisterIdent: integer;
    /// size (in bytes) of this argument on the stack
    SizeInStack: integer;
    /// size (in bytes) of this smvv64 ordinal value
    // - e.g. depending of the associated kind of enumeration
    SizeInStorage: integer;
    /// index of the associated variable in the local array[ArgsUsedCount[]]
    // - for smdConst argument, contains -1 (no need to a local var: the value
    // will be on the stack only)
    IndexVar: integer;
    /// serialize the argument into the TServiceContainer.Contract JSON format
    // - non standard types (e.g. clas, enumerate, dynamic array or record)
    // are identified by their type identifier - so contract does not extend
    // up to the content of such high-level structures
    function SerializeToContract: RawUTF8;
  end;

  /// describe a service provider method arguments
  TServiceMethodArgumentDynArray = array of TServiceMethodArgument;

  /// possible service provider method options, e.g. about logging or execution
  TServiceMethodOption = (
    {$ifdef LVCL}
    optNone
    {$else}
    optExecInMainThread, optFreeInMainThread
    {$endif}
  );

  /// set of per-method execution options for a service provider
  // - optExecInMainThread will force the method to be called within
  // a RunningThread.Synchronize() call - it can be used e.g. if your
  // implementation rely heavily on COM servers - by default, service methods
  // are called within the thread which received them, on multi-thread server
  // instances (e.g. TSQLite3HttpServer or TSQLRestServerNamedPipeResponse),
  // for better response time and CPU use (this is the technical reason why
  // service implementation methods have to handle multi-threading safety
  // carefully, e.g. by using TRTLCriticalSection mutex on purpose)
  // - optFreeInMainThread will force the _Release/Destroy method to be run
  // in the main thread: setting this option for any method will affect the
  // whole service class - is not set by default, for performance reasons
  TServiceMethodOptions = set of TServiceMethodOption;

  /// describe a service provider method
  TServiceMethod = {$ifndef UNICODE}object{$else}record{$endif}
  public
    /// the method URI
    // - basicaly the method name as declared in Delphi code (e.g. 'Add' for
    // ICalculator.Add)
    // - this property value is hashed internaly for faster access
    URI: RawUTF8;
    /// the method default result, formatted as a JSON array
    // - example of content may be '[]' for a procedure or '[0]' for a function
    // - any var/out and potential function result will be set as a JSON array
    // of values, with 0 for numerical values, "" for textual values,
    // false for booleans, [] for dynamic arrays, a void record serialized
    // as expected (including customized serialization) and null for objects
    DefaultResult: RawUTF8;
    /// describe expected method arguments
    // - Args[0] always is smvSelf
    // - if method is a function, an additional smdResult argument is appended
    Args: TServiceMethodArgumentDynArray;
    /// the index of the result pseudo-argument in Args[]
    // - is -1 if the method is defined as a (not a function)
    ArgsResultIndex: integer;
    /// the index of the first var / out / result argument in Args[]
    ArgsOutFirst: integer;
    /// the index of the last var / out / result argument in Args[]
    ArgsOutLast: integer;
    /// the number of input const / var parameters in Args[]
    ArgsInputValuesCount: cardinal;
    /// the number of input var / out parameters +  in Args[]
    ArgsOutputValuesCount: cardinal;
    /// true if the result is a TServiceCustomAnswer record
    // - that is, a custom Header+Content BLOB transfert, not a JSON object
    ArgsResultIsServiceCustomAnswer: boolean;
    /// needed CPU stack size (in bytes) for all arguments
    // - under x64, does not include the backup space for the four registers
    ArgsSizeInStack: cardinal;
    /// contains all used kind of arguments
    ArgsUsed: TServiceMethodValueTypes;
    /// contains the count of variables for all used kind of arguments
    ArgsUsedCount: array[TServiceMethodValueVar] of integer;
    /// method index in the original interface
    // - our custom methods start at index 3 (RESERVED_VTABLE_SLOTS), since
    // QueryInterface, _AddRef, and _Release are always defined by default
    MethodIndex: integer;
    /// execute the corresponding method of a given TInterfacedObject instance
    // - will retrieve a JSON array of parameters from Par
    // - will append a JSON array of results in Res, or set an Error message
    function InternalExecute(Instances: array of pointer; Par: PUTF8Char;
      Res: TTextWriter; var aHead: RawUTF8; Options: TServiceMethodOptions): boolean;
  end;

  /// describe a service provider methods
  TServiceMethodDynArray = array of TServiceMethod;

  /// a pointer to a service provider method
  // - since TInterfaceFactory instances are shared in a global list, we
  // can safely use such pointers in our code to refer to a particular method
  PServiceMethod = ^TServiceMethod;

  /// a record type to be used as result for a function method for custom content
  // - all answers are pure JSON object by default: using this kind of record
  // as result will allow a response of any type (e.g. binary, HTML or text)
  // - this kind of answer will be understood by our TServiceContainerClient
  // implementation, and it may be used with plain AJAX or HTML requests
  // (via POST), to retrieve some custom content
  TServiceCustomAnswer = record
    /// the response type, as encoded in the HTTP header
    // - useful to set the response mime-type - see e.g. the
    // TEXT_CONTENT_TYPE_HEADER or HTML_CONTENT_TYPE_HEADER constants or
    // GetMimeContentType() function
    // - in order to be handled as expected, this field SHALL be set (<>'')
    // (otherwise it will transmitted with default JSON object format)
    Header: RawUTF8;
    /// the response body
    Content: RawByteString;
  end;

  PServiceCustomAnswer = ^TServiceCustomAnswer;

  {$ifndef LVCL}
  /// any TCollection used between client and server shall inherit from this class
  // - you should override the GetClass virtual method to provide the
  // expected collection item class to be used on server side
  // - another possibility is to register a TCollection/TCollectionItem pair
  // via a call to TJSONSerializer.RegisterCollectionForJSON()
  TInterfacedCollection = class(TCollection)
  protected
    /// you shall override this abstract method
    class function GetClass: TCollectionItemClass; virtual; abstract;
  public
    /// this constructor which will call GetClass to initialize the collection
    constructor Create; reintroduce; virtual;
  end;

  /// the class of TInterfacedCollection kind
  TInterfacedCollectionClass = class of TInterfacedCollection;
  {$endif LVCL}

  /// event used by TInterfaceFactory.CreateFakeInstance() to run a method
  // - aMethod will specify which method is to be executed
  // - aParams will contain the input parameters, encoded as a JSON array
  // - shall return TRUE on success, or FALSE in case of failure, with
  // a corresponding explanation in aErrorMsg
  // - method results shall be serialized as JSON in aResult;  if
  // aServiceCustomAnswer is not nil, the result shall use this record
  // to set HTTP custom content and headers, and ignore aResult content
  // - aClientDrivenID can be set optionally to specify e.g. an URI-level session
  TOnFakeInstanceInvoke = function (const aMethod: TServiceMethod;
    const aParams: RawUTF8; aResult, aErrorMsg: PRawUTF8;
    aClientDrivenID: PCardinal; aServiceCustomAnswer: PServiceCustomAnswer): boolean of object;

  /// event called when destroying a TInterfaceFactory.CreateFakeInstance()
  /// - this method will be run when the fake class instance is destroyed
  // (e.g. if aInstanceCreation is sicClientDriven, to notify the server
  // than the client life time just finished)
  TOnFakeInstanceDestroy = procedure(aClientDrivenID: cardinal) of object;

  /// class handling interface RTTI and fake implementation class
  // - a thread-safe global list of such class instances is implemented to cache
  // information for better speed: use class function TInterfaceFactory.Get()
  // and not manual TInterfaceFactory.Create / Free
  // - if you want to specify the interfaces by name or TGUID, call once
  // Get(TypeInfo(IMyInterface)) or RegisterInterfaces()
  TInterfaceFactory = class
  protected
    fInterfaceTypeInfo: PTypeInfo;
    fInterfaceIID: TGUID;
    fMethodsCount: cardinal;
    fMethods: TServiceMethodDynArray;
    fMethod: TDynArrayHashed;
    fFakeVTable: array of pointer;
    fFakeStub: PByteArray;
    // contains e.g. [{"method":"Add","arguments":[...]},{"method":"...}]
    fContract: RawUTF8;
    procedure AddMethodsFromTypeInfo(aInterface: PTypeInfo);
    function GetMethodsVirtualTable: pointer;
  public
    /// this is the main entry point to the global interface factory cache
    // - access to this method is thread-safe
    // - this method will also register the class to further
    class function Get(aInterface: PTypeInfo): TInterfaceFactory; overload;
    /// retrieve an interface factory from cache, from its TGUID
    // - access to this method is thread-safe
    // - you shall have registered the interface by a previous call to the
    // overloaded Get(TypeInfo(IMyInterface)) method or RegisterInterfaces()
    // - if the supplied TGUID has not been previously registered, returns nil
    class function Get(const aGUID: TGUID): TInterfaceFactory; overload;
    /// retrieve an interface factory from cache, from its name (e.g. 'IMyInterface')
    // - access to this method is thread-safe
    // - you shall have registered the interface by a previous call to the
    // overloaded Get(TypeInfo(IMyInterface)) method or RegisterInterfaces()
    // - if the supplied TGUID has not been previously registered, returns nil
    class function Get(const aInterfaceName: RawUTF8): TInterfaceFactory; overload;
    /// register one or several interfaces to the global interface factory cache
    // - so that you can use TInterfaceFactory.Get(aGUID) or Get(
    class procedure RegisterInterfaces(const aInterfaces: array of PTypeInfo);
    /// create a fake class instance implementing the corresponding interface
    // - aInvoke event will be called at method execution
    // - optional aNotifyDestroy event will be called when the fake
    // implementation instance will be released (e.g. for server notification)
    function CreateFakeInstance(aInvoke: TOnFakeInstanceInvoke;
      aNotifyDestroy: TOnFakeInstanceDestroy=nil): TInterfacedObject;
    /// initialize the internal properties from the supplied interface RTTI
    // - it will check and retrieve all methods of the supplied interface,
    // and prepare all internal structures for later use
    // - do not call this constructor directly, but TInterfaceFactory.Get()
    constructor Create(aInterface: PTypeInfo);
    /// find the index of a particular method in internal Methods[] list
    // - won't find the default AddRef/Release/QueryInterface methods
    // - will return -1 if the method is not known
    function FindMethodIndex(const aMethodName: RawUTF8): integer;
    /// find the index of a particular method in internal Methods[] list
    // - won't find the default AddRef/Release/QueryInterface methods
    // - will raise an EInterfaceFactoryException if the method is not known
    function CheckMethodIndex(const aMethodName: RawUTF8): integer;
    /// the declared internal methods
    // - list does not contain default AddRef/Release/QueryInterface methods
    property Methods: TServiceMethodDynArray read fMethods;
    /// the number of internal methods
    // - does not include the default AddRef/Release/QueryInterface methods
    property MethodsCount: cardinal read fMethodsCount;
    /// the registered Interface low-level Delphi RTTI type
    property InterfaceTypeInfo: PTypeInfo read fInterfaceTypeInfo;
    /// the registered Interface GUID
    property InterfaceIID: TGUID read fInterfaceIID;
  end;

  TInterfaceStub = class;

  /// abstract parameters used by TInterfaceStub.Executes() events callbacks
  TOnInterfaceStubExecuteParamsAbstract = class
  private
    function GetSenderAsMockTestCase: TSynTestCase;
  protected
    fSender: TInterfaceStub;
    fMethod: PServiceMethod;
    fParams: RawUTF8;
    fEventParams: RawUTF8;
    fResult: RawUTF8;
    fFailed: boolean;
  public
    /// constructor of one parameters marshalling instance
    constructor Create(aSender: TInterfaceStub; aMethod: PServiceMethod;
      const aParams,aEventParams: RawUTF8); virtual;
    /// call this method if the callback implementation failed
    procedure Error(const aErrorMessage: RawUTF8); overload;
    /// call this method if the callback implementation failed
    procedure Error(Format: PUTF8Char; const Args: array of const); overload;
    /// the stubbing / mocking generator
    property Sender: TInterfaceStub read fSender;
    /// the mocking generator associated test case
    // - will raise an exception if the associated Sender generator is not
    // a TInterfaceMock
    property TestCase: TSynTestCase read GetSenderAsMockTestCase;
    /// pointer to the method which is to be executed
    property Method: PServiceMethod read fMethod;
    /// a custom message, defined at TInterfaceStub.Executes() definition
    property EventParams: RawUTF8 read fEventParams;
  end;

{$ifdef USEVARIANTS}
  /// parameters used by TInterfaceStub.Executes() events callbacks as Variant
  // - this class will expect input and output parameters to specified as
  // variant arrays properties, so is easier (and a bit slower) than the
  // TOnInterfaceStubExecuteParamsJSON class
  TOnInterfaceStubExecuteParamsVariant = class(TOnInterfaceStubExecuteParamsAbstract)
  private
    function GetInput(Index: Integer): variant;
    procedure SetOutput(Index: Integer; const Value: variant);
    function GetInNamed(const aParamName: RawUTF8): variant;
    procedure SetOutNamed(const aParamName: RawUTF8; const Value: variant);
  protected
    fInput: array of variant;
    fOutput: array of variant;
    procedure SetResult(var Result: RawUTF8);
  public
    /// constructor of one parameters marshalling instance
    constructor Create(aSender: TInterfaceStub; aMethod: PServiceMethod;
      const aParams,aEventParams: RawUTF8); override;
    /// input parameters when calling the method
    // - order shall follow the method const and var parameters
    // ! Stub.Add(10,20) -> Input[0]=10, Input[1]=20
    // - if the supplied Index is out of range, an EInterfaceStub will be raised
    property Input[Index: Integer]: variant read GetInput;
    /// output parameters returned after method process
    // - order shall follow the method var, out parameters and the function
    // result (if method is not a procedure)
    // - if the supplied Index is out of range, an EInterfaceStub will be raised
    // - can be used as such:
    // !  procedure TFooTestCase.ExecuteBar(var Ctxt: TOnInterfaceStubExecuteParamsVariant);
    // !  begin // Input[0]=i
    // !    Ctxt.Output[0] := Ctxt.Input[0]+1;  // i := i+1;
    // !    Ctxt.Output[1] := 42;               // result := 42;
    // !  end; // Output|0]=i, Output[1]=result
    // to emulate this native implementation:
    // ! function Bar(var i: Integer): Integer;
    // ! begin
    // !    inc(i);
    // !    result := 42;
    // !  end;
    property Output[Index: Integer]: variant write SetOutput;
    /// access to input/output parameters when calling the method
    // - if the supplied name is incorrect, an EInterfaceStub will be raised
    // - is a bit slower than Input[]/Output[] indexed properties, but easier
    // to work with, and safer in case of method signature change (like parameter
    // add or rename)
    // - marked as default property, so you can use it e.g. as such:
    // !  procedure TFooTestCase.ExecuteBar(var Ctxt: TOnInterfaceStubExecuteParamsVariant);
    // !  begin // Input[0]=i
    // !    Ctxt['i'] := Ctxt['i']+1;  // i := i+1;
    // !    Ctxt['result'] := 42;      // result := 42;
    // !  end;
    // to emulate this native implementation:
    // ! function Bar(var i: Integer): Integer;
    // ! begin
    // !    inc(i);
    // !    result := 42;
    // !  end;
    // - using this default Named[] property is recommended 
    property Named[const ParamName: RawUTF8]: variant read GetInNamed write SetOutNamed; default;
  end;
{$endif}

  /// parameters used by TInterfaceStub.Executes() events callbacks as JSON
  // - this class will expect input and output parameters to be encoded as
  // JSON arrays, so is faster than TOnInterfaceStubExecuteParamsVariant
  TOnInterfaceStubExecuteParamsJSON = class(TOnInterfaceStubExecuteParamsAbstract)
  public
    /// a method to return an array of values into Result
    // - just a wrapper around JSONEncodeArrayOfConst([...])
    // - can be used as such:
    // !  function TFooTestCase.ExecuteBar(var Ctxt: TOnInterfaceStubExecuteParamsJSON): Boolean;
    // !  begin // Ctxt.Params := '[i]' -> Ctxt.Result := '[i+1,42]'
    // !    Ctxt.Returns([GetInteger(pointer(Ctxt.Params))+1,42]);
    // !    result := true;
    // !  end;
    // to emulate this native implementation:
    // ! function Bar(var i: Integer): Integer;
    // ! begin
    // !    inc(i);
    // !    result := 42;
    // !  end;
    procedure Returns(const Values: array of const);
    /// incoming parameters array encoded as JSON array without braces
    // - order follows the method const and var parameters
    // ! Stub.Add(10,20) -> Params = '10,20';
    property Params: RawUTF8 read fParams;
    /// outgoing values array encoded as JSON
    // - every var, out parameter or the function result shall be encoded as
    // a JSON array into this variable, in the same order than the stubbed
    // method declaration
    // - use Returns() method to create the JSON array directly, from an array
    // of values
    property Result: RawUTF8 write fResult;
  end;

{$ifdef USEVARIANTS}
  /// event called by the TInterfaceStub.Executes() fluent method for variant process
  // - by default Ctxt.Result shall contain the default JSON array result for
  // this method - use Ctxt.Named[] default properties, e.g. as
  // ! Ctxt['result'] := Ctxt['n1']-Ctxt['n2'];
  // or with Input[] / Output[] properties:
  // ! with Ctxt do Output[0] := Input[0]-Input[1];
  // - you can call Ctxt.Error() to notify the caller for an execution error
  TOnInterfaceStubExecuteVariant = procedure(Ctxt: TOnInterfaceStubExecuteParamsVariant) of object;
{$endif}

  /// event called by the TInterfaceStub.Executes() fluent method for JSON process
  // - by default Ctxt.Result shall contain the default JSON array result for
  // this method - use Ctxt.Named[] default properties, e.g. as
  // !  P := pointer(Ctxt.Params);
  // !  Ctxt.Returns([GetNextItemDouble(P)-GetNextItemDouble(P)]);
  // - you can call Ctxt.Error() to notify the caller for an execution error
  TOnInterfaceStubExecuteJSON = procedure(Ctxt: TOnInterfaceStubExecuteParamsJSON)of object;

  /// diverse types of stubbing / mocking rules
  // - isUndefined is the first, since it will be a ExpectsCount() weak rule
  // which may be overwritten by the other real run-time rules
  TInterfaceStubRuleKind =
    (isUndefined, isExecutesJSON, {$ifdef USEVARIANTS}isExecutesVariant, {$endif}
     isRaises, isReturns, isFails);

  /// define a mocking / stubing rule used internaly by TInterfaceStub
  TInterfaceStubRule = record
    /// optional expected parameters, serialized as a JSON array
    // - if equals '', the rule is not parametrized - i.e. it will be the
    // default for this method
    Params: RawUTF8;
    /// values associated to the rule
    // - for TInterfaceStub.Executes(), is the aEventParams parameter transmitted
    // to Execute event handler (could be used to e.g. customize the handler)
    // - for TInterfaceStub.Raises(), is the Exception.Message associated
    // to one ExceptionClass
    // - for TInterfaceStub.Returns(), is the returned result, serialized as a
    // JSON array (including var / out parameters then any function result)
    // - for TInterfaceStub.Fails() is the returned error message for
    // TInterfaceStub exception or TInterfaceMock associated test case
    Values: RawUTF8;
    /// the type of this rule
    // - isUndefined is used for a TInterfaceStub.ExpectsCount() weak rule
    Kind: TInterfaceStubRuleKind;
    /// the event handler to be executed
    // - for TInterfaceStub.Executes(), Values is transmitted as aResult parameter
    // - either a TOnInterfaceStubExecuteJSON, or a TOnInterfaceStubExecuteVariant
    Execute: TNotifyEvent;
    /// the exception class to be raised
    // - for TInterfaceStub.Raises(), Values contains Exception.Message
    ExceptionClass: ExceptClass;
    /// the number of times this rule has been executed
    RulePassCount: cardinal;
    /// comparison operator set by TInterfaceStub.ExpectsCount()
    // - only qoEqualTo..qoGreaterThanOrEqualTo are relevant here
    ExpectedPassCountOperator: TSQLQueryOperator;
    /// expected pass count value set by TInterfaceStub.ExpectsCount()
    // - value to be compared to the number of times this rule has been executed
    // - TInterfaceStub/TInterfaceMock will check it in their Destroy destructor,
    // using the comparison stated by ExpectedPassCountOperator
    ExpectedPassCount: cardinal;
    /// log trace value set by TInterfaceStub.ExpectsTrace()
    // - value to be compared to the Hash32() value of the execution log trace
    // - TInterfaceStub/TInterfaceMock will check it in their Destroy destructor,
    // using the fLogs[] content
    ExpectedTraceHash: cardinal;
  end;

  /// define the rules for a given method as used internaly by TInterfaceStub
  TInterfaceStubRules = {$ifdef UNICODE}record{$else}object{$endif}
    /// the mocking / stubing rules associated to this method
    Rules: array of TInterfaceStubRule;
    /// index in Rules[] of the default rule, i.e. the one with Params=''
    DefaultRule: integer;
    /// the number of times this method has been executed
    MethodPassCount: cardinal;
    /// find a rule index from its Params content
    function FindRuleIndex(const aParams: RawUTF8): integer;
    /// find a strong rule index from its Params content
    function FindStrongRuleIndex(const aParams: RawUTF8): integer;
    /// register a rule
    procedure AddRule(Sender: TInterfaceStub; aKind: TInterfaceStubRuleKind;
      const aParams, aValues: RawUTF8; const aEvent: TNotifyEvent=nil;
      aExceptionClass: ExceptClass=nil;
      aExpectedPassCountOperator: TSQLQueryOperator=qoNone; aValue: cardinal=0);
  end;

  /// diverse options available to TInterfaceStub
  // - by default, method execution stack is not recorded - include
  // imoLogMethodCallsAndResults in the options to track all method calls
  // and the returned values; note that ExpectsTrace() method will set it
  // - by default, TInterfaceStub will be released when the stubed/mocked
  // interface is released - include imoFakeInstanceWontReleaseTInterfaceStub
  // in the options to force manual memory handling of TInterfaceStubs
  // - by default, all interfaces will return some default values, unless
  // imoRaiseExceptionIfNoRuleDefined or imoReturnErrorIfNoRuleDefined is
  // included in the options
  // - by default, any TInterfaceMock.Fails() rule execution will notify the
  // TSynTestCase, unless imoMockFailsWillPassTestCase which will let test pass
  TInterfaceStubOption = (
    imoLogMethodCallsAndResults,
    imoFakeInstanceWontReleaseTInterfaceStub,
    imoRaiseExceptionIfNoRuleDefined,
    imoReturnErrorIfNoRuleDefined,
    imoMockFailsWillPassTestCase);

  /// set of options available to TInterfaceStub
  TInterfaceStubOptions = set of TInterfaceStubOption;

  /// every potential part of TInterfaceStubLog.AddAsText() log entry
  TInterfaceStubLogLayout = (wName, wParams, wResults);

  /// set the output layout of TInterfaceStubLog.AddAsText() log entry
  TInterfaceStubLogLayouts = set of TInterfaceStubLogLayout;

  /// used to keep track of one stubbed method call
  TInterfaceStubLog = {$ifdef UNICODE}record{$else}object{$endif}
    /// call timestamp, in milliseconds
    // - under Windows, if filled with GetTickCount() API returned value
    TimeStamp: cardinal;
    /// set to TRUE if this calls failed
    // - i.e. if EInterfaceFactoryException was raised for TInterfaceStub, or
    // if TInterfaceMock did notify its associated TSynTestCase via a Check()
    // - CustomResults/Results will contain the error message
    WasError: boolean;
    /// the method called
    // - a pointer to the existing information in shared TInterfaceFactory
    Method: PServiceMethod;
    /// the parameters at execution call
    Params: RawUTF8;
    /// any non default result returned after execution
    // - if not set (i.e. if equals ''), Method^.DefaultResult has been returned
    // - if WasError is TRUE, always contain the error message
    CustomResults: RawUTF8;
    /// the result returned after execution
    // - this method will return Method^.DefaultResult
    function Results: RawUTF8;
    /// append the log in textual format
    // - typical output is as such:
    // $ Add(10,20)=[30],
    // or, if WasError is TRUE:
    // $ Divide(20,0) error "divide by zero",
    procedure AddAsText(WR: TTextWriter; aScope: TInterfaceStubLogLayouts);
  end;

  /// used to keep track of all stubbed methods calls
  TInterfaceStubLogDynArray = array of TInterfaceStubLog;

  /// used to stub an interface implementation
  // - define the expected workflow in a fluent interface using Executes /
  // Fails / Returns / Raises
  // - this class will be inherited by TInterfaceMock which will contain some
  // additional methods dedicated to mocking behavior (e.g. including in tests)
  // - each instance of this class will be owned by its generated fake
  // implementation class (retrieved at constructor out parameter): when the
  // stubed/mocked interface is freed, its associated TInterfaceStub will be
  // freed - so you do not need to protect TInterfaceStub.Create with a
  // try..finally clause, since it will be released when no more needed
  TInterfaceStub = class
  protected
    fInterface: TInterfaceFactory;
    fRules: array of TInterfaceStubRules;
    fOptions: TInterfaceStubOptions;
    fHasExpects: set of (eCount,eTrace);
    fLogs: TInterfaceStubLogDynArray;
    fLog: TDynArray;
    fLogCount: integer;
    fInterfaceExpectedTraceHash: cardinal;
    procedure InternalCreate(out aStubbedInterface); virtual;
    function InternalCheck(aValid: boolean; const aErrorMessage: RawUTF8;
      aExpectationFailed: boolean): boolean; virtual;
    function Invoke(const aMethod: TServiceMethod;
      const aParams: RawUTF8; aResult, aErrorMsg: PRawUTF8;
      aClientDrivenID: PCardinal; aServiceCustomAnswer: PServiceCustomAnswer): boolean;
    // will launch InternalCheck() process if some expectations defined by
    // ExpectsCount() are not met, i.e. raise an exception for TInterfaceStub
    // or notify the associated test case for TInterfaceMock
    procedure InstanceDestroyed(aClientDrivenID: cardinal);
    procedure IntSetOptions(Options: TInterfaceStubOptions); virtual;
    procedure IntCheckCount(aMethodIndex, aComputed: cardinal; aOperator: TSQLQueryOperator; aCount: cardinal);
    function IntGetLogAsText(asmndx: integer; const aParams: RawUTF8;
      aScope: TInterfaceStubLogLayouts): RawUTF8;
    function GetLogAsText: RawUTF8;
    function GetLogHash: cardinal;
  public
    /// initialize an interface stub from TypeInfo(IMyInterface)
    // - assign the fake class instance to the SubbedInterface variable:
    // !var I: ICalculator;
    // !  TInterfaceStub.Create(TypeInfo(ICalculator),I);
    // !  Check(I.Add(10,20)=0,'Default result');
    constructor Create(aInterface: PTypeInfo; out aStubbedInterface); reintroduce; overload;
    /// initialize an interface stub from an interface GUID
    // - you shall have registered the interface by a previous call to
    // TInterfaceFactory.Get(TypeInfo(IMyInterface)) or RegisterInterfaces()
    // - if the supplied TGUID has not been previously registered, raise an Exception
    constructor Create(const aGUID: TGUID; out aStubbedInterface); reintroduce; overload;
    /// initialize an interface stub from an interface name (e.g. 'IMyInterface')
    // - you shall have registered the interface by a previous call to
    // TInterfaceFactory.Get(TypeInfo(IMyInterface)) or RegisterInterfaces()
    // - if the supplied name has not been previously registered, raise an Exception
    constructor Create(const aInterfaceName: RawUTF8; out aStubbedInterface); reintroduce; overload;

    /// add an execution rule for a given method, with JSON marshalling
    // - optional aEventParams parameter will be transmitted to aEvent handler
    // - raise an Exception if the method name does not exist for this interface
    function Executes(const aMethodName: RawUTF8;
      aEvent: TOnInterfaceStubExecuteJSON; const aEventParams: RawUTF8=''): TInterfaceStub; overload;
    /// add an execution rule for a given method and a set of parameters,
    // with JSON marshalling
    // - if execution context matches the supplied aParams value, aEvent is triggered
    // - optional aEventParams parameter will be transmitted to aEvent handler
    // - raise an Exception if the method name does not exist for this interface
    function Executes(const aMethodName, aParams: RawUTF8;
      aEvent: TOnInterfaceStubExecuteJSON; const aEventParams: RawUTF8=''): TInterfaceStub; overload;
    /// add an execution rule for a given method and a set of parameters,
    // with JSON marshalling
    // - if execution context matches the supplied aParams value, aEvent is triggered
    // - optional aEventParams parameter will be transmitted to aEvent handler
    // - raise an Exception if the method name does not exist for this interface
    function Executes(const aMethodName: RawUTF8; const aParams: array of const;
      aEvent: TOnInterfaceStubExecuteJSON; const aEventParams: RawUTF8=''): TInterfaceStub; overload;
{$ifdef USEVARIANTS}
    /// add an execution rule for a given method, with Variant marshalling
    // - optional aEventParams parameter will be transmitted to aEvent handler
    // - raise an Exception if the method name does not exist for this interface
    function Executes(const aMethodName: RawUTF8;
      aEvent: TOnInterfaceStubExecuteVariant; const aEventParams: RawUTF8=''): TInterfaceStub; overload;
    /// add an execution rule for a given method and a set of parameters,
    // with Variant marshalling
    // - if execution context matches the supplied aParams value, aEvent is triggered
    // - optional aEventParams parameter will be transmitted to aEvent handler
    // - raise an Exception if the method name does not exist for this interface
    function Executes(const aMethodName, aParams: RawUTF8;
      aEvent: TOnInterfaceStubExecuteVariant; const aEventParams: RawUTF8=''): TInterfaceStub; overload;
    /// add an execution rule for a given method and a set of parameters,
    // with Variant marshalling
    // - if execution context matches the supplied aParams value, aEvent is triggered
    // - optional aEventParams parameter will be transmitted to aEvent handler
    // - raise an Exception if the method name does not exist for this interface
    function Executes(const aMethodName: RawUTF8; const aParams: array of const;
      aEvent: TOnInterfaceStubExecuteVariant; const aEventParams: RawUTF8=''): TInterfaceStub; overload;
{$endif}

    /// add an exception rule for a given method
    // - will create and raise the specified exception for this method
    // - raise an Exception if the method name does not exist for this interface
    function Raises(const aMethodName: RawUTF8;
      aException: ExceptClass; const aMessage: string): TInterfaceStub; overload;
    /// add an exception rule for a given method and a set of parameters
    // - will create and raise the specified exception for this method, if the
    // execution context matches the supplied aParams value
    // - raise an Exception if the method name does not exist for this interface
    function Raises(const aMethodName, aParams: RawUTF8;
      aException: ExceptClass; const aMessage: string): TInterfaceStub; overload;
    /// add an exception rule for a given method and a set of parameters
    // - will create and raise the specified exception for this method, if the
    // execution context matches the supplied aParams value
    // - raise an Exception if the method name does not exist for this interface
    function Raises(const aMethodName: RawUTF8; const aParams: array of const;
      aException: ExceptClass; const aMessage: string): TInterfaceStub; overload;

    /// add an evaluation rule for a given method
    // - aExpectedResults JSON array will be returned to the caller
    // - raise an Exception if the method name does not exist for this interface
    function Returns(const aMethodName, aExpectedResults: RawUTF8): TInterfaceStub; overload;
    /// add an evaluation rule for a given method
    // - aExpectedResults will be returned to the caller after conversion to
    // a JSON array
    // - raise an Exception if the method name does not exist for this interface
    function Returns(const aMethodName: RawUTF8; const aExpectedResults: array of const): TInterfaceStub; overload;
    /// add an evaluation rule for a given method and a set of parameters
    // - aExpectedResults JSON array will be returned to the caller
    // - raise an Exception if the method name does not exist for this interface
    function Returns(const aMethodName, aParams, aExpectedResults: RawUTF8): TInterfaceStub; overload;
    /// add an evaluation rule for a given method and a set of parameters
    // - aExpectedResults JSON array will be returned to the caller
    // - raise an Exception if the method name does not exist for this interface
    function Returns(const aMethodName: RawUTF8;
      const aParams, aExpectedResults: array of const): TInterfaceStub; overload;

    /// add an error rule for a given method
    // - an error will be returned to the caller, with aErrorMsg as message
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    // - raise an Exception if the method name does not exist for this interface
    function Fails(const aMethodName, aErrorMsg: RawUTF8): TInterfaceStub; overload;
    /// add an error rule for a given method and a set of parameters
    // - an error will be returned to the caller, with aErrorMsg as message
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    // - raise an Exception if the method name does not exist for this interface
    function Fails(const aMethodName, aParams, aErrorMsg: RawUTF8): TInterfaceStub; overload;
    /// add an error rule for a given method and a set of parameters
    // - an error will be returned to the caller, with aErrorMsg as message
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    // - raise an Exception if the method name does not exist for this interface
    function Fails(const aMethodName: RawUTF8; const aParams: array of const;
      const aErrorMsg: RawUTF8): TInterfaceStub; overload;

    /// add a pass count expectation rule for a given method
    // - those rules will be evaluated at Destroy execution
    // - only qoEqualTo..qoGreaterThanOrEqualTo are relevant here
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    // - raise an Exception if the method name does not exist for this interface
    function ExpectsCount(const aMethodName: RawUTF8; aOperator: TSQLQueryOperator;
      aValue: cardinal): TInterfaceStub; overload;
    /// add a pass count expectation rule for a given method and a set of parameters
    // - those rules will be evaluated at Destroy execution
    // - only qoEqualTo..qoGreaterThanOrEqualTo are relevant here
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    // - raise an Exception if the method name does not exist for this interface
    function ExpectsCount(const aMethodName, aParams: RawUTF8; aOperator: TSQLQueryOperator;
      aValue: cardinal): TInterfaceStub; overload;
    /// add a pass count expectation rule for a given method and a set of parameters
    // - those rules will be evaluated at Destroy execution
    // - only qoEqualTo..qoGreaterThanOrEqualTo are relevant here
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    // - raise an Exception if the method name does not exist for this interface
    function ExpectsCount(const aMethodName: RawUTF8; const aParams: array of const;
      aOperator: TSQLQueryOperator; aValue: cardinal): TInterfaceStub; overload;

    /// add a hash-based execution expectation rule for the whole interface
    // - those rules will be evaluated at Destroy execution
    // - supplied aValue is a Hash32() of the trace in LogAsText format
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    function ExpectsTrace(aValue: cardinal): TInterfaceStub; overload;
    /// add a hash-based execution expectation rule for a given method
    // - those rules will be evaluated at Destroy execution
    // - supplied aValue is a Hash32() of the trace in LogAsText format
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    // - raise an Exception if the method name does not exist for this interface
    function ExpectsTrace(const aMethodName: RawUTF8; aValue: cardinal): TInterfaceStub; overload;
    /// add a hash-based execution expectation rule for a given method
    // and a set of parameters
    // - those rules will be evaluated at Destroy execution
    // - supplied aValue is a Hash32() of the trace in LogAsText format
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    // - raise an Exception if the method name does not exist for this interface
    function ExpectsTrace(const aMethodName, aParams: RawUTF8;
      aValue: cardinal): TInterfaceStub; overload;
    /// add a hash-based execution expectation rule for a given method
    // and a set of parameters
    // - those rules will be evaluated at Destroy execution
    // - supplied aValue is a Hash32() of the trace in LogAsText format
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    // - raise an Exception if the method name does not exist for this interface
    function ExpectsTrace(const aMethodName: RawUTF8; const aParams: array of const;
      aValue: cardinal): TInterfaceStub; overload;

    /// set the optional stubing/mocking options
    // - same as the Options property, but in a fluent-style interface
    function SetOptions(Options: TInterfaceStubOptions): TInterfaceStub;

    /// access to the registered Interface RTTI information
    property InterfaceFactory: TInterfaceFactory read fInterface;
    /// optional stubing/mocking options
    // - you can use the SetOptions() method in a fluent-style interface
    property Options: TInterfaceStubOptions read fOptions write IntSetOptions;
    /// the stubbed method execution trace items
    property Log: TInterfaceStubLogDynArray read fLogs;
    /// the stubbed method execution trace number of items
    property LogCount: Integer read fLogCount;
    /// the stubbed method execution trace converted as text
    // - typical output is a list of calls separated by commas:
    // $ Add(10,20)=[30],Divide(20,0) error "divide by zero"
    property LogAsText: RawUTF8 read GetLogAsText;
    /// the stubbed method execution trace converted as one numerical hash
    // - returns Hash32(LogAsText)
    property LogHash: cardinal read GetLogHash;
  end;

  /// used to mock an interface implementation via expect-run-verify
  // - TInterfaceStub will raise an exception on Fails(), ExpectsCount() or
  // ExpectsTrace() rule activation, but TInterfaceMock will call
  // TSynTestCase.Check() with no exception with such rules, as expected by
  // a mocked interface
  // - this class will follow the expect-run-verify pattern, i.e. expectations
  // are defined before running the test, and verification is performed
  // when the instance is released - use TInterfaceMockSpy if you prefer the
  // more explicit run-verify pattern
  TInterfaceMock = class(TInterfaceStub)
  protected
    fTestCase: TSynTestCase;
    function InternalCheck(aValid: boolean; const aErrorMessage: RawUTF8;
      aExpectationFailed: boolean): boolean; override;
  public
    /// initialize an interface mock from TypeInfo(IMyInterface)
    // - aTestCase.Check() will be called in case of mocking failure
    constructor Create(aInterface: PTypeInfo; out aMockedInterface;
      aTestCase: TSynTestCase); reintroduce; overload;
    /// initialize an interface mock from an interface GUID
    // - aTestCase.Check() will be called in case of mocking failure
    // - you shall have registered the interface by a previous call to
    // TInterfaceFactory.Get(TypeInfo(IMyInterface)) or RegisterInterfaces()
    // - if the supplied TGUID has not been previously registered, raise an Exception
    constructor Create(const aGUID: TGUID; out aMockedInterface;
      aTestCase: TSynTestCase); reintroduce; overload;
    /// initialize an interface mock from an interface name (e.g. 'IMyInterface')
    // - aTestCase.Check() will be called in case of mocking failure
    // - you shall have registered the interface by a previous call to
    // TInterfaceFactory.Get(TypeInfo(IMyInterface)) or RegisterInterfaces()
    // - if the supplied name has not been previously registered, raise an Exception
    constructor Create(const aInterfaceName: RawUTF8; out aMockedInterface;
      aTestCase: TSynTestCase); reintroduce; overload;
    /// the associated test case
    property TestCase: TSynTestCase read fTestCase;
  end;

  /// how TInterfaceMockSpy.Verify() shall generate the calls trace
  TInterfaceMockSpyCheck = (chkName, chkNameParams, chkNameParamsResults);

  /// used to mock an interface implementation via run-verify
  // - this class will implement a so called "test-spy" mocking pattern, i.e.
  // no expectation is to be declared at first, but all calls are internally
  // logged (i.e. it force imoLogMethodCallsAndResults option to be defined),
  // and can afterwards been check via Verify() calls
  TInterfaceMockSpy = class(TInterfaceMock)
  protected
    /// this will set and force imoLogMethodCallsAndResults option as needed
    procedure InternalCreate(out aStubbedInterface); override;
    procedure IntSetOptions(Options: TInterfaceStubOptions); override;
  public
    /// check that a method has been called a specify number of times
    procedure Verify(const aMethodName: RawUTF8;
      aOperator: TSQLQueryOperator=qoGreaterThan; aCount: cardinal=0); overload;
    /// check a method calls count with a set of parameters
    // - parameters shall be defined as a JSON array of values
    procedure Verify(const aMethodName, aParams: RawUTF8;
      aOperator: TSQLQueryOperator=qoGreaterThan; aCount: cardinal=0); overload;
    /// check a method calls count with a set of parameters
    // - parameters shall be defined as a JSON array of values
    procedure Verify(const aMethodName: RawUTF8; const aParams: array of const;
      aOperator: TSQLQueryOperator=qoGreaterThan; aCount: cardinal=0); overload;
    /// check an execution trace for the global interface
    // - text trace format shall follow method calls, e.g.
    // ! Verify('Multiply,Add',chkName);
    // or may include parameters:
    // ! Verify('Multiply(10,30),Add(2,35)',chkNameParams);
    // or include parameters and function results:
    // ! Verify('Multiply(10,30)=[300],Add(2,35)=[37]',chkNameParamsResults);
    procedure Verify(const aTrace: RawUTF8; aScope: TInterfaceMockSpyCheck); overload;
    /// check an execution trace for a specified method
    // - text trace format will follow specified scope, e.g. 
    // ! Verify('Add','(10,30),(2,35)',chkNameParams);
    // or include parameters and function results:
    // ! Verify('Add','(10,30)=[300],(2,35)=[37]',chkNameParamsResults);
    // - if aMethodName does not exists or aScope=chkName, will raise an exception
    procedure Verify(const aMethodName, aTrace: RawUTF8; aScope: TInterfaceMockSpyCheck); overload;
    /// check an execution trace for a specified method and parameters
    // - text trace format shall contain only results, e.g.
    // ! Verify('Add','2,35','[37]');
    procedure Verify(const aMethodName, aParams, aTrace: RawUTF8); overload;
    /// check an execution trace for a specified method and parameters
    // - text trace format shall contain only results, e.g.
    // ! Verify('Add',[2,35],'[37]');
    procedure Verify(const aMethodName: RawUTF8; const aParams: array of const;
      const aTrace: RawUTF8); overload;
  end;

  /// an abstract service provider, as registered in TServiceContainer
  // - each registered interface has its own TServiceFactory instance, available
  // as one TSQLServiceContainer item from TSQLRest.Services property
  // - this will be either implemented by a registered TInterfacedObject on the
  // server, or by a on-the-fly generated fake TInterfacedObject class
  // communicating via JSON on a client
  // - TSQLRestServer will have to register an interface implementation as:
  // ! Server.ServiceRegister(TServiceCalculator,[TypeInfo(ICalculator)],sicShared);
  // - TSQLRestClientURI will have to register an interface remote access as:
  // ! Client.ServiceRegister([TypeInfo(ICalculator)],sicShared));
  // note that the implementation (TServiceCalculator) remain on the server side
  // only: the client only needs the ICalculator interface
  // - then TSQLRestServer and TSQLRestClientURI will both have access to the
  // service, via their Services property, e.g. as:
  // ! if Services.GUID(IID_ICalculator).Get(I) then
  // !   result := I.Add(10,20);
  TServiceFactory = class
  protected
    fInterface: TInterfaceFactory;
    fInterfaceURI: RawUTF8;
    fInterfaceMangledURI: RawUTF8;
    fInstanceCreation: TServiceInstanceImplementation;
    fRest: TSQLRest;
    fSharedInstance: TInterfacedObject;
    fContract: RawUTF8;
    fContractHash: RawUTF8;
    fContractExpected: RawUTF8;
    // per-method execution rights
    fExecution: array of record
      /// the list of denied TSQLAuthGroup ID(s)
      // - used on server side within TSQLRestServer.LaunchService method
      // - bit 0 for client TSQLAuthGroup.ID=1 and so on...
      // - is therefore able to store IDs up to 256
      // - void by default, i.e. no denial = all groups allowed for this method
      Denied: set of 0..255;
      /// execution options for this method (about thread safety or logging)
      Options: TServiceMethodOptions;
    end;
    function GetInterfaceTypeInfo: PTypeInfo; {$ifdef HASINLINE}inline;{$endif}
    function GetInterfaceIID: TGUID; {$ifdef HASINLINE}inline;{$endif}
  public
    /// initialize the service provider parameters
    // - it will check and retrieve all methods of the supplied interface,
    // and prepare all internal structures for its serialized execution
    constructor Create(aRest: TSQLRest; aInterface: PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation;
      const aContractExpected: RawUTF8);
    /// retrieve an instance of this interface
    // - this virtual method will be overriden to reflect the expected
    // behavior of client or server side
    // - can be used as such to resolve an I: ICalculator interface
    // ! if fClient.Services.Info(TypeInfo(ICalculator)).Get(I) then
    // !   ... use I
    function Get(out Obj): Boolean; virtual; abstract;
    /// retrieve the published signature of this interface
    // - is always available on TServiceFactoryServer, but TServiceFactoryClient
    // will be able to retrieve it only if TServiceContainerServer.PublishSignature
    // is set to TRUE (which is not the default setting, for security reasons)
    function RetrieveSignature: RawUTF8; virtual; abstract;
    /// the associated RESTful instance
    property Rest: TSQLRest read fRest;
    /// access to the registered Interface RTTI information
    property InterfaceFactory: TInterfaceFactory read fInterface;
    /// the registered Interface low-level Delphi RTTI type
    // - just maps InterfaceFactory.InterfaceTypeInfo
    property InterfaceTypeInfo: PTypeInfo read GetInterfaceTypeInfo;
    /// the registered Interface GUID
    // - just maps InterfaceFactory.InterfaceIID
    property InterfaceIID: TGUID read GetInterfaceIID;
    /// the registered Interface URI
    // - in fact this is the Interface name without the initial 'I', e.g.
    // 'Calculator' for ICalculator
    property InterfaceURI: RawUTF8 read fInterfaceURI;
    /// the registered Interface mangled URI
    // - in fact this is encoding the GUID using BinToBase64URI(), e.g.
    // ! ['{c9a646d3-9c61-4cb7-bfcd-ee2522c8f633}'] into '00amyWGct0y_ze4lIsj2Mw'
    // - can be substituted to the clear InterfaceURI name
    property InterfaceMangledURI: RawUTF8 read fInterfaceMangledURI;
    /// how each class instance is to be created
    // - only relevant on the server side; on the client side, this class will
    // be accessed only to retrieve a remote access instance, i.e. sicSingle
    property InstanceCreation: TServiceInstanceImplementation read fInstanceCreation;
    (*/ the service contract, serialized as a JSON object
    - a "contract" is in fact the used interface signature, i.e. its
      implementation mode (InstanceCreation) and all its methods definitions
    - a possible value for a one-method interface defined as such:
    ! function ICalculator.Add(n1,n2: integer): integer;
    may be returned as the following JSON object:
    $ {"contract":"Calculator","implementation":"shared",
    $  "methods":[{"method":"Add",
    $  "arguments":[{"argument":"Self","direction":"in","type":"self"},
    $               {"argument":"n1","direction":"in","type":"integer"},
    $               {"argument":"n2","direction":"in","type":"integer"},
    $               {"argument":"Result","direction":"out","type":"integer"}
    $ ]}]} *)
    property Contract: RawUTF8 read fContract;
    /// a hash of the service contract, serialized as a JSON string
    // - this may be used instead of the JSON signature, to enhance security
    // (i.e. if you do not want to publish the available methods, but want
    // to check for the proper synchronization of both client and server)
    // - a possible value may be: "C351335A7406374C"
    property ContractHash: RawUTF8 read fContractHash;
    /// the published service contract, as expected by both client and server
    // - by default, will contain ContractHash property value (for security)
    // - but you can override this value using plain Contract or any custom
    // value (e.g. a custom version number) - in this case, both TServiceFactoryClient
    // and TServiceFactoryServer instances must have a matching ContractExpected
    // - this value is returned by a '_contract_' pseudo-method name, with the URI:
    // $ POST /root/Interface._contract_
    // or (if rmJSON_RPC is used):
    // $ POST /root/Interface
    // $ (...)
    // $ {"method":"_contract_","params":[]}
    // (e.g. to be checked in TServiceFactoryClient.Create constructor)
    property ContractExpected: RawUTF8 read fContractExpected write fContractExpected;
  end;

  /// server-side service provider uses this to store one internal instance
  // - used by TServiceFactoryServer in sicClientDriven, sicPerSession,
  // sicPerUser or sicPerGroup mode
  TServiceFactoryServerInstance = {$ifndef ISDELPHI2010}object{$else}record{$endif}
  public
    /// the internal Instance ID, as remotely sent in "id":1
    // - is set to 0 when an entry in the array is free
    InstanceID: Cardinal;
    /// last time stamp access of this instance
    LastAccess: Cardinal;
    /// the implementation instance itself
    Instance: TInterfacedObject;
    /// used to release the implementation instance
    // - direct FreeAndNil(Instance) may lead to A/V if self has been assigned
    // to an interface to any sub-method on the server side -> dec(RefCount)
    procedure SafeFreeInstance({$ifndef LVCL}ReleaseInMainThread: boolean{$endif});
  end;

  /// server-side service provider uses this to store its internal instances
  // - used by TServiceFactoryServer in sicClientDriven, sicPerSession,
  // sicPerUser or sicPerGroup mode
  TServiceFactoryServerInstanceDynArray = array of TServiceFactoryServerInstance;

  /// abstract parent class with threadsafe implementation of IInterface and
  // a virtual constructor, ready to be overriden to initialize the instance
  // - you can specify such a class to TSQLRestServer.ServiceRegister() if
  // you need an interfaced object with a virtual constructor
  TInterfacedObjectWithCustomCreate = class(TInterfacedObject)
  protected
    /// just a method used to call _Release within a Synchronize() call
    procedure InternalRelease;
  public
    /// this virtual constructor will be called at instance creation
    constructor Create; virtual;
  end;

  TInterfacedObjectWithCustomCreateClass = class of TInterfacedObjectWithCustomCreate;

  /// a service provider implemented on the server side
  // - each registered interface has its own TServiceFactoryServer instance,
  // available as one TSQLServiceContainerServer item from TSQLRest.Services property
  // - will handle the implementation class instances of a given interface
  // - by default, all methods are allowed to execution: you can call AllowAll,
  // DenyAll, Allow or Deny in order to specify your exact security policy
  TServiceFactoryServer = class(TServiceFactory)
  protected
    fInstances: TServiceFactoryServerInstanceDynArray;
    fInstance: TDynArray;
    fInstancesCount: integer;
    fInstanceCurrentID: integer;
    fInstanceTimeOut: cardinal;
    fInstanceLock: TRTLCriticalSection;
    fImplementationClass: TInterfacedClass;
    fImplementationClassWithCustomCreate: Boolean;
    fSharedInterface: IInterface;
    {$ifndef LVCL}
    fImplementationFreeInMainThread: Boolean;
    {$endif}
    /// get an implementation Inst.Instance for the given Inst.InstanceID
    // - is called by ExecuteMethod() in sicClientDrive mode
    // - returns true for successfull {"method":"_free_".. call (aMethodIndex=-1)
    // - otherwise, fill Inst.Instance with the matching implementation (or nil)
    function InternalInstanceRetrieve(var Inst: TServiceFactoryServerInstance;
      aMethodIndex: integer): boolean;
    /// call a given method of this service provider
    // - aMethodIndex is the index in Methods[]
    // - if aMethodIndex=-1, then it will free/release corresponding aInstanceID
    // (is called  e.g. from {"method":"_free_", "params":[], "id":1234} )
    // - aParamsJSONArray is e.g. '[1,2]' i.e. a true JSON array, which will
    // contain the incoming parameters in the same exact order than the
    // corresponding implemented interface method
    // - aInstanceID is an optional number, to be used in case of sicClientDriven
    // kind of InstanceCreation
    // - returns 200/HTML_SUCCESS on success, or an HTTP error status, with an
    // optional error message in aErrorMsg
    // - on success, aResp shall contain a serialized JSON object with one
    // nested result property, which may be a JSON array, containing the
    // all "var" or "out" parameters values, and then the method main result -
    // for instance, ExecuteMethod(..,'[1,2]') over ICalculator.Add will return:
    // $ {"result":[3],"id":0}
    // the returned "id" number is the Instance identifier to be used for any later
    // sicClientDriven remote call - or just 0 in case of sicSingle or sicShared
    procedure ExecuteMethod(var Ctxt: TSQLRestServerCallBackParams;
      aMethodIndex, aInstanceID: cardinal; aParamsJSONArray: PUTF8Char);
    /// this method will create an implementation instance
    // - reference count will be set to one, in order to allow safe passing
    // of the instance into an interface, if AndIncreaseRefCount is TRUE
    function CreateInstance(AndIncreaseRefCount: boolean): TInterfacedObject;
  public
    /// initialize the service provider on the server side
    // - expect an direct server-side implementation class (inheriting from
    // TInterfacedClass or from TInterfacedObjectWithCustomCreate if you need
    // an overriden constructor)
    // - for sicClientDriven, sicPerSession, sicPerUser or sicPerGroup modes,
    // a time out (in seconds) can be defined - if the time out is 0, interface
    // will be forced in sicSingle mode
    // - you should usualy have to call the TSQLRestServer.ServiceRegister()
    // method instead of calling this constructor directly
    constructor Create(aRestServer: TSQLRestServer; aInterface: PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation;
      aImplementationClass: TInterfacedClass; const aContractExpected: RawUTF8='';
      aTimeOutSec: cardinal=30*60); reintroduce;
    /// release all used memory
    // - e.g. any internal TServiceFactoryServerInstance instances (any shared
    // instance, and all still living instances in sicClientDrive mode)
    destructor Destroy; override;

    /// allow all methods execution for all TSQLAuthGroup
    // - all Groups will be affected by this method (on both client and server sides)
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function AllowAll: TServiceFactoryServer;
    /// allow all methods execution for the specified TSQLAuthGroup ID(s)
    // - the specified group ID(s) will be used to authorize remote service
    // calls from the client side
    // - you can retrieve a TSQLAuthGroup ID from its identifier, as such:
    // ! UserGroupID := fServer.MainFieldID(TSQLAuthGroup,'User');
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function AllowAllByID(const aGroupID: array of integer): TServiceFactoryServer;
    /// allow all methods execution for the specified TSQLAuthGroup names
    // - is just a wrapper around the other AllowAllByID() method, retrieving the
    // Group ID from its main field
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function AllowAllByName(const aGroup: array of RawUTF8): TServiceFactoryServer;
    /// deny all methods execution for all TSQLAuthGroup
    // - all Groups will be affected by this method (on both client and server sides)
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function DenyAll: TServiceFactoryServer;
    /// deny all methods execution for the specified TSQLAuthGroup ID(s)
    // - the specified group ID(s) will be used to authorize remote service
    // calls from the client side
    // - you can retrieve a TSQLAuthGroup ID from its identifier, as such:
    // ! UserGroupID := fServer.MainFieldID(TSQLAuthGroup,'User');
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function DenyAllByID(const aGroupID: array of integer): TServiceFactoryServer;
    /// dent all methods execution for the specified TSQLAuthGroup names
    // - is just a wrapper around the other DenyAllByID() method, retrieving the
    // Group ID from its main field
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function DenyAllByName(const aGroup: array of RawUTF8): TServiceFactoryServer;
    /// allow specific methods execution for the all TSQLAuthGroup
    // - methods names should be specified as an array (e.g. ['Add','Multiply'])
    // - all Groups will be affected by this method (on both client and server sides)
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function Allow(const aMethod: array of RawUTF8): TServiceFactoryServer;
    /// allow specific methods execution for the specified TSQLAuthGroup ID(s)
    // - methods names should be specified as an array (e.g. ['Add','Multiply'])
    // - the specified group ID(s) will be used to authorize remote service
    // calls from the client side
    // - you can retrieve a TSQLAuthGroup ID from its identifier, as such:
    // ! UserGroupID := fServer.MainFieldID(TSQLAuthGroup,'User');
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function AllowByID(const aMethod: array of RawUTF8; const aGroupID: array of integer): TServiceFactoryServer;
    /// allow specific methods execution for the specified TSQLAuthGroup name(s)
    // - is just a wrapper around the other AllowByID() method, retrieving the
    // Group ID from its main field
    // - methods names should be specified as an array (e.g. ['Add','Multiply'])
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function AllowByName(const aMethod: array of RawUTF8; const aGroup: array of RawUTF8): TServiceFactoryServer;
    /// deny specific methods execution for the all TSQLAuthGroup
    // - methods names should be specified as an array (e.g. ['Add','Multiply'])
    // - all Groups will be affected by this method (on both client and server sides)
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function Deny(const aMethod: array of RawUTF8): TServiceFactoryServer;
    /// deny specific methods execution for the specified TSQLAuthGroup ID(s)
    // - methods names should be specified as an array (e.g. ['Add','Multiply'])
    // - the specified group ID(s) will be used to unauthorize remote service
    // calls from the client side
    // - you can retrieve a TSQLAuthGroup ID from its identifier, as such:
    // ! UserGroupID := fServer.MainFieldID(TSQLAuthGroup,'User');
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function DenyByID(const aMethod: array of RawUTF8; const aGroupID: array of integer): TServiceFactoryServer; overload;
    /// deny specific methods execution for the specified TSQLAuthGroup name(s)
    // - is just a wrapper around the other DenyByID() method, retrieving the
    // Group ID from its main field
    // - methods names should be specified as an array (e.g. ['Add','Multiply'])
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function DenyByName(const aMethod: array of RawUTF8; const aGroup: array of RawUTF8): TServiceFactoryServer;
    /// define execution options for a given set of methods
    // - methods names should be specified as an array (e.g. ['Add','Multiply'])
    // - if no method name is given (i.e. []), option will be set for all methods 
    // - include optExecInMainThread will force the method(s) to be called within
    // a RunningThread.Synchronize() call - slower, but thread-safe
    // - this method returns self in order to allow direct chaining of setting
    // calls for the service, in a fluent interface
    function SetOptions(const aMethod: array of RawUTF8; aOptions: TServiceMethodOptions): TServiceFactoryServer;

    /// retrieve an instance of this interface from the server side
    // - sicShared mode will retrieve the shared instance
    // - sicPerThread mode will retrieve the instance corresponding to the
    // current running thread
    // - all other kind of instance creation will behave the same as sicSingle
    // when accessed directly from this method, i.e. from server side: in fact,
    // on the server side, there is no notion of client, session, user nor group
    function Get(out Obj): Boolean; override;
    /// retrieve the published signature of this interface
    // - is always available on TServiceFactoryServer, but TServiceFactoryClient
    // will be able to retrieve it only if TServiceContainerServer.PublishSignature
    // is set to TRUE (which is not the default setting, for security reasons)
    function RetrieveSignature: RawUTF8; override;

    /// just typecast the associated TSQLRest instance to a true TSQLRestServer
    function RestServer: TSQLRestServer;
      {$ifdef HASINLINE}inline;{$endif}
  end;

  /// a service provider implemented on the client side
  // - each registered interface has its own TServiceFactoryClient instance,
  // available as one TSQLServiceContainerClient item from TSQLRest.Services property
  // - will emulate "fake" implementation class instance of a given interface
  // and call remotely the server to process the actual implementation
  TServiceFactoryClient = class(TServiceFactory)
  protected
    fClient: TSQLRestClientURI;
    function CreateFakeInstance: TInterfacedObject;
    function InternalInvoke(const aMethod: RawUTF8; const aParams: RawUTF8='';
      aResult: PRawUTF8=nil; aErrorMsg: PRawUTF8=nil; aClientDrivenID: PCardinal=nil;
      aServiceCustomAnswer: PServiceCustomAnswer=nil): boolean; virtual;
    function Invoke(const aMethod: TServiceMethod; const aParams: RawUTF8;
      aResult: PRawUTF8; aErrorMsg: PRawUTF8; aClientDrivenID: PCardinal;
      aServiceCustomAnswer: PServiceCustomAnswer): boolean;
      {$ifdef HASINLINE}inline;{$endif}
    procedure NotifyInstanceDestroyed(aClientDrivenID: cardinal); virtual;
  public
    /// initialize the service provider parameters
    // - it will check and retrieve all methods of the supplied interface,
    // and prepare all internal structures for its serialized execution
    // - also set the inherited TServiceInstanceImplementation property
    // - initialize fSharedInstance if aInstanceCreation is sicShared
    // - it will also ensure that the corresponding TServiceFactory.Contract
    // matches on both client and server sides, either by comparing the default
    // signature (based on methods and arguments), either by using the supplied
    // expected contract (which may be a custom version number)
    constructor Create(aRest: TSQLRest; aInterface: PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation;
      const aContractExpected: RawUTF8='');
    /// finalize the service provider used instance
    // - e.g. the shared fake implementation instance
    destructor Destroy; override;
    /// retrieve an instance of this interface from the server side
    function Get(out Obj): Boolean; override;
    /// retrieve the published signature of this interface
    // - TServiceFactoryClient will be able to retrieve it only if
    // TServiceContainerServer.PublishSignature is set to TRUE (which is not the
    // default setting, for security reasons) - this function is always available
    // on TServiceFactoryServer side
    function RetrieveSignature: RawUTF8; override;
  end;

  /// the routing mode of the service remote request
  // - by default, will use an URI-based layout (rmREST), in which the service
  // will be identified within the URI, as
  // $ /Model/Interface.Method[/ClientDrivenID]
  // e.g. for ICalculator.Add:
  // $ POST /root/Calculator.Add
  // $ (...)
  // $ [1,2]
  // or, for a sicClientDriven mode service:
  // $ POST /root/ComplexNumber.Add/1234
  // $ (...)
  // $ [20,30]
  // in this case, the sent content will be a JSON array of [parameters...]
  // (one benefit of using URI is that it will be more secured in our RESTful
  // authentication scheme: each method and even client driven session will
  // be signed properly)
  // - if rmJSON_RPC is used, the URI will define the interface, then the
  // method name will be inlined with parameters, e.g.
  // $ POST /root/Calculator
  // $ (...)
  // $ {"method":"Add","params":[1,2]}
  // or, for a sicClientDriven mode service:
  // $ POST /root/ComplexNumber
  // $ (...)
  // $ {"method":"Add","params":[20,30],"id":1234}
  TServiceRoutingMode = (rmREST, rmJSON_RPC);

  /// a global services provider class
  // - used to maintain a list of interfaces implementation
  TServiceContainer = class
  protected
    fRest: TSQLRest;
    fList: TRawUTF8ListHashed;
    fListInterfaceMethod: TRawUTF8ListHashed;
    fExpectMangledURI: boolean;
    procedure SetExpectMangledURI(aValue: Boolean);
    procedure CheckInterface(const aInterfaces: array of PTypeInfo);
    function AddServiceInternal(aService: TServiceFactory): integer;
    /// retrieve a service provider from its URI
    function GetService(const aURI: RawUTF8): TServiceFactory;
  public
    /// initialize the list
    constructor Create(aRest: TSQLRest);
    /// release all registered services
    destructor Destroy; override;
    /// return the number of registered service interfaces
    function Count: integer;
    /// method called on the client side to register a service via its interface(s)
    // - will add a TServiceFactoryClient instance to the internal list
    // - is called e.g. by TSQLRestClientURI.ServiceRegister or even by
    // TSQLRestServer.ServiceRegister(aClient: TSQLRest...) for a remote access -
    // use TServiceContainerServer.AddImplementation() instead for normal
    // server side implementation
    // - will raise an exception on error
    // - will return true if some interfaces have been added
    // - will check for the availability of the interfaces on the server side,
    // with an optional custom contract to be used instead of methods signature
    // (only for the first interface)
    function AddInterface(const aInterfaces: array of PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation;
      aContractExpected: RawUTF8=''): boolean; overload;
    /// method called on the client side to register a service via one interface
    // - overloaded method returning the corresponding service factory client,
    // or nil on error
    function AddInterface(aInterface: PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation;
      const aContractExpected: RawUTF8=''): TServiceFactoryClient; overload;
    /// retrieve a service provider from its index in the list
    // - returns nil if out of range index
    function Index(aIndex: integer): TServiceFactory; overload; {$ifdef HASINLINE}inline;{$endif}
    /// retrieve a service provider from its GUID
    // - on match, it  will return the service the corresponding interface factory
    // - returns nil if the GUID does not match any registered interface
    // - can be used as such to resolve an I: ICalculator interface
    // ! if fClient.Services.GUID(IID_ICalculator).Get(I) then
    // !   ... use I
    function GUID(const aGUID: TGUID): TServiceFactory; overload;
    /// retrieve a service provider from its type information
    // - on match, it  will return the service the corresponding interface factory
    // - returns nil if the type information does not match any registered interface
    // - can be used as such to resolve an I: ICalculator interface
    // ! if fClient.Services.Info(TypeInfo(ICalculator)).Get(I) then
    // !   ... use I
    function Info(aTypeInfo: PTypeInfo): TServiceFactory; overload; virtual;
    /// retrieve a service provider from its URI
    // - it expects the supplied URI variable  to be e.g. '00amyWGct0y_ze4lIsj2Mw'
    // or 'Calculator', depending on the ExpectMangledURI property
    // - on match, it  will return the service the corresponding interface factory
    // - returns nil if the URI does not match any registered interface
    property Services[const aURI: RawUTF8]: TServiceFactory read GetService; default;
    /// the associated RESTful instance
    property Rest: TSQLRest read fRest;
    /// set if the URI is expected to be mangled from the GUID
    // - by default (FALSE), the clear service name is expected to be supplied at
    // the URI level (e.g. 'Calculator')
    // - if this property is set to TRUE, the mangled URI value will be expected
    // instead (may enhance security) - e.g. '00amyWGct0y_ze4lIsj2Mw'
    property ExpectMangledURI: boolean read fExpectMangledURI write SetExpectMangledURI;
  end;

  /// a services provider class to be used on the server side
  // - this will maintain a list of true implementation classes
  TServiceContainerServer = class(TServiceContainer)
  protected
    fPublishSignature: boolean;
    /// make some garbage collection when session is finished
    procedure OnCloseSession(aSessionID: cardinal); virtual;
  public
    /// method called on the server side to register a service via its
    // interface(s) and a specified implementation class
    // - will add a TServiceFactoryServer instance to the internal list
    // - will raise an exception on error
    // - will return the first of the registered TServiceFactoryServer created
    // on success (i.e. the one corresponding to the first item of the aInterfaces
    // array), or nil if registration failed (e.g. if any of the supplied interfaces
    // is not implemented by the given class)
    // - the same implementation class can be used to handle several interfaces
    // (just as Delphi allows to do natively)
    function AddImplementation(aImplementationClass: TInterfacedClass;
      const aInterfaces: array of PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation): TServiceFactoryServer;
    /// defines if the "method":"_signature_" or /root/Interface._signature
    // pseudo method is available to retrieve the whole interface signature,
    // encoded as a JSON object
    // - is set to FALSE by default, for security reasons: only "_contract_"
    // pseudo method is available - see TServiceContainer.ContractExpected
    property PublishSignature: boolean read fPublishSignature write fPublishSignature;
  end;

  /// a services provider class to be used on the client side
  // - this will maintain a list of fake implementation classes, which will
  // remotely call the server to make the actual process
  TServiceContainerClient = class(TServiceContainer)
  protected
  public
    /// retrieve a service provider from its type information
    // - this overriden method will register the interface, if was not yet made
    // - in this case, the interface will be registered with sicClientDriven
    // implementation method
    function Info(aTypeInfo: PTypeInfo): TServiceFactory; overload; override;
  end;

  /// for TSQLRestCache, stores a table values
  TSQLRestCacheEntryValue = record
    /// corresponding ID
    ID: integer;
    /// GetTickCount value when this cached value was stored
    // - equals 0 licwhen there is no JSON value cached
    TimeStamp: cardinal; 
    /// JSON encoded UTF-8 serialization of the record
    JSON: RawUTF8;
  end;

  /// for TSQLRestCache, stores all tables values
  TSQLRestCacheEntryValueDynArray = array of TSQLRestCacheEntryValue;

  /// for TSQLRestCache, stores a table settings and values
  TSQLRestCacheEntry = {$ifndef UNICODE}object{$else}record{$endif}
  public
    /// TRUE if this table should use caching
    // - i.e. if was not set, or worth it for this table (e.g. in-memory table)
    CacheEnable: boolean;
    /// the whole specified Table content will be cached
    CacheAll: boolean;
    /// time out value (in ms)
    // - if 0, caching will never expire
    TimeOut: Cardinal;
    /// the number of entries stored in Values[]
    Count: integer;
    /// all cached IDs and JSON content
    Values: TSQLRestCacheEntryValueDynArray;
    /// TDynArray wrapper around the Values[] array
    Value: TDynArray;
    /// used to lock the table cache for multi thread safety
    Mutex: TRTLCriticalSection;
    /// flush cache for a given Value[] index
    procedure FlushCacheEntry(Index: Integer);
    /// flush cache for all Value[]
    procedure FlushCacheAllEntries;
    /// update/refresh the cached JSON serialization of a given ID 
    procedure SetJSON(aID: integer; const aJSON: RawUTF8); overload;
    /// update/refresh the cached JSON serialization of a supplied Record
    procedure SetJSON(aRecord: TSQLRecord); overload;
    /// retrieve a JSON serialization of a given ID from cache
    function RetrieveJSON(aID: integer; var aJSON: RawUTF8): boolean; overload;
    /// unserialize a JSON cached record of a given ID
    function RetrieveJSON(aID: integer; aValue: TSQLRecord): boolean; overload;
  end;

  {/ implement a fast cache content at the TSQLRest level
   - purpose of this caching mechanism is to speed up retrieval of some common
     values at either Client or Server level (like configuration settings)
   - only caching synchronization is about the following RESTful basic commands:
     RETRIEVE, ADD, DELETION and UPDATE (that is, a complex direct SQL UPDATE
     or via TSQLRecordMany pattern won't be taken in account)
   - only Simple fields are cached: e.g. the BLOB fields are not stored
   - this cache is thread-safe (access is locked per table)
   - this caching will be located at the TSQLRest level, that is no automated
     synchronization is implemented between TSQLRestClient and TSQLRestServer:
     you shall ensure that your code won't fail due to this restriction }
  TSQLRestCache = class(TObject)
  protected
    fRest: TSQLRest;
    /// fCache[] follows fModel.Tables[] array
    fCache: array of TSQLRestCacheEntry;
    /// retrieve a record specified by its ID from cache into JSON content
    // - return '' if the item is not in cache
    function Retrieve(aTableIndex, aID: integer): RawUTF8; overload;
    /// fill a record specified by its ID from cache into a new TSQLRecord instance
    // - return false if the item is not in cache
    // - this method will call RetrieveJSON method, unserializing the cached
    // JSON content into the supplied aValue instance
    function Retrieve(aID: Integer; aValue: TSQLRecord): boolean; overload;
  public
    /// create a cache instance
    // - the associated TSQLModel will be used internaly
    constructor Create(aRest: TSQLRest); reintroduce;
    /// release the cache instance
    destructor Destroy; override;
    /// flush the cache
    // - this will flush all stored JSON content, but keep the settings
    // (SetCache/SetTimeOut) as before
    procedure Flush; overload; 
    /// flush the cache for a given table
    // - this will flush all stored JSON content, but keep the settings
    // (SetCache/SetTimeOut) as before for this table
    procedure Flush(aTable: TSQLRecordClass); overload; 
    /// flush the cache for a given record
    // - this will flush the stored JSON content for this record (and table
    // settings will be kept)
    procedure Flush(aTable: TSQLRecordClass; aID: integer); overload;
    /// flush the cache, and destroy all settings
    // - this will flush all stored JSON content, AND destroy the settings
    // (SetCache/SetTimeOut) to default (i.e. no cache enabled)
    procedure Clear;
    {/ activate the internal caching for a whole Table
     - any cached item of this table will be flushed
     - return true on success }
    function SetCache(aTable: TSQLRecordClass): boolean; overload;
     {/ activate the internal caching for a given TSQLRecord
     - if this item is already cached, do nothing
     - return true on success }
    function SetCache(aTable: TSQLRecordClass; aID: Integer): boolean; overload;
     {/ activate the internal caching for a given TSQLRecord
     - will cache the specified aRecord.ID item
     - if this item is already cached, do nothing
     - return true on success }
    function SetCache(aRecord: TSQLRecord): boolean; overload;
    {/ set the internal caching time out delay (in ms) for a given table
     - time out setting is common to all items of the table
     - if aTimeOut is left to its default 0 value, caching will never expire
     - return true on success }
    function SetTimeOut(aTable: TSQLRecordClass; aTimeout: Integer): boolean;
    /// returns the number of JSON serialization records within this cache
    function CachedEntries: cardinal;
    /// returns the memory used by JSON serialization records within this cache
    function CachedMemory: cardinal;
    /// read-only access to the associated TSQLRest instance
    property Rest: TSQLRest read fRest;
  public { TSQLRest low level methods which are not to be called usualy: } 
    /// TSQLRest instance shall call this method when a record is added or updated
    // - this overloaded method expects the content to be specified as JSON object
    procedure Notify(aTable: TSQLRecordClass; aID: integer; const aJSON: RawUTF8;
     aAction: TSQLOccasion); overload;
    /// TSQLRest instance shall call this method when a record is retrieved,
    // added or updated
    // - this overloaded method expects the content to be specified as JSON object,
    // and TSQLRecordClass to be specified as its index in Rest.Model.Tables[]
    procedure Notify(aTableIndex: integer; aID: integer; const aJSON: RawUTF8;
      aAction: TSQLOccasion); overload;
    /// TSQLRest instance shall call this method when a record is added or updated
    // - this overloaded method will call the other Trace method, serializing
    // the supplied aRecord content as JSON (not in the case of seDelete)
    procedure Notify(aRecord: TSQLRecord; aAction: TSQLOccasion); overload;
    /// TSQLRest instance shall call this method when a record is deleted
    // - this method is dedicated for a record deletion
    procedure NotifyDeletion(aTable: TSQLRecordClass; aID: integer); overload;
    /// TSQLRest instance shall call this method when a record is deleted
    // - this method is dedicated for a record deletion
    // - TSQLRecordClass to be specified as its index in Rest.Model.Tables[]
    procedure NotifyDeletion(aTableIndex, aID: integer); overload;
  end;

  TSQLRestClass = class of TSQLRest;

  /// a generic REpresentational State Transfer (REST) client/server class
  TSQLRest = class
  protected
    fModel: TSQLModel;
    fCache: TSQLRestCache;
    fTransactionActive: cardinal;
    fTransactionTable: TSQLRecordClass;
    fTransactionCriticalSession: TRTLCriticalSection;
    fAcquireWriteTimeOut: cardinal;
    fServerTimeStampOffset: TDateTime;
    fServerTimeStampCacheTix: cardinal;
    fServerTimeStampCacheValue: Iso8601;
    fServices: TServiceContainer;
    fRouting: TServiceRoutingMode;
    /// retrieve a list of members as JSON encoded data - used by OneFieldValue()
    // and MultiFieldValue() public functions below
    // - overriden in TSQLRestClientURI and TSQLRestServer with proper method
    function InternalListJSON(Table: TSQLRecordClass; const SQL: RawUTF8): TSQLTableJSON;
      overload; virtual; abstract;
    /// retrieve a list of members as JSON encoded data - used by OneFieldValue()
    // and MultiFieldValue() public functions below
    // - call virtual abstract InternalListJSON() method to get the list content
    // - FieldName can be a CSV list of needed field names, if needed
    function InternalListJSON(Table: TSQLRecordClass; const FieldName, WhereClause: RawUTF8): TSQLTableJSON; overload;
    /// retrieve all fields for a list of members JSON encoded data
    // - this special method gets all fields content for a specified table:
    // the resulting TSQLTableJSON content can be used to fill whole records
    // instances by using the TSQLRecord.FillPrepare() and TSQLRecord.FillRow()
    // methods
    // - call virtual abstract InternalListJSON() method to get the list content
    function InternalListRecordsJSON(Table: TSQLRecordClass; const WhereClause: RawUTF8): TSQLTableJSON;
    /// override this method to guess if this record can be updated or deleted
    // - this default implementation returns always true
    // - e.g. you can add digital signature to a record to disallow record editing
    // - the ErrorMsg can be set to a variable, which will contain an explicit
    // error message
    function RecordCanBeUpdated(Table: TSQLRecordClass; ID: integer; Action: TSQLEvent;
      ErrorMsg: PRawUTF8 = nil): boolean; virtual;
    /// internal method used by Delete(Table,SQLWhere) method
    function InternalDelete(Table: TSQLRecordClass; const SQLWhere: RawUTF8;
      var IDs: TIntegerDynArray): boolean; 
    /// wait for the transaction critical section to be acquired
    // - used to implement a thread-safe and transaction-safe write to the DB
    // - returns FALSE in case of time out (see AcquireWriteTimeOut property)
    // - returns TRUE if it's safe to write to the DB - in this case, you must
    // call ReleaseWrite when done to release the fTransactionCriticalSession
    function AcquireWrite(const aContext: TSQLRestServerCallBackParams): Boolean;
    /// release the fTransactionCriticalSession
    procedure ReleaseWrite;
    /// retrieve the server time stamp
    // - default implementation will use fServerTimeStampOffset to compute
    // the value from PC time (i.e. Now+fServerTimeStampOffset as TTimeLog)
    // - inherited classes may override this method, or set the appropriate
    // value in fServerTimeStampOffset protected field
    function GetServerTimeStamp: TTimeLog; virtual;
    /// compute the server time stamp offset from the given
    procedure SetServerTimeStamp(const Value: TTimeLog);
    /// handle Client or Server side fast in-memory cache
    // - creates the internal fCache instance, if necessary
    function GetCache: TSQLRestCache;
    /// returns TRUE if this table is worth caching (e.g. not in memory)
    // - this default implementation always returns TRUE (always allow cache)
    function CacheWorthItForTable(aTableIndex: cardinal): boolean; virtual;
 protected // these abstract methods must be inherited by real database engine
    /// retrieve a list of members as JSON encoded data (implements REST GET Collection)
    // - returns '' on error, or JSON data, even with no result rows
    // - override this method for direct data retrieval from the database engine
    // and direct JSON export, avoiding a TSQLTable which allocates memory for every
    // field values before the JSON export
    // - can be called for a single Table (ModelRoot/Table), or with low level SQL
    // query (ModelRoot + SQL sent as request body)
    // - if ReturnedRowCount points to an integer variable, it must be filled with
    // the number of row data returned (excluding field names)
    // - this method must be implemented in a thread-safe manner
    function EngineList(const SQL: RawUTF8; ForceAJAX: Boolean=false; ReturnedRowCount: PPtrInt=nil): RawUTF8; virtual; abstract;
    /// create a new member (implements REST POST Collection)
    // - SentData can contain the JSON object with field values to be added
    // - class is taken from Model.Tables[TableModelIndex]
    // - returns the TSQLRecord ID/ROWID value, 0 on error
    // - is a "RowID":.. or "ID":.. member is set in SentData, it shall force its
    // value as insertion ID
    // - override this method for proper calling the database engine
    // - this method must be implemented in a thread-safe manner
    function EngineAdd(Table: TSQLRecordClass; const SentData: RawUTF8): integer; virtual; abstract;
    /// update a member (implements REST PUT Member)
    // - SentData can contain the JSON object with field values to be added
    // - returns true on success
    // - override this method for proper calling the database engine
    // - this method must be implemented in a thread-safe manner
    function EngineUpdate(Table: TSQLRecordClass; ID: integer; const SentData: RawUTF8): boolean; virtual; abstract;
    /// delete a member (implements REST DELETE Member)
    // - returns true on success
    // - override this method for proper calling the database engine
    // - this method must be implemented in a thread-safe manner
    function EngineDelete(Table: TSQLRecordClass; ID: integer): boolean; virtual; abstract;
    /// delete several members, from a WHERE clause
    // - IDs[] contains the already-computed matching IDs for SQLWhere
    // - returns true on success
    // - override this method for proper calling the database engine, i.e.
    // using either IDs[] or a faster SQL statement
    // - this method must be implemented in a thread-safe manner
    function EngineDeleteWhere(Table: TSQLRecordClass; const SQLWhere: RawUTF8;
      const IDs: TIntegerDynArray): boolean; virtual; abstract;
    /// get a blob field content from its member ID and field name
    // - implements REST GET member with a supplied blob field name
    // - returns TRUE on success
    // - returns the data of this blob as raw binary (not JSON) in BlobData
    // - override this method for proper data retrieval from the database engine
    // - this method must be implemented in a thread-safe manner
    function EngineRetrieveBlob(Table: TSQLRecordClass; aID: integer;
      BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean; virtual; abstract;
    /// update a blob field content from its member ID and field name
    // - implements REST PUT member with a supplied blob field name
    // - returns TRUE on success
    // - the data of this blob must be specified as raw binary (not JSON) in BlobData
    // - override this method for proper data retrieval from the database engine
    // - this method must be implemented in a thread-safe manner
    function EngineUpdateBlob(Table: TSQLRecordClass; aID: integer;
      BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean; virtual; abstract;
    /// update an individual record field value from a specified ID or Value
    // - return true on success
    // - will allow execution of requests like
    // $ UPDATE tablename SET setfieldname=setvalue WHERE wherefieldname=wherevalue
    // - SetValue and WhereValue parameters must match our inline format, i.e.
    // by double quoted with " for strings, or be plain text for numbers - e.g.
    // $ Client.EngineUpdateField(TSQLMyRecord,'FirstName','"Smith"','RowID','10')
    // - this method must be implemented in a thread-safe manner
    function EngineUpdateField(Table: TSQLRecordClass;
      const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean; virtual; abstract;
  public
    /// initialize the class, and associate it to a specified database Model
    constructor Create(aModel: TSQLModel); virtual;
    /// release internal used instances
    // - e.g. release associated TSQLModel or TServiceContainer
    destructor Destroy; override;
    /// the Database Model associated with this REST Client or Server
    property Model: TSQLModel read fModel;
  public
    /// get the row count of a specified table
    // - return -1 on error
    // - return the row count of the table on success
    // - calls internaly the "SELECT Count(*) FROM TableName;" SQL statement
    function TableRowCount(Table: TSQLRecordClass): integer; virtual;
    /// check if there is some data rows in a specified table
    // - calls internaly a "SELECT RowID FROM TableName LIMIT 1" SQL statement,
    // which is much faster than testing if "SELECT count(*)" equals 0 - see
    // @http://stackoverflow.com/questions/8988915
    function TableHasRows(Table: TSQLRecordClass): boolean; virtual;
    /// get the UTF-8 encoded value of an unique field with a Where Clause
    // - example of use - including inlined parameters via :(...):
    // ! aClient.OneFieldValue(TSQLRecord,'Name','ID=:(23):')
    // you should better call the corresponding overloaded method as such:
    // ! aClient.OneFieldValue(TSQLRecord,'Name','ID=?',[aID])
    // which is the same as calling:
    // ! aClient.OneFieldValue(TSQLRecord,'Name',FormatUTF8('ID=?',[],[23]))
    // - call internaly InternalListJSON() to get the value
    function OneFieldValue(Table: TSQLRecordClass;
      const FieldName, WhereClause: RawUTF8): RawUTF8; overload;
    /// get the UTF-8 encoded value of an unique field with a Where Clause
    // - this overloaded function will call FormatUTF8 to create the Where Clause
    // from supplied parameters, binding all '?' chars with Args[] values
    // - example of use:
    // ! aClient.OneFieldValue(TSQLRecord,'Name','ID=?',[aID])
    // - call internaly InternalListJSON() to get the value
    // - note that this method prototype changed with revision 1.17 of the
    // framework: array of const used to be Args and '%' in the FormatSQLWhere
    // statement, whereas it now expects bound parameters as '?'
    function OneFieldValue(Table: TSQLRecordClass; const FieldName: RawUTF8;
      FormatSQLWhere: PUTF8Char; const BoundsSQLWhere: array of const): RawUTF8; overload;
    /// get the UTF-8 encoded value of an unique field with a Where Clause
    // - this overloaded function will call FormatUTF8 to create the Where Clause
    // from supplied parameters, replacing all '%' chars with Args[], and all '?'
    // chars with Bounds[] (inlining them with :(...): and auto-quoting strings)
    // - example of use:
    // ! OneFieldValue(TSQLRecord,'Name','%=?',['ID'],[aID])
    // - call internaly InternalListJSON() to get the value
    function OneFieldValue(Table: TSQLRecordClass; const FieldName: RawUTF8;
      WhereClauseFmt: PUTF8Char; const Args, Bounds: array of const): RawUTF8; overload;
    /// get the UTF-8 encoded value of an unique field from its ID
    // - example of use: OneFieldValue(TSQLRecord,'Name',23)
    // - call internaly InternalListJSON() to get the value
    function OneFieldValue(Table: TSQLRecordClass;
      const FieldName: RawUTF8; WhereID: integer): RawUTF8; overload;
    /// get the UTF-8 encoded value of some fields with a Where Clause
    // - example of use: MultiFieldValue(TSQLRecord,['Name'],Name,'ID=:(23):')
    // (using inlined parameters via :(...): is always a good idea)
    // - FieldValue[] will have the same length as FieldName[]
    // - return true on success, false on SQL error or no result
    // - call internaly InternalListJSON() to get the list
    function MultiFieldValue(Table: TSQLRecordClass;
      const FieldName: array of RawUTF8; var FieldValue: array of RawUTF8;
      const WhereClause: RawUTF8): boolean; overload;
    /// get the UTF-8 encoded value of some fields from its ID
    // - example of use: MultiFieldValue(TSQLRecord,['Name'],Name,23)
    // - FieldValue[] will have the same length as FieldName[]
    // - return true on success, false on SQL error or no result
    // - call internaly InternalListJSON() to get the list
    function MultiFieldValue(Table: TSQLRecordClass;
      const FieldName: array of RawUTF8; var FieldValue: array of RawUTF8;
      WhereID: integer): boolean; overload;
    /// get the UTF-8 encoded values of an unique field with a Where Clause
    // - example of use: OneFieldValue(TSQLRecord,'FirstName','Name=:("Smith"):',Data)
    // (using inlined parameters via :(...): is always a good idea)
    // - leave WhereClause void to get all records
    // - call internaly InternalListJSON() to get the list
    // - returns TRUE on success, FALSE if no data was retrieved
    function OneFieldValues(Table: TSQLRecordClass; const FieldName: RawUTF8;
      const WhereClause: RawUTF8; var Data: TRawUTF8DynArray): boolean; overload;
    /// get the integer value of an unique field with a Where Clause
    // - example of use: OneFieldValue(TSQLRecordPeople,'ID','Name=:("Smith"):',Data)
    // (using inlined parameters via :(...): is always a good idea)
    // - leave WhereClause void to get all records
    // - call internaly InternalListJSON() to get the list
    function OneFieldValues(Table: TSQLRecordClass; const FieldName: RawUTF8;
      const WhereClause: RawUTF8; var Data: TIntegerDynArray): boolean; overload;
    /// dedicated method used to retrieve free-text matching DocIDs
    // - this method will work for both TSQLRecordFTS3 and TSQLRecordFTS4
    // - this method expects the column/field names to be supplied in the MATCH
    // statement clause
    // - example of use:  FTSMatch(TSQLMessage,'Body MATCH :("linu*"):',IntResult)
    // (using inlined parameters via :(...): is always a good idea)
    function FTSMatch(Table: TSQLRecordFTS3Class; const WhereClause: RawUTF8;
      var DocID: TIntegerDynArray): boolean; overload;
    /// dedicated method used to retrieve free-text matching DocIDs with
    // enhanced ranking information
    // - this method will work for both TSQLRecordFTS3 and TSQLRecordFTS4
    // - this method will search in all FTS3 columns, and except some floating-point
    // constants for weigthing each column (there must be the same number of
    // PerFieldWeight parameters as there are columns in the TSQLRecordFTS3 table)
    // - example of use:  FTSMatch(TSQLDocuments,'"linu*"',IntResult,[1,0.5])
    // which will sort the results by the rank obtained with the 1st column/field
    // beeing given twice the weighting of those in the 2nd (and last) column
    // - FTSMatch(TSQLDocuments,'linu*',IntResult,[1,0.5]) will perform a
    // SQL query as such, which is the fastest way of ranking according to
    // http://www.sqlite.org/fts3.html#appendix_a
    // $ SELECT RowID FROM Documents WHERE Documents MATCH 'linu*'
    // $ ORDER BY rank(matchinfo(Documents),1.0,0.5) DESC
    function FTSMatch(Table: TSQLRecordFTS3Class; const MatchClause: RawUTF8;
      var DocID: TIntegerDynArray; const PerFieldWeight: array of double): boolean; overload;
    /// get the CSV-encoded UTF-8 encoded values of an unique field with a Where Clause
    // - example of use: OneFieldValue(TSQLRecord,'FirstName','Name=:("Smith")',Data)
    // (using inlined parameters via :(...): is always a good idea)
    // - leave WhereClause void to get all records
    // - call internaly InternalListJSON() to get the list
    // - using inlined parameters via :(...): in WhereClause is always a good idea
    function OneFieldValues(Table: TSQLRecordClass; const FieldName: RawUTF8;
      const WhereClause: RawUTF8=''; const Separator: RawUTF8=','): RawUTF8; overload;
    /// get the string-encoded values of an unique field into some TStrings
    // - Items[] will be filled with string-encoded values of the given field)
    // - Objects[] will be filled with pointer(ID)
    // - call internaly InternalListJSON() to get the list
    // - returns TRUE on success, FALSE if no data was retrieved
    // - if IDToIndex is set, its value will be replaced with the index in
    // Strings.Objects[] where ID=IDToIndex^
    // - using inlined parameters via :(...): in WhereClause is always a good idea
    function OneFieldValues(Table: TSQLRecordClass;
      const FieldName, WhereClause: RawUTF8; Strings: TStrings;
      IDToIndex: PInteger=nil): Boolean; overload;
    /// Execute directly a SQL statement, expecting a list of resutls
    // - return a result table on success, nil on failure
    // - if FieldNames='', all simple fields content is retrieved
    // - call internaly InternalListJSON() to get the list
    // - using inlined parameters via :(...): in WhereClause is always a good idea
    function MultiFieldValues(Table: TSQLRecordClass; FieldNames: RawUTF8;
       const WhereClause: RawUTF8=''): TSQLTableJSON; overload; virtual;
    /// Execute directly a SQL statement, expecting a list of resutls
    // - return a result table on success, nil on failure
    // - if FieldNames='', all simple fields content is retrieved
    // - this overloaded function will call FormatUTF8 to create the Where Clause
    // from supplied parameters, binding all '?' chars with Args[] values
    // - example of use:
    // ! aList := aClient.MultiFieldValues(TSQLRecord,'Name,FirstName','Salary>=?',[aMinSalary]);
    // - call internaly MultiFieldValues() to get the list
    // - note that this method prototype changed with revision 1.17 of the
    // framework: array of const used to be Args and '%' in the WhereClauseFormat
    // statement, whereas it now expects bound parameters as '?'
    function MultiFieldValues(Table: TSQLRecordClass; const FieldNames: RawUTF8;
      WhereClauseFormat: PUTF8Char; const BoundsSQLWhere: array of const): TSQLTableJSON; overload;
    /// Execute directly a SQL statement, expecting a list of resutls
    // - return a result table on success, nil on failure
    // - if FieldNames='', all simple fields content is retrieved
    // - in this version, the WHERE clause can be created with the same format
    // as FormatUTF8() function, replacing all '%' chars with Args[], and all '?'
    // chars with Bounds[] (inlining them with :(...): and auto-quoting strings)
    // - example of use:
    // ! Table := MultiFieldValues(TSQLRecord,'Name','%=?',['ID'],[aID]);
    // - call internaly MultiFieldValues() to get the list
    function MultiFieldValues(Table: TSQLRecordClass; const FieldNames: RawUTF8;
      WhereClauseFormat: PUTF8Char; const Args, Bounds: array of const): TSQLTableJSON; overload;
    /// retrieve the main field (mostly 'Name') value of the specified record
    // - use GetMainFieldName() method to get the main field name
    // - use OneFieldValue() method to get the field value
    // - return '' if no such field or record exists
    // - if ReturnFirstIfNoUnique is TRUE and no unique property is found,
    //   the first RawUTF8 property is returned anyway
    function MainFieldValue(Table: TSQLRecordClass; ID: Integer;
      ReturnFirstIfNoUnique: boolean=false): RawUTF8;
    {/ return the ID of the record which main field match the specified value
      - search field is mainly the "Name" property, i.e. the one with
        "stored AS_UNIQUE" (i.e. "stored false") definition on most TSQLRecord
      - returns 0 if no matching record was found }
    function MainFieldID(Table: TSQLRecordClass; const Value: RawUTF8): integer;
    {/ return the IDs of the record which main field match the specified values
      - search field is mainly the "Name" property, i.e. the one with
        "stored AS_UNIQUE" (i.e. "stored false") definition on most TSQLRecord
      - if any of the Values[] is not existing, then no ID will appear in the
        IDs[] array - e.g. it will return [] if no matching record was found
      - returns TRUE if any matching ID was found (i.e. if length(IDs)>0) }
    function MainFieldIDs(Table: TSQLRecordClass; const Values: array of RawUTF8;
      var IDs: TIntegerDynArray): boolean;
  public // here are REST basic direct calls (works with Server or Client)
    /// get a member from a SQL statement (implements REST GET member)
    // - return true on success
    // - Execute 'SELECT * FROM TableName WHERE SQLWhere LIMIT 1' SQL Statememt
    // (using inlined parameters via :(...): in SQLWhere is always a good idea)
    // - since no record is specified, locking is pointless here
    // - default implementation call InternalListJSON(), and fill Value from a
    // temporary TSQLTable
    // - the TSQLRawBlob (BLOB) fields are not retrieved by this method, to
    // preserve bandwidth: use the RetrieveBlob() methods for handling
    // BLOB fields, or set globaly the TSQLRestClientURI.ForceBlobTransfert
    // property to TRUE
    // - the TSQLRecordMany fields are not retrieved either: they are separate
    // instances created by TSQLRecordMany.Create, with dedicated methods to
    // access to the separated pivot table
    function Retrieve(const SQLWhere: RawUTF8; Value: TSQLRecord): boolean; overload; virtual;
    /// get a member from a SQL statement (implements REST GET member)
    // - return true on success
    // - same as Retrieve(const SQLWhere: RawUTF8; Value: TSQLRecord) method, but
    // this overloaded function will call FormatUTF8 to create the Where Clause
    // from supplied parameters, replacing all '%' chars with Args[], and all '?'
    // chars with Bounds[] (inlining them with :(...): and auto-quoting strings)
    function Retrieve(WhereClauseFmt: PUTF8Char; const Args,Bounds: array of const;
      Value: TSQLRecord): boolean; overload;
    /// get a member from its ID
    // - return true on success
    // - Execute 'SELECT * FROM TableName WHERE ID=:(aID): LIMIT 1' SQL Statememt
    // - if ForUpdate is true, the REST method is LOCK and not GET: it tries to lock
    // the corresponding record, then retrieve its content; caller has to call
    // UnLock() method after Value usage, to release the record
    // - this method is defined as abstract, i.e. there is no default implementation -
    // it must be implemented 100% RestFul with a GET ModelRoot/TableName/ID
    // and handle the LOCK command if necessary: real RESTful class
    // should implement a GET member from URI in an overriden method
    // - the TSQLRawBlob (BLOB) fields are not retrieved by this method, to
    // preserve bandwidth:
    // use the RetrieveBlob() methods for handling BLOB fields, or set globaly
    // the TSQLRestClientURI.ForceBlobTransfert property to TRUE (that is, by
    // default "Lazy loading" is enabled, but can be disabled on purpose)
    // - the TSQLRecordMany fields are not retrieved either: they are separate
    // instances created by TSQLRecordMany.Create, with dedicated methods to
    // access to the separated pivot table
   function Retrieve(aID: integer; Value: TSQLRecord;
      ForUpdate: boolean=false): boolean; overload; virtual; abstract;
    /// get a member from its TRecordReference property content
    // - instead of the other Retrieve() methods, this implementation Create an
    // instance, with the appropriated class stored in Reference
    // - returns nil on any error (invalid Reference e.g.)
    // - if ForUpdate is true, the REST method is LOCK and not GET: it tries to lock
    // the corresponding record, then retrieve its content; caller has to call
    // UnLock() method after Value usage, to release the record
    // - the TSQLRawBlob(BLOB) fields are not retrieved by this method, to
    // preserve bandwidth:
    // use the RetrieveBlob() methods for handling BLOB fields, or set globaly
    // the TSQLRestClientURI.ForceBlobTransfert property to TRUE
    // - the TSQLRecordMany fields are not retrieved either: they are separate
    // instances created by TSQLRecordMany.Create, with dedicated methods to
    // access to the separated pivot table
    function Retrieve(Reference: TRecordReference;
      ForUpdate: boolean=false): TSQLRecord; overload; virtual;
    /// get a member from a published property TSQLRecord
    // - those properties are not class instances, but TObject(aRecordID)
    // - is just a wrapper around Retrieve(aPublishedRecord.ID,aValue)
    // - return true on success
    function Retrieve(aPublishedRecord, aValue: TSQLRecord): boolean; overload;
    /// get a list of members from a SQL statement (implements REST GET member)
    // - return a TObjectList on success (possibly with Count=0) - caller is
    // responsible of freeing the instance
    // - this TObjectList will contain a list of all matching records
    // - return nil on error
    function RetrieveList(Table: TSQLRecordClass; FormatSQLWhere: PUTF8Char;
      const BoundsSQLWhere: array of const; const aCustomFieldsCSV: RawUTF8=''): TObjectList;
    /// Execute directly a SQL statement, expecting a list of results
    // - return a result table on success, nil on failure
    function ExecuteList(const Tables: array of TSQLRecordClass; const SQL: RawUTF8): TSQLTableJSON; virtual; abstract;
    /// unlock the corresponding record
    // - use our custom UNLOCK REST-like method
    // - returns true on success
    function UnLock(Table: TSQLRecordClass; aID: integer): boolean; overload; virtual; abstract;
    /// unlock the corresponding record
    // - use our custom UNLOCK REST-like method
    // - calls internally UnLock() above
    // - returns true on success
    function UnLock(Rec: TSQLRecord): boolean; overload;
    /// create a new member (implements REST POST Collection)
    // - if SendData is true, client sends the current content of Value with the
    // request, otherwize record is created with default values
    // - if ForceID is true, client sends the Value.ID field to use this ID for
    // adding the record (instead of a database-generated ID)
    // - on success, returns the new ROWID value; on error, returns 0
    // - on success, Value.ID is updated with the new ROWID
    // - the TSQLRawBlob(BLOB) fields values are not set by this method, to
    // preserve bandwidth
    // - the TSQLRecordMany fields are not set either: they are separate
    // instances created by TSQLRecordMany.Create, with dedicated methods to
    // access to the separated pivot table
    function Add(Value: TSQLRecord; SendData: boolean; ForceID: boolean=false): integer; overload; virtual; abstract;
    /// create a new member, from a supplied list of field values
    // - the aSimpleFields parameters must follow explicitely the order of published
    // properties of the supplied aTable class, excepting the TSQLRawBlob and
    // TSQLRecordMany kind (i.e. only so called "simple fields")
    // - the aSimpleFields must have exactly the same count of parameters as
    // there are "simple fields" in the published properties
    // - if ForcedID is set to non null, client sends this ID to be used
    // when adding the record (instead of a database-generated ID)
    // - on success, returns the new ROWID value; on error, returns 0
    // - call internaly the Add virtual method above
    function Add(aTable: TSQLRecordClass; const aSimpleFields: array of const; ForcedID: integer=0): integer; overload;
    /// update a record from Value fields content
    // - implements REST PUT Member
    // - return true on success
    // - this default method call RecordCanBeUpdated() to check if the action is
    // allowed - this method must be overriden to provide effective data update
    // - the TSQLRawBlob(BLOB) fields values are not updated by this method, to
    // preserve bandwidth: use the UpdateBlob() methods for handling BLOB fields
    // - the TSQLRecordMany fields are not set either: they are separate
    // instances created by TSQLRecordMany.Create, with dedicated methods to
    // access to the separated pivot table
    function Update(Value: TSQLRecord): boolean; overload; virtual;
    /// update a record from a supplied list of field values
    // - implements REST PUT Member
    // - the aSimpleFields parameters must follow explicitely the order of published
    // properties of the supplied aTable class, excepting the TSQLRawBlob and
    // TSQLRecordMany kind (i.e. only so called "simple fields")
    // - the aSimpleFields must have exactly the same count of parameters as there are
    // "simple fields" in the published properties
    // - return true on success
    // - call internaly the Update virtual method above
    function Update(aTable: TSQLRecordClass; aID: integer; const aSimpleFields: array of const): boolean; overload;
    /// delete a member (implements REST DELETE Member)
    // - return true on success
    // - this default method call RecordCanBeUpdated() to check if it is possible
    function Delete(Table: TSQLRecordClass; ID: integer): boolean; overload; virtual;
    /// delete a member with a WHERE clause (implements REST DELETE Member)
    // - return true on success
    // - this default method call OneFieldValues() to retrieve all matching IDs,
    // then will delete each row using protected EngineDeleteWhere() virtual method
    function Delete(Table: TSQLRecordClass; const SQLWhere: RawUTF8): boolean; overload; virtual;
    /// delete a member with a WHERE clause (implements REST DELETE Member)
    // - return true on success
    // - for better server speed, the WHERE clause should use bound parameters
    //   identified as '?' in the FormatSQLWhere statement, which is expected to
    //   follow the order of values supplied in BoundsSQLWhere open array - use
    //   DateToSQL/DateTimeToSQL for TDateTime, or directly any integer / double /
    //   currency / RawUTF8 values to be bound to the request as parameters
    // - it will run Delete(Table,FormatUTF8(FormatSQLWhere,[],BoundsSQLWhere))
    function Delete(Table: TSQLRecordClass; FormatSQLWhere: PUTF8Char;
      const BoundsSQLWhere: array of const): boolean; overload;

    {/ access the internal caching parameters for a given TSQLRecord
     - purpose of this caching mechanism is to speed up retrieval of some
       common values at either Client or Server level (like configuration
       settings)
     - only caching synchronization is about the direct RESTful/CRUD commands:
       RETRIEVE, ADD, UPDATE and DELETE (that is, a complex direct SQL UPDATE or
       via TSQLRecordMany pattern won't be taken in account - only exception is
       TSQLRestServerStatic tables accessed as SQLite3 virtual table)
     - this caching will be located at the TSQLRest level, that is no automated
       synchronization is implemented between TSQLRestClient and TSQLRestServer:
       you shall ensure that your code won't fail due to this restriction
     - use Cache.SetCache() and Cache.SetTimeOut() methods to set the appropriate
       configuration for this particular TSQLRest instance }
    property Cache: TSQLRestCache read GetCache;

    /// get a blob field content from its record ID and supplied blob field name
    // - implements REST GET member with a supplied member ID and a blob field name
    // - return true on success
    // - this method is defined as abstract, i.e. there is no default implementation:
    // it must be implemented 100% RestFul with a GET ModelRoot/TableName/ID/BlobFieldName
    // request for example
    // - this method retrieve the blob data as a TSQLRawBlob string
    function RetrieveBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; out BlobData: TSQLRawBlob): boolean; overload; virtual; abstract;
    /// get a blob field content from its record ID and supplied blob field name
    // - implements REST GET member with a supplied member ID and a blob field name
    // - return true on success
    // - this method will create a TStream instance (which must be freed by the
    // caller after use) and fill it with the blob data
    function RetrieveBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; out BlobStream: THeapMemoryStream): boolean; overload;
    /// update a blob field from its record ID and supplied blob field name
    // - implements REST PUT member with a supplied member ID and field name
    // - return true on success
    // - this default method call RecordCanBeUpdated() to check if the action is
    // allowed
    // - this method expect the Blob data to be supplied as TSQLRawBlob
    function UpdateBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; const BlobData: TSQLRawBlob): boolean; overload; virtual; abstract;
    /// update a blob field from its record ID and blob field name
    // - implements REST PUT member with a supplied member ID and field name
    // - return true on success
    // - this default method call RecordCanBeUpdated() to check if the action is
    // allowed
    // - this method expect the Blob data to be supplied as a TStream: it will
    // send the whole stream content (from its beginning position upto its
    // current size) to the database engine
    function UpdateBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; BlobData: TStream): boolean; overload;
    /// update a blob field from its record ID and blob field name
    // - implements REST PUT member with a supplied member ID and field name
    // - return true on success
    // - this default method call RecordCanBeUpdated() to check if the action is
    // allowed
    // - this method expect the Blob data to be supplied as direct memory pointer
    // and size
    function UpdateBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; BlobData: pointer; BlobSize: integer): boolean; overload;
    /// update all BLOB fields of the supplied Value
    // - uses the UpdateBlob() method to send the BLOB properties content to the Server
    // - called internaly by Add and Update methods when ForceBlobTransfert is TRUE
    // - you can use this method by hand, to avoid several calls to UpdateBlob()
    // - returns TRUE on success (or if there is no BLOB field)
    // - returns FALSE on error (e.g. if Value is invalid or with db/transmission) 
    function UpdateBlobFields(Value: TSQLRecord): boolean; virtual;
    /// get all BLOB fields of the supplied value from the remote server
    // - call internaly e.g. by TSQLRestClient.Retrieve method when
    // ForceBlobTransfert is TRUE
    function RetrieveBlobFields(Value: TSQLRecord): boolean; virtual;

    {/ begin a transaction (implements REST BEGIN Member)
     - to be used to speed up some SQL statements like Add/Update/Delete methods
     above
     - in the current implementation, the aTable parameter is not used yet
     - in the current implementation, nested transactions are not allowed
     - must be ended with Commit on success
     - must be aborted with Rollback if any SQL statement failed
     - default implementation just handle the protected fTransactionActive flag
     - return true if no transaction is active, false otherwize
     - in a multi-threaded or Client-Server with multiple concurent Client
     connections, you should check the returned value, as such:
      !if Client.TransactionBegin(TSQLRecordPeopleObject) then
      !try
      !  //.... modify the database content, raise exceptions on error
      !  Client.Commit;
      !except
      !  Client.RollBack; // in case of error
      !end;
     - in aClient-Server environment with multiple Clients connected at the
       same time, you can use the dedicated TSQLRestClientURI.
       TransactionBeginRetry() method
     - the supplied SessionID will allow multi-user transaction safety on the
       Server-Side: all database modification from another session will wait
       for the global transaction to be finished; on Client-side, the SessionID
       is just ignored (TSQLRestClient will override this method with a default
       SessionID=CONST_AUTHENTICATION_NOT_USED=1 parameter) }
    function TransactionBegin(aTable: TSQLRecordClass; SessionID: cardinal): boolean; virtual;
    {/ end a transaction (implements REST END Member)
     - write all pending SQL statements to the disk
     - default implementation just reset the protected fTransactionActive flag
     - the supplied SessionID will allow multi-user transaction safety on the
       Server-Side: all database modification from another session will wait
       for the global transaction to be finished; on Client-side, the SessionID
       is just ignored (TSQLRestClient will override this method with a default
       SessionID=CONST_AUTHENTICATION_NOT_USED=1 parameter) }
    procedure Commit(SessionID: cardinal); virtual;
    {/ abort a transaction (implements REST ABORT Member)
     - restore the previous state of the database, before the call to TransactionBegin
     - default implementation just reset the protected fTransactionActive flag 
     - the supplied SessionID will allow multi-user transaction safety on the
       Server-Side: all database modification from another session will wait
       for the global transaction to be finished; on Client-side, the SessionID
       is just ignored (TSQLRestClient will override this method with a default
       SessionID=CONST_AUTHENTICATION_NOT_USED=1 parameter) }
    procedure RollBack(SessionID: cardinal); virtual;

    {$ifdef ISDELPHI2010} // Delphi 2009 generics support is buggy :(
    /// get an instance of one interface-based service
    // - may return nil if this service interface is not available
    function Service<T: IInterface>: T;
    {$endif}

    {/ the time (in mili seconds) which the server will wait for acquiring a
       write acccess to the database
     - in order to handle safe transactions and multi-thread safe writing, the
       server will identify transactions using the client Session ID: this
       property will set the time out wait period
     - default value is 2000, i.e. TSQLRestServer.URI will wait up to 2 seconds
       in order to acquire the right to write on the database before returning
       a "408 Request Time-out" status error }
    property AcquireWriteTimeOut: cardinal read fAcquireWriteTimeOut write fAcquireWriteTimeOut;
    /// the current Date and Time, as retrieved from the server
    // - this property will return the timestamp as TTimeLog / Iso8601 / Int64
    // after correction from the Server returned time-stamp (if any)
    // - is used e.g. by TSQLRecord.ComputeFieldsBeforeWrite to update TModTime
    // and TCreateTime published fields
    // - default implementation will return the executable time, i.e. Iso8601Now
    // - you can set the server-side time offset by setting a value to this
    // property (e.g. using TSQLDBConnection.ServerTimeStamp property for
    // Oracle, MSSQL and MySQL external databases)
    // - you can use this value in a WHERE clause for a query, as such:
    // ! aRec.CreateAndFillPrepare(Client,'Datum<=?',[Iso8601ToSQL(Client.ServerTimeStamp)]);
    property ServerTimeStamp: TTimeLog read GetServerTimeStamp write SetServerTimeStamp;
    /// access to the interface-based services list
    // - may be nil if no service interface has been registered yet: so be
    // aware that the following line may trigger an access violation if
    // no ICalculator is defined on server side:
    // ! if fServer.Services['Calculator'].Get(Calc)) then
    // !   ...
    property Services: TServiceContainer read fServices;
    /// the routing mode of the service remote request
    // - by default, will use an URI-based layout (rmREST), which is more secure
    // (since will use our RESTful authentication scheme), and also 10% faster
    // - but rmJSON_RPC can be set (on BOTH client and server sides), if the
    // client would rather use this alternative pattern
    property ServicesRouting: TServiceRoutingMode read fRouting write fRouting;
  public
    /// the custom queries parameters for User Interface Query action
    QueryCustom: array of TSQLQueryCustom;
    /// evaluate a basic operation for implementing User Interface Query action
    // - expect both Value and Reference to be UTF-8 encoded (as in TSQLTable
    // or TSQLTableToGrid)
    // - aID parameter is ignored in this function implementation (expect only
    // this parameter to be not equal to 0)
    // - is TSQLQueryEvent prototype compatible
    // - for qoContains and qoBeginWith, the Reference is expected to be
    // already uppercase
    // - for qoSoundsLike* operators, Reference is not a PUTF8Char, but a
    // typecase of a prepared TSynSoundEx object instance (i.e. pointer(@SoundEx))
    class function QueryIsTrue(aTable: TSQLRecordClass; aID: integer;
      FieldType: TSQLFieldType; Value: PUTF8Char; Operator: integer;
      Reference: PUTF8Char): boolean;
    /// add a custom query
    // - one event handler with an enumeration type containing all available
    // query names
    // - and associated operators
    procedure QueryAddCustom(aTypeInfo: pointer; aEvent: TSQLQueryEvent;
      const aOperators: TSQLQueryOperators);
  end;

{$ifdef MSWINDOWS}
  /// Server thread accepting connections from named pipes
  TSQLRestServerNamedPipe = class(TThread)
  private
  protected
    fServer: TSQLRestServer;
    fChild: TList;
    fChildCount: integer;
    fPipeName: TFileName;
    procedure Execute; override;
  public
    /// create the server thread
    constructor Create(aServer: TSQLRestServer; const PipeName: TFileName);
    /// release all associated memory, and wait for all
    // TSQLRestServerNamedPipeResponse children to be terminated
    destructor Destroy; override;
    /// the associated pipe name
    property PipeName: TFileName read fPipeName;
  end;

  /// Server child thread dealing with a connection through a named pipe
  TSQLRestServerNamedPipeResponse = class(TThread)
  private
  protected
    fServer: TSQLRestServer;
    fPipe: cardinal;
    fMasterThread: TSQLRestServerNamedPipe;
    fMasterThreadChildIndex: Integer;
    procedure Execute; override;
    {$ifndef LVCL}
    // will release any thread-specific resource (e.g. external DB connection)
    procedure DoTerminate; override;
    {$endif}
  public
    /// create the child connection thread
    constructor Create(aServer: TSQLRestServer; aMasterThread: TSQLRestServerNamedPipe;
      aPipe: cardinal);
    /// release all associated memory, and decrement fMasterThread.fChildCount
    destructor Destroy; override;
  end;

{$ifdef FPC}
  TWMCopyData = packed record
    Msg: Cardinal;
    From: HWND;
    CopyDataStruct: PCopyDataStruct;
    Result: Longint;
  end;
{$endif}
{$endif}

  /// function prototype for remotly calling a TSQLRestServer
  // - use PUTF8Char instead of string: no need to share a memory manager, and can
  // be used with any language (even C or .NET, thanks to the cdecl calling convention)
  // - you can specify some POST/PUT data in SendData (leave as nil otherwize)
  // - returns in result.Lo the HTTP STATUS integer error or success code
  // - returns in result.Hi the server database internal status
  // - on success, allocate and store the resulting JSON body into Resp^, headers in Head^
  // - use a GlobalFree() function to release memory for Resp and Head responses
  TURIMapRequest = function(url, method, SendData: PUTF8Char; Resp, Head: PPUTF8Char): Int64Rec; cdecl;

{$ifdef MSWINDOWS}
  {$define WITHSTATPROCESS}
  // if defined, the server statistics will contain precise working time process
{$endif}

  /// structure used to specify custom request paging parameters for TSQLRestServer
  // - default values are the one used for YUI component paging (i.e.
  // PAGINGPARAMETERS_YAHOO constant, as set by TSQLRestServer.Create)
  // - warning: using paging can be VERY expensive on Server side, especially
  // when used with external databases (since all data is retrieved before
  // paging, when SQLite3 works in virtual mode)
  TSQLRestServerURIPagingParameters = record
    /// parameter name used to specify the request sort order
    // - default value is 'SORT='
    Sort: PUTF8Char;
    /// parameter name used to specify the request sort direction
    // - default value is 'DIR='
    Dir: PUTF8Char;
    /// parameter name used to specify the request starting offset
    // - default value is 'STARTINDEX='
    StartIndex: PUTF8Char;
    /// parameter name used to specify the request the page size (LIMIT clause)
    // - default value is 'RESULTS='
    Results: PUTF8Char;
    /// parameter name used to specify the request field names
    // - default value is 'SELECT='
    Select: PUTF8Char;
    /// parameter name used to specify the request WHERE clause
    // - default value is 'WHERE=' 
    Where: PUTF8Char;
    /// returned JSON field value of optional total row counts
    // - default value is nil, i.e. no total row counts field
    // - computing total row counts can be very expensive, depending on the
    // database back-end used (especially for external databases)
    // - can be set e.g. to ',"totalRows":%' value (note that the initial "," is
    // expected by the produced JSON content, and % will be set with the value)
    SendTotalRowsCountFmt: PUTF8Char;
  end;

  /// used for statistics update in TSQLRestServer.URI()
  TSQLRestServerStats = class(TPersistent)
  private
    /// used to determine if something changed
    fLastIncomingBytes: QWord;
    /// current count of connected clients
    fClientsCurrent,
    /// max count of connected clients
    fClientsMax,
    /// count of invalid request
    fInvalid,
    /// count of valid responses (returned status code 200/HTML_SUCCESS or 201/HTML_CREATED)
    fResponses,
    /// count of requests which modified the data
    fModified,
    /// size of data requests processed in bytes (without the transfert protocol overhead)
    fIncomingBytes,
    /// size of data responses generated in bytes (without the transfert protocol overhead)
    fOutcomingBytes,
    /// count of the remote service calls
    fServices: QWord;
{$ifdef WITHSTATPROCESS}
    /// time used to process the requests, with appended unit ('0.13 ms' e.g.)
    function GetProcessTimeString: RawUTF8;
{$endif}
  public
{$ifdef WITHSTATPROCESS}
    /// high-resolution performance counter of the time used to process the requests
    // - this value depend on the high-resolution performance counter frequency
    // - use ProcessTime property below to get the time in seconds
    ProcessTimeCounter: Int64;
{$endif}
    /// update ClientsCurrent and ClientsMax
    procedure ClientConnect;
    /// update ClientsCurrent and ClientsMax
    procedure ClientDisconnect;
    /// get a standard message to be displayed with the above statistics
    // - return the published properties of this class as a JSON object
    function DebugMessage: RawUTF8;
    /// percent (0..100) of request which modified the data
    function ModifPercent: cardinal;
    /// return true if IncomingBytes value changed since last call
    function Changed: boolean;
  published
    /// current count of connected clients
    property ClientsCurrent: QWord read fClientsCurrent;
    /// max count of connected clients
    property ClientsMax: QWord read fClientsMax;
    /// count of invalid request
    property Invalid: QWord read fInvalid;
    /// count of valid responses (returned status code 200/HTML_SUCCESS or 201/HTML_CREATED)
    property Responses: QWord read fResponses;
    /// count of requests which modified the data
    property Modified: QWord read fModified;
    /// size of data requests processed in bytes (without the transfert protocol overhead)
    property IncomingBytes: QWord read fIncomingBytes;
    /// size of data responses generated in bytes (without the transfert protocol overhead)
    property OutcomingBytes: QWord read fOutcomingBytes;
    /// count of the remote service calls
    property ServiceCalls: QWord read fServices;
{$ifdef WITHSTATPROCESS}
    /// the global time spent in the server process
    property ProcessTime: RawUTF8 read GetProcessTimeString;
{$endif}
  end;

  ///  used to define how to trigger Events on record update
  // - see TSQLRestServer.OnUpdateEvent property and InternalUpdateEvent() method
  // - returns true on success, false if an error occured (but action must continue)
  // - to be used only server-side, not to synchronize some clients: the framework
  // is designed around a stateless RESTful architecture (like HTTP/1.1), in which
  // clients ask the server for refresh (see TSQLRestClientURI.UpdateFromServer)
  TNotifySQLEvent = function(Sender: TSQLRestServer; Event: TSQLEvent;
    aTable: TSQLRecordClass; aID: integer): boolean of object;

  /// a set of potential actions to be executed from the server
  // - reSQL will indicate the right to execute any POST SQL statement (not only
  // SELECT statements)
  // - reService will indicate the right to execute the interface-based JSON-RPC
  // service implementation
  // - reUrlEncodedSQL will indicate the right to execute a SQL query encoded
  // at the URI level, for a GET (to be used e.g. with XMLHTTPRequest, which
  // forced SentData='' by definition), encoded as sql=.... inline parameter
  // - reUrlEncodedDelete will indicate the right to delete items using a
  // WHERE clause for DELETE verb at /root/TableName?WhereClause
  // - reOneSessionPerUser will force that only one session may be created
  // for one user, even if connection comes from the same IP: in this case,
  // you may have to set the SessionTimeOut to a small value, in case the
  // session is not closed gracefully 
  TSQLAllowRemoteExecute = set of (
    reSQL, reService, reUrlEncodedSQL, reUrlEncodedDelete, reOneSessionPerUser);

  /// set the User Access Rights, for each Table
  // - one property for every and each URI method (GET/POST/PUT/DELETE)
  // - one bit for every and each Table in Model.Tables[]
  {$ifdef UNICODE}
  TSQLAccessRights = record
  {$else}
  TSQLAccessRights = object
  {$endif}
    /// set of allowed actions on the server side
    AllowRemoteExecute: TSQLAllowRemoteExecute;
    /// GET method (retrieve record) table access bits
    // - note that a GET request with a SQL statement without a table (i.e.
    // on 'ModelRoot' URI with a SQL statement as SentData, as used in
    // TSQLRestClientURI.UpdateFromServer) is always valid, whatever the bits
    // here are: since TSQLRestClientURI.UpdateFromServer() is called only
    // for refreshing a direct statement, it will be OK; you can improve this
    // by overriding the TSQLRestServer.URI() method
    // - if the REST request is LOCK, the PUT access bits will be read instead
    // of the GET bits value
    GET: TSQLFieldTables;
    /// POST method (create record) table access bits
    POST: TSQLFieldTables;
    /// PUT method (update record) table access bits
    // - if the REST request is LOCK, the PUT access bits will be read instead
    // of the GET bits value
    PUT: TSQLFieldTables;
    /// DELETE method (delete record) table access bits
    DELETE: TSQLFieldTables;
    /// wrapper method which can be used to set the CRUD abilities over a table
    // - C=Create, R=Read, U=Update, D=Delete rights
    procedure Edit(aTableIndex: integer; C, R, U, D: Boolean); overload;
    /// wrapper method which can be used to set the CRUD abilities over a table
    // - use TSQLOccasion set as parameter
    procedure Edit(aTableIndex: integer; aRights: TSQLOccasions); overload;
    /// serialize the content as TEXT
    // - use the TSQLAuthGroup.AccessRights CSV format
    function ToString: RawUTF8;
    /// unserialize the content from TEXT
    // - use the TSQLAuthGroup.AccessRights CSV format
    procedure FromString(P: PUTF8Char);
  end;

  TSQLRestServerStatic = class;
  TSQLRestServerStaticClass = class of TSQLRestServerStatic;
  TSQLRestServerStaticInMemory = class;
  TSQLVirtualTableModule = class;


  {/ table containing the available user access rights for authentication
    - this class should be added to the TSQLModel, together with TSQLAuthUser,
      to allow authentication support
    - by default, it won't be accessible remotely by anyone }
  TSQLAuthGroup = class(TSQLRecord)
  private
    fIdent: RawUTF8;
    fSessionTimeOut: integer;
    fAccessRights: RawUTF8;
    function GetSQLAccessRights: TSQLAccessRights;
    procedure SetSQLAccessRights(const Value: TSQLAccessRights);
  public
    /// called when the associated table is created in the database
    // - on a new database, if TSQLAuthUser and TSQLAuthGroup tables are defined
    // in the associated TSQLModel, it this will add 'Admin', 'Supervisor',
    // and 'User' rows in the AuthUser table (with 'synopse' as default password),
    // and associated 'Admin', 'Supervisor', 'User' and 'Guest' groups, with the
    // following access rights to the AuthGroup table:
    // $           POST SQL  Service  Auth R  Auth W  Tables R  Tables W
    // $ Admin        Yes      Yes     Yes     Yes      Yes      Yes
    // $ Supervisor   No       Yes     Yes     No       Yes      Yes
    // $ User         No       Yes     No      No       Yes      Yes
    // $ Guest        No       No      No      No       Yes      No
    // 'Admin' will be the only able to execute remote not SELECT SQL statements
    // for POST commands (reSQL in TSQLAccessRights.AllowRemoteExecute) and
    // modify the Auth tables (i.e. AuthUser and AuthGroup), and Guest won't have
    // access to the interface-based remote JSON-RPC service (no reService)
    // - you MUST override those default 'synopse' password to a custom value
    // - of course, you can change and tune the settings of the AuthGroup and
    // AuthUser tables, but only 'Admin' group users will be able to remotly
    // modify the content of those table
    class procedure InitializeTable(Server: TSQLRestServer; const FieldName: RawUTF8); override;
    /// corresponding TSQLAccessRights for this authentication group
    // - content is converted into/from text format via AccessRight DB property
    // (so it will be not fixed e.g. by the binary TSQLFieldTables layout, i.e.
    // the MAX_SQLTABLES constant value)
    property SQLAccessRights: TSQLAccessRights read GetSQLAccessRights write SetSQLAccessRights;
  published
    /// the access right identifier, ready to be displayed
    // - the same identifier can be used only once (this column is marked as
    // unique via a "stored AS_UNIQUE" (i.e. "stored false") attribute)
    // - so you can retrieve a TSQLAuthGroup ID from its identifier, as such:
    // ! UserGroupID := fClient.MainFieldID(TSQLAuthGroup,'User');
    property Ident: RawUTF8 index 50 read fIdent write fIdent stored AS_UNIQUE;
    /// the number of minutes a session is kept alive
    property SessionTimeout: integer read fSessionTimeOut write fSessionTimeOut;
    /// a textual representation of a TSQLAccessRights buffer
    property AccessRights: RawUTF8 index 1600 read fAccessRights write fAccessRights;
  end;

  {/ table containing the Users registered for authentication
    - this class should be added to the TSQLModel, together with TSQLAuthGroup,
      to allow authentication support
    - by default, it won't be accessible remotely by anyone
    - to enhance security, you could use the TSynValidatePassWord filter to
      this table  }
  TSQLAuthUser = class(TSQLRecord)
  protected
    fLogonName: RawUTF8;
    fPasswordHashHexa: RawUTF8;
    fDisplayName: RawUTF8;
    fGroup: TSQLAuthGroup;
    fData: TSQLRawBlob;
    procedure SetPasswordPlain(const Value: RawUTF8);
  public
    /// able to set the PasswordHashHexa field from a plain password content
    // - in fact, PasswordHashHexa := SHA256('salt'+PasswordPlain) in UTF-8
    property PasswordPlain: RawUTF8 write SetPasswordPlain;
  published
    /// the User identification Name, as entered at log-in
    // - the same identifier can be used only once (this column is marked as
    // unique via a "stored AS_UNIQUE" - i.e. "stored false" - attribute), and
    // therefore indexed in the database (e.g. hashed in TSQLRestServerStaticInMemory)
    property LogonName: RawUTF8 index 20 read fLogonName write fLogonName stored AS_UNIQUE;
    /// the User Name, as may be displayed or printed
    property DisplayName: RawUTF8 index 50 read fDisplayName write fDisplayName;
    /// the hexa encoded associated SHA-256 hash of the password
    property PasswordHashHexa: RawUTF8 index 64 read fPasswordHashHexa write fPasswordHashHexa;
    /// the associated access rights of this user
    // - access rights are managed by group
    // - in TAuthSession.User instance, GroupRights property will contain a
    // real TSQLAuthGroup instance for fast retrieval in TSQLRestServer.URI
    // - note that 'Group' field name is not allowed by SQLite
    property GroupRights: TSQLAuthGroup read fGroup write fGroup;
    /// some custom data, associated to the User
    // - Server application may store here custom data
    // - its content is not used by the framework but 'may' be used by your
    // application
    property Data: TSQLRawBlob read fData write fData;
  end;

  {/ class used to maintain in-memory sessions
    - this is not a TSQLRecord table so won't be remotely accessible, for
      performance and security reasons
    - the User field is a true instance, copy of the corresponding database
      content (for better speed) }
  TAuthSession = class
  private
    fUser: TSQLAuthUser;
    fLastAccess: cardinal;
    fID: RawUTF8;
    fIDCardinal: cardinal;
    fTimeOut: cardinal;
    fAccessRights: TSQLAccessRights;
    fPrivateKey: RawUTF8;
    fPrivateSalt: RawUTF8;
    fSentHeaders: RawUTF8;
    fRemoteIP: RawUTF8;
    fConnectionID: RawUTF8;
    fPrivateSaltHash: Cardinal;
    fLastTimeStamp: Cardinal;
  public
    /// initialize a session instance with the supplied TSQLAuthUser instance
    // - this aUser instance will be handled by the class until Destroy
    // - raise an exception on any error
    // - on success, will also retrieve the aUser.Data BLOB field content
    constructor Create(aServer: TSQLRestServer; aUser: TSQLAuthUser;
      aContext: PSQLRestServerURIParams);
    /// will release the User and User.GroupRights instances
    destructor Destroy; override;
    /// check if the session_signature=... parameter is correct
    // - session_signature=... is expected at the end of the URL, i.e.
    // aURL[aURLLength+1] will point e.g. to '?session_signature=...':
    // the caller must ensure that aURL[] follows this expected layout
    // - will expect the format as generated by TSQLRestClientURI.SessionSign()
    function IsValidURL(const aURL: RawUTF8; aURLlength: integer): boolean;
  public
    /// the session ID number, as text
    property ID: RawUTF8 read fID;
    /// the session ID number, as numerical value
    // - never equals to 1 (CONST_AUTHENTICATION_NOT_USED, i.e. authentication
    // mode is not enabled), nor 0 (CONST_AUTHENTICATION_SESSION_NOT_STARTED,
    // i.e. session still in handshaking phase)
    property IDCardinal: cardinal read fIDCardinal;
    /// the associated User
    // - this is a true TSQLAuthUser instance, and User.GroupRights will contain
    // also a true TSQLAuthGroup instance
    property User: TSQLAuthUser read fUser;
    /// set by the Access method to the current time stamp
    property LastAccess: cardinal read fLastAccess;
    /// copy of the associated user access rights
    // - extracted from User.TSQLAuthGroup.SQLAccessRights
    property AccessRights: TSQLAccessRights read fAccessRights;
    /// the number of millisedons a session is kept alive
    // - extracted from User.TSQLAuthGroup.SessionTimeout
    // - allow direct comparison with GetTickCount API call
    property Timeout: cardinal read fTimeOut;
    /// the hexadecimal private key as returned to the connected client
    // as 'SessionID+PrivateKey'
    property PrivateKey: RawUTF8 read fPrivateKey;
    /// the transmitted HTTP headers, if any
    // - can contain e.g. 'RemoteIp: 127.0.0.1' or 'User-Agent: Mozilla/4.0'
    property SentHeaders: RawUTF8 read fSentHeaders;
    /// the remote IP, if any
    // - is extracted from SentHeaders properties
    property RemoteIP: RawUTF8 read fRemoteIP;
    /// a remote connection identifier, if any
    // - is extracted from SentHeaders properties
    property ConnectionID: RawUTF8 read fConnectionID;
  end;

  { we need the RTTI information to be compiled for the published methods
    of this TSQLRestServer class and its children (like TPersistent), to
    enable Server-Side ModelRoot/[TableName/[ID/]]MethodName requests
      -> see TSQLRestServerCallBack }

  /// a generic REpresentational State Transfer (REST) server
  // - descendent must implement the protected EngineList() Retrieve() Add()
  // Update() Delete() methods
  // - automatic call of this methods by a generic URI() RESTful function
  // - any published method of descendants must match TSQLRestServerCallBack
  // prototype, and is expected to be thread-safe
  TSQLRestServer = class(TSQLRest)
  protected
    fStats: TSQLRestServerStats;
    fVirtualTableDirect: boolean;
    fNoAJAXJSON: boolean;
    fHandleAuthentication: Boolean;
    /// fast access to the TSQLAuthUser and TSQLAuthGroup table in Model.Tables[]
    fAuthUserIndex, fAuthGroupIndex: integer;
    /// will contain the in-memory representation of some static tables
    // - this array has the same length as the associated Model.Tables[]
    // - fStaticData[] will contain pure in-memory tables, not declared as
    // SQLite3 virtual tables, therefore not available from joined SQL statements
    fStaticData: array of TSQLRestServerStatic;
    /// map TSQLRestServerStaticInMemory or TSQLRestServerStaticExternal engines
    // - this array has the same length as the associated Model.Tables[]
    // - fStaticVirtualTable[] will contain in-memory or external tables declared
    // as SQLite3 virtual tables, therefore available from joined SQL statements
    fStaticVirtualTable: array of TSQLRestServerStatic;
    /// in-memory storage of TAuthSession instances
    fSessions: TObjectList;
    /// used to compute genuine TAuthSession.ID cardinal value
    fSessionCounter: cardinal;
    /// mutex used to make fSessions[] use thread-safe
    fSessionCriticalSection: TRTLCriticalSection;
{$ifdef SSPIAUTH}
    /// Windows built-in authentication
    // - holds information between calls to ServerSSPIAuth
    fSSPIAuthContexts: TSecContexts;
    /// mutex used to make fSSPIAuthContexts use thread-safe
    fSSPIAuthCriticalSection: TRTLCriticalSection;
    /// used to compute TSecContext.ID cardinal value
    fSSPIAuthCounter: Cardinal;
{$endif}
{$ifdef MSWINDOWS}
    /// thread initialized by ExportServerNamedPipe() to response to client through a pipe
    fExportServerNamedPipeThread: TSQLRestServerNamedPipe;
    /// internal server window handle, initialized by ExportServerMessage() method
    fServerWindow: HWND;
    /// internal server window class name, initialized by ExportServerMessage() method
    // - use "string" type, i.e. UnicodeString for Delphi 2009+, in order
    // to call directly the correct FindWindow?()=FindWindow Win32 API
    fServerWindowName: string;
{$endif}
    fPublishedMethods: TSynNameValue;
    fPublishedMethodsUnauthenticated: TIntegerDynArray;
    fPublishedMethodsUnauthenticatedCount: integer;
    /// fast get the associated static server, if any
    function GetStaticDataServer(aClass: TSQLRecordClass): TSQLRestServerStatic;
    /// retrieve a TSQLRestServerStatic instance associated to a Virtual Table
    // - is e.g. TSQLRestServerStaticInMemory instance associated to a
    // TSQLVirtualTableBinary or TSQLVirtualTableJSON class
    // - may be a TSQLRestServerStaticExternal (as defined in SQLite3DB unit)
    // for a virtual table giving access to an external database
    function GetVirtualTable(aClass: TSQLRecordClass): TSQLRestServerStatic;
    /// fast get the associated static server or Virtual table, if any
    // - this can be used to call directly the TSQLRestServerStatic instance
    // on the server side
    // - same as a dual call to StaticDataServer[aClass] + StaticVirtualTable[aClass]
    // - TSQLRestServer.URI will make a difference between the a static server
    // or a TSQLVirtualTable, but this method won't
    function GetStaticDataServerOrVirtualTable(aClass: TSQLRecordClass): TSQLRestServerStatic; overload;
    /// overloaded method using table index in associated Model
    function GetStaticDataServerOrVirtualTable(aTableIndex: integer): TSQLRestServerStatic; overload;
       {$ifdef HASINLINE}inline;{$endif}
    /// retrieve a list of members as JSON encoded data - used by OneFieldValue()
    // and MultiFieldValue() public functions
    function InternalListJSON(Table: TSQLRecordClass; const SQL: RawUTF8): TSQLTableJSON; override;
    function InternalAdaptSQL(TableIndex: integer; var SQL: RawUTF8): TSQLRestServerStatic;
    function InternalListRawUTF8(TableIndex: integer; const SQL: RawUTF8): RawUTF8;
    /// this method is overriden for setting the NoAJAXJSON field
    // of all associated TSQLRestServerStatic servers
    procedure SetNoAJAXJSON(const Value: boolean); virtual;
    /// search for the corresponding TSQLRestServerCallBack in its published methods,
    // then launch it
    // - the Ctxt parameters will be used to set a default header for the callback
    // - return TRUE if the method was found and run, FALSE if method was not found
    function LaunchCallBack(var Ctxt: TSQLRestServerCallBackParams): boolean;
    /// try to call a Service from a given URI
    // - this method will call any interface-based service previously registered
    // via ServerRegister()
    // - returns TRUE if the supplied method was a service name, and an error
    // code is returned in aResult (with an optional message in aErrorMsg)
    // - is in fact used internaly by the URI method: you are not likely to call
    // this method, but should rather call e.g. Services['Calculator'].Get(I)
    // to retrieve a working service interface to work with
    function LaunchService(var Ctxt: TSQLRestServerCallBackParams): boolean;
    /// execute a BATCH sequence
    // - expect input as generated by TSQLRestClientURI.Batch*() methods:
    // & '{"Table":["cmd":values,...]}'
    // or, in a table-independent way:
    // & '["cmd@table":values,...]'
    // - returns an array of integers: '[200,200,...]'
    function RunBatch(aStatic: TSQLRestServerStatic; aTable: TSQLRecordClass;
      var aCall: TSQLRestServerCallBackParams): boolean;
    /// fill the supplied context from the supplied aContext.Session ID
    // - returns nil if not found, or fill aContext.User/Group values if matchs
    // - this method will also check for outdated sessions, and delete them
    // - this method is not thread-safe: caller should use fSessionCriticalSection
    function SessionAccess(var aContext: TSQLRestServerCallBackParams): TAuthSession;
    /// delete a session from its index in fSessions[]
    // - will perform any needed clean-up, and log the event
    // - this method is not thread-safe: caller should use fSessionCriticalSection
    procedure SessionDelete(aSessionIndex: integer);
    /// returns a copy of the user associated to a session ID
    // - returns nil if the session does not exist (e.g. if authentication is
    // disabled)
    // - caller MUST release the TSQLAuthUser instance returned (if not nil)
    // - this method IS thread-safe, and call internaly fSessionCriticalSection
    // (the returned TSQLAuthUser is a private copy from fSessions[].User instance,
    // in order to be really thread-safe)
    // - the returned TSQLAuthUser instance will have GroupRights=nil but will
    // have ID, LogonName, DisplayName, PasswordHashHexa and Data fields available
    function SessionGetUser(aSessionID: Cardinal): TSQLAuthUser;
    /// returns TRUE if this table is worth caching (e.g. already in memory)
    // - this overriden implementation returns FALSE for TSQLRestServerStaticInMemory
    function CacheWorthItForTable(aTableIndex: cardinal): boolean; override;
    /// get a member from its ID (implements REST GET member)
    // - returns the data of this object as JSON
    // - override this method for proper data retrieval from the database engine
    // - this method must be implemented in a thread-safe manner
    // - ForUpdate parameter is used only on Client side
    function EngineRetrieve(TableModelIndex: integer; ID: integer): RawUTF8; virtual; abstract;
    /// virtual method called when a record is updated
    // - default implementation will call the OnUpdateEvent method, if defined
    // - returns true on success, false if an error occured (but action must continue)
    // - you can override this method to implement a server-wide notification,
    // but be aware it may be the first step to break the stateless architecture
    // of the framework
    function InternalUpdateEvent(aEvent: TSQLEvent; aTable: TSQLRecordClass; aID: integer): boolean; virtual;
  public
    /// this integer property is incremented by the database engine when any SQL
    // statement changes the database contents (i.e. on any not SELECT statement)
    // - its value can be published to the client on every remote request
    // - it may be used by client to avoid retrieve data only if necessary
    // - if its value is 0, this feature is not activated on the server, and the
    // client must ignore it and always retrieve the content
    InternalState: Cardinal;
    /// a method can be specified here to trigger events after any table update
    // - is called BEFORE deletion, and AFTER insertion or update 
    // - to be used only server-side, not to synchronize some clients: the framework
    // is designed around a stateless RESTful architecture (like HTTP/1.1), in which
    // clients ask the server for refresh (see TSQLRestClientURI.UpdateFromServer)
    OnUpdateEvent: TNotifySQLEvent;
    /// this property can be used to specify the URI parmeters to be used
    // for query paging
    // - is set by default to PAGINGPARAMETERS_YAHOO constant by
    // TSQLRestServer.Create() constructor
    URIPagingParameters: TSQLRestServerURIPagingParameters;

    /// implement Server-Side TSQLRest Retrieval (GET or LOCK methods)
    // - uses internally EngineRetrieve() function for calling the database engine
    // (via fStaticData[] if the table is stored as Static)
    // - handles locking if necessary
    // - if ForUpdate is true, the REST method is LOCK and not GET: it tries to lock
    // the corresponding record, then retrieve its content; caller has to call
    // UnLock() method after Value usage, to release the record
    function Retrieve(aID: integer; Value: TSQLRecord; ForUpdate: boolean=false): boolean; override;
    /// Execute directly a SQL statement, expecting a list of results
    // - return a result table on success, nil on failure
    // - will call EngineList() abstract method to retrieve its JSON content
    function ExecuteList(const Tables: array of TSQLRecordClass; const SQL: RawUTF8): TSQLTableJSON; override;
    /// implement Server-Side TSQLRest adding
    // - uses internally EngineAdd() function for calling the database engine
    // - call corresponding fStaticData[] if necessary
    // - on success, returns the new ROWID value; on error, returns 0
    // - on success, Value.ID is updated with the new ROWID
    // - if aValue is TSQLRecordFTS3, Value.ID is stored to the virtual table
    function Add(Value: TSQLRecord; SendData: boolean; ForceID: boolean=false): integer; override;
    /// implement Server-Side TSQLRest update
    // - uses internally EngineUpdate() function for calling the database engine
    // - call corresponding fStaticData[] if necessary
    function Update(Value: TSQLRecord): boolean; override;
    /// implement Server-Side TSQLRest deletion
    // - uses internally EngineDelete() function for calling the database engine
    // - call corresponding fStaticData[] if necessary
    // - this record is also erased in all available TRecordReference properties
    // in the database Model, for relational database coherency
    function Delete(Table: TSQLRecordClass; ID: integer): boolean; override;
    /// implement Server-Side TSQLRest deletion with a WHERE clause
    // - will process all ORM-level validation, coherency checking and
    // notifications together with a low-level SQL deletion work (if possible)
    function Delete(Table: TSQLRecordClass; const SQLWhere: RawUTF8): boolean; override;
    /// overriden method for direct static class call (if any)
    function TableRowCount(Table: TSQLRecordClass): integer; override;
    /// overriden method for direct static class call (if any)
    function TableHasRows(Table: TSQLRecordClass): boolean; override;
    /// this method is called internally after any successfull deletion to
    // ensure relational database coherency
    // - delete all available TRecordReference properties pointing to this record
    // in the database Model, for database coherency
    // - delete all available TSQLRecord properties pointing to this record
    // in the database Model, for database coherency
    // - important notice: we don't use FOREIGN KEY constraints in this framework,
    // and handle all integrity check within this method (it's therefore less
    // error-prone, and more cross-database engine compatible)S
    function AfterDeleteForceCoherency(Table: TSQLRecordClass; aID: integer): boolean; virtual;
    /// implement Server-Side TSQLRest blob field content retrieval
    // - implements REST GET member with a supplied member ID and a blob field name
    // - uses internally EngineRetrieveBlob() function for calling the database engine
    // - call corresponding fStaticData[] if necessary
    // - this method retrieve the blob data as a TSQLRawBlob string
    function RetrieveBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; out BlobData: TSQLRawBlob): boolean; override;
    /// implement Server-Side TSQLRest blob field content update
    // - implements REST PUT member with a supplied member ID and field name
    // - uses internally EngineUpdateBlob() function for calling the database engine
    // - this method expect the blob data to be supplied as a TSQLRawBlob string
    function UpdateBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; const BlobData: TSQLRawBlob): boolean; override;
    /// update all BLOB fields of the supplied Value
    // - this overriden method will execute the direct static class, if any
    function UpdateBlobFields(Value: TSQLRecord): boolean; override;
    /// get all BLOB fields of the supplied value from the remote server
    // - this overriden method will execute the direct static class, if any
    function RetrieveBlobFields(Value: TSQLRecord): boolean; override;
    /// implement Server-Side TSQLRest unlocking
    // - implements our custom UNLOCK REST-like method
    // - locking is handled by TSQLServer.Model
    // - returns true on success
    function UnLock(Table: TSQLRecordClass; aID: integer): boolean; override;
    {/ end a transaction (implements REST END Member)
     - write all pending TSQLVirtualTableJSON data to the disk }
    procedure Commit(SessionID: cardinal); override;
    /// Execute directly all SQL statement (POST SQL on ModelRoot URI)
    // - return true on success
    // - override this method for proper calling the database engine
    // - don't call this method in normal cases
    // - this method must be implemented to be thread-safe
    function EngineExecuteAll(const aSQL: RawUTF8): boolean; virtual; abstract;

{$ifdef MSWINDOWS}
    /// declare the server on the local machine as a Named Pipe: allows
    // TSQLRestClientURINamedPipe local or remote client connection
    // - ServerApplicationName ('DBSERVER' e.g.) will be used to create a named
    // pipe server identifier, it is of UnicodeString type since Delphi 2009
    // (use of Unicode FileOpen() version)
    // - this server identifier is appended to '\\.\pipe\mORMot_' to obtain
    // the full pipe name to initiate ('\\.\pipe\mORMot_DBSERVER' e.g.)
    // - this server identifier may also contain a fully qualified path
    // ('\\.\pipe\ApplicationName' e.g.)
    // - allows only one ExportServer*() by running process
    // - returns true on success, false otherwize (ServerApplicationName already used?)
    function ExportServerNamedPipe(const ServerApplicationName: TFileName): boolean;
    /// end any currently initialized named pipe server
    function CloseServerNamedPipe: boolean;
    /// grant access to this database content from a dll using the global
    // URIRequest() function
    // - returns true if the URIRequest() function is set to this TSQLRestServer
    // - returns false if a TSQLRestServer was already exported
    // - client must release all memory acquired by URIRequest() with GlobalFree()
    function ExportServer: boolean; overload;
    /// declare the server on the local machine to be accessible for local
    // client connection, by using Windows messages
    // - the data is sent and received by using the standard and fast WM_COPYDATA message
    // - Windows messages are very fast (faster than named pipe and much faster
    // than HTTP), but only work localy on the same computer
    // - create a new Window Class with the supplied class name (UnicodeString
    // since Delphi 2009 for direct use of Wide Win32 API), and instanciate
    // a window which will handle pending WM_COPYDATA messages
    // - the main server instance has to process the windows messages regularely
    // (e.g. with Application.ProcessMessages)
    // - ServerWindowName ('DBSERVER' e.g.) will be used to create a
    // Window name identifier
    // - allows only one ExportServer*() by running process
    // - returns true on success, false otherwize (ServerWindowName already used?)
    function ExportServerMessage(const ServerWindowName: string): boolean;
    /// implement a message-based server response
    // - this method is called automaticaly if ExportServerMessage() method
    // was initilialized
    // - you can also call this method from the WM_COPYDATA message handler
    // of your main form, and use the TSQLRestClientURIMessage class to access
    // the server instance from your clients
    // - it will answer to the Client with another WM_COPYDATA message
    // - message oriented architecture doesn't need any thread, but will use
    // the main thread of your application
    procedure AnswerToMessage(var Msg: TWMCopyData); message WM_COPYDATA;
    /// end any currently initialized message-oriented server
    function CloseServerMessage: boolean;
{$endif}
    /// Server initialization with a specified Database Model
    // - if HandleUserAuthentication is false, will set URI access rights to
    // 'Supervisor' (i.e. all R/W access) by default
    // - if HandleUserAuthentication is true, will add TSQLAuthUser and
    // TSQLAuthGroup to the TSQLModel (if not already there)
    constructor Create(aModel: TSQLModel; aHandleUserAuthentication: boolean=false); reintroduce;
    /// release memory and any existing pipe initialized by ExportServer()
    destructor Destroy; override;
    /// create an external static in-memory database for a specific class
    // - call it just after Create, before TSQLRestServerDB.CreateMissingTables;
    // warning: if you don't call this method before CreateMissingTable method
    // is called, the table will be created as a regular table by the main
    // database engine, and won't be static
    // - can load the table content from a file if a file name is specified
    // (could be either JSON or compressed Binary format on disk)
    // - you can define a particular external engine by setting a custom class -
    // by default, it will create a TSQLRestServerStaticInMemory instance
    // - this data handles basic REST commands, since no complete SQL interpreter
    // can be implemented by TSQLRestServerStatic; to provide full SQL process,
    // you should better use a Virtual Table class, inheriting e.g. from
    // TSQLRecordVirtualTableAutoID associated with TSQLVirtualTableJSON/Binary
    // via a Model.VirtualTableRegister() call before TSQLRestServer.Create 
    // - return nil on any error, or an EModelException if the class is not in
    // the database model
    function StaticDataCreate(aClass: TSQLRecordClass;
      const aFileName: TFileName = ''; aBinaryFile: boolean=false;
      aServerClass: TSQLRestServerStaticClass=nil): TSQLRestServerStatic;
    /// call this method when the internal DB content is known to be invalid
    // - by default, all REST/CRUD requests and direct SQL statements are
    // scanned and identified as potentially able to change the internal SQL/JSON
    // cache used at SQLite3 database level; but some virtual tables (e.g.
    // TSQLRestServerStaticExternal classes defined in SQLite3DB) could flush
    // the database content without proper notification
    // - this default implementation just do nothing, but SQlite3 unit
    // will call TSQLDataBase.CacheFlush method
    procedure FlushInternalDBCache; virtual;
    /// you can call this method in TThread.Execute to ensure that
    // the thread will be taken in account during process
    // - caller must specify the TThread instance running
    // - used e.g. for optExecInMainThread option in TServiceMethod.InternalExecute
    // - this default implementation will call the methods of all its internal
    // TSQLRestServerStatic instances
    // - this method shall be called from the thread just initiated: e.g.
    // if you call it from the main thread, it may fail to prepare resources
    procedure BeginCurrentThread(Sender: TThread); virtual;
    /// you can call this method just before a thread is finished to ensure
    // e.g. that the associated external DB connection will be released
    // - this default implementation will call the methods of all its internal
    // TSQLRestServerStatic instances, allowing e.g. TSQLRestServerStaticExternal
    // instances to clean their thread-specific connections
    // - this method shall be called from the thread about to be terminated: e.g.
    // if you call it from the main thread, it may fail to release resources
    // - it is set e.g. by TSQLite3HttpServer to be called from HTTP threads,
    // or by TSQLRestServerNamedPipeResponse for named-pipe server cleaning
    procedure EndCurrentThread(Sender: TObject); virtual;

    /// implement a generic local, piped or HTTP/1.1 provider
    // - this is the main entry point of the server, from the client side
    // - default implementation calls protected methods EngineList() Retrieve()
    // Add() Update() Delete() UnLock() EngineExecute() above, which must be overriden by
    // the TSQLRestServer child
    // - for 'GET ModelRoot/TableName', url parameters can be either "select" and
    // "where" (to specify a SQL Query, from the SQLFromSelectWhere function),
    // either "sort", "dir", "startIndex", "results", as expected by the YUI
    // DataSource Request Syntax for data pagination - see
    // http://developer.yahoo.com/yui/datatable/#data
    procedure URI(var Call: TSQLRestServerURIParams); virtual;

    /// create an index for the specific FieldName
    // - will call CreateSQLMultiIndex() internaly
    function CreateSQLIndex(Table: TSQLRecordClass; const FieldName: RawUTF8;
      Unique: boolean; const IndexName: RawUTF8=''): boolean; overload;
    /// create one or multiple index(es) for the specific FieldName(s)
    function CreateSQLIndex(Table: TSQLRecordClass; const FieldNames: array of RawUTF8;
      Unique: boolean): boolean; overload;
    /// create one index for all specific FieldNames at once
    function CreateSQLMultiIndex(Table: TSQLRecordClass; const FieldNames: array of RawUTF8;
      Unique: boolean; IndexName: RawUTF8=''): boolean; virtual;

    /// call this method to disable Authentication method check for a given
    // published method name
    // - by default, only Auth and TimeStamp methods do not require the RESTful
    // authentication of the URI; you may call this method to add another method
    // to the list (e.g. for returning some HTML content from a public URI)
    procedure ServiceMethodByPassAuthentication(const aMethodName: RawUTF8);

    /// register a Service on the server side
    // - this methods expects a class to be supplied, and the exact list of
    // interfaces to be registered to the server (e.g. [TypeInfo(IMyInterface)])
    // and implemented by this class
    // - class can be any TInterfacedObject, but TInterfacedObjectWithCustomCreate
    // can be used if you need an overriden constructor
    // - instance implementation pattern will be set by the appropriate parameter
    // - will return the first of the registered TServiceFactoryServer created
    // on success (i.e. the one corresponding to the first item of the aInterfaces
    // array), or nil if registration failed (e.g. if any of the supplied interfaces
    // is not implemented by the given class)
    // - you can use the returned TServiceFactoryServer instance to set the
    // expected security parameters associated with this interface
    // - the same implementation class can be used to handle several interfaces
    // (just as Delphi allows to do natively)
    function ServiceRegister(aImplementationClass: TInterfacedClass;
      const aInterfaces: array of PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation=sicSingle): TServiceFactoryServer; overload; virtual;
    /// register a remote Service via its interface
    // - this overloaded method will register a remote Service, accessed via the
    // supplied TSQLRest(ClientURI) instance: it can be available in the main
    // TSQLRestServer.Services property, but execution will take place on a
    // remote server - may be used e.g. for dedicated hosting of services (in
    // a DMZ for instance)
    // - this methods expects a list of interfaces to be registered to the client
    // (e.g. [TypeInfo(IMyInterface)])
    // - instance implementation pattern will be set by the appropriate parameter
    // - will return true on success, false if registration failed (e.g. if any of
    // the supplied interfaces is not correct or is not available on the server)
    // - that is, server side will be called to check for the availability of
    // each interface
    // - you can specify an optional custom contract for the first interface
    function ServiceRegister(aClient: TSQLRest; const aInterfaces: array of PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation=sicSingle;
      const aContractExpected: RawUTF8=''): boolean; overload; virtual;

    /// set this property to true to transmit the JSON data in a "not expanded" format
    // - not directly compatible with Javascript object list decode: not to be
    // used in AJAX environnement (like in TSQLite3HttpServer)
    // - but transmitted JSON data is much smaller if set it's set to FALSE, and
    // if you use a Delphi Client, parsing will be also faster and memory usage
    // will be lower
    // - By default, the NoAJAXJSON property is set to TRUE in
    // TSQLRestServer.ExportServerNamedPipe: if you use named pipes for communication,
    // you probably won't use javascript because browser communicates via HTTP!
    // - But otherwise, NoAJAXJSON property is set to FALSE. You could force its
    // value to TRUE and you'd save some bandwidth if you don't use javascript:
    // even the parsing of the JSON Content will be faster with Delphi client
    // if JSON content is not expanded
    // - the "expanded" or standard/AJAX layout allows you to create pure JavaScript
    // objects from the JSON content, because the field name / JavaScript object
    // property name is supplied for every value
    // - the "not expanded" layout, NoAJAXJSON property is set to TRUE,
    // reflects exactly the layout of the SQL request - first line contains the
    // field names, then all next lines are the field content
    property NoAJAXJSON: boolean read fNoAJAXJSON write SetNoAJAXJSON;
    /// set to true if the server will handle per-user authentication and
    // access right management
    // - i.e. if the associated TSQLModel contains TSQLAuthUser and
    // TSQLAuthGroup tables (set by constructor)
    property HandleAuthentication: boolean read fHandleAuthentication;
    /// access to the Server statistics
    property Stats: TSQLRestServerStats read fStats;
    /// retrieve the TSQLRestServerStatic instance used to store and manage
    // a specified TSQLRecordClass in memory
    // - has been associated by the StaticDataCreate method
    property StaticDataServer[aClass: TSQLRecordClass]: TSQLRestServerStatic
      read GetStaticDataServer;
    /// retrieve a running TSQLRestServerStatic virtual table
    // - associated e.g. to a 'JSON' or 'Binary' virtual table module, or may
    // return a TSQLRestServerStaticExternal instance (as defined in SQLite3DB)
    // - this property will return nil if there is no Virtual Table associated
    // or if the corresponding module is not a TSQLVirtualTable
    // (e.g. "pure" static tables registered by StaticDataCreate would be
    // accessible only via StaticDataServer[], not via StaticVirtualTable[])
    // - has been associated by the TSQLModel.VirtualTableRegister method or
    // the VirtualTableExternalRegister() global function
    property StaticVirtualTable[aClass: TSQLRecordClass]: TSQLRestServerStatic
      read GetVirtualTable;
    /// this property can be left to its TRUE default value, to handle any
    // TSQLVirtualTableJSON static tables (module JSON or BINARY) with direct
    // calls to the storage instance
    // - is set to TRUE by default to enable faster Direct mode
    // - in Direct mode, GET/POST/PUT/DELETE of individual records (or BLOB fields)
    // from URI() will call directly the corresponding TSQLRestServerStatic
    // instance, for better speed for most used RESTful operations; but complex
    // SQL requests (e.g. joined SELECT) will rely on the main SQL engine
    // - if set to false, will use the main SQLite3 engine for all statements
    // (should not to be used normaly, because it will add unnecessary overhead)
    property StaticVirtualTableDirect: boolean read fVirtualTableDirect
      write fVirtualTableDirect;
  published
    /// this method will be accessible from ModelRoot/Stat URI, and
    // will retrieve some statistics as a JSON object
    // - method parameters signature matches TSQLRestServerCallBack type
    procedure Stat(var Ctxt: TSQLRestServerCallBackParams);
    /// this method will be accessible from ModelRoot/Auth URI, and
    // will be called by the client for authentication and session management
    // - method parameters signature matches TSQLRestServerCallBack type
    // - to be called in a two pass "challenging" algorithm:
    // $ GET ModelRoot/auth?UserName=...
    // $  -> returns an hexadecimal nonce contents (valid for 5 minutes)
    // $ GET ModelRoot/auth?UserName=...&PassWord=...&ClientNonce=...
    // $ -> if password OK, open the corresponding session
    // $    and returns 'SessionID+HexaSessionPrivateKey'
    // The Password parameter as sent for the 2nd request will be computed as
    // ! Sha256(ModelRoot+Nonce+ClientNonce+UserName+Sha256('salt'+PassWord))
    // - the returned HexaSessionPrivateKey content will identify the current
    // user logged and its corresponding session (the same user may have several
    // sessions opened at once, each with its own private key)
    // - then the private session key must be added to every query sent to
    // the server as a session_signature=???? parameter, which will be computed
    // as such:
    // $ ModelRoot/url?A=1&B=2&session_signature=012345670123456701234567
    // were the session_signature= parameter will be computed as such:
    // ! Hexa8(SessionID)+Hexa8(TimeStamp)+
    // ! Hexa8(crc32('SessionID+HexaSessionPrivateKey'+Sha256('salt'+PassWord)+
    // !  Hexa8(TimeStamp)+url))
    // ! with url='ModelRoot/url?A=1&B=2'
    // this query authentication uses crc32 for hashing instead of SHA-256 in
    // in order to lower the Server-side CPU consumption; the salted password
    // (i.e. TSQLAuthUser.PasswordHashHexa) and client-side TimeStamp are
    // inserted inside the session_signature calculation to prevent naive
    // man-in-the-middle attack (MITM)
    // - the session ID will be used to retrieve the rights associated with the
    // user which opened the session via a successful call to the Auth service
    // - when you don't need the session any more (e.g. if the TSQLRestClientURI
    // instance is destroyed), you can call the service as such:
    // $ GET ModelRoot/auth?UserName=...&Session=...
    // - for a way of computing SHA-256 in JavaScript, see for instance
    // @http://www.webtoolkit.info/javascript-sha256.html
    // - this global callback method is thread-safe
    procedure Auth(var Ctxt: TSQLRestServerCallBackParams);
    /// this method will be accessible from the ModelRoot/TimeStamp URI, and
    // will return the server time stamp TTimeLog/Int64 value as RawUTF8
    // - method parameters signature matches TSQLRestServerCallBack type
    procedure TimeStamp(var Ctxt: TSQLRestServerCallBackParams);
    /// this method will be accessible from the ModelRoot/CacheFlush URI, and
    // will flush the server cache
    // - this method shall be called by the clients when the Server cache could
    // be not refreshed
    // - ModelRoot/CacheFlush URI will flush the whole Server cache, for all tables
    // - ModelRoot/CacheFlush/TableName URI will flush the specified table cache
    // - ModelRoot/CacheFlush/TableName/ID URI will flush the content of the
    // specified record
    // - method parameters signature matches TSQLRestServerCallBack type
    procedure CacheFlush(var Ctxt: TSQLRestServerCallBackParams);
    /// this method will be accessible from the ModelRoot/Batch URI, and
    // will execute a set of RESTful commands
    // - expect input as JSON commands - see TSQLRestServer.RunBatch, i.e.
    // & '{"Table":["cmd":values,...]}'
    // or for multiple tables:
    // & '["cmd@Table":values,...]'
    // with cmd in POST/PUT with {object} as value or DELETE with ID
    // - only accepted context HTTP verb is PUT (for thread-safe and security
    // reasons)
    procedure Batch(var Ctxt: TSQLRestServerCallBackParams);
  end;

  /// REST server with direct access to an external database engine
  // - you can set an alternate per-table database engine by using this class
  // - this abstract class is to be overriden with a proper implementation (like
  // our TSQLRestServerStaticInMemory class)
  TSQLRestServerStatic = class(TSQLRestServer)
  protected
    fStoredClass: TSQLRecordClass;
    fStoredClassProps: TSQLModelRecordProperties;
    fStoredClassRecordProps: TSQLRecordProperties;
    fFileName: TFileName;
    fModified: boolean;
    fOwner: TSQLRestServer;
    /// any set bit in this field indicates UNIQUE field value
    fIsUnique: TSQLFieldBits;
    procedure Lock(WillModifyContent: boolean);
    procedure UnLock;
    /// override this method if you want to update the refresh state
    // - returns FALSE if the static table content was not modified (default
    // method implementation is to always return FALSE)
    // - returns TRUE if the table has been refreshed and its content was modified:
    // therefore the client will know he'll need to refresh some content
    function RefreshedAndModified: boolean; virtual;
    /// overriden method calling the owner (if any) to guess if this record
    // can be updated or deleted
    function RecordCanBeUpdated(Table: TSQLRecordClass; ID: integer; Action: TSQLEvent;
      ErrorMsg: PRawUTF8 = nil): boolean; override;
    /// internal method called by TSQLRestServer.RunBatch() to process fast sending
    // to remote database engine (e.g. Oracle bound arrays or MS SQL Bulk insert)
    // - returns TRUE if this method is handled by the engine, or FALSE if
    // individual calls to Engine*() are expected
    // - this default implementation returns FALSE
    // - an overriden method returning TRUE shall ensure that calls to
    // EngineAdd / EngineUpdate / EngineDelete (depending of supplied Method)
    // will properly handle operations until InternalBatchStop is called
    function InternalBatchStart(Method: TSQLURIMethod): boolean; virtual;
    /// internal method called by TSQLRestServer.RunBatch() to process fast sending
    // to remote database engine (e.g. Oracle bound arrays or MS SQL Bulk insert)
    // - this default implementation does nothing (since InternalBatchStart
    // returns always FALSE)
    // - InternalBatchStart/Stop may safely use a lock for multithreading:
    // implementation in TSQLRestServer.RunBatch use a try..finally block
    procedure InternalBatchStop; virtual;
    /// TSQLRestServer.URI use it for Static.EngineList to by-pass virtual table
    // - this default implementation will return TRUE and replace SQL with
    // SQLSelectAll[true] if it SQL equals SQLSelectAll[false] (i.e. 'SELECT *')
    // - this method is called only if the WHERE clause of SQL refers to the
    // static table name only (not needed to check it twice)  
    function AdaptSQLForEngineList(var SQL: RawUTF8): boolean; virtual;
  public
    /// initialize the server data, reading it from a file if necessary
    // - data encoding on file is UTF-8 JSON format by default, or
    // should be some binary format if aBinaryFile is set to true (this virtual
    // method will just ignore this parameter, which will be used for overriden
    // constructor only)
    constructor Create(aClass: TSQLRecordClass; aServer: TSQLRestServer;
      const aFileName: TFileName = ''; aBinaryFile: boolean=false); virtual;
    
    /// overriden method for direct in-memory database engine call
    // - not implemented: always return false
    // - this method must be implemented to be thread-safe
    function EngineExecuteAll(const aSQL: RawUTF8): boolean; override;
    /// overriden method for direct in-memory database engine call
    // - made public since a TSQLRestServerStatic instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    // - do nothing method: will return FALSE (aka error)
    function EngineUpdateField(Table: TSQLRecordClass;
      const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean; override;
    /// search for a numerical field value
    // - return true on success (i.e. if some values have been added to ResultID)
    // - store the results into the ResultID dynamic array
    // - faster than OneFieldValues method, which creates a temporary JSON content
    // - this default implementation will call the overloaded SearchField()
    // value after conversion of the FieldValue into RawUTF8
    function SearchField(const FieldName: RawUTF8; FieldValue: Integer;
      var ResultID: TIntegerDynArray): boolean; overload; virtual;
    /// search for a field value, according to its SQL content representation
    // - return true on success (i.e. if some values have been added to ResultID)
    // - store the results into the ResultID dynamic array
    // - faster than OneFieldValues method, which creates a temporary JSON content
    function SearchField(const FieldName, FieldValue: RawUTF8;
      var ResultID: TIntegerDynArray): boolean; overload; virtual; abstract;

    /// read only access to the file name specified by constructor
    // - you can call the TSQLRestServer.StaticDataCreate method to
    // update the file name of an already instancied static table
    property FileName: TFileName read fFileName write fFileName;
    /// read only access to a boolean value set to true if table data was modified
    property Modified: boolean read fModified write fModified;
    /// read only access to the class defining the record type stored in this REST server
    property StoredClass: TSQLRecordClass read fStoredClass;
    /// read only access to the ORM properties of the associated record type
    // - may be nil if this instance is not associated with a TSQLModel
    property StoredClassProps: TSQLModelRecordProperties read fStoredClassProps;
    /// read only access to the RTTI properties of the associated record type
    property StoredClassRecordProps: TSQLRecordProperties read fStoredClassRecordProps;
    /// read only access to the Server using this in-memory database
    property Owner: TSQLRestServer read fOwner;
  end;

  /// event prototype called by FindWhereEqual() method
  TFindWhereEqualEvent = procedure(aDest: pointer; aRec: TSQLRecord; aIndex: integer) of object;

  /// abstract REST server exposing some internal TSQLRecord-based methods
  TSQLRestServerStaticRecordBased = class(TSQLRestServerStatic)
  protected
    function EngineAdd(Table: TSQLRecordClass; const SentData: RawUTF8): integer; override;
    function EngineUpdate(Table: TSQLRecordClass; ID: integer; const SentData: RawUTF8): boolean; override;
  public
    /// manual Add of a TSQLRecord
    // - returns the ID created on success
    // - returns -1 on failure (not UNIQUE field value e.g.)
    // - on success, the Rec instance is added to the Values[] list: caller
    // doesn't need to Free it
    function AddOne(Rec: TSQLRecord; ForceID: boolean): integer; virtual; abstract;
    /// manual Retrieval of a TSQLRecord field values
    // - an instance of the associated static class is created
    // - and all its properties are filled from the Items[] values
    // - caller can modify these properties, then use UpdateOne() if the changes
    // have to be stored inside the Items[] list
    // - calller must always free the returned instance
    // - returns NIL if any error occured, e.g. if the supplied aID was incorrect
    // - method available since a TSQLRestServerStatic instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    function GetOne(aID: integer): TSQLRecord; virtual; abstract;
    /// manual Update of a TSQLRecord field values
    // - Rec.ID specifies which record is to be updated
    // - will update all properties, including BLOB fields and such
    // - returns TRUE on success, FALSE on any error (e.g. invalid Rec.ID)
    // - method available since a TSQLRestServerStatic instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    function UpdateOne(Rec: TSQLRecord): boolean; overload; virtual; abstract;
    /// manual Update of a TSQLRecord field values from TVarData array
    // - will update all properties, including BLOB fields and such
    // - returns TRUE on success, FALSE on any error (e.g. invalid Rec.ID)
    // - method available since a TSQLRestServerStatic instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    // - this default implementation will create a temporary TSQLRecord instance
    // with the supplied Values[], and will call overloaded UpdateOne() method
    function UpdateOne(ID: integer; const Values: TVarDataDynArray): boolean; overload; virtual;
  end;

  /// class able to handle a O(1) hashed-based search of a property in a TList 
  // - used e.g. to hash TSQLRestServerStaticInMemory field values
  TListFieldHash = class(TObjectHash)
  protected
    fValues: TList;
    fField: integer;
    fProp: TSQLPropInfo;
    fCaseInsensitive: boolean;
    /// overriden method to hash an item
    function Hash(Item: TObject): cardinal; override;
    /// overriden method to compare two items
    function Compare(Item1,Item2: TObject): boolean; override;
    /// overriden method to get an item
    // - shall return nil if Index is out of range (e.g. >= Count)
    // - will be called e.g. by Find() with Compare() to avoid collision
    function Get(Index: integer): TObject; override;
    /// overriden method to retrieve the number of items
    function Count: integer; override;
  public
    /// initialize a hash for a record array field
    // - aFieldIndex/aField parameters correspond to the indexed field (e.g.
    // "stored AS_UNIQUE" published property)
    // - if CaseInsensitive is TRUE, will apply NormToUpper[] 8 bits uppercase,
    // handling RawUTF8 properties just like the SYSTEMNOCASE collation
    constructor Create(aValues: TList; aFieldIndex: integer;
      aField: TSQLPropInfo; aCaseInsensitive: boolean);
    /// the corresponding field index in the TSQLRecord
    property FieldIndex: integer read fField;
    /// the corresponding field RTTI
    property Field: TSQLPropInfo read fProp;
    /// if the string comparison shall be case-insensitive
    property CaseInsensitive: boolean read fCaseInsensitive;
  end;

  /// REST server with direct access to a memory-stored database
  // - store the associated TSQLRecord values in memory
  // - handle only one TSQLRecord by server (it's NOT a true Rest Server)
  // - must be registered individualy in a TSQLRestServer to access data from a
  // common client, by using the TSQLRestServer.StaticDataCreate method:
  // it allows an unique access for both SQLite3 and Static databases
  // - handle basic REST commands, no SQL interpreter is implemented: only
  // valid SQL command is "SELECT Field1,Field2 FROM Table WHERE ID=120;", i.e
  // a one Table SELECT with one optional "WHERE fieldname = value" statement;
  // if used within a TSQLVirtualTableJSON, you'll be able to handle any kind of
  // SQL statement (even joined SELECT or such) with this memory-stored database
  // - our TSQLRestServerStatic database engine is very optimized and is a lot
  // faster than SQLite3 for such queries - but its values remain in RAM,
  // therefore it is not meant to deal with more than 100,000 rows
  // - data can be stored and retrieved from a file (JSON format is used by
  // default, if BinaryFile parameter is left to false; a proprietary compressed
  // binary format can be used instead) if a file name is supplied at creating
  // the TSQLRestServerStaticInMemory instance
  TSQLRestServerStaticInMemory = class(TSQLRestServerStaticRecordBased)
  protected
    fValue: TObjectList;
    /// true if IDs are sorted (which is the default behavior of this class),
    // for fastest ID2Index() by using a binary search algorithm
    fIDSorted: boolean;
    fCommitShouldNotUpdateFile: boolean;
    fBinaryFile: boolean;
    fExpandedJSON: boolean;
    fSearchRec: TSQLRecord;
    fBasicUpperSQLWhere: RawUTF8;
    fBasicSQLCount: RawUTF8;
    fBasicSQLHasRows: RawUTF8;
    fUniqueFields: TObjectList;
    function UniqueFieldsUpdateOK(aRec: TSQLRecord; aUpdateIndex: integer): boolean;
    function UniqueFieldHash(aFieldIndex: integer): TListFieldHash;
    function GetCount: integer;
    function GetItem(Index: integer): TSQLRecord;
    function GetID(Index: integer): integer;
    // optimized search of WhereValue in WhereField (0=RowID,1..=RTTI)
    function FindWhereEqual(WhereField: integer; const WhereValue: RawUTF8;
      OnFind: TFindWhereEqualEvent; Dest: pointer; FoundLimit,FoundOffset: integer): PtrInt;
    procedure GetJSONValuesEvent(aDest: pointer; aRec: TSQLRecord; aIndex: integer);
    procedure AddIntegerDynArrayEvent(aDest: pointer; aRec: TSQLRecord; aIndex: integer);
    procedure DoNothingEvent(aDest: pointer; aRec: TSQLRecord; aIndex: integer);
    /// used to create the JSON content from a SELECT parsed command
    // - WhereField index follows FindWhereEqual / TSynTableStatement.WhereField
    // - returns the number of data row added (excluding field names)
    // - this method is very fast and optimized (for search and JSON serializing)
    function GetJSONValues(Stream: TStream; Expand, withID: boolean;
      const Fields: TSQLFieldBits; WhereField: integer; const WhereValue: RawUTF8;
      FoundLimit,FoundOffset: integer): PtrInt;
    /// TSQLRestServer.URI use it for Static.EngineList to by-pass virtual table
    // - overriden method to handle basic queries as handled by EngineList()
    function AdaptSQLForEngineList(var SQL: RawUTF8): boolean; override;
    /// overriden methods for direct in-memory database engine thread-safe process
    function EngineRetrieve(TableModelIndex: integer; ID: integer): RawUTF8; override;
    function EngineList(const SQL: RawUTF8; ForceAJAX: Boolean=false; ReturnedRowCount: PPtrInt=nil): RawUTF8; override;
    function EngineUpdate(Table: TSQLRecordClass; ID: integer; const SentData: RawUTF8): boolean; override;
    function EngineRetrieveBlob(Table: TSQLRecordClass; aID: integer;
      BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean; override;
    function EngineUpdateBlob(Table: TSQLRecordClass; aID: integer;
      BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean; override;
    function EngineDeleteWhere(Table: TSQLRecordClass; const SQLWhere: RawUTF8;
      const IDs: TIntegerDynArray): boolean; override;
  public
    /// initialize the server data, reading it from a file if necessary
    // - data encoding on file is UTF-8 JSON format by default, or
    // should be some binary format if aBinaryFile is set to true
    constructor Create(aClass: TSQLRecordClass; aServer: TSQLRestServer;
      const aFileName: TFileName = ''; aBinaryFile: boolean=false); override;
    /// free used memory
    // - especially release all fValue[] instances
    destructor Destroy; override;

    /// load the values from JSON data
    procedure LoadFromJSON(const aJSON: RawUTF8); overload;
    /// load the values from JSON data
    procedure LoadFromJSON(JSONBuffer: PUTF8Char; JSONBufferLen: integer); overload;
    /// save the values into JSON data
    function SaveToJSON(Expand: Boolean): RawUTF8; overload;
    /// save the values into JSON data
    procedure SaveToJSON(Stream: TStream; Expand: Boolean); overload;
    /// load the values from binary data
    // - the binary format is a custom compressed format (using our SynLZ fast
    // compression algorithm), with variable-length record storage
    // - the binary content is first checked for consistency, before loading
    // - warning: the field layout should be the same at SaveToBinary call;
    // for instance, it won't be able to read a file content with a renamed
    // or modified field type 
    // - will return false if the binary content is invalid
    function LoadFromBinary(Stream: TStream): boolean;
    /// save the values into binary data
    // - the binary format is a custom compressed format (using our SynLZ fast
    // compression algorithm), with variable-length record storage: e.g. a 27 KB
    // Dali1.json content is stored into a 6 KB Dali2.data file
    // (this data has a text redundant field content in its FirstName field);
    // 502 KB People.json content is stored into a 92 KB People.data file
    // - returns the number of bytes written into Stream
    function SaveToBinary(Stream: TStream): integer;
    /// if file was modified, the file is updated on disk
    // - this method is called automaticaly when the TSQLRestServerStatic
    // instance is destroyed: should should want to call in in some cases,
    // in order to force the data to be saved regularly
    // - do nothing if the table content was not modified
    // - will write JSON content by default, or binary content if BinaryFile
    // property was set to true
    procedure UpdateFile;
    /// retrieve the index in Items[] of a particular ID
    // - return -1 if this ID was not found
    // - use fast binary search algorithm (since Items[].ID should be increasing)
    function IDToIndex(ID: integer): integer;
    /// manual Add of a TSQLRecord
    // - returns the ID created on success
    // - returns -1 on failure (not UNIQUE field value e.g.)
    // - on success, the Rec instance is added to the Values[] list: caller
    // doesn't need to Free it
    function AddOne(Rec: TSQLRecord; ForceID: boolean): integer; override;
    /// manual Retrieval of a TSQLRecord field values
    // - an instance of the associated static class is created
    // - and all its properties are filled from the Items[] values
    // - caller can modify these properties, then use UpdateOne() if the changes
    // have to be stored inside the Items[] list
    // - calller must always free the returned instance
    // - returns NIL if any error occured, e.g. if the supplied aID was incorrect
    // - method available since a TSQLRestServerStatic instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    function GetOne(aID: integer): TSQLRecord; override;
    /// manual Update of a TSQLRecord field values
    // - Rec.ID specifies which record is to be updated
    // - will update all properties, including BLOB fields and such
    // - returns TRUE on success, FALSE on any error (e.g. invalid Rec.ID)
    // - method available since a TSQLRestServerStatic instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    function UpdateOne(Rec: TSQLRecord): boolean; override;
    /// manual Update of a TSQLRecord field values from TVarData array
    // - will update all properties, including BLOB fields and such
    // - returns TRUE on success, FALSE on any error (e.g. invalid Rec.ID)
    // - method available since a TSQLRestServerStatic instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    function UpdateOne(ID: integer; const Values: TVarDataDynArray): boolean; override;
    /// overriden method for direct in-memory database engine call
    // - made public since a TSQLRestServerStatic instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    function EngineDelete(Table: TSQLRecordClass; ID: integer): boolean; override;
    /// overriden method for direct in-memory database engine call
    // - made public since a TSQLRestServerStatic instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    function EngineUpdateField(Table: TSQLRecordClass;
      const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean; override;
    /// overriden method for direct in-memory database engine call
    function UpdateBlobFields(Value: TSQLRecord): boolean; override;
    /// overriden method for direct in-memory database engine call
    function RetrieveBlobFields(Value: TSQLRecord): boolean; override;
    /// overriden method for direct in-memory database engine call
    function TableRowCount(Table: TSQLRecordClass): integer; override;
    /// overriden method for direct in-memory database engine call
    function TableHasRows(Table: TSQLRecordClass): boolean; override;
    /// search for a field value, according to its SQL content representation
    // - return true on success (i.e. if some values have been added to ResultID)
    // - store the results into the ResultID dynamic array
    // - faster than OneFieldValues method, which creates a temporary JSON content
    function SearchField(const FieldName, FieldValue: RawUTF8;
      var ResultID: TIntegerDynArray): boolean; override;
    /// read-only access to the number of TSQLRecord values
    property Count: integer read GetCount;
    /// read-only access to the TSQLRecord values, storing the data
    // - this returns directly the item class instance stored in memory: if you
    // change the content, it will affect the internal data - so for instance
    // DO NOT change the ID values, unless you may have unexpected behavior
    property Items[Index: integer]: TSQLRecord read GetItem; default;
    /// read-only access to the ID of a TSQLRecord values
    property ID[Index: integer]: integer read GetID;
    /// if set to true, file content on disk will expect binary format
    // - default format on disk is JSON but can be overriden at constructor call
    // - binary format should be more efficient in term of speed and disk usage,
    // but can be proprietary
    property BinaryFile: boolean read fBinaryFile write fBinaryFile;
    // JSON writing, can set if the format should be expanded or not
    // - by default, the JSON will be in the custom non-expanded format,
    // to save disk space and time
    // - you can force the JSON to be emitted as an array of objects,
    // e.g. for better human friendliness (reading and modification)
    property ExpandedJSON: boolean read fExpandedJSON write fExpandedJSON;
    /// set this property to TRUE if you want the COMMIT statement not to
    // update the associated TSQLVirtualTableJSON
    property CommitShouldNotUpdateFile: boolean read fCommitShouldNotUpdateFile
      write fCommitShouldNotUpdateFile;
  end;

  /// REST server with direct access to a memory database, to be used as
  // external table
  // - this is the kind of in-memory table expected by TSQLVirtualTableJSON,
  // in order to be consistent with the internal DB cache
  TSQLRestServerStaticInMemoryExternal = class(TSQLRestServerStaticInMemory)
  public
    /// call this method when the internal DB content is known to be invalid
    // - by default, all REST/CRUD requests and direct SQL statements are
    // scanned and identified as potentially able to change the internal SQL/JSON
    // cache used at SQLite3 database level; but TSQLVirtualTableJSON virtual
    // tables could flush the database content without proper notification
    // - this overriden implementation will call Owner.FlushInternalDBCache
    procedure FlushInternalDBCache; override;
  end;

  /// a REST server using only in-memory tables
  // - this server will use TSQLRestServerStaticInMemory instances to handle
  // the data in memory, and optionally persist the data on disk as JSON or
  // binary files
  // - so it will not handle all SQL requests, just basic CRUD commands on
  // separated tables
  // - at least, it will compile as a TSQLRestServer without complaining for
  // pure abstract methods; it can be used to host some services if database
  // and ORM needs are basic (e.g. if only authentication and CRUD are needed)
  TSQLRestServerFullMemory = class(TSQLRestServer)
  protected
    fFileName: TFileName;
    fBinaryFile: Boolean;
    fStaticDataCount: cardinal;
    function GetStatic(Table: TSQLRecordClass): TSQLRestServerStaticInMemory;
    function EngineRetrieve(TableModelIndex: integer; ID: integer): RawUTF8; override;
    function EngineList(const SQL: RawUTF8; ForceAJAX: Boolean=false; ReturnedRowCount: PPtrInt=nil): RawUTF8; override;
    function EngineAdd(Table: TSQLRecordClass; const SentData: RawUTF8): integer; override;
    function EngineUpdate(Table: TSQLRecordClass; ID: integer; const SentData: RawUTF8): boolean; override;
    function EngineDelete(Table: TSQLRecordClass; ID: integer): boolean; override;
    function EngineDeleteWhere(Table: TSQLRecordClass; const SQLWhere: RawUTF8;
      const IDs: TIntegerDynArray): boolean; override;
    function EngineRetrieveBlob(Table: TSQLRecordClass; aID: integer;
      BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean; override;
    function EngineUpdateBlob(Table: TSQLRecordClass; aID: integer;
      BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean; override;
    function EngineUpdateField(Table: TSQLRecordClass;
      const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean; override;
  public
    /// initialize a REST server with a database file
    // - all classes of the model will be created as TSQLRestServerStaticInMemory
    // - then data persistence will be created using aFileName
    // - if aFileName is left void (''), data will not be persistent
    constructor Create(aModel: TSQLModel; const aFileName: TFileName='';
      aBinaryFile: boolean=false; aHandleUserAuthentication: boolean=false); reintroduce; virtual;
    /// write any modification on file (if needed), and release all used memory
    destructor Destroy; override;
    /// load the content from the specified file name
    // - do nothing if file name was not assigned
    procedure LoadFromFile; virtual;
    /// write any modification into file
    // - do nothing if file name was not assigned
    procedure UpdateToFile; virtual;
    /// overriden method for direct in-memory database engine call
    // - not implemented: always return false
    function EngineExecuteAll(const aSQL: RawUTF8): boolean; override;
    /// the file name used for data persistence
    property FileName: TFileName read fFileName write fFileName;
    /// set if the file content is to be compressed binary, or standard JSON
    // - it will use TSQLRestServerStaticInMemory LoadFromJSON/LoadFromBinary
    // SaveToJSON/SaveToBinary methods for optimized storage
    property BinaryFile: Boolean read fBinaryFile write fBinaryFile;
  end;

  /// a REST server using a TSQLRestClient for all its ORM process
  // - this server will use an internal TSQLRestClient instance to handle
  // all ORM operations (i.e. access to objects)
  // - it can be used e.g. to host some services on a stand-alone server, with
  // all ORM and data access retrieved from another server: it will allow to
  // easily implement a proxy architecture (for instance, as a DMZ for
  // publishing services, but letting ORM process stay out of scope)
  TSQLRestServerRemoteDB = class(TSQLRestServer)
  protected
    fClient: TSQLRestClient;
    function EngineRetrieve(TableModelIndex: integer; ID: integer): RawUTF8; override;
    function EngineList(const SQL: RawUTF8; ForceAJAX: Boolean=false; ReturnedRowCount: PPtrInt=nil): RawUTF8; override;
    function EngineAdd(Table: TSQLRecordClass; const SentData: RawUTF8): integer; override;
    function EngineUpdate(Table: TSQLRecordClass; ID: integer; const SentData: RawUTF8): boolean; override;
    function EngineDelete(Table: TSQLRecordClass; ID: integer): boolean; override;
    function EngineDeleteWhere(Table: TSQLRecordClass; const SQLWhere: RawUTF8;
      const IDs: TIntegerDynArray): boolean; override;
    function EngineRetrieveBlob(Table: TSQLRecordClass; aID: integer;
      BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean; override;
    function EngineUpdateBlob(Table: TSQLRecordClass; aID: integer;
      BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean; override;
    function EngineUpdateField(Table: TSQLRecordClass;
      const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean; override;
  public
    /// initialize a REST server associated to a given TSQLRestClient instance
    // - the specified TSQLRestClient will be used for all ORM and data process
    // - the supplied TSQLRestClient.Model will be used for TSQLRestServerRemoteDB
    // - note that the TSQLRestClient instance won't be freed - caller shall
    // manage its life time
    constructor Create(aRemoteClient: TSQLRestClient;
      aHandleUserAuthentication: boolean=false); reintroduce; virtual;
    /// implement Server-Side TSQLRest deletion
    /// overriden method for remote database engine call
    // - will return false - i.e. not implemented - since it is a server side
    // operation
    function EngineExecuteAll(const aSQL: RawUTF8): boolean; override;
    /// Execute directly a SQL statement, expecting a list of results
    // - return a result table on success, nil on failure
    // - will call EngineList() abstract method to retrieve its JSON content
    function ExecuteList(const Tables: array of TSQLRecordClass; const SQL: RawUTF8): TSQLTableJSON; override;
    /// this method is called internally after any successfull deletion to
    // ensure relational database coherency
    // - this overriden method will just return TRUE: in this remote access,
    // true coherency will be performed on the ORM server side
    function AfterDeleteForceCoherency(Table: TSQLRecordClass; aID: integer): boolean; override;
    /// the remote ORM client used for data persistence
    property Client: TSQLRestClient read fClient;
  end;


  /// possible call parameters for TOnTableUpdate Event
  TOnTableUpdateState = (tusPrepare, tusChanged, tusNoChange);

  /// used by TSQLRestClientURI.UpdateFromServer() to let the client
  // perform the rows update (for Marked[] e.g.)
  TOnTableUpdate = procedure(aTable: TSQLTableJSON; State: TOnTableUpdateState) of object;

  /// used by TSQLRestClientURI.Update() to let the client
  // perform the record update (refresh associated report e.g.)
  TOnRecordUpdate = procedure(Value: TSQLRecord) of object;

  /// a generic REpresentational State Transfer (REST) client
  // - is RESTful (i.e. URI) remotely implemented (TSQLRestClientURI e.g.)
  // - is implemented for direct access to a database (TSQLRestClientDB e.g.)
  TSQLRestClient = class(TSQLRest)
  protected
    fForceBlobTransfert: boolean;
    fOnTableUpdate: TOnTableUpdate;
    fOnRecordUpdate: TOnRecordUpdate;
    /// get a member from its ID (implements REST GET member)
    // - returns the data of this object as JSON
    // - override this method for proper data retrieval from the database engine
    // - this method must be implemented in a thread-safe manner
    function EngineRetrieve(TableModelIndex: integer; ID: integer;
      ForUpdate: boolean; var InternalState: cardinal; var Resp: RawUTF8): boolean; virtual; abstract;
    /// this method is called before updating any record
    // - should return FALSE to force no update
    // - can be use to update some field values just before saving to the database
    // (e.g. for digital signing purpose)
    // - this default method just return TRUE (i.e. OK to update)
    function BeforeUpdateEvent(Value: TSQLRecord): Boolean; virtual;
  public
    /// create a new member (implements REST POST Collection)
    // - URI is 'ModelRoot/TableName' with POST method
    // - if SendData is true, content of Value is sent to the server as JSON
    // - if ForceID is true, client sends the Value.ID field to use this ID
    // - server must return Status 201/HTML_CREATED on success
    // - server must send on success an header entry with 'Location: ModelRoot/TableName/ID
    // - on success, returns the new ROWID value; on error, returns 0
    // - on success, Value.ID is updated with the new ROWID
    // - if aValue is TSQLRecordFTS3, Value.ID is stored to the virtual table
    function Add(Value: TSQLRecord; SendData: boolean; ForceID: boolean=false): integer; override;
    /// update a member (implements REST PUT Collection/Member)
    // - URI is 'ModelRoot/TableName/ID' with PUT method
    // - server must return Status 200/HTML_SUCCESS OK on success
    function Update(Value: TSQLRecord): boolean; override;
    /// delete a member (implements REST DELETE Collection/Member)
    // - URI is 'ModelRoot/TableName/ID' with DELETE method
    // - server must return Status 200/HTML_SUCCESS OK on success
    function Delete(Table: TSQLRecordClass; ID: integer): boolean; override;
    /// get a member from its ID (implements REST GET Collection/Member)
    // - URI is 'ModelRoot/TableName/ID' with GET method
    // - server must return Status 200/HTML_SUCCESS OK on success
    // - if ForUpdate is true, the REST method is LOCK and not GET: it tries to lock
    // the corresponding record, then retrieve its content; caller has to call
    // UnLock() method after Value usage, to release the record
    function Retrieve(aID: integer; Value: TSQLRecord; ForUpdate: boolean=false): boolean; override;
    /// get a blob field content from its record ID and supplied blob field name
    // - implements REST GET member with a supplied member ID and a blob field name
    // - URI is 'ModelRoot/TableName/ID/BlobFieldName' with GET method
    // - server must return Status 200/HTML_SUCCESS OK on success
    // - this method retrieve the blob data as a TSQLRawBlob string
    function RetrieveBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; out BlobData: TSQLRawBlob): boolean; override;
    /// update a blob field from its record ID and supplied blob field name
    // - implements REST PUT member with a supplied member ID and field name
    // - URI is 'ModelRoot/TableName/ID/BlobFieldName' with PUT method
    // - server must return Status 200/HTML_SUCCESS OK on success
    // - this method expect the blob data to be supplied as a TSQLRawBlob string
    function UpdateBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; const BlobData: TSQLRawBlob): boolean; override;
    /// get a member from its ID (implements REST GET Collection/Member)
    // - URI is 'ModelRoot/TableName/ID' with GET method
    // - returns true on server returned 200/HTML_SUCCESS OK success, false on error
    // - set Refreshed to true if the content changed
    function Refresh(aID: integer; Value: TSQLRecord; var Refreshed: boolean): boolean;

    /// retrieve a list of members as a TSQLTable (implements REST GET Collection)
    // - default SQL statement is 'SELECT ID FROM TableName;' (i.e. retrieve
    // the list of all ID of this collection members)
    // - optional SQLSelect parameter to change the returned fields
    // as in 'SELECT SQLSelect FROM TableName;'
    // - optional SQLWhere parameter to change the search range or ORDER
    // as in 'SELECT SQLSelect FROM TableName WHERE SQLWhere;'
    // - using inlined parameters via :(...): in SQLWhere is always a good idea
    // - for one TClass, you should better use TSQLRest.MultiFieldValues()
    function List(const Tables: array of TSQLRecordClass; const SQLSelect: RawUTF8 = 'RowID';
      const SQLWhere: RawUTF8 = ''): TSQLTableJSON; virtual; abstract;
    /// retrieve a list of members as a TSQLTable (implements REST GET Collection)
    // - in this version, the WHERE clause can be created with the same format
    // as FormatUTF8() function, replacing all '%' chars with Args[] values
    // - using inlined parameters via :(...): in SQLWhereFormat is always a good idea
    // - for one TClass, you should better use TSQLRest.MultiFieldValues()
    // - will call the List virtual method internaly
    function ListFmt(const Tables: array of TSQLRecordClass; const SQLSelect: RawUTF8;
      SQLWhereFormat: PUTF8Char; const Args: array of const): TSQLTableJSON; overload;
    /// retrieve a list of members as a TSQLTable (implements REST GET Collection)
    // - in this version, the WHERE clause can be created with the same format
    // as FormatUTF8() function, replacing all '%' chars with Args[], and all '?'
    // chars with Bounds[] (inlining them with :(...): and auto-quoting strings)
    // - example of use:
    // ! Table := ListFmt([TSQLRecord],'Name','ID=?',[],[aID]);
    // - for one TClass, you should better use TSQLRest.MultiFieldValues()
    // - will call the List virtual method internaly
    function ListFmt(const Tables: array of TSQLRecordClass; const SQLSelect: RawUTF8;
      SQLWhereFormat: PUTF8Char; const Args, Bounds: array of const): TSQLTableJSON; overload;
    /// Execute directly a SQL statement
    // - return true on success
    function EngineExecute(const SQL: RawUTF8): boolean; overload; virtual; abstract;
    /// Execute directly a SQL statement with supplied parameters
    // - expect the same format as FormatUTF8() function, replacing all '%' chars
    // with Args[] values
    // - return true on success
    function EngineExecuteFmt(SQLFormat: PUTF8Char; const Args: array of const): boolean; overload;
    /// Execute directly a SQL statement with supplied parameters
    // - expect the same format as FormatUTF8() function, replacing all '%' chars
    // with Args[] values, and all '?' chars with Bounds[] (inlining them
    // with :(...): and auto-quoting strings)
    // - return true on success
    function EngineExecuteFmt(SQLFormat: PUTF8Char; const Args, Bounds: array of const): boolean; overload;
    /// dedicated method used to retrieve matching IDs using a fast R-Tree index
    // - a TSQLRecordRTree is associated to a TSQLRecord with a specified BLOB
    // field, and will call TSQLRecordRTree BlobToCoord and ContainedIn virtual
    // class methods to execute an optimized SQL query
    // - will return all matching DataTable IDs in DataID[]
    // - will generate e.g. the following statement
    // $ SELECT MapData.ID From MapData, MapBox WHERE MapData.ID=MapBox.ID
    // $  AND minX>=:(-81.0): AND maxX<=:(-79.6): AND minY>=:(35.0): AND :(maxY<=36.2):
    // $  AND MapBox_in(MapData.BlobField,:('\uFFF0base64encoded-81,-79.6,35,36.2'):);
    // when the following Delphi code is executed:
    // ! aClient.RTreeMatch(TSQLRecordMapData,'BlobField',TSQLRecordMapBox,
    // !   aMapData.BlobField,ResultID);
    function RTreeMatch(DataTable: TSQLRecordClass;
      const DataTableBlobFieldName: RawUTF8; RTreeTable: TSQLRecordRTreeClass;
      const DataTableBlobField: RawByteString; var DataID: TIntegerDynArray): boolean;
    /// begin a transaction (calls REST BEGIN Member)
    // - by default, Client transaction will use here a pseudo session
    function TransactionBegin(aTable: TSQLRecordClass; SessionID: cardinal=CONST_AUTHENTICATION_NOT_USED): boolean; override;
    /// end a transaction (calls REST END Member)
    // - by default, Client transaction will use here a pseudo session
    procedure Commit(SessionID: cardinal=CONST_AUTHENTICATION_NOT_USED); override;
    /// abort a transaction (calls REST ABORT Member)
    // - by default, Client transaction will use here a pseudo session
    procedure RollBack(SessionID: cardinal=CONST_AUTHENTICATION_NOT_USED); override;

    /// is set to TRUE, all BLOB fields are transferred between the Client and
    // the remote Server
    // - i.e. Add() Update() will use Blob-related RESTful PUT/POST request
    // - i.e. Retrieve() will use Blob-related RESTful GET request
    // - note that the Refresh method won't handle BLOB fields, even if this
    // property setting is set to TRUE
    // - by default, this property is set to FALSE, which setting will spare
    // bandwidth and CPU
    property ForceBlobTransfert: boolean read fForceBlobTransfert write fForceBlobTransfert;
    /// this Event is called by UpdateFromServer() to let the Client adapt to
    // some rows update (for Marked[] e.g.)
    property OnTableUpdate: TOnTableUpdate read fOnTableUpdate write fOnTableUpdate;
    /// this Event is called by Update() to let the client
    // perform the record update (refresh associated report e.g.)
    property OnRecordUpdate: TOnRecordUpdate read fOnRecordUpdate write fOnRecordUpdate;
  end;

  /// used by TSQLRestClientURI.URI() to let the client ask for an User name
  // and password, in order to retry authentication to the server
  // - should return TRUE if aUserName and aPassword both contain some entered
  // values to be sent for remote secure authentication
  // - should return FALSE if the user pressed cancel or the number of Retry
  // reached a defined limit 
  TOnAuthentificationFailed = function(Retry: integer;
    var aUserName, aPassword: string): boolean of object;

  /// a generic REpresentational State Transfer (REST) client with URI
  // - URI are standard Collection/Member implemented as ModelRoot/TableName/ID
  // - handle RESTful commands GET POST PUT DELETE LOCK UNLOCK
  TSQLRestClientURI = class(TSQLRestClient)
  protected
    fBatch: TJSONSerializer;
    fBatchTable: TSQLRecordClass;
    fBatchCount: integer;
    fOnAuthentificationFailed: TOnAuthentificationFailed;
    fOnSetUser: TNotifyEvent;
    fMaximumAuthentificationRetry: Integer;
    fLastErrorCode: integer;
    fLastErrorMessage: RawUTF8;
    fLastErrorException: ExceptClass;
    /// private values created by sucessfull SetUser() method
    fSessionUser: TSQLAuthUser;
    fSessionID: cardinal;
    fSessionIDHexa8: RawUTF8;
    fSessionPrivateKey: cardinal;
    fSessionLastTickCount: cardinal;
    fSessionTickCountOffset: cardinal;
    /// will call the /auth service on the server to notify client shutdown
    procedure SessionClose;
    /// abstract method to be implemented with a local, piped or HTTP/1.1 provider
    // - you can specify some POST/PUT data in SendData (leave as nil otherwize)
    // - return in result.Lo the HTTP STATUS integer error or success code
    // - return in result.Hi the server database internal status
    // - on success, store the resulting data into Resp^, headers in Head^ if not nil
    function InternalURI(const url, method: RawUTF8; Resp: PRawUTF8=nil;
      Head: PRawUTF8=nil; SendData: PRawUTF8=nil): Int64Rec; virtual; abstract;
    /// overriden protected method shall check if not connected to reopen it
    // - shall return TRUE on success, FALSE on any connection error
    function InternalCheckOpen: boolean; virtual; abstract;
    /// overriden protected method shall force the connection to be closed,
    // - a next call to InternalCheckOpen method shall re-open the connection 
    procedure InternalClose; virtual; abstract;
    /// calls 'ModelRoot/TableName/ID' with appropriate REST method
    // - uses GET method if ForUpdate is false
    // - uses LOCK method if ForUpdate is true
    function URIGet(Table: TSQLRecordClass; ID: integer; var Resp: RawUTF8;
      ForUpdate: boolean=false): Int64Rec;
    /// retrieve a list of members as JSON encoded data - used by OneFieldValue()
    // and MultiFieldValue() public functions
    function InternalListJSON(Table: TSQLRecordClass; const SQL: RawUTF8): TSQLTableJSON; override;
    // overriden methods
    function EngineRetrieve(TableModelIndex: integer; ID: integer;
      ForUpdate: boolean; var InternalState: cardinal; var Resp: RawUTF8): boolean; override;
    function EngineList(const SQL: RawUTF8; ForceAJAX: Boolean=false; ReturnedRowCount: PPtrInt=nil): RawUTF8; override;
    function EngineAdd(Table: TSQLRecordClass; const SentData: RawUTF8): integer; override;
    function EngineUpdate(Table: TSQLRecordClass; ID: integer; const SentData: RawUTF8): boolean; override;
    function EngineDelete(Table: TSQLRecordClass; ID: integer): boolean; override;
    function EngineDeleteWhere(Table: TSQLRecordClass; const SQLWhere: RawUTF8;
      const IDs: TIntegerDynArray): boolean; override;
    function EngineRetrieveBlob(Table: TSQLRecordClass; aID: integer;
      BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean; override;
    function EngineUpdateBlob(Table: TSQLRecordClass; aID: integer;
      BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean; override;
    function EngineUpdateField(Table: TSQLRecordClass;
      const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean; override;
    procedure SetLastException(E: Exception=nil; ErrorCode: integer=HTML_BADREQUEST);
  public
    /// initialize REST client instance 
    constructor Create(aModel: TSQLModel); override;
    /// release memory and close client connection
    // - also unlock all still locked records by this client
    destructor Destroy; override;
    /// authenticate an User to the current connected Server
    // - will call the ModelRoot/Auth service, i.e. call TSQLRestServer.Auth()
    // published method to create a session for this user
    // - returns true on success
    // - calling this method is optional, depending on your user right policy:
    // your Server need to handle authentication
    // - on success, the SessionUser property map the logged user session on the
    // server side
    // - if aHashedPassword is TRUE, the aPassword parameter is expected to
    // contain the already-hashed value, just as stored in PasswordHashHexa
    // (i.e. SHA256('salt'+Value) as in TSQLAuthUser.SetPasswordPlain method)
    // - if SSPIAUTH conditional is defined, and aUserName='', a Windows
    // authentication will be performed - in this case, aPassword is ignored and
    // table TSQLAuthUser shall contain an entry for the logged Windows user,
    // with the LoginName in form 'DomainName\UserName' 
    function SetUser(const aUserName, aPassword: RawUTF8;
      aHashedPassword: Boolean=false): boolean;
    /// append the '&session_signature' to the url, if fSession<>0
    // - should be called in URI() overriden method
    // - will use the format as described for TSQLRestServer.Auth() method, i.e.
    // as expected by TAuthSession.IsValidURL(); in particular, time stamp
    // resolution is about 256 ms in the current implementation
    function SessionSign(const url: RawUTF8): RawUTF8;
    /// method calling the remote Server via a RESTful command
    // - calls the InternalURI abstract method, which should be overriden with a
    // local, piped or HTTP/1.1 provider
    // - this method will add sign the url with the appropriate digital signature
    // according to the current SessionUser property
    // - this method will retry the connection in case of authentication failure
    // (i.e. if the session was closed by the remote server, for any reason -
    // mostly a time out) if the OnAuthentificationFailed event handler is set
    function URI(const url, method: RawUTF8; Resp: PRawUTF8=nil;
      Head: PRawUTF8=nil; SendData: PRawUTF8=nil): Int64Rec; 
    /// retrieve a list of members as a TSQLTable (implements REST GET Collection)
    // - URI is 'ModelRoot/TableName' with GET method
    // - SQLSelect and SQLWhere are encoded as 'select=' and 'where=' URL parameters
    // (using inlined parameters via :(...): in SQLWhere is always a good idea)
    // - server must return Status 200/HTML_SUCCESS OK on success
    function List(const Tables: array of TSQLRecordClass; const SQLSelect: RawUTF8 = 'RowID';
      const SQLWhere: RawUTF8 = ''): TSQLTableJSON; override;
    /// unlock the corresponding record
    // - URI is 'ModelRoot/TableName/ID' with UNLOCK method
    // - returns true on success
    function UnLock(Table: TSQLRecordClass; aID: integer): boolean; override;
    /// Execute directly a SQL statement
    // - URI is 'ModelRoot' with POST method, and SQL statement sent as UTF-8
    // - server must return Status 200/HTML_SUCCESS OK on success
    function EngineExecute(const SQL: RawUTF8): boolean; override;
    /// Execute directly a SQL statement, expecting a list of resutls
    // - URI is 'ModelRoot' with GET method, and SQL statement sent as UTF-8
    // - return a result table on success, nil on failure
    function ExecuteList(const Tables: array of TSQLRecordClass;
      const SQL: RawUTF8): TSQLTableJSON; override;
    /// ask the server for its current internal state revision counter
    // - this counter is incremented every time the database is modified
    // - the returned value is 0 if the database doesn't support this feature
    // - TSQLTable does compare this value with its internal one to check if
    // its content must be updated
    function ServerInternalState: cardinal;
    /// check if the data may have changed of the server for this objects, and
    // update it if possible
    // - only working types are TSQLTableJSON and TSQLRecord descendants
    // - make use of the InternalState function to check the data content revision
    // - return true if Data is updated successfully, or false on any error
    // during data retrieval from server (e.g. if the TSQLRecord has been deleted)
    // - if Data contains only one TSQLTableJSON, PCurrentRow can point to the
    // current selected row of this table, in order to refresh its value
    // - use this method to refresh the client UI, e.g. via a timer
    function UpdateFromServer(const Data: array of TObject; out Refreshed: boolean;
      PCurrentRow: PInteger = nil): boolean;
    /// send a flush command to the remote Server cache
    // - this method will remotely call the Cache.Flush() methods of the server
    // instance, to force cohesion of the data
    // - ServerCacheFlush() with no parameter will flush all stored JSON content
    // - ServerCacheFlush(aTable) will flush the cache for a given table
    // - ServerCacheFlush(aTable,aID) will flush the cache for a given record
    function ServerCacheFlush(aTable: TSQLRecordClass=nil; aID: integer=0): boolean;
    /// you can call this method to call the remote URI root/TimeStamp
    // - this can be an handy way of testing the connection, since this method
    // is always available, even without authentication
    // - returns TRUE if the client time correction has been retrieved
    // - returns FALSE on any connection error - check LastErrorMessage and
    // LastErrorException to find out the exact connection error
    function ServerTimeStampSynchronize: boolean;

    {/ begin a transaction (implements REST BEGIN Member)
     - to be used to speed up some SQL statements like Add/Update/Delete methods above
     - must be ended with Commit on success
     - in the current implementation, the aTable parameter is not used yet
     - must be aborted with Rollback if any SQL statement failed
     - return true if no transaction is active, false otherwize
      !if Client.TransactionBegin(TSQLRecordPeopleObject) then
      !try
      !  //.... modify the database content, raise exceptions on error
      !  Client.Commit;
      !except
      !  Client.RollBack; // in case of error
      !end;
     - you can should better use the dedicated TransactionBeginRetry() method
      in case of Client concurent access }
    function TransactionBegin(aTable: TSQLRecordClass; SessionID: cardinal=1): boolean; override;
    {/ begin a transaction (implements REST BEGIN Member)
     - this version retries a TranslationBegin() to be successfull within
      a supplied number of times
     - will retry every 100 ms for "Retries" times (excluding the connection
      time in this 100 ms time period
     - default is to retry 10 times, i.e. within 2 second timeout
     - in the current implementation, the aTable parameter is not used yet
     - typical usage should be for instance:
      !if Client.TransactionBeginRetry(TSQLRecordPeopleObject,20) then
      !try
      !  //.... modify the database content, raise exceptions on error
      !  Client.Commit;
      !except
      !  Client.RollBack; // in case of error
      !end; }
    function TransactionBeginRetry(aTable: TSQLRecordClass; Retries: integer=10): boolean;
    {/ end a transaction (implements REST END Member)
     - write all pending SQL statements to the disk }
    procedure Commit(SessionID: cardinal=CONST_AUTHENTICATION_NOT_USED); override;
    {/ abort a transaction (implements REST ABORT Member)
     - restore the previous state of the database, before the call to TransactionBegin }
    procedure RollBack(SessionID: cardinal=CONST_AUTHENTICATION_NOT_USED); override;

    {/ begin a BATCH sequence to speed up huge database change
     - each call to normal Add/Update/Delete methods will create a Server request,
       therefore can be slow (e.g. if the remote server has bad ping timing)
     - start a BATCH sequence using this method, then call BatchAdd() BatchUpdate()
       or BatchDelete() methods to make some changes to the database
     - when BatchSend will be called, all the sequence transactions will be sent
       as one to the remote server, i.e. in one URI request
     - if BatchAbort is called instead, all pending BatchAdd/Update/Delete
       transactions will be aborted, i.e. ignored
     - expect one TSQLRecordClass as parameter, which will be used for the whole
       sequence (in this case, you can't mix classes in the same BATCH sequence)
     - if no TSQLRecordClass is supplied, the BATCH sequence will allow any
       kind of individual record in BatchAdd/BatchUpdate/BatchDelete
     - return TRUE on sucess, FALSE if aTable is incorrect or a previous BATCH
       sequence was already initiated
     - should normally be used inside a Transaction block: there is no automated
       TransactionBegin..Commit/RollBack generated in the BATCH sequence }
    function BatchStart(aTable: TSQLRecordClass): boolean;
    /// create a new member in current BATCH sequence
    // - work in BATCH mode: nothing is sent to the server until BatchSend call
    // - returns the corresponding index in the current BATCH sequence, -1 on error
    // - if SendData is true, content of Value is sent to the server as JSON
    // - if ForceID is true, client sends the Value.ID field to use this ID for
    // adding the record (instead of a database-generated ID)
    // - if Value is TSQLRecordFTS3, Value.ID is stored to the virtual table
    // - Value class MUST match the TSQLRecordClass used at BatchTransactionBegin,
    // or may be of any kind if no class was specified
    // - BLOB fields are NEVER transmitted here, even if ForceBlobTransfert=TRUE
    function BatchAdd(Value: TSQLRecord; SendData: boolean; ForceID: boolean=false): integer;
    /// update a member in current BATCH sequence
    // - work in BATCH mode: nothing is sent to the server until BatchSend call
    // - returns the corresponding index in the current BATCH sequence, -1 on error
    // - Value class MUST match the TSQLRecordClass used at BatchTransactionBegin,
    // or may be of any kind if no class was specified
    // - BLOB fields are NEVER transmitted here, even if ForceBlobTransfert=TRUE
    // - if Value has an opened FillPrepare() mapping, only the mapped fields
    // will be updated (and also ID and TModTime fields) - FillPrepareMany() is
    // not handled yet (all simple fields will be updated)
    function BatchUpdate(Value: TSQLRecord): integer;
    /// delete a member in current BATCH sequence
    // - work in BATCH mode: nothing is sent to the server until BatchSend call
    // - returns the corresponding index in the current BATCH sequence, -1 on error
    // - deleted record class is the TSQLRecordClass used at BatchTransactionBegin()
    // call: it will fail if no class was specified for this BATCH sequence
    function BatchDelete(ID: integer): integer; overload;
    /// delete a member in current BATCH sequence
    // - work in BATCH mode: nothing is sent to the server until BatchSend call
    // - returns the corresponding index in the current BATCH sequence, -1 on error
    // - with this overloaded method, the deleted record class is specified:
    // no TSQLRecordClass shall have been set at BatchTransactionBegin() call
    function BatchDelete(Table: TSQLRecordClass; ID: integer): integer; overload;
    /// retrieve the current number of pending transactions in the BATCH sequence
    // - every call to BatchAdd/Update/Delete methods increases this count
    function BatchCount: integer;
    {/ execute a BATCH sequence started by BatchStart method
     - send all pending BatchAdd/Update/Delete statements to the remote server
     - URI is 'ModelRoot/TableName/0' with POST method
     - will return the URI Status value, i.e. 200/HTML_SUCCESS OK on success
     - a dynamic array of integers will be created in Results,
       containing all ROWDID created for each BatchAdd call, 200 (=HTML_SUCCESS)
       for all successfull BatchUpdate/BatchDelete, or 0 on error
     - any error during server-side process MUST be checked against Results[]
       (the main URI Status is 200 if about communication success, and won't
       imply that all statements in the BATCH sequence were successfull }
    function BatchSend(var Results: TIntegerDynArray): integer;
    {/ abort a BATCH sequence started by BatchStart method
     - in short, nothing is sent to the remote server, and current BATCH sequence
       is closed }
    procedure BatchAbort;

    {/ wrapper to the protected URI method to call a method on the server, using
      a ModelRoot/[TableName/[ID/]]MethodName RESTful GET request
      - returns the HTTP error code (e.g. 200/HTML_SUCCESS on success)
      - this version will use a GET with supplied parameters (which will be encoded
        with the URL) }
    function CallBackGet(const aMethodName: RawUTF8; const aParameters: array of const;
      out aResponse: RawUTF8; aTable: TSQLRecordClass=nil; aID: integer=0;
      aResponseHead: PRawUTF8=nil): integer;
    {/ wrapper to the protected URI method to call a method on the server, using
      a ModelRoot/[TableName/[ID/]]MethodName RESTful GET request
      - returns the UTF-8 decoded JSON result (server must reply with one
        "result":"value" JSON object)
      - this version will use a GET with supplied parameters (which will be encoded
        with the URL) }
    function CallBackGetResult(const aMethodName: RawUTF8; const aParameters: array of const;
      aTable: TSQLRecordClass=nil; aID: integer=0): RawUTF8;
    {/ wrapper to the protected URI method to call a method on the server, using
      a ModelRoot/[TableName/[ID/]]MethodName RESTful PUT request
      - returns the HTTP error code (e.g. 200/HTML_SUCCESS on success)
      - this version will use a PUT with the supplied raw UTF-8 data }
    function CallBackPut(const aMethodName, aSentData: RawUTF8;
      out aResponse: RawUTF8; aTable: TSQLRecordClass=nil; aID: integer=0;
      aResponseHead: PRawUTF8=nil): integer;
    /// register one or several Services on the client side via their interfaces
    // - this methods expects a list of interfaces to be registered to the client
    // (e.g. [TypeInfo(IMyInterface)])
    // - instance implementation pattern will be set by the appropriate parameter
    // - will return true on success, false if registration failed (e.g. if any of
    // the supplied interfaces is not correct or is not available on the server)
    // - that is, server side will be called to check for the availability of
    // each interface
    // - you can specify an optional custom contract for the first interface
    function ServiceRegister(const aInterfaces: array of PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation=sicSingle;
      const aContractExpected: RawUTF8=''): boolean; overload; virtual;
    /// register a Service on the client side via its interface
    // - this methods expects one interface to be registered to the client, as
    // ! Client.ServiceRegister(TypeInfo(IMyInterface),sicShared);
    // - instance implementation pattern will be set by the appropriate parameter
    // - will return the corresponding fake class factory on success, nil if
    // registration failed (e.g. if any of supplied interfaces is not correct or
    // is not available on the server)
    // - that is, server side will be called to check for the availability of
    // each interface
    // - you can specify an optional custom contract for the first interface
    function ServiceRegister(aInterface: PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation=sicSingle;
      const aContractExpected: RawUTF8=''): TServiceFactory; overload;
    /// register and retrieve the sicClientDriven Service instance
    // - will return TRUE on success, filling Obj output variable with the
    // corresponding interface instance
    // - will return FALSE on error
    function ServiceRegisterClientDriven(aInterface: PTypeInfo; out Obj;
      const aContractExpected: RawUTF8=''): boolean; 

    /// low-level error code, as returned by server
    // - check this value about HTML_* constants
    // - HTML_SUCCESS or HTML_CREATED mean no error
    // - otherwise, check LastErrorMessage property for additional information
    // - this property value will record status codes returned by URI() method
    property LastErrorCode: integer read fLastErrorCode;
    /// low-level error message, as returned by server
    // - this property value will record content returned by URI() method in
    // case of an error, or '' if LastErrorCode is HTML_SUCCESS or HTML_CREATED
    property LastErrorMessage: RawUTF8 read fLastErrorMessage;
    /// low-level exception class, if any
    // - will record any Exception class raised within URI() method
    // - contains nil if URI() execution did not raise any exception (which
    // is the most expected behavior, since server-side errors are trapped
    // into LastErrorCode/LastErrorMessage properties 
    property LastErrorException: ExceptClass read fLastErrorException;

    /// this Event is called in case of remote authentication failure
    // - client software can ask the user to enter a password and user name
    // - if no event is specified, the URI() method will return directly
    // an HTML_FORBIDDEN "403 Forbidden" error code
    property OnAuthentificationFailed: TOnAuthentificationFailed
      read fOnAuthentificationFailed write fOnAuthentificationFailed;
    /// this Event is called when a user is authenticated
    // - is called always, on each TSQLRestClientURI.SetUser call
    // - you can check the SessionUser property to retrieve the current
    // authenticated user, or nil if authentication failed
    // - could be used to refresh the User Interface layout according to
    // current authenticated user rights 
    property OnSetUser: TNotifyEvent read fOnSetUser write fOnSetUser;
    /// maximum additional retry occurence
    // - defaut is 0, i.e. will retry once
    // - set OnAuthentificationFailed to nil in order to avoid any retry 
    property MaximumAuthentificationRetry: Integer
      read fMaximumAuthentificationRetry write fMaximumAuthentificationRetry;
    /// the current user as set by SetUser() method
    // - returns nil if no User is currently authenticated
    // - only available fields by default are LogonName and PasswordHashHexa:
    // you can run code similar to the following to fill all needed properties:
    // !  if fClient.SessionUser<>nil then
    // !  begin
    // !    fClient.Retrieve('LogonName=?',[],[fClient.SessionUser.LogonName],
    // !      fClient.SessionUser); // fill ID, DisplayName, GroupRights
    // !    fClient.RetrieveBlobFields(fClient.SessionUser); // optional Data
    // !  end;
    property SessionUser: TSQLAuthUser read fSessionUser;
    /// the current session ID as set after a successfull SetUser() method call
    // - equals 0 (CONST_AUTHENTICATION_SESSION_NOT_STARTED) if the session
    // is not started yet - i.e. if SetUser() call failed
    // - equals 1 (CONST_AUTHENTICATION_NOT_USED) if authentication mode
    // is not enabled - i.e. after a fresh Create() without SetUser() call
    property SessionID: cardinal read fSessionID;
  end;

{$ifdef MSWINDOWS}
  /// Rest client with remote access to a server through a dll
  // - use only one TURIMapRequest function for the whole communication
  // - the data is stored in Global system memory, and freed by GlobalFree()
  TSQLRestClientURIDll = class(TSQLRestClientURI)
  private
    /// used by Create(from dll) constructor
    fLibraryHandle: cardinal;
  protected
    Func: TURIMapRequest;
    /// method calling the RESTful server through a DLL or executable, using
    // direct memory
    function InternalURI(const url, method: RawUTF8; Resp: PRawUTF8=nil;
      Head: PRawUTF8=nil; SendData: PRawUTF8=nil): Int64Rec; override;
    /// overriden protected method do nothing (direct DLL access has no connection)
    function InternalCheckOpen: boolean; override;
    /// overriden protected method do nothing (direct DLL access has no connection)
    procedure InternalClose; override;
  public
    /// connect to a server from a remote function
    constructor Create(aModel: TSQLModel; aRequest: TURIMapRequest); reintroduce; overload;
    /// connect to a server contained in a shared library
    // - this dll must contain at least a URIRequest entry
    // - raise an exception if the shared library is not found or invalid
    constructor Create(aModel: TSQLModel; const DllName: TFileName); reintroduce; overload;
    /// release memory and handles
    destructor Destroy; override;
  end;

  /// Rest client with remote access to a server through Windows messages
  // - use only one TURIMapRequest function for the whole communication
  // - the data is sent and received by using the standard and fast WM_COPYDATA message
  // - named pipes seems to be somewhat better for bigger messages under XP
  TSQLRestClientURIMessage = class(TSQLRestClientURI)
  protected
    /// the HWND of the server process, retrieved by InternalCheckOpen() method
    fServerWindow: HWND;
    /// the Window name used of the server process
    fServerWindowName: string;
    /// the HWND of the client process, as set by Create() method
    fClientWindow: HWND;
    /// the Window name used, if created internaly
    fClientWindowName: string;
    /// the time out to be used, in mili seconds
    fTimeOutMS: cardinal;
    /// the expected current response
    // - this value is set from the incoming WM_COPYDATA
    // - this value is set to #0 (i.e. string of one #0 char) while waiting
    // for a WM_COPYDATA message in URI() method
    fCurrentResponse: RawUTF8;
    /// used to make the internal client-side process reintrant
    fLock: TRTLCriticalSection;
    /// method calling the RESTful server by using Windows WM_COPYDATA messages
    function InternalURI(const url, method: RawUTF8; Resp: PRawUTF8=nil;
      Head: PRawUTF8=nil; SendData: PRawUTF8=nil): Int64Rec; override;
    /// overriden protected method to handle GDI message loop connection
    function InternalCheckOpen: boolean; override;
    /// overriden protected method to close GDI message
    procedure InternalClose; override;
  public
    /// connect to a server from its window name
    // - ServerWindowName is of UnicodeString type since Delphi 2009
    // (direct use of FindWindow()=FindWindowW() Win32 API)
    // - this version must supply a Client Window handle
    constructor Create(aModel: TSQLModel; const ServerWindowName: string;
      ClientWindow: HWND; TimeOutMS: cardinal); reintroduce; overload;
    /// connect to a server from its window name
    // - ServerWindowName is of UnicodeString type since Delphi 2009
    // (direct use of FindWindow()=FindWindowW() Win32 API)
    // - this version will instanciante and create a Client Window from
    // a Window Name, by using low level Win32 API: therefore, the Forms unit
    // is not needed with this constructor (save some KB)
    constructor Create(aModel: TSQLModel; const ServerWindowName,
      ClientWindowName: string; TimeOutMS: cardinal); reintroduce; overload;
    /// release the internal Window class created, if any
    destructor Destroy; override;
    /// event to be trigerred when a WM_COPYDATA message is received from the server
    // - to be called by the corresponding message WM_COPYDATA; method in the
    // client window 
    procedure WMCopyData(var Msg : TWMCopyData); message WM_COPYDATA;
  end;

  /// Rest client with remote access to a server through a Named Pipe
  // - named pipe is fast and optimized under Windows
  // - can be accessed localy or remotely
  TSQLRestClientURINamedPipe = class(TSQLRestClientURI)
  private
    /// handle for '\\.\pipe\mORMot_TEST' e.g.
    fServerPipe: THandle;
    /// the pipe name
    fPipeName: TFileName;
{$ifndef ANONYMOUSNAMEDPIPE}
  {$ifndef NOSECURITYFORNAMEDPIPECLIENTS}
    fPipeSecurityAttributes: TSecurityAttributes;
    fPipeSecurityDescriptor: array[0..SECURITY_DESCRIPTOR_MIN_LENGTH] of byte;
  {$endif}
{$endif}
    fLock: TRTLCriticalSection;
  protected
    /// method calling the RESTful server through a DLL or executable, by using
    // a named pipe (faster than TCP/IP or HTTP connection)
    // - return status code in result.Lo
    // - return database internal state in result.Hi
    // - status code 501 HTML_NOTIMPLEMENTED if no server is available
    function InternalURI(const url, method: RawUTF8; Resp: PRawUTF8=nil;
      Head: PRawUTF8=nil; SendData: PRawUTF8=nil): Int64Rec; override;
    /// overriden protected method to handle named-pipe connection
    function InternalCheckOpen: boolean; override;
    /// overriden protected method to close named-pipe connection
    procedure InternalClose; override;
  public
    /// connect to a server contained in a running application
    // - the server must have been declared by a previous
    // TSQLRestServer.ExportServer(ApplicationName) call
    // with ApplicationName as user-defined server identifier ('DBSERVER' e.g.)
    // - ApplicationName is of UnicodeString type since Delphi 2009
    // (direct use of Wide Win32 API version)
    // - this server identifier is appended to '\\.\pipe\mORMot_' to obtain
    // the full pipe name to connect to ('\\.\pipe\mORMot__DBSERVER' e.g.)
    // - this server identifier may also contain a remote computer name, and
    // must be fully qualified ('\\ServerName\pipe\ApplicationName' e.g.)
    // - raise an exception if the server is not running or invalid
    constructor Create(aModel: TSQLModel; const ApplicationName: TFileName); reintroduce;
    /// release memory and handles
    destructor Destroy; override;
  end;
{$endif Win32}

  /// will define a validation to be applied to a TSQLRecord field, using
  // if necessary an associated TSQLRest instance and a TSQLRecord class
  // - a typical usage is to validate a value to be unique in the table
  // (implemented in the TSynValidateUniqueField class)
  // - the optional associated parameters are to be supplied JSON-encoded
  // - ProcessRest and ProcessRec properties will be filled before Process
  // method call by TSQLRecord.Validate()
  TSynValidateRest = class(TSynValidate)
  protected
    fProcessRest: TSQLRest;
    fProcessRec: TSQLRecord;
  public
    /// the associated TSQLRest instance
    // - this value is updated by TSQLRecord.Validate with the current
    // TSQLRest used for the validation
    // - it can be used in the overriden Process method
    property ProcessRest: TSQLRest read fProcessRest;
    /// the associated TSQLRecord instance
    // - this value is updated by TSQLRecord.Validate with the current
    // TSQLRecord instance to be validated
    // - it can be used in the overriden Process method
    property ProcessRec: TSQLRecord read fProcessRec;
  end;

  /// will define a validation for a TSQLRecord Unique field
  // - it will check that the field value is not void
  // - it will check that the field value is not a duplicate
  TSynValidateUniqueField = class(TSynValidateRest)
  public
    /// perform the unique field validation action to the specified value
    // - duplication value check will use ProcessRest and ProcessRec properties,
    // as set by TSQLRecord.Validate
    function Process(aFieldIndex: integer; const Value: RawUTF8; var ErrorMsg: string): boolean; override;
  end;


  /// a WHERE constraint as set by the TSQLVirtualTable.Prepare() method
  TSQLVirtualTablePreparedConstraint = record
    /// Column on left-hand side of constraint
    // - The first column of the virtual table is column 0
    // - The ROWID of the virtual table is column -1
    // - Hidden columns are counted when determining the column index
    // - if this field contains VIRTUAL_TABLE_IGNORE_COLUMN (-2), TSQLVirtualTable.
    // Prepare() should ignore this entry
    Column: integer;
    /// Constraint operator
    // - MATCH keyword is parsed into soBeginWith, and should be handled as
    // soBeginWith, soContains or soSoundsLike* according to the effective
    // expression text value ('text*', '%text'...)
    Operation: TCompareOperator;
    /// If true, the constraint is assumed to be fully handled
    // by the virtual table and is not checked again by SQLite
    // - By default (OmitCheck=false), the SQLite core double checks all
    // constraints on each row of the virtual table that it receives
    // - TSQLVirtualTable.Prepare() can set this property to true
    OmitCheck: boolean;
    /// The associated expression
    // - TSQLVirtualTable.Prepare() must set this property VType to <> varEmpty
    // (=0) e.g. to varAny, if an expression is expected at
    // TSQLVirtualTableCursor.Search() call
    // - TSQLVirtualTableCursor.Search() will receive an expression value,
    // to be retrieved e.g. via sqlite3_value_*() functions
    Value: TVarData;
  end;

  /// an ORDER BY clause as set by the TSQLVirtualTable.Prepare() method
  TSQLVirtualTablePreparedOrderBy = record
    /// Column number
    // - The first column of the virtual table is column 0
    // - The ROWID of the virtual table is column -1
    // - Hidden columns are counted when determining the column index.
    Column: Integer;
    /// True for DESCending order, false for ASCending order.
    Desc: boolean;
  end;


  /// the WHERE and ORDER BY statements as set by TSQLVirtualTable.Prepare 
  // - Where[] and OrderBy[] are fixed sized arrays, for fast and easy code
  TSQLVirtualTablePrepared = {$ifndef ISDELPHI2010}object{$else}record{$endif}
  public
    /// number of WHERE statement parameters in Where[] array
    WhereCount: integer;
    /// numver of ORDER BY statement parameters in OrderBy[]
    OrderByCount: integer;
    /// if true, the ORDER BY statement is assumed to be fully handled
    // by the virtual table and is not checked again by SQLite
    // - By default (OmitOrderBy=false), the SQLite core sort all rows of the
    // virtual table that it receives according in order
    OmitOrderBy: boolean;
    ///  Estimated cost of using this prepared index
    // - SQLite uses this value to make a choice between several calls to
    // the TSQLVirtualTable.Prepare() method with several expressions
    EstimatedCost: Double;
    /// WHERE statement parameters, in TSQLVirtualTableCursor.Search() order
    Where: array[0..MAX_SQLFIELDS-1] of TSQLVirtualTablePreparedConstraint;
    /// ORDER BY statement parameters
    OrderBy: array[0..MAX_SQLFIELDS-1] of TSQLVirtualTablePreparedOrderBy;
    /// returns TRUE if there is only one ID=? statement in this search
    function IsWhereIDEquals(CalledFromPrepare: Boolean): boolean;
       {$ifdef HASINLINE}inline;{$endif}
    /// returns TRUE if there is only one FieldName=? statement in this search
    function IsWhereOneFieldEquals: boolean;
       {$ifdef HASINLINE}inline;{$endif}
  end;

  PSQLVirtualTablePrepared = ^TSQLVirtualTablePrepared;

  TSQLVirtualTableCursor = class;
  TSQLVirtualTableCursorClass = class of TSQLVirtualTableCursor;

  /// the possible features of a Virtual Table
  // - vtWrite is to be set if the table is not Read/Only
  // - vtTransaction if handles vttBegin, vttSync, vttCommit, vttRollBack
  // - vtSavePoint if handles vttSavePoint, vttRelease, vttRollBackTo
  // - vtWhereIDPrepared if the ID=? WHERE statement will be handled in
  // TSQLVirtualTableCursor.Search()
  TSQLVirtualTableFeature = (vtWrite, vtTransaction, vtSavePoint,
    vtWhereIDPrepared);

  /// a set of features of a Virtual Table
  TSQLVirtualTableFeatures = set of TSQLVirtualTableFeature;

  /// used to store and handle the main specifications of a TSQLVirtualTableModule
  TVirtualTableModuleProperties = record
    /// a set of features of a Virtual Table
    Features: TSQLVirtualTableFeatures;
    /// the associated cursor class
    CursorClass: TSQLVirtualTableCursorClass;
    /// the associated TSQLRecord class
    // - used to retrieve the field structure with all collations
    RecordClass: TSQLRecordClass;
    /// the associated TSQLRestServerStatic class used for storage
    // - is e.g. TSQLRestServerStaticInMemory for TSQLVirtualTableJSON,
    // TSQLRestServerStaticExternal for TSQLVirtualTableExternal, or nil for
    // TSQLVirtualTableLog
    StaticClass: TSQLRestServerStaticClass;
    /// can be used to customize the extension of the filename
    // - the '.' is not to be included
    FileExtension: TFileName;
  end;

  {/ parent class able to define a Virtual Table module
   - in order to implement a new Virtual Table type, you'll have to define a so
     called "Module" to handle the fields and data access and an associated
     TSQLVirtualTableCursorClass for handling the SELECT statements
   - for our framework, the SQLite3 unit will inherit from this class to define
     a TSQLVirtualTableModuleSQLite3 class, which will register the associated
     virtual table definition into a SQLite3 connection, on the server side
   - children should override abstract methods in order to implement the
     association with the database engine itself }
  TSQLVirtualTableModule = class
  protected
    fModuleName: RawUTF8;
    fTableClass: TSQLVirtualTableClass;
    fServer: TSQLRestServer;
    fFeatures: TVirtualTableModuleProperties;
    fFilePath: TFileName;
  public
    /// create the Virtual Table instance according to the supplied class
    // - inherited constructors may register the Virtual Table to the specified
    // database connection
    constructor Create(aTableClass: TSQLVirtualTableClass;
      aServer: TSQLRestServer); virtual;
    /// retrieve the file name to be used for a specific Virtual Table
    // - returns by default a file located in the executable folder, with the
    // table name as file name, and module name as extension
    function FileName(const aTableName: RawUTF8): TFileName; virtual;
    /// the Virtual Table module features
    property Features: TSQLVirtualTableFeatures read fFeatures.Features;
    /// the associated virtual table class
    property TableClass: TSQLVirtualTableClass read fTableClass;
    /// the associated virtual table cursor class
    property CursorClass: TSQLVirtualTableCursorClass read fFeatures.CursorClass;
    /// the associated TSQLRestServerStatic class used for storage
    // - e.g. returns TSQLRestServerStaticInMemory for TSQLVirtualTableJSON,
    // or TSQLRestServerStaticExternal for TSQLVirtualTableExternal, or
    // either nil for TSQLVirtualTableLog
    property StaticClass: TSQLRestServerStaticClass read fFeatures.StaticClass;
    /// the associated TSQLRecord class
    // - is mostly nil, e.g. for TSQLVirtualTableJSON
    // - used to retrieve the field structure for TSQLVirtualTableLog e.g.
    property RecordClass: TSQLRecordClass read fFeatures.RecordClass;
    /// the extension of the filename (without any left '.')
    property FileExtension: TFileName read fFeatures.FileExtension;
    /// the full path to be used for the filename
    // - is '' by default, i.e. will use the executable path
    // - you can specify here a custom path, which will be used by the FileName
    // method to retrieve the .json/.data full file 
    property FilePath: TFileName read fFilePath write fFilePath;
    /// the associated Server instance
    // - may be nil, in case of direct access to the virtual table
    property Server: TSQLRestServer read fServer;
    /// the corresponding module name
    property ModuleName: RawUTF8 read fModuleName;
  end;

  /// the available transaction levels
  TSQLVirtualTableTransaction = (
    vttBegin, vttSync, vttCommit, vttRollBack,
    vttSavePoint, vttRelease, vttRollBackTo);

  {/ abstract class able to access a Virtual Table content
   - override the Prepare/Structure abstract virtual methods for reading
     access to the virtual table content
   - you can optionaly override Drop/Delete/Insert/Update/Rename/Transaction
     virtual methods to allow content writing to the virtual table
   - the same virtual table mechanism can be used with several database module,
     with diverse database engines }
  TSQLVirtualTable = class
  protected
    fModule: TSQLVirtualTableModule;
    fTableName: RawUTF8;
    fStatic: TSQLRestServerStatic;
  public
    /// create the virtual table access instance
    // - the created instance will be released when the virtual table will be
    // disconnected from the DB connection (e.g. xDisconnect method for SQLite3)
    // - shall raise an exception in case of invalid parameters (e.g. if the
    // supplied module is not associated to a TSQLRestServer instance)
    // - aTableName will be checked against the current aModule.Server.Model
    // to retrieve the corresponding TSQLRecordVirtualTableAutoID class and
    // create any associated Static: TSQLRestServerStatic instance
    constructor Create(aModule: TSQLVirtualTableModule; const aTableName: RawUTF8;
      FieldCount: integer; Fields: PPUTF8CharArray); virtual;
    /// release the associated memory, especially the Static instance
    destructor Destroy; override;
    /// retrieve the corresponding module name
    // - will use the class name, triming any T/TSQL/TSQLVirtual/TSQLVirtualTable* 
    // - when the class is instanciated, it will be faster to retrieve the same
    // value via Module.ModuleName
    class function ModuleName: RawUTF8;
    /// a generic method to get a 'CREATE TABLE' structure from a supplied
    // TSQLRecord class
    // - is called e.g. by the Structure method
    class function StructureFromClass(aClass: TSQLRecordClass;
      const aTableName: RawUTF8): RawUTF8;
    /// the associated Virtual Table module
    property Module: TSQLVirtualTableModule read fModule;
    /// the name of the Virtual Table, as specified following the TABLE keyword
    // in the CREATE VIRTUAL TABLE statement
    property TableName: RawUTF8 read fTableName;
  public { virtual methods to be overriden }
    /// should return the main specifications of the associated TSQLVirtualTableModule
    class procedure GetTableModuleProperties(
      var aProperties: TVirtualTableModuleProperties); virtual; abstract;
    /// called to determine the best way to access the virtual table
    // - will prepare the request for TSQLVirtualTableCursor.Search()
    // - in Where[], Expr must be set to not 0 if needed for Search method,
    // and OmitCheck to true if double check is not necessary
    // - OmitOrderBy must be set to true if double sort is not necessary
    // - EstimatedCost should receive the estimated cost
    // - default implementation will let the DB engine perform the search,
    // and prepare for ID=? statement if vtWhereIDPrepared was set
    function Prepare(var Prepared: TSQLVirtualTablePrepared): boolean; virtual;
    /// should retrieve the format (the names and datatypes of the columns) of
    // the virtual table, as expected by sqlite3_declare_vtab()
    // - default implementation is to retrieve the structure for the associated
    // Module.RecordClass property (as set by GetTableModuleProperties) or
    // the Static.StoredClass: in both cases, column numbering will follow
    // the TSQLRecord published field order (TSQLRecord.RecordProps.Fields[])
    function Structure: RawUTF8; virtual;
    /// called when a DROP TABLE statement is executed against the virtual table
    // - should return true on success, false otherwise
    // - does nothing by default, and returns false, i.e. always fails
    function Drop: boolean; virtual;
    /// called to delete a virtual table row
    // - should return true on success, false otherwise
    // - does nothing by default, and returns false, i.e. always fails
    function Delete(aRowID: Int64): boolean; virtual;
    /// called to insert a virtual table row content
    // - the column values are available via some TVarData of type
    // varNull, varInt64, varDouble, varString (mapping a constant PUTF8Char),
    // and varAny (BLOB with size = VLongs[0])
    // - should return true on success, false otherwise
    // - should return the just created row ID in insertedRowID on success
    // - does nothing by default, and returns false, i.e. always fails
    function Insert(aRowID: Int64; var Values: TVarDataDynArray;
      out insertedRowID: Int64): boolean; virtual;
    /// called to update a virtual table row content
    // - the column values are available via some TVarData of type
    // varNull, varInt64, varDouble, varString (mapping a constant PUTF8Char),
    // and varAny (BLOB with size = VLongs[0])
    // - should return true on success, false otherwise
    // - does nothing by default, and returns false, i.e. always fails
    function Update(oldRowID, newRowID: Int64; var Values: TVarDataDynArray): boolean; virtual;
    /// called to begin a transaction to the virtual table row
    // - do nothing by default, and returns false in case of RollBack/RollBackto
    // - aSavePoint is used for vttSavePoint, vttRelease and vttRollBackTo only
    // - note that if you don't nest your writing within a transaction, SQLite
    // will call vttCommit for each INSERT/UPDATE/DELETE, just like a regular
    // SQLite database - it could make bad written code slow even with Virtual
    // Tables
    function Transaction(aState: TSQLVirtualTableTransaction; aSavePoint: integer): boolean; virtual;
    /// called to rename the virtual table
    // - by default, returns false, i.e. always fails
    function Rename(const NewName: RawUTF8): boolean; virtual;
    /// the associated virtual table storage
    // - can be e.g. a TSQLRestServerStaticInMemory for TSQLVirtualTableJSON,
    // or a TSQLRestServerStaticExternal for TSQLVirtualTableExternal, or nil
    // for TSQLVirtualTableLog
    property Static: TSQLRestServerStatic read fStatic;
  end;

  {/ abstract class able to define a Virtual Table cursor
    - override the Search/HasData/Column/Next abstract virtual methods to
    implement the search process }
  TSQLVirtualTableCursor = class
  protected
    fTable: TSQLVirtualTable;
    /// used internaly between two Column() method calls for GetFieldVarData()
    fColumnTemp: RawByteString;
    /// easy set a TVarData content for the Column() method
    procedure SetColumn(var aResult: TVarData; aValue: Int64); overload;
      {$ifdef HASINLINE}inline;{$endif}
    procedure SetColumn(var aResult: TVarData; const aValue: double); overload;
      {$ifdef HASINLINE}inline;{$endif}
    procedure SetColumn(var aResult: TVarData; const aValue: RawUTF8); overload;
      {$ifdef HASINLINE}inline;{$endif}
    procedure SetColumn(var aResult: TVarData; aValue: PUTF8Char; aValueLength: integer); overload;
      {$ifdef HASINLINE}inline;{$endif}
    procedure SetColumnBlob(var aResult: TVarData; aValue: pointer; aValueLength: integer);
      {$ifdef HASINLINE}inline;{$endif}
  public
    /// create the cursor instance
    // - it will be destroyed when by the DB engine (e.g. via xClose in SQLite3)
    constructor Create(aTable: TSQLVirtualTable); virtual;
    /// the associated Virtual Table class instance
    property Table: TSQLVirtualTable read fTable;
  public { abstract methods to be overriden }
    /// called to begin a search in the virtual table
    // - the TSQLVirtualTablePrepared parameters were set by
    // TSQLVirtualTable.Prepare and will contain both WHERE and ORDER BY statements
    // (retrieved e.g. by x_BestIndex() from a TSQLite3IndexInfo structure)
    // - Prepared will contain all prepared constraints and the corresponding
    // expressions in the Where[].Value field
    // - should move cursor to first row of matching data
    // - should return false on low-level database error (but true in case of a
    // valid call, even if HasData will return false, i.e. no data match)
    function Search(const Prepared: TSQLVirtualTablePrepared): boolean; virtual; abstract;
    /// called after Search() to check if there is data to be retrieved
    // - should return false if reached the end of matching data
    function HasData: boolean; virtual; abstract;
    /// called to retrieve a column value of the current data row
    // - handled types in aResult are varNull, varInt64, varDouble, varString
    // (mapping a constant PUTF8Char) and varAny (BLOB with size = VLongs[0])
    // - if aColumn=-1, should return the row ID as varInt64 into aResult
    // - should return false in case of an error, true on success
    function Column(aColumn: integer; var aResult: TVarData): boolean;
      virtual; abstract;
    /// called to go to the next row of matching data
    // - should return false on low-level database error (but true in case of a
    // valid call, even if HasData will return false, i.e. no data match)
    function Next: boolean; virtual; abstract;
  end;

  {/ A generic Virtual Table cursor associated to Current/Max index properties }
  TSQLVirtualTableCursorIndex = class(TSQLVirtualTableCursor)
  protected
    fCurrent: integer;
    fMax: integer;
  public
    /// called after Search() to check if there is data to be retrieved
    // - will return false if reached the end of matching data, according to
    // the fCurrent/fMax protected properties values
    function HasData: boolean; override;
    /// called to go to the next row of matching data
    // - will return false on low-level database error (but true in case of a
    // valid call, even if HasData will return false, i.e. no data match)
    // - will check the fCurrent/fMax protected properties values
    function Next: boolean; override;
    /// called to begin a search in the virtual table
    // - this no-op version will mark EOF, i.e. fCurrent=0 and fMax=-1
    function Search(const Prepared: TSQLVirtualTablePrepared): boolean; override;
  end;
  
  {/ A Virtual Table cursor for reading a TSQLRestServerStaticInMemory content
    - this is the cursor class associated to TSQLVirtualTableJSON }
  TSQLVirtualTableCursorJSON = class(TSQLVirtualTableCursorIndex)
  public
    /// called to begin a search in the virtual table
    // - the TSQLVirtualTablePrepared parameters were set by
    // TSQLVirtualTable.Prepare and will contain both WHERE and ORDER BY statements
    // (retrieved by x_BestIndex from a TSQLite3IndexInfo structure)
    // - Prepared will contain all prepared constraints and the corresponding
    // expressions in the Where[].Value field
    // - will move cursor to first row of matching data
    // - will return false on low-level database error (but true in case of a
    // valid call, even if HasData will return false, i.e. no data match)
    // - only handled WHERE clause is for "ID = value" - other request will
    // return all records in ID order, and let the database engine handle it
    function Search(const Prepared: TSQLVirtualTablePrepared): boolean; override;
    /// called to retrieve a column value of the current data row
    // - handled types in aResult are varNull, varInt64, varDouble, varString
    // (mapping a constant PUTF8Char) and varAny (BLOB with size = VLongs[0])
    // - if aColumn=-1, will return the row ID as varInt64 into aResult
    // - will return false in case of an error, true on success
    function Column(aColumn: integer; var aResult: TVarData): boolean; override;
  end;

  {/ A TSQLRestServerStaticInMemory-based virtual table using JSON storage
   - for ORM access, you should use TSQLModel.VirtualTableRegister method to
     associated this virtual table module to a TSQLRecordVirtualTableAutoID class
   - transactions are not handled by this module
   - by default, no data is written on disk: you will need to call explicitly
     aServer.StaticVirtualTable[aClass].UpdateToFile for file creation or refresh
   - file extension is set to '.json' }
  TSQLVirtualTableJSON = class(TSQLVirtualTable)
  public { overriden methods }
    /// returns the main specifications of the associated TSQLVirtualTableModule
    // - this is a read/write table, without transaction, associated to the
    // TSQLVirtualTableCursorJSON cursor type, with 'JSON' as module name
    // - no particular class is supplied here, since it will depend on the
    // associated Static instance 
    class procedure GetTableModuleProperties(var aProperties: TVirtualTableModuleProperties);
      override;
    /// called to determine the best way to access the virtual table
    // - will prepare the request for TSQLVirtualTableCursor.Search()
    // - only prepared WHERE statement is for "ID = value"
    // - only prepared ORDER BY statement is for ascending IDs
    function Prepare(var Prepared: TSQLVirtualTablePrepared): boolean; override;
    /// called when a DROP TABLE statement is executed against the virtual table
    // - returns true on success, false otherwise
    function Drop: boolean; override;
    /// called to delete a virtual table row
    // - returns true on success, false otherwise
    function Delete(aRowID: Int64): boolean; override;
    /// called to insert a virtual table row content
    // - the column values are available via some TVarData of type
    // varNull, varInt64, varDouble, varString (mapping a constant PUTF8Char),
    // and varAny (BLOB with size = VLongs[0])
    // - column order follows the Structure method, i.e.
    // StoredClassRecordProps.Fields[] order
    // - returns true on success, false otherwise
    // - returns the just created row ID in insertedRowID on success
    // - does nothing by default, and returns false, i.e. always fails
    function Insert(aRowID: Int64; var Values: TVarDataDynArray;
      out insertedRowID: Int64): boolean; override;
    /// called to update a virtual table row content
    // - the column values are available via some TVarData of type
    // varNull, varInt64, varDouble, varString (mapping a constant PUTF8Char),
    // and varAny (BLOB with size = VLongs[0])
    // - column order follows the Structure method, i.e.
    // StoredClassRecordProps.Fields[] order
    // - returns true on success, false otherwise
    // - does nothing by default, and returns false, i.e. always fails
    function Update(oldRowID, newRowID: Int64; var Values: TVarDataDynArray): boolean; override;
  end;

  {/ A TSQLRestServerStaticInMemory-based virtual table using Binary storage
   - for ORM access, you should use TSQLModel.VirtualTableRegister method to
     associated this virtual table module to a TSQLRecordVirtualTableAutoID class
   - transactions are not handled by this module
   - by default, no data is written on disk: you will need to call explicitly
     aServer.StaticVirtualTable[aClass].UpdateToFile for file creation or refresh
   - binary format is more efficient in term of speed and disk usage than
     the JSON format implemented by TSQLVirtualTableJSON
   - binary format will be set by TSQLVirtualTableJSON.CreateTableInstance
   - file extension is set to '.data' }
  TSQLVirtualTableBinary = class(TSQLVirtualTableJSON);

  {/ Implements a read/only virtual table able to access a .log file, as created
     by TSynLog
   - to be used e.g. by a TSQLRecordLog_Log ('Log_' will identify this 'Log' module)
    - the .log file name will be specified by the Table Name, to which a '.log'
      file extension will be appended before loading it from the current
      directory }
  TSQLVirtualTableLog = class(TSQLVirtualTable)
  protected
    fLogFile: TSynLogFile;
  public
    /// returns the main specifications of the associated TSQLVirtualTableModule
    // - this is a read only table, with transaction, associated to the
    // TSQLVirtualTableCursorLog cursor type, with 'Log' as module name,
    // and associated to TSQLRecordLog_Log table field layout
    class procedure GetTableModuleProperties(
      var aProperties: TVirtualTableModuleProperties); override;
    /// creates the TSQLVirtualTable according to the supplied parameters
    // - aTableName will be checked against the current aModule.Server.Model
    // to retrieve the corresponding TSQLRecordVirtualTableAutoID class
    constructor Create(aModule: TSQLVirtualTableModule; const aTableName: RawUTF8;
      FieldCount: integer; Fields: PPUTF8CharArray); override;
    /// release the associated .log file mapping and all internal structures
    destructor Destroy; override;
  end;

  {/ A Virtual Table cursor for reading a TSynLogFile content
    - this is the cursor class associated to TSQLVirtualTableLog }
  TSQLVirtualTableCursorLog = class(TSQLVirtualTableCursorIndex)
  public
    /// called to begin a search in the virtual table
    function Search(const Prepared: TSQLVirtualTablePrepared): boolean; override;
    /// called to retrieve a column value of the current data row
    function Column(aColumn: integer; var aResult: TVarData): boolean; override;
  end;

  {/ Record associated to a Virtual Table implemented in Delphi, with ID
    forced at INSERT
  - will use TSQLVirtualTableModule / TSQLVirtualTable / TSQLVirtualTableCursor
    classes for a generic Virtual table mechanism on the Server side
  - call Model.VirtualTableRegister() before TSQLRestServer.Create on the
    Server side (not needed for Client) to associate such a record with a
    particular Virtual Table module, otherwise an exception will be raised:
    ! Model.VirtualTableRegister(TSQLRecordDali1,TSQLVirtualTableJSON); }
  TSQLRecordVirtualTableForcedID = class(TSQLRecordVirtual);

  {/ Record associated to Virtual Table implemented in Delphi, with ID
    generated automatically at INSERT
  - will use TSQLVirtualTableModule / TSQLVirtualTable / TSQLVirtualTableCursor
    classes for a generic Virtual table mechanism
  - call Model.VirtualTableRegister() before TSQLRestServer.Create on the
    Server side (not needed for Client) to associate such a record with a
    particular Virtual Table module, otherwise an exception will be raised:
    ! Model.VirtualTableRegister(TSQLRecordDali1,TSQLVirtualTableJSON); }
  TSQLRecordVirtualTableAutoID = class(TSQLRecordVirtual);

/// special comparaison function for sorting ftRecord (TRecordReference/RecordRef)
// UTF-8 encoded values in the SQLite3 database or JSON content
function UTF8CompareRecord(P1,P2: PUTF8Char): PtrInt;

/// special comparaison function for sorting sftBoolean
// UTF-8 encoded values in the SQLite3 database or JSON content
function UTF8CompareBoolean(P1,P2: PUTF8Char): PtrInt;

/// special comparaison function for sorting sftEnumerate, sftSet or sftID
// UTF-8 encoded values in the SQLite3 database or JSON content
function UTF8CompareUInt32(P1,P2: PUTF8Char): PtrInt;

/// special comparaison function for sorting sftInteger or
// sftTimeLog / sftModTime / sftCreateTime UTF-8 encoded values in the SQLite3
// database or JSON content
function UTF8CompareInt64(P1,P2: PUTF8Char): PtrInt;

/// special comparaison function for sorting sftCurrency
// UTF-8 encoded values in the SQLite3 database or JSON content
function UTF8CompareCurr64(P1,P2: PUTF8Char): PtrInt;

/// special comparaison function for sorting sftFloat
// UTF-8 encoded values in the SQLite3 database or JSON content
function UTF8CompareDouble(P1,P2: PUTF8Char): PtrInt;

/// special comparaison function for sorting sftDateTime
// UTF-8 encoded values in the SQLite3 database or JSON content
function UTF8CompareISO8601(P1,P2: PUTF8Char): PtrInt;

const
  /// if a TSQLVirtualTablePreparedConstraint.Column is to be ignored
  VIRTUAL_TABLE_IGNORE_COLUMN = -2;
  /// if a TSQLVirtualTablePreparedConstraint.Column points to the RowID
  VIRTUAL_TABLE_ROWID_COLUMN = -1;

  /// if the TSQLRecordVirtual table kind is a FTS3/FTS4 virtual table
  IS_FTS = [rFTS3, rFTS4];

  /// if the TSQLRecordVirtual table kind is not an embedded type
  // - can be set for a TSQLRecord after a VirtualTableExternalRegister call
  IS_CUSTOM_VIRTUAL = [rCustomForcedID, rCustomAutoID];

  /// if the TSQLRecordVirtual table kind expects the ID to be set on INSERT
  INSERT_WITH_ID = [rFTS3, rFTS4, rRTree, rCustomForcedID];

  /// Supervisor Table access right, i.e. alllmighty over all fields
  ALL_ACCESS_RIGHTS = [0..MAX_SQLTABLES-1];

  /// Supervisor Database access right, i.e. allmighty over all Tables
  SUPERVISOR_ACCESS_RIGHTS: TSQLAccessRights =
    (AllowRemoteExecute: [reService,reUrlEncodedDelete];
     GET: ALL_ACCESS_RIGHTS; POST: ALL_ACCESS_RIGHTS;
     PUT: ALL_ACCESS_RIGHTS; DELETE: ALL_ACCESS_RIGHTS);

  /// Supervisor Database access right, i.e. allmighty over all Tables
  // - this constant will set AllowRemoteExecute field to true
  // - is used by default only TSQLRestClientDB.URI() method, for direct
  // local access right
  FULL_ACCESS_RIGHTS: TSQLAccessRights =
    (AllowRemoteExecute: [reSQL,reService,reUrlEncodedDelete];
     GET: ALL_ACCESS_RIGHTS; POST: ALL_ACCESS_RIGHTS;
     PUT: ALL_ACCESS_RIGHTS; DELETE: ALL_ACCESS_RIGHTS);

  /// special TSQLFieldBits value containing all field bits set to 1
  ALL_FIELDS: TSQLFieldBits = [0..MAX_SQLFIELDS-1];

  /// timer identifier which indicates we must refresh the current Page
  // - used for User Interface generation
  // - is associated with the TSQLRibbonTabParameters.AutoRefresh property,
  // and is handled in TSQLRibbon.RefreshClickHandled
  WM_TIMER_REFRESH_SCREEN = 1;
  /// timer identifier which indicates we must refresh the Report content
  // - used for User Interface generation
  // - is handled in TSQLRibbon.RefreshClickHandled
  WM_TIMER_REFRESH_REPORT = 2;

  /// the default URI parameters for query paging
  // - those values are the one expected by YUI components 
  PAGINGPARAMETERS_YAHOO: TSQLRestServerURIPagingParameters = (
    Sort: 'SORT=';
    Dir: 'DIR=';
    StartIndex: 'STARTINDEX=';
    Results: 'RESULTS=';
    Select: 'SELECT=';
    Where: 'WHERE=';
    SendTotalRowsCountFmt: nil);


/// create a TRecordReference with the corresponding parameters
function RecordReference(Model: TSQLModel; aTable: TSQLRecordClass; aID: integer): TRecordReference;

/// convert a dynamic array of TRecordReference into its corresponding IDs
procedure RecordRefToID(var aArray: TPtrUIntDynArray);

/// get the order table name from a SQL statement
// - return the word following any 'ORDER BY' statement
// - return 'RowID' if none found
function SQLGetOrder(const SQL: RawUTF8): RawUTF8;

{$ifdef PUREPASCAL}{$ifdef HASINLINE}
/// this function is published only for class function TSQLRecord.RecordProps()
// internal call after inlining
function PropsCreate(aTable: TSQLRecordClass): TSQLRecordProperties;
{$endif}{$endif}

/// low-level function to retrieve the class instance implementing a given
// interface
// - this will work with interfaces stubs generated by the compiler, but also
// with TInterfaceFactory.CreateFakeInstance kind of classes
function ObjectFromInterface(const aValue: IInterface): TObject;

/// assign a Weak interface reference, to be used for circular references
// - by default setting aInterface.Field := aValue will increment the internal
// reference count of the implementation object: when underlying objects reference
// each other via interfaces (e.g. as parent and children), what causes the
// reference count to never reach zero, therefore resulting in memory links
// - to avoid this issue, use this procedure instead
procedure SetWeak(aInterfaceField: PIInterface; const aValue: IInterface);
 // {$ifdef HASINLINE}inline;{$endif} raise compilation Internal Error C2170

/// assign a Weak interface reference, which will be ZEROed (set to nil) when
// the corresponding object will be released
// - this function is bit slower than SetWeak, but will avoid any GPF, by
// maintaining a list of per-instance weak interface field reference, and
// hook the FreeInstance virtual method in order to reset any reference to nil:
// FreeInstance will be overriden for this given class VMT only (to avoid
// unnecessary slowdown of other classes), calling the previous method afterward
// (so will work even with custom FreeInstance implementations)
// - for faster possible retrieval, it will assign the unused vmtAutoTable VMT
// entry trick (just like TSQLRecord.RecordProps) - note that it will be
// compatible also with interfaces implemented via TSQLRecord children
// - thread-safe implementation, using a per-class fast lock
procedure SetWeakZero(aObject: TObject; aObjectInterfaceField: PIInterface;
  const aValue: IInterface);

{$ifdef ISDELPHIXE} // class helper requires Delphi 2006 or newer but are buggy before XE :(
type
  /// TWeakZeroInterfaceHelper is a class helper that allows you to use
  // SetWeakZero() in any class without specifying the Self parameter
  TWeakZeroInterfaceHelper = class helper for TObject
  protected
    /// Use SetWeak0 to assign an interface to a weak interface field
    // - this is just a wrapper around the global SetWeakZero() function
    procedure SetWeak0(aObjectInterfaceField: PIInterface; const aValue: IInterface);
  end;
{$endif}

{$ifdef MSWINDOWS}
var
  /// if this variable is TRUE, the URIRequest() function won't use
  // Win32 API GlobalAlloc() function, but fastest native Getmem()
  // - can be also usefull for debugg
  USEFASTMM4ALLOC: boolean = false;

/// this function can be exported from a DLL to remotely access to a TSQLRestServer
// - use TSQLRestServer.ExportServer to assign a server to this function
// - return 501 HTML_NOTIMPLEMENTED if no TSQLRestServer.ExportServer has been assigned
// - memory for Resp and Head are allocated with GlobalAlloc(): client must release
// this pointers with GlobalFree() after having retrieved their content
// - simply use TSQLRestClientURIDll to access to an exported URIRequest() function
function URIRequest(url, method, SendData: PUTF8Char; Resp, Head: PPUTF8Char): Int64Rec; cdecl;
{$endif}


type
  PServiceRunningContext = ^TServiceRunningContext;
  
  /// will identify the currently running service on the server side
  // - is the type of the global ServiceContext threadvar
  TServiceRunningContext = record
    /// the currently running service factory
    // - it can be used within server-side implementation to retrieve the
    // associated TSQLRestServer instance
    Factory: TServiceFactoryServer;
    /// the currently runnning context which launched the method
    // - make available e.g. current session or authentication parameters
    // (including e.g. user details via Factory.RestServer.SessionGetUser)
    // - low-level RESTful context is also available in its Call member 
    Session: ^TSQLRestServerCallBackParams;
    /// the thread which launched the request
    // - is set by TSQLRestServer.BeginCurrentThread from multi-thread server
    // handlers - e.g. TSQLite3HttpServer or TSQLRestServerNamedPipeResponse
    RunningThread: TThread;
  end;

threadvar
  /// this thread-specific variable will be set with the currently running
  // service context (on the server side)
  // - is set by TServiceFactoryServer.ExecuteMethod() just before calling the
  // implementation method of a service, allowing to retrieve the current
  // execution context
  // - its content is reset to zero out of the scope of a method execution
  // - when used, a local copy or a PServiceRunningContext pointer should better
  // be created, since accessing a threadvar has a non negligible performance cost
  // - when accessed from a package, use function CurrentServiceContext()
  // instead, to circumvent a Delphi RTL/compiler restriction (bug?)
  ServiceContext: TServiceRunningContext;

/// wrapper function to retrieve the global ServiceContext threadvar value
// - to be used when accessing the value from a package, to circumvent a
// Delphi RTL/compiler restriction (bug?) 
function CurrentServiceContext: TServiceRunningContext;


{ ************ Logging classes and functions }

type
  /// logging class with enhanced RTTI
  // - will write TObject/TSQLRecord, enumerations and sets content as JSON
  // - is the default logging family used by the mORMot framework
  // - mORMotDB.pas unit will set SynDBLog := TSQLLog
  // - moRMotSQLite3.pas unit will set SynSQLite3Log := TSQLLog
  TSQLLog = class(TSynLog)
  protected
    procedure CreateLogWriter; override;
  end;

{$ifdef WITHLOG}
var
  /// TSQLLog class is used for logging for all our ORM related functions
  // - this global variable can be used to customize it
  SQLite3Log: TSynLogClass = TSQLLog;
{$endif}


implementation

uses
  SynCrypto; // for TSQLRecordSigned


// ************ some RTTI and SQL mapping routines

{$ifdef FPC}
function aligntoptr(p : pointer) : pointer; inline;
begin
{$ifdef FPC_REQUIRES_PROPER_ALIGNMENT}
  result := align(p,sizeof(p));
{$else FPC_REQUIRES_PROPER_ALIGNMENT}
  result := p;
{$endif FPC_REQUIRES_PROPER_ALIGNMENT}
end;
{$endif}

type
  /// used to map a TPropInfo.GetProc/SetProc and retrieve its kind
  PropWrap = packed record
    FillBytes: array [0..SizeOf(Pointer)-2] of byte;
    /// = $ff for a field address, or =$fe for a virtual method
    Kind: byte;
  end;

const
  NO_INDEX = Integer($80000000);


function GetOrdProp(Instance: TObject; PropInfo: PPropInfo): PtrInt;
{$ifdef USETYPEINFO}
type // function(Instance: TObject) trick does not work with CPU64 :(
  TGetProc = function: PtrInt of object;
  TIndexedGetProc = function(Index: Integer): PtrInt of object;
var value: PtrInt;
    Call: TMethod;
    P: pointer;
begin
  if PropInfo^.GetProc=0 then  // no read attribute -> use write offset
    if PropWrap(PropInfo^.SetProc).Kind<>$FF then begin
      result := 0;
      exit;
    end else // we only allow setting if we know the field address
      P := Pointer(PtrInt(Instance)+PropInfo^.SetProc and $00FFFFFF) else
    if PropWrap(PropInfo^.GetProc).Kind=$FF then
      P := Pointer(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF) else begin
      if PropWrap(PropInfo^.GetProc).Kind=$FE then
        Call.Code := Pointer(PPtrUInt(PPtrInt(Instance)^+SmallInt(PropInfo^.GetProc))^) else
        Call.Code := Pointer(PropInfo^.GetProc);
      Call.Data := Instance;
      if PropInfo^.Index=NO_INDEX then
        value := TGetProc(Call) else
        value := TIndexedGetProc(Call)(PropInfo^.Index);
      P := @value;
    end;
  with PropInfo^.PropType^^ do
  if Kind=tkClass then
    Result := PPtrInt(P)^ else
    case OrdType of
    otSByte: result := PShortInt(P)^;
    otSWord: result := PSmallInt(P)^;
    otSLong: result := PInteger(P)^;
    otUByte, otUWord, otULong: result := PCardinal(P)^;
    else result := 0; // should not happen
    end;
end;
{$else}
asm     { ->    EAX Pointer to instance         }
        {       EDX Pointer to property info    }
        { <-    EAX Longint result              }
        PUSH    EBX
        PUSH    EDI
        MOV     EDI,[EDX].TPropInfo.PropType
        MOV     EDI,[EDI]
        MOV     BL,otSLong
        CMP     [EDI].TTypeInfo.Kind,tkClass
        JE      @@isClass
        MOVZX   ECX,[EDI].TTypeInfo.Name.Byte[0]
        MOV     BL,byte ptr [EDI].TTypeInfo.Name[ECX+1] // get the ord type
@@isClass:
        MOV     ECX,[EDX].TPropInfo.GetProc
        CMP     [EDX].TPropInfo.GetProc.Byte[3],$FE
        MOV     EDX,[EDX].TPropInfo.Index
        JB      @@isStaticMethod
        JA      @@isField
        {       the GetProc is a virtual method }
        MOVSX   ECX,CX                  { sign extend slot offs }
        ADD     ECX,[EAX]               { vmt   + slotoffs      }
        CALL    dword ptr [ECX]         { call vmt[slot]        }
        JMP     @@final
@@isStaticMethod:
        CALL    ECX
        JMP     @@final
@@isField:
        AND     ECX,$00FFFFFF
        ADD     ECX,EAX
        MOV     AL,[ECX]
        CMP     BL,otSWord
        JB      @@final
        MOV     AX,[ECX]
        CMP     BL,otSLong
        JB      @@final
        MOV     EAX,[ECX]
@@final:CMP     BL,otSLong
        JAE     @@exit
        CMP     BL,otSWord
        JAE     @@word
        CMP     BL,otSByte
        MOVSX   EAX,AL
        JE      @@exit
        AND     EAX,$FF
        JMP     @@exit
@@word: MOVSX   EAX,AX
        JE      @@exit
        AND     EAX,$FFFF
@@exit: POP     EDI
        POP     EBX
end;
{$endif}

procedure SetOrdProp(Instance: TObject; PropInfo: PPropInfo; Value: PtrInt);
// AB: use the getter field address if no setter (no write attribute) exists
{$ifdef USETYPEINFO}
type // procedure(Instance: TObject) trick does not work with CPU64 :(
  TSetProp = procedure(Value: PtrInt) of object;
  TIndexedProp = procedure(Index: integer; Value: PtrInt) of object;
var P: pointer;
    Call: TMethod;
begin
  if PropInfo^.SetProc=0 then  // no write attribute -> use read offset
    if PropWrap(PropInfo^.GetProc).Kind<>$FF then
      exit else // we only allow setting if we know the field address
      P := Pointer(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF) else
    if PropWrap(PropInfo^.SetProc).Kind=$FF then
      P := Pointer(PtrInt(Instance)+PropInfo^.SetProc and $00FFFFFF) else begin
      if PropWrap(PropInfo^.SetProc).Kind=$FE then
        Call.Code := Pointer(PPtrUInt(PPtrInt(Instance)^+SmallInt(PropInfo^.SetProc))^) else
        Call.Code := Pointer(PropInfo^.SetProc);
      Call.Data := Instance;
      if PropInfo^.Index=NO_INDEX then
        TSetProp(Call)(Value) else
        TIndexedProp(Call)(PropInfo^.Index,Value);
      exit;
    end;
  with PropInfo^.PropType^^ do
  if Kind=tkClass then
    PPtrInt(P)^ := Value else
    case OrdType of
    otSByte,otUByte: PByte(P)^ := Value;
    otSWord,otUWord: PWord(P)^ := Value;
    otSLong,otULong: PInteger(P)^ := Value;
    end;
end;
{$else}
asm     { ->    EAX Pointer to instance         }
        {       EDX Pointer to property info    }
        {       ECX Value                       }
        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
        MOV     EDI,EDX
        MOV     ESI,[EDI].TPropInfo.PropType
        MOV     ESI,[ESI]
        MOV     BL,otSLong
        CMP     [ESI].TTypeInfo.Kind,tkClass
        JE      @@isClass
        XOR     EBX,EBX
        MOV     BL,[ESI].TTypeInfo.Name.Byte[0]
        MOV     BL,byte ptr [ESI].TTypeInfo.Name[EBX+1] // get field size
@@isClass:
        MOV     EDX,[EDI].TPropInfo.Index       { pass Index in DX      }
        CMP     EDX,$80000000
        JNE     @@hasIndex
        MOV     EDX,ECX                         { pass value in EDX     }
@@hasIndex:
        MOV     ESI,[EDI].TPropInfo.SetProc
        OR      ESI,ESI // no setter ? -> use the field address
        JZ      @NOSET
        CMP     [EDI].TPropInfo.SetProc.Byte[3],$FE
@set:   JA      @@isField
        JB      @@isStaticMethod
        {       SetProc turned out to be a virtual method. call it      }
        MOVSX   ESI,SI                          { sign extend slot offset }
        ADD     ESI,[EAX]                       { vmt   + slot offset   }
        CALL    dword ptr [ESI]
        JMP     @@exit
@@isStaticMethod:
        CALL    ESI
        JMP     @@exit
@NoSet: MOV     ESI,[EDI].TPropInfo.GetProc // use the field address
        CMP     [EDI].TPropInfo.GetProc.Byte[3],$FF
        JNE     @@exit // we only allow setting if we know the field address
@@isField:
        AND     ESI,$00FFFFFF
        ADD     EAX,ESI
        MOV     [EAX],CL
        CMP     BL,otSWord
        JB      @@exit
        MOV     [EAX],CX
        CMP     BL,otSLong
        JB      @@exit
        MOV     [EAX],ECX
@@exit: POP     EDI
        POP     ESI
        POP     EBX
end;
{$endif}

function GetInt64Prop(Instance: TObject; PropInfo: PPropInfo): Int64;
{$ifdef USETYPEINFO}
type // function(Instance: TObject) trick does not work with CPU64 :(
  TGetProc = function: Int64 of object;
  TIndexedGetProc = function(Index: Integer): Int64 of object;
var Call: TMethod;
begin 
  if PropWrap(PropInfo^.GetProc).Kind=$FF then
    // field - Getter is the field offset in the instance data
    result := PInt64(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF)^
  else begin
    if PropWrap(PropInfo^.GetProc).Kind=$FE then
      Call.Code := Pointer(PPtrUInt(PPtrInt(Instance)^+SmallInt(PropInfo^.GetProc))^) else
      Call.Code := Pointer(PropInfo^.GetProc);
    Call.Data := Instance;
    if PropInfo^.Index=NO_INDEX then
      result := TGetProc(Call) else
      result := TIndexedGetProc(Call)(PropInfo^.Index);
  end;
end;
{$else}
asm     { ->    EAX Pointer to instance         }
        {       EDX Pointer to property info    }
        { <-    EDX:EAX result                  }
        CMP     [EDX].TPropInfo.GetProc.Byte[3],$FE
        MOV     ECX,[EDX].TPropInfo.GetProc
        MOV     EDX,[EDX].TPropInfo.Index       { pass Index in EDX     }
        JA      @@isField
        JB      @@isStaticMethod
        {       GetProc is a virtual method     }
        MOVSX   ECX,CX                          { sign extend slot number }
        ADD     ECX,[EAX]
        CALL    dword ptr [ECX]
        JMP     @@exit
@@isStaticMethod:
        CALL    ECX
        JMP     @@exit
@@isField:
        AND     ECX,$00FFFFFF
        ADD     EAX,ECX
        MOV     EDX,[EAX].Integer[4]
        MOV     EAX,[EAX].Integer[0]
@@exit:
end;
{$endif}

procedure SetInt64Prop(Instance: TObject; PropInfo: PPropInfo; const Value: Int64);
// AB: use the getter field address if no setter (no write attribute) exists
{$ifdef USETYPEINFO}
type // procedure(Instance: TObject) trick does not work with CPU64 :(
  TSetProp = procedure(const Value: Int64) of object;
  TIndexedProp = procedure(Index: integer; const Value: Int64) of object;
var Call: TMethod;
begin
  if PropInfo^.SetProc=0 then  // no write attribute -> use read offset
    if PropWrap(PropInfo^.GetProc).Kind<>$FF then
      exit else // we only allow setting if we know the field address
      PInt64(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF)^ := Value else
    if PropWrap(PropInfo^.SetProc).Kind=$FF then
      PInt64(PtrInt(Instance)+PropInfo^.SetProc and $00FFFFFF)^ := Value else begin
      if PropWrap(PropInfo^.SetProc).Kind=$FE then
        Call.Code := Pointer(PPtrUInt(PPtrInt(Instance)^+SmallInt(PropInfo^.SetProc))^) else
        Call.Code := Pointer(PropInfo^.SetProc);
      Call.Data := Instance;
      if PropInfo^.Index=NO_INDEX then
        TSetProp(Call)(Value) else
        TIndexedProp(Call)(PropInfo^.Index,Value);
  end;
end;
{$else}
asm     { ->    EAX Pointer to instance         }
        {       EDX Pointer to property info    }
        {       [ESP+4] Value                   }
        MOV     ECX,[EDX].TPropInfo.SetProc
        OR      ECX,ECX
        JZ      @NoSet
        CMP     [EDX].TPropInfo.SetProc.Byte[3],$FE
        JA      @@isField
        MOV     EDX,[EDX].TPropInfo.Index
        PUSH    Value.Integer[4]
        PUSH    Value.Integer[0]
        JB      @@isStaticMethod
        {       SetProc is a virtual method     }
        MOVSX   ECX,CX
        ADD     ECX,[EAX]
        CALL    DWORD PTR [ECX]
        JMP     @@exit
@@isStaticMethod:
        CALL    ECX
        JMP     @@exit
@NoSet: MOV     ECX,[EDX].TPropInfo.GetProc // use the field address
        CMP     [EDX].TPropInfo.GetProc.Byte[3],$FF
        JNE     @@exit // we only allow setting if we know the field address
@@isField:
        AND     ECX,$00FFFFFF
        ADD     EAX,ECX
        MOV     EDX,Value.Integer[0]
        MOV     ECX,Value.Integer[4]
        MOV     [EAX].Integer[0],EDX
        MOV     [EAX].Integer[4],ECX
@@exit:
end;
{$endif}

procedure GetLongStrProp(Instance: TObject; PropInfo: PPropInfo; var Value: RawByteString);
{$ifdef USETYPEINFO}
procedure CallMethod(Instance: TObject; PropInfo: PPropInfo; var Value: RawByteString);
type // function(Instance: TObject) trick does not work with CPU64 :(
  TAStringGetProc = function: RawByteString of object;
  TAStringIndexedGetProc = function(Index: Integer): RawByteString of object;
var Call: TMethod;
begin
  if PropWrap(PropInfo^.GetProc).Kind=$FE then
    // virtual method  - Getter is a signed 2 byte integer VMT offset
    Call.Code := Pointer(PPtrUInt(PPtrInt(Instance)^+SmallInt(PropInfo^.GetProc))^) else
    // static method - Getter is the actual address
    Call.Code := Pointer(PropInfo^.GetProc);
  Call.Data := Instance;
  if PropInfo^.Index=NO_INDEX then  // no index
    Value := TAStringGetProc(Call) else
    Value := TAStringIndexedGetProc(Call)(PropInfo^.Index);
end;
begin // caller must check that PropInfo^.PropType^.Kind = tkWString
  if PropWrap(PropInfo^.GetProc).Kind=$FF then
    // field - Getter is the field offset in the instance data
    Value := PRawByteString(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF)^ else
    CallMethod(Instance,PropInfo,Value);
end;
{$else}
asm     { ->    EAX Pointer to instance         }
        {       EDX Pointer to property info    }
        {       ECX Pointer to result string    }
        PUSH    ESI
        PUSH    EDI
        MOV     EDI,EDX
        MOV     EDX,[EDI].TPropInfo.Index       { pass index in EDX }
        CMP     EDX,$80000000
        JNE     @@hasIndex
        MOV     EDX,ECX                         { pass value in EDX }
@@hasIndex:
        MOV     ESI,[EDI].TPropInfo.GetProc
        CMP     [EDI].TPropInfo.GetProc.Byte[3],$FE
        JA      @@isField
        JB      @@isStaticMethod
@@isVirtualMethod:
        MOVSX   ESI,SI                          { sign extend slot offset }
        ADD     ESI,[EAX]                       { vmt + slot offset }
        CALL    DWORD PTR [ESI]
        JMP     @@exit
@@isStaticMethod:
        CALL    ESI
        JMP     @@exit
@@isField:
        AND     ESI,$00FFFFFF
        MOV     EDX,[EAX+ESI]
        MOV     EAX,ECX
        CALL    System.@LStrLAsg // copy local string(EDX) into string(EAX)
@@exit: POP     EDI
        POP     ESI
end;
{$endif}

procedure SetLongStrProp(Instance: TObject; PropInfo: PPropInfo; const Value: RawByteString);
// AB: use the getter field address if no setter (no write attribute) exists
{$ifdef USETYPEINFO}
type // procedure(Instance: TObject) trick does not work with CPU64 :(
  TSetProp = procedure(const Value: RawByteString) of object;
  TIndexedProp = procedure(Index: integer; const Value: RawByteString) of object;
var Call: TMethod;
begin // caller must check that PropInfo^.PropType^.Kind = tkLString
  if PropInfo^.SetProc=0 then  // no setter ?
    if PropWrap(PropInfo^.GetProc).Kind<>$FF then
      exit else  // we only allow setting if we know the field address
      PRawByteString(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF)^ := Value else
  if PropWrap(PropInfo^.SetProc).Kind=$FF then
    // field - Setter is the field offset in the instance data
    PRawByteString(PtrInt(Instance)+PropInfo^.SetProc and $00FFFFFF)^ := Value else begin
      if PropWrap(PropInfo^.SetProc).Kind=$FE then
        Call.Code := Pointer(PPtrUInt(PPtrInt(Instance)^+SmallInt(PropInfo^.SetProc))^) else
        Call.Code := Pointer(PropInfo^.SetProc);
      Call.Data := Instance;
      if PropInfo^.Index=NO_INDEX then
        TSetProp(Call)(Value) else
        TIndexedProp(Call)(PropInfo^.Index,Value);
  end;
end;
{$else}
asm     { ->    EAX Pointer to instance         }
        {       EDX Pointer to property info    }
        {       ECX Pointer to string value     }
        PUSH    ESI
        PUSH    EDI
        MOV     ESI,EDX
        MOV     EDX,[ESI].TPropInfo.Index       { pass index in EDX }
        CMP     EDX,$80000000
        JNE     @@hasIndex
        MOV     EDX,ECX                         { pass value in EDX }
@@hasIndex:
        MOV     EDI,[ESI].TPropInfo.SetProc
        or edi,edi // no setter ?
        jz @NoSet
        CMP     [ESI].TPropInfo.SetProc.Byte[3],$FE
        JA      @@isField
        JB      @@isStaticMethod
@@isVirtualMethod:
        MOVSX   EDI,DI
        ADD     EDI,[EAX]
        CALL    DWORD PTR [EDI]
        JMP     @@exit
@@isStaticMethod:
        CALL    EDI
        JMP     @@exit
@NoSet: MOV     EDI,[ESI].TPropInfo.GetProc // use the field address
        CMP     [ESI].TPropInfo.GetProc.Byte[3],$FF
        JNE     @@exit // we only allow setting if we know the field address
@@isField:
        AND     EDI,$00FFFFFF
        ADD     EAX,EDI
        MOV     EDX,ECX
        CALL    System.@LStrLAsg // copy local string(EDX) into string(EAX)
@@exit: POP     EDI
        POP     ESI
end;
{$endif}

{$ifdef USETYPEINFO}
// this pure pascal version must handle the 64-bits ordinal values and
// the special layout of the underlying compiler (mostly FPC)
// -> use the typinfo unit
procedure GetWideStrProp(Instance: TObject; PropInfo: PPropInfo; var Value: WideString); overload;
{$ifdef HASINLINE}inline;{$endif}
begin
  Value := GetWideStrProp(Instance,pointer(PropInfo));
end;
{$else}

procedure GetWideStrProp(Instance: TObject; PropInfo: PPropInfo; var Value: WideString);
type
  TUStringGetProc = function: WideString of object;
  TUStringIndexedGetProc = function(Index: Integer): WideString of object;
var M: TMethod;
begin // caller must check that PropInfo^.PropType^.Kind = tkWString
  if PropWrap(PropInfo^.GetProc).Kind=$FF then 
    // field - Getter is the field offset in the instance data
    Value := PWideString(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF)^
  else begin
    if PropWrap(PropInfo^.GetProc).Kind=$FE then
      // virtual method  - Getter is a signed 2 byte integer VMT offset
      M.Code := Pointer(PPtrUInt(PPtrInt(Instance)^+SmallInt(PropInfo^.GetProc))^) else
      // static method - Getter is the actual address
      M.Code := Pointer(PropInfo^.GetProc);
    M.Data := Instance;
    if PropInfo^.Index=NO_INDEX then  // no index
      Value := TUStringGetProc(M)() else
      Value := TUStringIndexedGetProc(M)(PropInfo^.Index);
  end;
end;

procedure SetWideStrProp(Instance: TObject; PropInfo: PPropInfo; const Value: WideString);
type
  TUStringSetProc = procedure(const Value: WideString) of object;
  TUStringIndexedSetProc = procedure(Index: Integer; const Value: WideString) of object;
var M: TMethod;
begin // caller must check that PropInfo^.PropType^.Kind = tkWString
  if PropInfo^.SetProc=0 then  // no setter ?
    if PropWrap(PropInfo^.GetProc).Kind<>$FF then
      exit else begin  // we only allow setting if we know the field address
      PWideString(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF)^ := Value;
      exit;
    end;
  if PropWrap(PropInfo^.SetProc).Kind=$FF then
    // field - Setter is the field offset in the instance data
    PWideString(PtrInt(Instance)+PropInfo^.SetProc and $00FFFFFF)^ := Value else begin
    if PropWrap(PropInfo^.SetProc).Kind=$FE then
      // virtual method  - Setter is a signed 2 byte integer VMT offset
      M.Code := Pointer(PPtrUInt(PPtrInt(Instance)^+SmallInt(PropInfo^.SetProc))^) else
      // static method - Setter is the actual address
      M.Code := Pointer(PropInfo^.SetProc);
    M.Data := Instance;
    if PropInfo^.Index=NO_INDEX then  // no index
      TUStringSetProc(M)(Value) else
      TUStringIndexedSetProc(M)(PropInfo^.Index, Value);
  end;
end;

{$ifdef UNICODE}
function GetUnicodeStrProp(Instance: TObject; PropInfo: PPropInfo): UnicodeString;
type
  TUStringGetProc = function: UnicodeString of object;
  TUStringIndexedGetProc = function(Index: Integer): UnicodeString of object;
var M: TMethod;
begin // caller must check that PropInfo^.PropType^.Kind = tkUString
  if PropWrap(PropInfo^.GetProc).Kind=$FF then
    // field - Getter is the field offset in the instance data
    result := PUnicodeString(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF)^
  else begin
    if PropWrap(PropInfo^.GetProc).Kind=$FE then
      // virtual method  - Getter is a signed 2 byte integer VMT offset
      M.Code := Pointer(PPtrUInt(PPtrInt(Instance)^+SmallInt(PropInfo^.GetProc))^) else
      // static method - Getter is the actual address
      M.Code := Pointer(PropInfo^.GetProc);
    M.Data := Instance;
    if PropInfo^.Index=NO_INDEX then  // no index
      result := TUStringGetProc(M)() else
      result := TUStringIndexedGetProc(M)(PropInfo^.Index);
  end;
end;

procedure SetUnicodeStrProp(Instance: TObject; PropInfo: PPropInfo; const Value: UnicodeString);
type
  TUStringSetProc = procedure (const Value: UnicodeString) of object;
  TUStringIndexedSetProc = procedure (Index: Integer; const Value: UnicodeString) of object;
var M: TMethod;
begin // caller must check that PropInfo^.PropType^.Kind = tkUString
  if PropInfo^.SetProc=0 then  // no setter ?
    if PropWrap(PropInfo^.GetProc).Kind<>$FF then
      exit else begin  // we only allow setting if we know the field address
      PUnicodeString(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF)^ := Value;
      exit;
    end;
  if PropWrap(PropInfo^.SetProc).Kind=$FF then
    // field - Setter is the field offset in the instance data
    PUnicodeString(PtrInt(Instance)+PropInfo^.SetProc and $00FFFFFF)^ := Value else begin
    if PropWrap(PropInfo^.SetProc).Kind=$FE then
      // virtual method  - Setter is a signed 2 byte integer VMT offset
      M.Code := Pointer(PPtrUInt(PPtrInt(Instance)^+SmallInt(PropInfo^.SetProc))^) else
      // static method - Setter is the actual address
      M.Code := Pointer(PropInfo^.SetProc);
    M.Data := Instance;
    if PropInfo^.Index=NO_INDEX then // no index
      TUStringSetProc(M)(Value) else
      TUStringIndexedSetProc(M)(PropInfo^.Index, Value);
  end;
end;
{$endif UNICODE}

procedure SetFloatProp(Instance: TObject; PropInfo: PPropInfo; Value: Extended);
// AB: use the getter field address if no setter (no write attribute) exists
type // procedure(Instance: TObject) trick does not work with CPU64 :(
  TSingleSetProc = procedure(const Value: Single) of object;
  TDoubleSetProc = procedure(const Value: Double) of object;
  TExtendedSetProc = procedure(const Value: Extended) of object;
  TCompSetProc = procedure(const Value: Comp) of object;
  TCurrencySetProc = procedure(const Value: Currency) of object;
var P: Pointer;
    Call: TMethod;
label St;
begin
  if PropInfo^.SetProc=0 then  // no setter ?
    if PropWrap(PropInfo^.GetProc).Kind<>$FF then
      exit else begin  // we only allow setting if we know the field address
      P := Pointer(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF);
      goto St;  // use the field address to set its value
    end;
  if PropWrap(PropInfo^.SetProc).Kind=$FF then begin
    // field - SetProc is the field offset in the instance data
    P := Pointer(PtrInt(Instance)+PropInfo^.SetProc and $00FFFFFF);
St: case PropInfo^.PropType^^.FloatType of
      ftSingle:    PSingle(P)^ := Value;
      ftDouble:    PDouble(P)^ := Value;
      ftExtended:  PExtended(P)^ := Value;
      ftComp:      PComp(P)^ := Value;
      ftCurr:      PCurrency(P)^ := Value;
    end;
  end
  else begin
    if PropWrap(PropInfo^.SetProc).Kind=$FE then
      Call.Code := Pointer(PPtrUInt(PPtrInt(Instance)^+SmallInt(PropInfo^.SetProc))^) else
      Call.Code := Pointer(PropInfo^.SetProc);
    Call.Data := Instance;
    if PropInfo^.Index=NO_INDEX then begin // no index
      case PropInfo^.PropType^^.FloatType of
        ftSingle  :  TSingleSetProc(Call)(Value);
        ftDouble  :  TDoubleSetProc(Call)(Value);
        ftExtended:  TExtendedSetProc(Call)(Value);
        ftComp    :  TCompSetProc(Call)(Value);
        ftCurr    :  TCurrencySetProc(Call)(Value);
      end;
    end;  // indexed methods not handled here, since not used in TSQLRecord
  end;
end;
{$endif}

{$ifdef USETYPEINFO}
// this pure pascal version must handle the 64-bits ordinal values and
// the special layout of the underlying compiler (mostly FPC)
// -> use the typinfo unit
{$else}
function GetFloatProp(Instance: TObject; PropInfo: PPropInfo): Extended;
type // function(Instance: TObject) trick does not work with CPU64 :(
  TGetProc = function: extended of object;
  TIndexedGetProc = function(Index: Integer): extended of object;
var P: Pointer;
    Call: TMethod;
begin // faster code by AB
  if PropWrap(PropInfo^.GetProc).Kind=$FF then begin
    // field - GetProc is the field offset in the instance data
    P := Pointer(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF);
    case PropInfo^.PropType^.FloatType of
      ftSingle:    Result := PSingle(P)^;
      ftDouble:    Result := PDouble(P)^;
      ftExtended:  Result := PExtended(P)^;
      ftComp:      Result := PComp(P)^;
      ftCurr:      Result := PCurrency(P)^; // use GetInt64Prop() to avoid rounding
    else Result := 0;
    end;
  end
  else begin
    if PropWrap(PropInfo^.GetProc).Kind=$FE then
      Call.Code := Pointer(PPtrUInt(PPtrInt(Instance)^+SmallInt(PropInfo^.GetProc))^) else
      Call.Code := Pointer(PropInfo^.GetProc);
    Call.Data := Instance;
    if PropInfo^.Index=NO_INDEX then
      result := TGetProc(Call) else
      result := TIndexedGetProc(Call)(PropInfo^.Index);
    if PropInfo^.PropType^.FloatType = ftCurr then
      Result := Result / 10000;
  end;
end;
{$endif}


{$ifdef USETYPEINFO}
// this pure pascal version must handle the 64-bits ordinal values and
// the special layout of the underlying compiler (mostly FPC)
// -> use the typinfo unit
{$else}
function GetMethodProp(Instance: TObject; PropInfo: PPropInfo): TMethod;
asm     { ->    EAX Pointer to instance         }
        {       EDX Pointer to property info    }
        {       ECX Pointer to result           }
        PUSH    EBX
        PUSH    EDI
        MOV     EDI,EDX
        MOV     EDX,[EDI].TPropInfo.Index       { pass Index in DX      }
        CMP     EDX,$80000000
        JNE     @@hasIndex
        MOV     EDX,ECX                         { pass value in EDX     }
@@hasIndex:
        MOV     EBX,[EDI].TPropInfo.GetProc
        CMP     [EDI].TPropInfo.GetProc.Byte[3],$FE
        JA      @@isField
        JB      @@isStaticMethod
        {       GetProc is a virtual method     }
        MOVSX   EBX,BX                          { sign extend slot number }
        ADD     EBX,[EAX]
        CALL    dword ptr [EBX]
        JMP     @@exit
@@isStaticMethod:
        CALL    EBX
        JMP     @@exit
@@isField:
        AND     EBX,$00FFFFFF
        ADD     EAX,EBX
        MOV     EDX,[EAX]
        MOV     EBX,[EAX+4]
        MOV     [ECX],EDX
        MOV     [ECX+4],EBX
@@exit: POP     EDI
        POP     EBX
end;
{$endif}

function InternalMethodInfo(aClassType: TClass; const aMethodName: ShortString): PMethodInfo;
var Count, i: integer;
begin
  while aClassType<>nil do begin
    result := PPointer(PtrInt(aClassType)+vmtMethodTable)^;
    if result<>nil then begin
      {$ifdef FPC}
      Count := PCardinal(result)^;
      inc(PCardinal(result));
      {$else}
      Count := PWord(result)^;
      inc(PWord(result));
      {$endif}
      for i := 0 to Count-1 do
      if IdemPropName(result^.Name{$ifdef FPC}^{$endif},aMethodName) then
        Exit else
        {$ifdef FPC}
        inc(result);
        {$else}
        inc(PtrUInt(result),result^.Len);
        {$endif}
    end;
    if PPointer(PtrInt(aClassType)+vmtParent)^<>nil then
      aClassType := PPointer(PPointer(PtrInt(aClassType)+vmtParent)^)^ else
      break;
  end;
  result := nil;
end;

function TMethodInfo.MethodAddr: Pointer;
begin
  if @self<>nil then
    result := Addr else
    result := @self;
end;

function TMethodInfo.ReturnInfo: PReturnInfo;
begin
  if @self<>nil then begin
    result := {$ifdef FPC}aligntoptr{$endif}(@Name[ord(Name[0])+1]);
    if PtrUInt(result)-PtrUInt(@self)=Len then
      result := nil;
  end else
      result := @self;
end;

(*
function TMethodInfo.RetrieveValidTSQLRestServerCallBack: pointer;
{$ifndef DELPHI6OROLDER}
var RI: PReturnInfo;
{$endif}
begin
  {$ifdef DELPHI6OROLDER} // not enough RTTI (e.g. Delphi 6) -> assume OK :(
  if @Self<>nil then
    result := Addr else
  {$else}
  RI := ReturnInfo;
   if (RI=nil) and (@Self<>nil) then begin
    result := Addr; // returns method address (OK) if not enough RTTI
    exit;
  end;
  if (RI^.ParamCount=6) and (RI^.CallingConvention=ccRegister) and
     (RI^.ReturnType<>nil) and (RI^.ReturnType^.Kind=tkInteger) then
  with RI^.Param^ do // expects "aSession: cardinal"
    if ParamType^.Kind=tkInteger then
    with Next^ do
    if (ParamType^.Kind=tkClass) and ParamType^.InheritsFrom(TSQLRecord) then
      with Next^ {ignore PUTF8Char} .Next^ do // expects "const aSentData: RawUTF8"
      if (ParamType^.Kind=tkLString) and (pfConst in Flags) then
        with Next^ do // expects "out aResp: RawUTF8"
        if (ParamType^.Kind=tkLString) and (pfOut in Flags) then
          with Next^ do // expects "out aHead: RawUTF8"
          if (ParamType^.Kind=tkLString) and (pfOut in Flags) then begin
            result := Addr; // returns method address on matching signature
            exit;
          end;
  {$endif}
  result := nil; // method unknown or with wrong signature
end;
*)

function TReturnInfo.Param: PParamInfo;
begin
  result := Pointer(PtrUInt(@self)+sizeof(TReturnInfo));
end;

function TParamInfo.Next: PParamInfo;
begin
  result := {$ifdef FPC}aligntoptr{$endif}(@Name[ord(Name[0])+1]);
end;

{$ifdef FPC}
function InternalClassProp(ClassType: TClass): PClassProp;
begin // FPC use memory alignment + vmtTypeInfo =-60 -> use PtrInt
  result := PTypeInfo(PPointer(PtrInt(ClassType)+vmtTypeInfo)^)^.ClassType^.ClassProp;
end;
{$else}
{$ifdef PUREPASCAL}
function InternalClassProp(ClassType: TClass): PClassProp;
var PTI: PTypeInfo;
begin // code is a bit abstract, but compiles very well
  PTI := PPointer(PtrInt(ClassType)+vmtTypeInfo)^;
  if PTI<>nil then // avoid GPF if no RTTI available for this class
    with PTI^, PClassType(@Name[ord(Name[0])+1])^ do
      result := PClassProp(@UnitName[ord(UnitName[0])+1]) else
    result := nil;
end;
{$else}
function InternalClassProp(ClassType: TClass): PClassProp;
asm // this code is the fastest possible
  mov eax,[eax+vmtTypeInfo]
  or eax,eax; jz @z // avoid GPF if no RTTI available for this class
  movzx edx,byte ptr [eax].TTypeInfo.Name
  lea eax,[eax+edx].TTypeInfo.Name[1]
  movzx edx,byte ptr [eax].TClassType.UnitName
  lea eax,[eax+edx].TClassType.UnitName[1].TClassProp
@z:
end;
{$endif}
{$endif}

function ClassFieldIndex(ClassType: TClass; const PropName: shortstring): integer;
var P: PPropInfo;
    CP: PClassProp;
begin
  if ClassType<>nil then begin
    CP := InternalClassProp(ClassType);
    if CP<>nil then begin
      P := @CP^.PropList;
      for result := 0 to CP^.PropCount-1 do
        if IdemPropName(P^.Name,PropName) then
          exit else
          P := P^.Next;
    end;
  end;
  result := -1;
end;

function ClassFieldProp(ClassType: TClass; const PropName: shortstring): PPropInfo;
begin
  if ClassType<>nil then
    result := InternalClassProp(ClassType)^.FieldProp(PropName) else
    result := nil;
end;

function ClassFieldPropWithParents(aClassType: TClass; const PropName: shortstring): PPropInfo;
var i: integer;
    CP: PClassProp;
begin
  while aClassType<>nil do begin
    CP := InternalClassProp(aClassType);
    if CP=nil then
      break; // no RTTI information (e.g. reached TObject level)
    result := @CP^.PropList;
    for i := 1 to CP^.PropCount do
      if IdemPropName(result^.Name,PropName) then
        exit else
        result := result^.Next;
    aClassType := aClassType.ClassParent;
  end;
  result := nil;
end;

function ClassFieldPropWithParentsFromUTF8(aClassType: TClass; PropName: PUTF8Char): PPropInfo;
var i, L: integer;
    CP: PClassProp;
begin
  L := StrLen(PropName);
  while (L<>0) and (aClassType<>nil) do begin
    CP := InternalClassProp(aClassType);
    if CP=nil then
      break; // no RTTI information (e.g. reached TObject level)
    result := @CP^.PropList;
    for i := 1 to CP^.PropCount do
      if IdemPropName(result^.Name,PropName,L) then
        exit else
        {$ifdef FPC}
        result := result^.Next;
        {$else}
        result := @result^.Name[ord(result^.Name[0])+1]; // inlined result^.Next
        {$endif}
    aClassType := aClassType.ClassParent;
  end;
  result := nil;
end;

function GetObjectComponent(Obj: TPersistent; const ComponentName: shortstring;
  ComponentClass: TClass): pointer;
var P: PPropInfo;
begin
  result := nil;
  if Obj=nil then
    exit;
  P := ClassFieldPropWithParents(PPointer(Obj)^,ComponentName);
  if (P<>nil) and (P^.PropType^^.Kind=tkClass) then
    if P^.PropType^^.ClassType^.ClassType.InheritsFrom(ComponentClass) then
{$ifdef CPU64} // pointer(P) to call typinfo
      result := pointer(GetOrdProp(Obj, pointer(P))); {$else}
      result := pointer(P^.GetOrdValue(Obj));
{$endif}
end;
  
function ClassFieldPropFromIndex(ClassType: TClass; PropIndex: integer): PPropInfo;
var i: integer;
begin
  result := nil;
  if ClassType<>nil then
  with InternalClassProp(ClassType)^ do
  if PropIndex<PropCount then begin
    result := @PropList;
    for i := 1 to PropIndex do
      result := result^.Next;
  end;
end;

function GetEnumCaption(aTypeInfo: PTypeInfo; const aIndex): string;
begin
  if (aTypeInfo=nil) or (aTypeInfo^.Kind<>tkEnumeration) then
    result := '' else
    result := aTypeInfo^.EnumBaseType^.GetCaption(PByte(@aIndex)^);
end;

function GetEnumNameTrimed(aTypeInfo: PTypeInfo; const aIndex): RawUTF8;
begin
  if (aTypeInfo=nil) or (aTypeInfo^.Kind<>tkEnumeration) then
    result := '' else
    result := aTypeInfo^.EnumBaseType^.GetEnumNameTrimed(aIndex);
end;


{ TSQLPropInfo }

const
  NULL_SHORTSTRING: string[0] = '';

function TSQLPropInfo.GetSQLFieldTypeName: PShortString;
begin
  if self=nil then
    result := @NULL_SHORTSTRING else
    result := PTypeInfo(TypeInfo(TSQLFieldType))^.EnumBaseType^.GetEnumNameOrd(ord(SQLFieldType));
end;

procedure TSQLPropInfo.TextToBinary(Value: PUTF8Char; var result: RawByteString);
begin
  result := BlobToTSQLRawBlob(Value);
end;

procedure TSQLPropInfo.BinaryToText(var Value: RawUTF8; ToSQL: boolean;
  wasSQLString: PBoolean);
begin
  if Value='' then begin
    if wasSQLString<>nil then
      wasSQLString^ := false;
    Value := 'null';
  end else begin
    if wasSQLString<>nil then
      wasSQLString^ := true;
    if ToSQL then
      // encode as BLOB literals (e.g. "X'53514C697465'")
      Value := TSQLRawBlobToBlob(TSQLRawBlob(Value)) else
      // JSON content is e.g. '\uFFF0base64encodedbinary'
      Value := BinToBase64WithMagic(Value);
  end;
end;

constructor TSQLPropInfo.Create(const aName: RawUTF8; aSQLFieldType: TSQLFieldType;
  aAttributes: TSQLPropInfoAttributes; aFieldWidth: integer);
begin
  if aName='' then
    EORMException.CreateFmt('Void name for %s.Create',[ClassName]);
  fName := aName;
  fSQLFieldType := aSQLFieldType;
  fAttributes := aAttributes;
  fFieldWidth := aFieldWidth;
end;

function TSQLPropInfo.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var tmp: RawUTF8;
begin
  GetValueVar(Instance,false,tmp,nil);
  result := crc32(0,pointer(tmp),length(tmp));
end;

procedure TSQLPropInfo.GetJSONValues(Instance: TObject; W: TJSONSerializer);
var wasString: boolean;
    tmp: RawUTF8;
begin
  GetValueVar(Instance,false,tmp,@wasString);
  if wasString then begin
    W.Add('"');
    if PtrUInt(tmp)<>0 then
      W.AddJSONEscape(pointer(tmp),PInteger(PtrUInt(tmp)-4)^);
    W.Add('"');
  end else
    if PtrUInt(tmp)<>0 then
      W.AddNoJSONEscape(pointer(tmp),PInteger(PtrUInt(tmp)-4)^);
end;

function TSQLPropInfo.GetValue(Instance: TObject; ToSQL: boolean;
  wasSQLString: PBoolean): RawUTF8;
begin
  GetValueVar(Instance,ToSQL,Result,wasSQLString);
end;

const
  SQLFieldTypeToVType: array[TSQLFieldType] of word =
    (varEmpty,       // sftUnknown
     varString,      // sftAnsiText
     varString,      // sftUTF8Text
     varInt64,       // sftEnumerate
     varInt64,       // sftSet
     varInt64,       // sftInteger
     varInt64,       // sftID
     varInt64,       // sftRecord
     varInt64,       // sftBoolean
     varDouble,      // sftFloat
     varString,      // sftDateTime
     varInt64,       // sftTimeLog
     varDouble,      // sftCurrency
     varString,      // sftObject
{$ifdef USEVARIANTS}
     varString,      // sftVariant
{$endif}
     varAny,         // sftBlob
     varAny,         // sftBlobDynArray
     varAny,         // sftBlobCustom
     varString,      // sftUTF8Custom
{$ifdef PUBLISHRECORD}
     varAny,         // sftBlobRecord
{$endif}
     varEmpty,       // sftMany
     varInt64,       // sftModTime
     varInt64);      // sftCreateTime

procedure TSQLPropInfo.GetFieldVarData(Instance: TObject; var aValue: TVarData;
  var temp: RawByteString);
begin
  GetValueVar(Instance,true,RawUTF8(temp),nil);
  aValue.VType := SQLFieldTypeToVType[fSQLFieldType];
  case aValue.VType of
    varInt64:
      aValue.VInt64 := GetInt64(pointer(temp));
    varDouble:
      aValue.VDouble := GetExtended(pointer(temp));
    varAny: begin
      temp := BlobToTSQLRawBlob(Pointer(temp));
      aValue.VPointer := pointer(temp);
      aValue.VLongs[0] := length(temp);
    end;
    varString:
      aValue.VString := pointer(temp);
    else
      aValue.VAny := nil;
  end;
end;

function TSQLPropInfo.SetFieldVarData(Instance: TObject; const aValue: TVarData): boolean;
begin
  case aValue.VType of
    varInt64:
      SetValue(Instance,pointer(Int64ToUtf8(aValue.VInt64)),false);
    varDouble:
      SetValue(Instance,pointer(DoubleToStr(aValue.VDouble)),false);
    varAny:
      SetValue(Instance,pointer(TSQLRawBlobToBlob(aValue.VPointer,aValue.VLongs[0])),true);
    varString:
      SetValue(Instance,aValue.VString,true);
    else
      SetValue(Instance,nil,false);
  end;
  result := true;
end;

{$ifdef USEVARIANTS}
procedure TSQLPropInfo.GetVariant(Instance: TObject; var Dest: Variant);
var result: RawUTF8;
    I64: Int64;
begin
  GetValueVar(Instance,true,result,nil);
  case fSQLFieldType of
    sftBoolean:
      Dest := boolean(GetInteger(pointer(result)));
    sftEnumerate, sftSet, sftInteger, sftID, sftRecord,
    sftTimeLog, sftModTime, sftCreateTime: begin
      I64 := GetInt64(pointer(result));
      if (I64<=high(integer)) and (I64>=low(integer)) then
        Dest := integer(I64) else
        Dest := I64;
    end;
    sftFloat:
      Dest := GetExtended(pointer(result));
    sftCurrency: begin
      I64 := StrToCurr64(Pointer(result));
      Dest := PCurrency(@I64)^;
    end;
    sftDateTime:
      Dest := Iso8601ToDateTime(result);
  else
    Dest := UTF8ToString(result); // other types will be converted to string
  end;
end;

procedure TSQLPropInfo.SetVariant(Instance: TObject; const Source: Variant);
begin
  SetValue(Instance,pointer(VariantToUTF8(Source)),
    not (TVarData(Source).VType in VTYPE_STATIC));
end;
{$endif USEVARIANTS}

function TSQLPropInfo.CompareValue(Item1, Item2: TObject; CaseInsensitive: boolean): PtrInt;
var tmp1,tmp2: RawUTF8;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    GetValueVar(Item1,false,tmp1,nil);
    GetValueVar(Item2,false,tmp2,nil);
    if CaseInsensitive then // slow, always working implementation
      result := StrIComp(pointer(tmp1),pointer(tmp2)) else
      result := StrComp(pointer(tmp1),pointer(tmp2));
  end;
end;


{ TSQLPropInfoRTTI }

class function TSQLPropInfoRTTI.CreateFrom(aPropInfo: PPropInfo): TSQLPropInfo;
var aSQLFieldType: TSQLFieldType;
    aType: PTypeInfo;
    C: TSQLPropInfoRTTIClass;
begin
  if aPropInfo=nil then
    raise EORMException.Create('Invalid CreateFrom() call');
  aType := aPropInfo^.PropType^;
  aSQLFieldType := aType^.SQLFieldType;
  C := nil;
  case aSQLFieldType of
    sftUnknown, sftBlobCustom, sftUTF8Custom:
      ; // will raise an EORMException
    sftBoolean, sftEnumerate:
      C := TSQLPropInfoRTTIEnum;
    sftTimeLog, sftModTime, sftCreateTime: // specific class for further use
      C := TSQLPropInfoRTTITimeLog;
    sftCurrency:
      C := TSQLPropInfoRTTICurrency;
    sftDateTime:
      C := TSQLPropInfoRTTIDateTime;
    sftID:
      C := TSQLPropInfoRTTIID;
    sftRecord:
      C := TSQLPropInfoRTTIInstance;
    sftMany:
      C := TSQLPropInfoRTTIMany;
    sftObject:
      C := TSQLPropInfoRTTIObject;
    {$ifdef USEVARIANTS}
    sftVariant:
      C := TSQLPropInfoRTTIVariant; 
    {$endif}
    sftBlob:
      C := TSQLPropInfoRTTIRawBlob;
    sftBlobDynArray:
      C := TSQLPropInfoRTTIDynArray;
    else
    case aType^.Kind of // retrieve exact type at binary level
      tkInteger, tkRecord:
        C := TSQLPropInfoRTTIInt32;
      tkSet:
        C := TSQLPropInfoRTTISet;
      tkChar, tkWChar:
        C := TSQLPropInfoRTTIChar;
      tkInt64{$ifdef FPC}, tkQWord{$endif}:
        C := TSQLPropInfoRTTIInt64;
      tkFloat:
        if aType^.FloatType=ftDouble then
          C := TSQLPropInfoRTTIDouble;
      {$ifdef FPC}tkAString,{$endif}
      tkLString:
        if aType=TypeInfo(RawUTF8) then
          C := TSQLPropInfoRTTIRawUTF8 else
        if aType=TypeInfo(RawUnicode) then
          C := TSQLPropInfoRTTIRawUnicode else
        if aType=TypeInfo(WinAnsiString) then
          C := TSQLPropInfoRTTIWinAnsi else
        if aType=TypeInfo(AnsiString) then
          C := TSQLPropInfoRTTIAnsi;
      {$ifdef UNICODE}
      tkUString:
        C := TSQLPropInfoRTTIUnicode;
      {$endif}
      tkWString:
        C := TSQLPropInfoRTTIWide;
    end;
  end;
  if C=nil then
    raise EORMException.CreateFmt('Unhanled type for property %s',[aPropInfo^.Name]);
  result := C.Create(aPropInfo,aSQLFieldType);
end;

function TSQLPropInfoRTTI.GetFieldAddr(Instance: TObject): pointer;
begin
  if Instance=nil then
    result := nil else
    result := fPropInfo^.GetFieldAddr(Instance);
end;

constructor TSQLPropInfoRTTI.Create(aPropInfo: PPropInfo; aSQLFieldType: TSQLFieldType);
var attrib: TSQLPropInfoAttributes;
begin
  byte(attrib) := 0;
  if aPropInfo^.IsStored(nil)=AS_UNIQUE then
    Include(attrib,aIsUnique); // property MyProperty: RawUTF8 stored AS_UNIQUE;
  inherited Create(ShortStringToAnsi7String(aPropInfo^.Name),aSQLFieldType,attrib,
    aPropInfo^.Index); // property MyProperty: RawUTF8 index 10; -> FieldWidth=10
  fPropInfo := aPropInfo;
end;


{ TSQLPropInfoRTTIInt32 }

procedure TSQLPropInfoRTTIInt32.CopyValue(Source, Dest: TObject);
begin
  SetOrdProp(Dest,pointer(fPropInfo),GetOrdProp(Source,pointer(fPropInfo)));
end;

procedure TSQLPropInfoRTTIInt32.GetBinary(Instance: TObject; W: TFileBufferWriter);
begin
   W.WriteVarUInt32(cardinal(GetOrdProp(Instance,pointer(fPropInfo))));
end;

function TSQLPropInfoRTTIInt32.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
begin
  result := GetOrdProp(Instance,pointer(fPropInfo));
end;

procedure TSQLPropInfoRTTIInt32.GetJSONValues(Instance: TObject; W: TJSONSerializer);
begin
  W.Add(GetOrdProp(Instance,pointer(fPropInfo)));
end;

procedure TSQLPropInfoRTTIInt32.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  if wasSQLString<>nil then
    wasSQLString^ := false;
  result := Int32ToUtf8(GetOrdProp(Instance,pointer(fPropInfo)));
end;

procedure TSQLPropInfoRTTIInt32.NormalizeValue(var Value: RawUTF8);
var err, VInt: integer;
begin
  VInt := GetInteger(pointer(Value),err);
  if err<>0 then
    Value := '' else
    Value := Int32ToUtf8(VInt);
end;

function TSQLPropInfoRTTIInt32.CompareValue(Item1, Item2: TObject; CaseInsensitive: boolean): PtrInt;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else 
    result := GetOrdProp(Item1,pointer(fPropInfo))-GetOrdProp(Item2,pointer(fPropInfo));
end;

function TSQLPropInfoRTTIInt32.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
begin
  if P<>nil then
    SetOrdProp(Instance,pointer(fPropInfo),integer(FromVarUInt32(PByte(P))));
  result := P;
end;

procedure TSQLPropInfoRTTIInt32.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
begin
  SetOrdProp(Instance,pointer(fPropInfo),GetInteger(Value));
end;

function TSQLPropInfoRTTIInt32.SetFieldVarData(Instance: TObject; const aValue: TVarData): boolean;
begin
  if aValue.VType=varInt64 then begin
    SetOrdProp(Instance,pointer(fPropInfo),aValue.VInt64);
    result := true;
  end else
    result := inherited SetFieldVarData(Instance,aValue);
end;

procedure TSQLPropInfoRTTIInt32.GetFieldVarData(Instance: TObject; var aValue: TVarData;
  var temp: RawByteString);
begin
  aValue.VType := varInt64;
  aValue.VInt64 := GetOrdProp(Instance,pointer(fPropInfo));
end;


{ TSQLPropInfoRTTISet }

constructor TSQLPropInfoRTTISet.Create(aPropInfo: PPropInfo; aSQLFieldType: TSQLFieldType);
begin
  inherited;
  fSetEnumType := fPropInfo^.PropType^^.SetEnumType;
end;


{ TSQLPropInfoRTTIEnum }

constructor TSQLPropInfoRTTIEnum.Create(aPropInfo: PPropInfo; aSQLFieldType: TSQLFieldType);
begin
  inherited;
  fEnumType := fPropInfo^.PropType^^.EnumBaseType;
end;

procedure TSQLPropInfoRTTIEnum.GetJSONValues(Instance: TObject; W: TJSONSerializer);
var i: integer;
begin
  i := GetOrdProp(Instance,pointer(fPropInfo));
  if fSQLFieldType=sftBoolean then
    W.AddString(JSON_BOOLEAN[boolean(i)]) else
    W.Add(i);
end;

procedure TSQLPropInfoRTTIEnum.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
var i: integer;
begin
  if wasSQLString<>nil then
    wasSQLString^ := false;
  i := GetOrdProp(Instance,pointer(fPropInfo));
  if (fSQLFieldType=sftBoolean) and not ToSQL then
    result := JSON_BOOLEAN[boolean(i)] else
    result := Int32ToUtf8(i);
end;

procedure TSQLPropInfoRTTIEnum.NormalizeValue(var Value: RawUTF8);
var i,err: integer;
begin
  i := GetInteger(pointer(Value),err);
  if err<>0 then // we allow a value stated as text
    if fSQLFieldType=sftBoolean then
      i := fEnumType^.GetEnumNameValue(Value) else   // 'true' or 'false'
      i := fEnumType^.GetEnumNameTrimedValue(Value); // -> convert into integer
  if cardinal(i)>cardinal(fEnumType^.MaxValue) then
    Value := '' else  // only set a valid value
    Value := Int32ToUtf8(i);
end;

procedure TSQLPropInfoRTTIEnum.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
var i,err: integer;
begin
  if Value=nil then
    i := 0 else begin
    i := GetInteger(Value,err);
    if err<>0 then // we allow a value stated as text
      if fSQLFieldType=sftBoolean then
        i := fEnumType^.GetEnumNameValue(Value) else   // 'true' or 'false'
        i := fEnumType^.GetEnumNameTrimedValue(Value); // -> convert into integer
    if cardinal(i)>cardinal(fEnumType^.MaxValue) then
      i := 0;  // only set a valid value
  end;
  SetOrdProp(Instance,pointer(fPropInfo),i);
end;


{ TSQLPropInfoRTTIChar }

procedure TSQLPropInfoRTTIChar.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
var w: WideChar;
begin
  w := WideChar(GetOrdProp(Instance,pointer(fPropInfo)));
  if ToSQL and (w=#0) then begin
    // 'null' and not #0 to avoid end of SQL text - JSON will escape #0
    result := 'null';
    if wasSQLString<>nil then
      wasSQLString^ := false;
   end else begin
    RawUnicodeToUtf8(@w,1,result);
    if wasSQLString<>nil then
      wasSQLString^ := true;
  end;
end;

procedure TSQLPropInfoRTTIChar.NormalizeValue(var Value: RawUTF8);
begin // do nothing: should already be UTF-8 encoded
end;

const
  NULL_LOW = ord('n')+ord('u')shl 8+ord('l')shl 16+ord('l')shl 24;

procedure TSQLPropInfoRTTIChar.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
var i: integer;
begin
  if (Value=nil) or (PInteger(Value)^=NULL_LOW) then
    i := 0 else
    i := GetUTF8Char(Value);
  SetOrdProp(Instance,pointer(fPropInfo),I);
end;


{ TSQLPropInfoRTTIInt64 }

procedure TSQLPropInfoRTTIInt64.CopyValue(Source, Dest: TObject);
begin
  SetInt64Prop(Dest,pointer(fPropInfo),GetInt64Prop(Source,pointer(fPropInfo)));
end;

procedure TSQLPropInfoRTTIInt64.GetBinary(Instance: TObject;
  W: TFileBufferWriter);
var V64: Int64;
begin
  V64 := GetInt64Prop(Instance,pointer(fPropInfo));
  W.Write(@V64,SizeOf(Int64));
end;

function TSQLPropInfoRTTIInt64.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var I64: Int64;
begin
  I64 := GetInt64Prop(Instance,pointer(fPropInfo));
  result := Int64Rec(I64).Lo xor Int64Rec(I64).Hi;
end;

procedure TSQLPropInfoRTTIInt64.GetJSONValues(Instance: TObject; W: TJSONSerializer);
begin
  W.Add(GetInt64Prop(Instance,pointer(fPropInfo)));
end;

procedure TSQLPropInfoRTTIInt64.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  if wasSQLString<>nil then
    wasSQLString^ := false;
  result := Int64ToUtf8(GetInt64Prop(Instance,pointer(fPropInfo)));
end;

procedure TSQLPropInfoRTTIInt64.NormalizeValue(var Value: RawUTF8);
var err: integer;
    VInt64: Int64;
begin
  VInt64 := GetInt64(pointer(Value),err);
  if err<>0 then
    Value := '' else
    Value := Int64ToUtf8(VInt64);
end;

function TSQLPropInfoRTTIInt64.CompareValue(Item1, Item2: TObject; CaseInsensitive: boolean): PtrInt;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else 
    result := GetInt64Prop(Item1,pointer(fPropInfo))-GetInt64Prop(Item2,pointer(fPropInfo));
end;

function TSQLPropInfoRTTIInt64.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
begin
  if P=nil then
    result := nil else begin
    SetInt64Prop(Instance,pointer(fPropInfo),PInt64(P)^);
    result := P+sizeof(Int64);
  end;
end;

procedure TSQLPropInfoRTTIInt64.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
begin
  SetInt64Prop(Instance,pointer(fPropInfo),GetInt64(Value));
end;

function TSQLPropInfoRTTIInt64.SetFieldVarData(Instance: TObject; const aValue: TVarData): boolean;
begin
  if aValue.VType=varInt64 then begin
    SetInt64Prop(Instance,pointer(fPropInfo),aValue.VInt64);
    result := true;
  end else
    result := inherited SetFieldVarData(Instance,aValue);
end;

procedure TSQLPropInfoRTTIInt64.GetFieldVarData(Instance: TObject; var aValue: TVarData;
  var temp: RawByteString);
begin
  aValue.VType := varInt64;
  aValue.VInt64 := GetInt64Prop(Instance,pointer(fPropInfo));
end;


{ TSQLPropInfoRTTIDouble }

procedure TSQLPropInfoRTTIDouble.GetJSONValues(Instance: TObject; W: TJSONSerializer);
begin
  W.Add(GetFloatProp(Instance,pointer(fPropInfo)));
end;

procedure TSQLPropInfoRTTIDouble.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  if wasSQLString<>nil then
    wasSQLString^ := false;
  result := ExtendedToStr(GetFloatProp(Instance,pointer(fPropInfo)),DOUBLE_PRECISION);
end;

procedure TSQLPropInfoRTTIDouble.NormalizeValue(var Value: RawUTF8);
var VFloat: Extended;
    err: integer;
begin
  VFloat := GetExtended(pointer(Value),err);
  if err<>0 then
    Value := '' else
    Value := ExtendedToStr(VFloat,DOUBLE_PRECISION);
end;

procedure TSQLPropInfoRTTIDouble.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
var V: extended;
    err: integer;
begin
  if Value=nil then begin
    V := 0;
    err := 1;
  end else
    V := GetExtended(pointer(Value),err);
  if err<>0 then
    SetInt64Prop(Instance,pointer(fPropInfo),0) else
    SetFloatProp(Instance,pointer(fPropInfo),V);
end;

function TSQLPropInfoRTTIDouble.CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt;
var V1, V2: double;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    V1 := GetFloatProp(Item1,pointer(fPropInfo));
    V2 := GetFloatProp(Item2,pointer(fPropInfo));
    if SynCommons.SameValue(V1,V2) then
      result := 0 else
    if V1>V2 then
      result := 1 else
      result := -1;
  end;
end;

function TSQLPropInfoRTTIDouble.SetFieldVarData(Instance: TObject; const aValue: TVarData): boolean;
begin
  if aValue.VType=varDouble then begin
    SetFloatProp(Instance,pointer(fPropInfo),aValue.VDouble);
    result := true;
  end else
    result := inherited SetFieldVarData(Instance,aValue);
end;

procedure TSQLPropInfoRTTIDouble.GetFieldVarData(Instance: TObject; var aValue: TVarData;
  var temp: RawByteString);
begin
  aValue.VType := varDouble;
  aValue.VDouble := GetFloatProp(Instance,pointer(fPropInfo));
end;


{ TSQLPropInfoRTTICurrency }

procedure TSQLPropInfoRTTICurrency.GetJSONValues(Instance: TObject; W: TJSONSerializer);
begin
  W.AddCurr64(GetInt64Prop(Instance,pointer(fPropInfo)));
end;

procedure TSQLPropInfoRTTICurrency.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  if wasSQLString<>nil then
    wasSQLString^ := false;
  result := Curr64ToStr(GetInt64Prop(Instance,pointer(fPropInfo)));
end;

procedure TSQLPropInfoRTTICurrency.NormalizeValue(var Value: RawUTF8);
begin
  Value := Curr64ToStr(StrToCurr64(pointer(Value)));
end;

procedure TSQLPropInfoRTTICurrency.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
begin
  SetInt64Prop(Instance,pointer(fPropInfo),StrToCurr64(Value));
end;


{ TSQLPropInfoRTTIDateTime }

procedure TSQLPropInfoRTTIDateTime.GetJSONValues(Instance: TObject; W: TJSONSerializer);
begin
  W.Add('"');
  W.AddDateTime(GetFloatProp(Instance,pointer(fPropInfo)));
  W.Add('"');
end;

function TSQLPropInfoRTTIDateTime.CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt;
var Date1,Date2: Iso8601;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    Date1.From(GetFloatProp(Item1,pointer(fPropInfo)));
    Date2.From(GetFloatProp(Item2,pointer(fPropInfo)));
    result := Date1.Value-Date2.Value;
  end;
end;

procedure TSQLPropInfoRTTIDateTime.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  if wasSQLString<>nil then
    wasSQLString^ := true;
  result := DateTimeToIso8601Text(GetFloatProp(Instance,pointer(fPropInfo)));
end;

procedure TSQLPropInfoRTTIDateTime.NormalizeValue(var Value: RawUTF8);
begin
  Value := DateTimeToIso8601Text(Iso8601ToDateTime(Value));
end;

procedure TSQLPropInfoRTTIDateTime.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
var V: TDateTime;
begin
  Iso8601ToDateTimePUTF8CharVar(Value,0,V);
  SetFloatProp(Instance,pointer(fPropInfo),V);
end;


{ TSQLPropInfoRTTIMany }

// TSQLRecordMany stores nothing within the table

procedure TSQLPropInfoRTTIMany.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  result := '';
end;

procedure TSQLPropInfoRTTIMany.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
begin
end;

procedure TSQLPropInfoRTTIMany.GetBinary(Instance: TObject; W: TFileBufferWriter);
begin
end;

function TSQLPropInfoRTTIMany.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
begin
  result := P;
end;


{ TSQLPropInfoRTTIInstance }

constructor TSQLPropInfoRTTIInstance.Create(aPropInfo: PPropInfo;
  aSQLFieldType: TSQLFieldType);
begin
  inherited Create(aPropInfo,aSQLFieldType);
  fObjectClass := aPropInfo^.PropType^^.ClassType^.ClassType;
end;

function TSQLPropInfoRTTIInstance.GetInstance(Instance: TObject): TObject;
begin
  result := pointer(GetOrdProp(Instance,pointer(fPropInfo)));
end;

procedure TSQLPropInfoRTTIInstance.SetInstance(Instance, Value: TObject);
begin
  SetOrdProp(Instance,pointer(fPropInfo),PtrInt(Value));
end;


{ TSQLPropInfoRTTIIObject }

procedure TSQLPropInfoRTTIObject.CopyValue(Source, Dest: TObject);
var S,D: TObject;
begin
  // generic case: copy also class content (create instances)
  S := GetInstance(Source);
  D := GetInstance(Dest);
  // note: Get/SetOrdProp() works also for CPU64 (returns an PtrInt)
{$ifndef LVCL}
  if S.InheritsFrom(TCollection) then
    CopyCollection(TCollection(S),TCollection(D)) else
{$endif} begin
    D.Free; // release previous child
    if S=nil then
      D := nil else begin
      D := ClassInstanceCreate(S.ClassType); // create new child instance
      CopyObject(S,D); // copy child content
    end;
    SetInstance(Dest,D);
  end;
end;                 

procedure TSQLPropInfoRTTIObject.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
var valid: boolean;
begin
  PropInfo^.ClassFromJSON(Instance,Value,valid);
end;

procedure TSQLPropInfoRTTIObject.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  if wasSQLString<>nil then
    wasSQLString^ := true;
  result := ObjectToJSON(GetInstance(Instance));
end;                                         

procedure TSQLPropInfoRTTIObject.GetBinary(Instance: TObject; W: TFileBufferWriter);
begin
  // serialize object as JSON UTF-8 TEXT - not fast, but works
  W.Write(ObjectToJSON(GetInstance(Instance)));
end;

function TSQLPropInfoRTTIObject.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
var valid: boolean;
begin
  // unserialize object from JSON UTF-8 TEXT - not fast, but works
  PropInfo^.ClassFromJSON(Instance,pointer(FromVarString(PByte(P))),valid);
  if valid then
    result := P else
    result := nil;
end;

function TSQLPropInfoRTTIObject.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var tmp: RawUTF8;
begin
  tmp := ObjectToJSON(GetInstance(Instance));
  result := crc32(0,pointer(tmp),length(tmp));
end;

procedure TSQLPropInfoRTTIObject.NormalizeValue(var Value: RawUTF8);
begin // do nothing: should already be normalized
end;

procedure TSQLPropInfoRTTIObject.GetJSONValues(Instance: TObject; W: TJSONSerializer);
begin
  W.WriteObjectAsString(GetInstance(Instance));
end;


{ TSQLPropInfoRTTIAnsi }

procedure TSQLPropInfoRTTIAnsi.CopyValue(Source, Dest: TObject);
var Value: RawByteString;
begin
  GetLongStrProp(Source,fPropInfo,Value);
  SetLongStrProp(Dest,fPropInfo,Value);
end;

procedure TSQLPropInfoRTTIAnsi.GetBinary(Instance: TObject; W: TFileBufferWriter);
var Value: RawByteString;
begin
  GetLongStrProp(Instance,fPropInfo,Value);
  W.Write(Value);
end;

function TSQLPropInfoRTTIAnsi.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var Up: array[byte] of AnsiChar; // avoid slow heap allocation
    Value: RawByteString;
begin
  GetLongStrProp(Instance,fPropInfo,Value);
  if CaseInsensitive then
    result := crc32(0,Up,UpperCopy255(Up,Value)-Up) else
    result := crc32(0,pointer(Value),length(Value));
end;

procedure TSQLPropInfoRTTIAnsi.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
var tmp: RawByteString;
begin
  if wasSQLString<>nil then
    wasSQLString^ := true;
  GetLongStrProp(Instance,fPropInfo,tmp);
  result := CurrentAnsiConvert.AnsiToUTF8(tmp);
end;

procedure TSQLPropInfoRTTIAnsi.NormalizeValue(var Value: RawUTF8);
begin // do nothing: should already be UTF-8 encoded
end;

function TSQLPropInfoRTTIAnsi.CompareValue(Item1, Item2: TObject; CaseInsensitive: boolean): PtrInt;
var tmp1,tmp2: RawByteString;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    GetLongStrProp(Item1,fPropInfo,tmp1);
    GetLongStrProp(Item2,fPropInfo,tmp2);
    if CaseInsensitive then
      result := StrIComp(pointer(tmp1),pointer(tmp2)) else
      result := StrComp(pointer(tmp1),pointer(tmp2));
  end;
end;

function TSQLPropInfoRTTIAnsi.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
begin
  SetLongStrProp(Instance,fPropInfo,FromVarString(PByte(P)));
  result := P;
end;

procedure TSQLPropInfoRTTIAnsi.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
begin
  if Value=nil then
    SetLongStrProp(Instance,fPropInfo,'') else
    SetLongStrProp(Instance,fPropInfo,
      CurrentAnsiConvert.UTF8BufferToAnsi(Value,StrLen(Value)));
end;


{ TSQLPropInfoRTTIRawUTF8 }

function TSQLPropInfoRTTIRawUTF8.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var Up: array[byte] of AnsiChar; // avoid slow heap allocation
    Value: RawByteString;
begin
  GetLongStrProp(Instance,fPropInfo,Value);
  if CaseInsensitive then
    result := crc32(0,Up,UTF8UpperCopy255(Up,Value)-Up) else
    result := crc32(0,pointer(Value),length(Value));
end;

procedure TSQLPropInfoRTTIRawUTF8.GetJSONValues(Instance: TObject; W: TJSONSerializer);
var tmp: RawByteString;
begin
  W.Add('"');
  GetLongStrProp(Instance,fPropInfo,tmp);
  if PtrUInt(tmp)<>0 then
    W.AddJSONEscape(pointer(tmp),PInteger(PtrUInt(tmp)-4)^);
  W.Add('"');
end;

procedure TSQLPropInfoRTTIRawUTF8.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  if wasSQLString<>nil then
    wasSQLString^ := true;
  GetLongStrProp(Instance,fPropInfo,RawByteString(result));
end;

function TSQLPropInfoRTTIRawUTF8.CompareValue(Item1, Item2: TObject; CaseInsensitive: boolean): PtrInt;
var tmp1,tmp2: RawByteString;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    GetLongStrProp(Item1,fPropInfo,tmp1);
    GetLongStrProp(Item2,fPropInfo,tmp2);
    if CaseInsensitive then
      result := UTF8IComp(pointer(tmp1),pointer(tmp2)) else
      result := StrComp(pointer(tmp1),pointer(tmp2));
  end;
end;

procedure TSQLPropInfoRTTIRawUTF8.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
begin
  SetLongStrProp(Instance,fPropInfo,RawUTF8(Value));
end;


{ TSQLPropInfoRTTIWinAnsi }

function TSQLPropInfoRTTIWinAnsi.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var Up: array[byte] of AnsiChar; // avoid slow heap allocation
    Value: RawByteString;
begin
  GetLongStrProp(Instance,fPropInfo,Value);
  if CaseInsensitive then
    result := crc32(0,Up,UpperCopyWin255(Up,Value)-Up) else
    result := crc32(0,pointer(Value),length(Value));
end;

procedure TSQLPropInfoRTTIWinAnsi.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
var tmp: RawByteString;
begin
  if wasSQLString<>nil then
    wasSQLString^ := true;
  GetLongStrProp(Instance,fPropInfo,tmp);
  result := WinAnsiConvert.AnsiBufferToRawUTF8(pointer(tmp),length(tmp));
end;

function TSQLPropInfoRTTIWinAnsi.CompareValue(Item1, Item2: TObject;
  CaseInsensitive: boolean): PtrInt;
var tmp1,tmp2: RawByteString;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    GetLongStrProp(Item1,fPropInfo,tmp1);
    GetLongStrProp(Item2,fPropInfo,tmp2);
    if CaseInsensitive then
      result := AnsiIComp(pointer(tmp1),pointer(tmp2)) else
      result := StrComp(pointer(tmp1),pointer(tmp2));
  end;
end;

procedure TSQLPropInfoRTTIWinAnsi.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
begin
  if Value=nil then
    SetLongStrProp(Instance,fPropInfo,'') else
    SetLongStrProp(Instance,fPropInfo,
      WinAnsiConvert.UTF8BufferToAnsi(Value,StrLen(Value)));
end;


{ TSQLPropInfoRTTIRawUnicode }

function TSQLPropInfoRTTIRawUnicode.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var Up: array[byte] of AnsiChar; // avoid slow heap allocation
    Value: RawByteString;
begin
  GetLongStrProp(Instance,fPropInfo,Value);
  if CaseInsensitive then
    result := crc32(0,Up,UpperCopy255W(Up,pointer(Value),length(Value)shr 1)-Up) else
    result := crc32(0,pointer(Value),length(Value));
end;

procedure TSQLPropInfoRTTIRawUnicode.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
var tmp: RawByteString;
begin
  if wasSQLString<>nil then
    wasSQLString^ := true;
  GetLongStrProp(Instance,fPropInfo,tmp);
  RawUnicodeToUTF8(pointer(tmp),length(tmp)shr 1,result);
end;

function TSQLPropInfoRTTIRawUnicode.CompareValue(Item1, Item2: TObject;
  CaseInsensitive: boolean): PtrInt;
var tmp1,tmp2: RawByteString;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    GetLongStrProp(Item1,fPropInfo,tmp1);
    GetLongStrProp(Item2,fPropInfo,tmp2);
    if CaseInsensitive then
      result := AnsiICompW(pointer(tmp1),pointer(tmp2)) else
      result := StrCompW(pointer(tmp1),pointer(tmp2));
  end;
end;

procedure TSQLPropInfoRTTIRawUnicode.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
begin
  if Value=nil then
    SetLongStrProp(Instance,fPropInfo,'') else
    SetLongStrProp(Instance,fPropInfo,Utf8DecodeToRawUnicode(Value,StrLen(Value)));
end;


{ TSQLPropInfoRTTIRawBlob }

function TSQLPropInfoRTTIRawBlob.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var Value: RawByteString;
begin
  GetLongStrProp(Instance,fPropInfo,Value);
  result := crc32(0,pointer(Value),length(Value)); // binary -> case sensitive
end;

procedure TSQLPropInfoRTTIRawBlob.GetJSONValues(Instance: TObject; W: TJSONSerializer);
var tmp: RawByteString;
begin
  GetLongStrProp(Instance,fPropInfo,tmp);
  W.WrRecord(pointer(tmp)^,fPropInfo^.PropType^);
end;

procedure TSQLPropInfoRTTIRawBlob.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  GetLongStrProp(Instance,fPropInfo,RawByteString(result));
  BinaryToText(result,ToSQL,wasSQLString);
end;

function TSQLPropInfoRTTIRawBlob.CompareValue(Item1, Item2: TObject;
  CaseInsensitive: boolean): PtrInt;
var tmp1,tmp2: RawByteString;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    GetLongStrProp(Item1,fPropInfo,tmp1);
    GetLongStrProp(Item2,fPropInfo,tmp2);
    // BLOB is binary so always case sensitive
    result := StrComp(pointer(tmp1),pointer(tmp2));
  end;
end;

procedure TSQLPropInfoRTTIRawBlob.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
begin
  SetLongStrProp(Instance,fPropInfo,BlobToTSQLRawBlob(Value));
end;

function TSQLPropInfoRTTIRawBlob.SetFieldVarData(Instance: TObject; const aValue: TVarData): boolean;
var tmp: RawByteString;
begin
  case aValue.VType of
  varAny: begin
    SetString(tmp,PAnsiChar(aValue.VPointer),aValue.VLongs[0]);
    SetLongStrProp(Instance,fPropInfo,tmp);
    result := true;
  end;
  varNull: begin
    SetLongStrProp(Instance,fPropInfo,'');
    result := True;
  end;
  else
    result := inherited SetFieldVarData(Instance,aValue);
  end;
end;

procedure TSQLPropInfoRTTIRawBlob.GetFieldVarData(Instance: TObject; var aValue: TVarData;
  var temp: RawByteString);
begin
  GetLongStrProp(Instance,fPropInfo,temp);
  aValue.VType := varAny;
  aValue.VPointer := pointer(temp);
  aValue.VLongs[0] := length(temp);
end;


{ TSQLPropInfoRTTIWide }

procedure TSQLPropInfoRTTIWide.CopyValue(Source, Dest: TObject);
var Value: WideString;
begin
  GetWideStrProp(Source,fPropInfo,Value);
  SetWideStrProp(Dest,pointer(fPropInfo),Value);
end;

procedure TSQLPropInfoRTTIWide.GetBinary(Instance: TObject; W: TFileBufferWriter);
var Value: WideString;
begin
  GetWideStrProp(Instance,fPropInfo,Value);
  W.Write(WideStringToUTF8(Value));
end;

function TSQLPropInfoRTTIWide.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var Up: array[byte] of AnsiChar; // avoid slow heap allocation
    Value: WideString;
begin
  GetWideStrProp(Instance,fPropInfo,Value);
  if CaseInsensitive then
    result := crc32(0,Up,UpperCopy255W(Up,pointer(Value),length(Value))-Up) else
    result := crc32(0,pointer(Value),length(Value)*2);
end;

procedure TSQLPropInfoRTTIWide.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
var Value: WideString;
begin
  GetWideStrProp(Instance,fPropInfo,Value);
  result := WideStringToUTF8(Value);
  if wasSQLString<>nil then
    wasSQLString^ := true;
end;

function TSQLPropInfoRTTIWide.CompareValue(Item1, Item2: TObject;
  CaseInsensitive: boolean): PtrInt;
var tmp1,tmp2: WideString;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    GetWideStrProp(Item1,fPropInfo,tmp1);
    GetWideStrProp(Item2,fPropInfo,tmp2);
    if CaseInsensitive then
      result := AnsiICompW(pointer(tmp1),pointer(tmp2)) else
      result := StrCompW(pointer(tmp1),pointer(tmp2));
  end;
end;

function TSQLPropInfoRTTIWide.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
begin
  SetWideStrProp(Instance,pointer(fPropInfo),
    UTF8ToWideString(FromVarString(PByte(P))));
  result := P;
end;

procedure TSQLPropInfoRTTIWide.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
var Wide: WideString;
begin
  UTF8ToWideString(Value,StrLen(Value),Wide);
  SetWideStrProp(Instance,pointer(fPropInfo),Wide);
end;


{$ifdef UNICODE}

{ TSQLPropInfoRTTIUnicode }

procedure TSQLPropInfoRTTIUnicode.CopyValue(Source, Dest: TObject);
begin
  SetUnicodeStrProp(Dest,pointer(fPropInfo),
    GetUnicodeStrProp(Source,pointer(fPropInfo)));
end;

procedure TSQLPropInfoRTTIUnicode.GetBinary(Instance: TObject; W: TFileBufferWriter);
begin
  W.Write(UnicodeStringToUtf8(GetUnicodeStrProp(Instance,pointer(fPropInfo))));
end;

function TSQLPropInfoRTTIUnicode.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var Up: array[byte] of AnsiChar; // avoid slow heap allocation
    Value: UnicodeString;
begin
  Value := GetUnicodeStrProp(Instance,pointer(fPropInfo));
  if CaseInsensitive then
    result := crc32(0,Up,UpperCopy255W(Up,pointer(Value),length(Value))-Up) else
    result := crc32(0,pointer(Value),length(Value)*2);
end;

procedure TSQLPropInfoRTTIUnicode.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  result := UnicodeStringToUtf8(GetUnicodeStrProp(Instance,pointer(fPropInfo)));
  if wasSQLString<>nil then
    wasSQLString^ := true;
end;

function TSQLPropInfoRTTIUnicode.CompareValue(Item1, Item2: TObject;
  CaseInsensitive: boolean): PtrInt;
var tmp1,tmp2: UnicodeString;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    tmp1 := GetUnicodeStrProp(Item1,pointer(fPropInfo));
    tmp2 := GetUnicodeStrProp(Item2,pointer(fPropInfo));
    if CaseInsensitive then
      result := AnsiICompW(pointer(tmp1),pointer(tmp2)) else
      result := StrCompW(pointer(tmp1),pointer(tmp2));
  end;
end;

function TSQLPropInfoRTTIUnicode.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
begin
  SetUnicodeStrProp(Instance,pointer(fPropInfo),
    UTF8DecodeToUnicodeString(FromVarString(PByte(P))));
  result := P;
end;

procedure TSQLPropInfoRTTIUnicode.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
begin
  SetUnicodeStrProp(Instance,pointer(fPropInfo),UTF8DecodeToUnicodeString(Value,StrLen(Value)));
end;

{$endif UNICODE}


{ TSQLPropInfoRTTIDynArray }

procedure TSQLPropInfoRTTIDynArray.CopyValue(Source, Dest: TObject);
begin
  GetDynArray(Dest).Copy(GetDynArray(Source));
end;

procedure TSQLPropInfoRTTIDynArray.GetBinary(Instance: TObject; W: TFileBufferWriter);
var Value: RawByteString;
begin
  Value := GetDynArray(Instance).SaveTo;
  W.Write(pointer(Value),length(Value));
end;

function TSQLPropInfoRTTIDynArray.GetDynArray(Instance: TObject): TDynArray;
begin
  result.Init(fPropInfo^.PropType^,GetFieldAddr(Instance)^);
end;

function TSQLPropInfoRTTIDynArray.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var tmp: RawByteString;
begin
  tmp := GetDynArray(Instance).SaveTo;
  result := crc32(0,pointer(tmp),length(tmp));
end;

procedure TSQLPropInfoRTTIDynArray.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  result := GetDynArray(Instance).SaveTo;
  BinaryToText(result,ToSQL,wasSQLString);
end;

{$ifdef USEVARIANTS}

procedure TSQLPropInfoRTTIDynArray.GetVariant(Instance: TObject; var Dest: Variant);
begin
  DynArrayToVariant(Dest,GetFieldAddr(Instance),fPropInfo^.PropType^);
end;

procedure TSQLPropInfoRTTIDynArray.SetVariant(Instance: TObject; const Source: Variant);
begin
  DynArrayFromVariant(PPointer(GetFieldAddr(Instance))^,Source,fPropInfo^.PropType^);
end;

{$endif USEVARIANTS}

procedure TSQLPropInfoRTTIDynArray.NormalizeValue(var Value: RawUTF8);
begin // do nothing: should already be normalized
end;

function TSQLPropInfoRTTIDynArray.CompareValue(Item1, Item2: TObject; CaseInsensitive: boolean): PtrInt;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else
  if GetDynArray(Item1).Equals(GetDynArray(Item2)) then
    result := 0 else
    result := PtrInt(Item1)-PtrInt(Item2); // pseudo comparison
end;

function TSQLPropInfoRTTIDynArray.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
begin
  result := GetDynArray(Instance).LoadFrom(P);
end;

procedure TSQLPropInfoRTTIDynArray.SetValue(Instance: TObject;  Value: PUTF8Char; wasString: boolean);
begin
  GetDynArray(Instance).LoadFrom(pointer(BlobToTSQLRawBlob(Value)));
end;

function TSQLPropInfoRTTIDynArray.SetFieldVarData(Instance: TObject; const aValue: TVarData): boolean;
begin
  if aValue.VType=varAny then
    result := GetDynArray(Instance).LoadFrom(aValue.VPointer)<>nil else
    result := inherited SetFieldVarData(Instance,aValue);
end;

procedure TSQLPropInfoRTTIDynArray.GetJSONValues(Instance: TObject; W: TJSONSerializer);
var tmp: RawByteString;
begin
  tmp := GetDynArray(Instance).SaveTo;
  W.WrBase64(pointer(tmp),Length(tmp),true); // withMagic=true -> add ""
end;

procedure TSQLPropInfoRTTIDynArray.GetFieldVarData(Instance: TObject; var aValue: TVarData;
  var temp: RawByteString);
begin
  temp := GetDynArray(Instance).SaveTo;
  aValue.VType := varAny;
  aValue.VPointer := pointer(temp);
  aValue.VLongs[0] := length(temp);
end;


{$ifdef USEVARIANTS}

{ TSQLPropInfoRTTIVariant }

procedure TSQLPropInfoRTTIVariant.CopyValue(Source, Dest: TObject);
begin
  PVariant(GetFieldAddr(Dest))^ := PVariant(GetFieldAddr(Source))^;
end;

procedure TSQLPropInfoRTTIVariant.GetBinary(Instance: TObject;
  W: TFileBufferWriter);
begin
  W.Write(PVariant(GetFieldAddr(Instance))^);
end;

function TSQLPropInfoRTTIVariant.GetHash(Instance: TObject;
  CaseInsensitive: boolean): cardinal;
var Up: array[byte] of AnsiChar; // avoid slow heap allocation
begin
  with PVarData(GetFieldAddr(Instance))^ do
  case VType of
    varNull, varEmpty:
      result := 0;
    varSmallint, varWord, varBoolean:
      result := VWord;
    varShortInt, varByte:
      result := VByte;
    varLongWord, varInteger, varSingle:
      result := varLongWord;
    varInt64, varDouble, varDate, varCurrency:
      result := PInt64Rec(@VInt64)^.Lo xor PInt64Rec(@VInt64)^.Hi;
    varString:
      if CaseInsensitive then
        result := crc32(0,Up,UTF8UpperCopy255(Up,RawUTF8(VString))-Up) else
        result := crc32(0,VString,length(RawUTF8(VString)));
    varOleStr {$ifdef UNICODE}, varUString{$endif}:
      if CaseInsensitive then
        result := crc32(0,Up,UpperCopy255W(Up,VOleStr,StrLenW(VOleStr))-Up) else
        result := crc32(0,VAny,StrLenW(VOleStr)*2);
  else
    raise ESynException.CreateFmt('Unhandled variant type %d',[VType]);
  end;
end;

procedure TSQLPropInfoRTTIVariant.GetJSONValues(Instance: TObject;
  W: TJSONSerializer);
begin
  W.AddVariantJSON(PVariant(GetFieldAddr(Instance))^,twJSONEscape);
end;

procedure TSQLPropInfoRTTIVariant.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
var wasString: boolean;
    V: PVariant;
begin
  V := GetFieldAddr(Instance);
  VariantToUTF8(V^,result,wasString);
  if wasSQLString<>nil then
    // from SQL point of view, variant columns are TEXT or null
    wasSQLString^ := PVarData(V)^.VType>varNull;
end;

procedure TSQLPropInfoRTTIVariant.GetVariant(Instance: TObject;
  var Dest: Variant);
begin
  Dest := PVariant(GetFieldAddr(Instance))^;
end;

procedure TSQLPropInfoRTTIVariant.NormalizeValue(var Value: RawUTF8);
begin // content should be already normalized
end;

function TSQLPropInfoRTTIVariant.CompareValue(Item1, Item2: TObject;
  CaseInsensitive: boolean): PtrInt;
var V1,V2: PVariant;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    V1 := GetFieldAddr(Item1);
    V2 := GetFieldAddr(Item2);
    if CaseInsensitive then
      result := AnsiICompW(pointer(SynUnicode(V1^)),pointer(SynUnicode(V2^))) else
      if V1^>V2^ then
        result := 1 else
      if V1^=V2^ then
        result := 0 else
        result := -1;
  end;
end;

function TSQLPropInfoRTTIVariant.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
begin
  FromVarVariant(PByte(P),PVariant(GetFieldAddr(Instance))^);
  result := P;
end;

procedure TSQLPropInfoRTTIVariant.SetValue(Instance: TObject; Value: PUTF8Char;
  wasString: boolean);
begin
  GetVariantFromJSON(Value,wasString,PVariant(GetFieldAddr(Instance))^);
end;

procedure TSQLPropInfoRTTIVariant.SetVariant(Instance: TObject;
  const Source: Variant);
begin
  PVariant(GetFieldAddr(Instance))^ := Source;
end;

{$endif USEVARIANTS}


{ TSQLPropInfoCustom }

function TSQLPropInfoCustom.GetFieldAddr(Instance: TObject): pointer;
begin
  if Instance=nil then
    result := nil else
    result := PAnsiChar(Instance)+fOffset;
end;

constructor TSQLPropInfoCustom.Create(const aName: RawUTF8;
  aSQLFieldType: TSQLFieldType; aAttributes: TSQLPropInfoAttributes;
  aFieldWidth: integer; aProperty: pointer;
  aData2Text: TOnSQLPropInfoRecord2Text; aText2Data: TOnSQLPropInfoRecord2Data);
begin
  inherited Create(aNAme,aSQLFieldType,aAttributes,aFieldWidth);
  fOffset := PtrUInt(aProperty);
  if (Assigned(aData2Text) and not Assigned(aText2Data)) or
     (Assigned(aText2Data) and not Assigned(aData2Text)) then
    raise EORMException.CreateFmt(
      'Invalid %s.Create: expecting both Data2Text/Text2Data',[ClassName]);
  fData2Text := aData2Text;
  fText2Data := aText2Data;
end;

procedure TSQLPropInfoCustom.TextToBinary(Value: PUTF8Char; var result: RawByteString);
begin
  if Assigned(fText2Data) then
    fText2Data(Value,result) else
    result := BlobToTSQLRawBlob(Value);
end;

procedure TSQLPropInfoCustom.BinaryToText(var Value: RawUTF8; ToSQL: boolean;
  wasSQLString: PBoolean);
begin
  if Assigned(fData2Text) then 
    fData2Text(@Value[1],length(Value),Value) else
    inherited BinaryToText(Value,ToSQL,wasSQLString);
end;


{ TSQLPropInfoRecordRTTI }

procedure TSQLPropInfoRecordRTTI.CopyValue(Source, Dest: TObject);
begin
  RecordCopy(GetFieldAddr(Dest)^,GetFieldAddr(Source)^,fTypeInfo);
end;

constructor TSQLPropInfoRecordRTTI.Create(aRecordInfo: PTypeInfo;
  const aName: RawUTF8; aPropertyPointer: pointer;
  aAttributes: TSQLPropInfoAttributes; aFieldWidth: integer;
  aData2Text: TOnSQLPropInfoRecord2Text; aText2Data: TOnSQLPropInfoRecord2Data);
begin
  if (aRecordInfo=nil) or (aRecordInfo^.Kind<>tkRecord) then
    raise EORMException.CreateFmt(
      'TSQLPropInfoRecordRTTI: Invalid type information for %s',[aName]);
  inherited Create(aName,sftBlobCustom,aAttributes,aFieldWidth,
    aPropertyPointer,aData2Text,aText2Data);
  fTypeInfo := aRecordInfo;
end;

procedure TSQLPropInfoRecordRTTI.GetBinary(Instance: TObject; W: TFileBufferWriter);
var Value: RawByteString;
begin
  Value := RecordSave(GetFieldAddr(Instance)^,fTypeInfo);
  W.Write(pointer(Value),length(Value));
end;

function TSQLPropInfoRecordRTTI.GetHash(Instance: TObject;
  CaseInsensitive: boolean): cardinal;
var Value: RawByteString;
begin
  Value := RecordSave(GetFieldAddr(Instance)^,fTypeInfo);
  result := crc32(0,pointer(Value),length(Value));
end;

{$ifdef USEVARIANTS}
procedure TSQLPropInfoRecordRTTI.GetVariant(Instance: TObject; var Dest: Variant);
begin
  Dest := RecordSave(GetFieldAddr(Instance)^,fTypeInfo);
end;

procedure TSQLPropInfoRecordRTTI.SetVariant(Instance: TObject; const Source: Variant);
begin
  if TVarData(Source).VType=varString then
    RecordLoad(GetFieldAddr(Instance)^,TVarData(Source).VAny,fTypeInfo) else
    RecordClear(GetFieldAddr(Instance)^,fTypeInfo);
end;
{$endif USEVARIANTS}

procedure TSQLPropInfoRecordRTTI.NormalizeValue(var Value: RawUTF8);
begin // a BLOB should already be normalized
end;

function TSQLPropInfoRecordRTTI.CompareValue(Item1, Item2: TObject;
  CaseInsensitive: boolean): PtrInt;
begin
  if RecordEquals(GetFieldAddr(Item1)^,GetFieldAddr(Item2)^,fTypeInfo) then
    result := 0 else
    result := PtrInt(Item1)-PtrInt(Item2); // pseudo comparison
end;

function TSQLPropInfoRecordRTTI.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
begin
  result := RecordLoad(GetFieldAddr(Instance)^,P,fTypeInfo);
end;

procedure TSQLPropInfoRecordRTTI.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
var data: RawByteString;
begin
  TextToBinary(Value,data);
  RecordLoad(GetFieldAddr(Instance)^,pointer(data),fTypeInfo);
end;

procedure TSQLPropInfoRecordRTTI.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  result := RecordSave(GetFieldAddr(Instance)^,fTypeInfo);
  BinaryToText(result,ToSQL,wasSQLString);
end;

function TSQLPropInfoRecordRTTI.SetFieldVarData(Instance: TObject; const aValue: TVarData): boolean;
begin
  if aValue.VType=varAny then
    result := RecordLoad(GetFieldAddr(Instance)^,aValue.VPointer,fTypeInfo)<>nil else
    result := inherited SetFieldVarData(Instance,aValue);
end;

procedure TSQLPropInfoRecordRTTI.GetFieldVarData(Instance: TObject; var aValue: TVarData;
  var temp: RawByteString);
begin
  temp := RecordSave(GetFieldAddr(Instance)^,fTypeInfo);
  aValue.VType := varAny;
  aValue.VPointer := pointer(temp);
  aValue.VLongs[0] := length(temp);
end;


{ TSQLPropInfoRecordFixedSize }

procedure TSQLPropInfoRecordFixedSize.CopyValue(Source, Dest: TObject);
begin
  move(GetFieldAddr(Source)^,GetFieldAddr(Dest)^,fRecordSize);
end;

constructor TSQLPropInfoRecordFixedSize.Create(aRecordSize: cardinal;
  const aName: RawUTF8; aPropertyPointer: pointer; aAttributes: TSQLPropInfoAttributes;
  aFieldWidth: integer; aData2Text: TOnSQLPropInfoRecord2Text;
  aText2Data: TOnSQLPropInfoRecord2Data);
begin
  if integer(aRecordSize)<=0 then
    raise EORMException.CreateFmt(
      'TSQLPropInfoRecordFixedSize: invalid %d record size',[aRecordSize]);
  fRecordSize := aRecordSize;
  inherited Create(aName,sftBlobCustom,aAttributes,aFieldWidth,aPropertyPointer,
    aData2Text,aText2Data);
end;

procedure TSQLPropInfoRecordFixedSize.GetBinary(Instance: TObject; W: TFileBufferWriter);
begin
  W.Write(GetFieldAddr(Instance),fRecordSize);
end;

function TSQLPropInfoRecordFixedSize.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
begin
  result := crc32(0,GetFieldAddr(Instance),fRecordSize);
end;

procedure TSQLPropInfoRecordFixedSize.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  SetString(result,PAnsiChar(GetFieldAddr(Instance)),fRecordSize);
  BinaryToText(result,ToSQL,wasSQLString);
end;

{$ifdef USEVARIANTS}
procedure TSQLPropInfoRecordFixedSize.GetVariant(Instance: TObject;
  var Dest: Variant);
var tmp: RawByteString;
begin
  SetString(tmp,PAnsiChar(GetFieldAddr(Instance)),fRecordSize);
  Dest := tmp;
end;

procedure TSQLPropInfoRecordFixedSize.SetVariant(Instance: TObject;
  const Source: Variant);
begin
  if TVarData(Source).VType=varString then
    move(TVarData(Source).VAny^,GetFieldAddr(Instance)^,fRecordSize) else
    fillchar(GetFieldAddr(Instance)^,fRecordSize,0);
end;
{$endif USEVARIANTS}

procedure TSQLPropInfoRecordFixedSize.NormalizeValue(var Value: RawUTF8);
begin // a BLOB should already be normalized
end;

function TSQLPropInfoRecordFixedSize.CompareValue(Item1, Item2: TObject;
  CaseInsensitive: boolean): PtrInt;
var i: Integer;
    P1,P2: PByteArray;
begin
  if (Item1=Item2) or (fRecordSize=0) then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    result := 0;
    P1 := GetFieldAddr(Item1);
    P2 := GetFieldAddr(Item2);
    for i := 0 to fRecordSize-1 do begin
      result := P1^[i]-P2^[i];
      if result<>0 then
        exit;
    end;
  end;
end;

function TSQLPropInfoRecordFixedSize.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
begin
  if P=nil then
    fillchar(GetFieldAddr(Instance)^,fRecordSize,0) else
    move(P^,GetFieldAddr(Instance)^,fRecordSize);
  result := P+fRecordSize;
end;

procedure TSQLPropInfoRecordFixedSize.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
var data: RawByteString;
begin
  TextToBinary(Value,data);
  Value := pointer(data);
  if Value=nil then
    fillchar(GetFieldAddr(Instance)^,fRecordSize,0) else
    move(Value^,GetFieldAddr(Instance)^,fRecordSize);
end;

function TSQLPropInfoRecordFixedSize.SetFieldVarData(Instance: TObject; const aValue: TVarData): boolean;
begin
  if aValue.VType=varAny then begin
    result := aValue.VLongs[0]=fRecordSize;
    if result then
      move(aValue.VPointer^,GetFieldAddr(Instance)^,fRecordSize)
  end else
    result := inherited SetFieldVarData(Instance,aValue);
end;

procedure TSQLPropInfoRecordFixedSize.GetFieldVarData(Instance: TObject; var aValue: TVarData;
  var temp: RawByteString);
begin
  SetString(temp,PAnsiChar(GetFieldAddr(Instance)),fRecordSize);
  aValue.VType := varAny;
  aValue.VPointer := pointer(temp);
  aValue.VLongs[0] := length(temp);
end;


{ TSQLPropInfoList }

destructor TSQLPropInfoList.Destroy;
var i: integer;
begin
  for i := 0 to fCount-1 do
    fList[i].Free;
  inherited;
end;

function TSQLPropInfoList.Add(aTable: TClass; aItem: TSQLPropInfo): integer;
var f: integer;
begin
  // check that this property is not an ID/RowID (handled separately)
  if IsRowID(pointer(aItem.Name)) then
    raise EModelException.CreateFmt('%s should not include a %s published property',
      [aTable.ClassName,aItem.Name]);
  // check that this property name is not already defined
  for f := 0 to fCount-1 do
    if IdemPropNameU(fList[f].Name,aItem.Name) then
      raise EModelException.CreateFmt('dup property name %s',[aItem.Name]);
  // add to the internal list
  result := fCount;
  if result>=length(fList) then
    SetLength(fList,result+result shr 3+32);
  inc(fCount);
  fList[result] := aItem;
  if fOrderedByName<>nil then
    SetLength(fOrderedByName,0);
end;

function TSQLPropInfoList.GetItem(aIndex: integer): TSQLPropInfo;
begin
  if cardinal(aIndex)>=Cardinal(fCount) then
    EORMException.Create('Invalid TSQLPropInfoList index');
  result := fList[aIndex];
end;

procedure TSQLPropInfoList.QuickSortByName(L,R: PtrInt);
var I,J,P,Tmp: PtrInt;
    pivot: PUTF8Char;
begin
  if L<R then
  repeat
    I := L; J := R;
    P := (L+R) shr 1;
    repeat
      pivot := pointer(fList[fOrderedByName[P]].fName);
      while StrIComp(pointer(fList[fOrderedByName[I]].fName),pivot)<0 do inc(I);
      while StrIComp(pointer(fList[fOrderedByName[J]].fName),pivot)>0 do dec(J);
      if I <= J then begin
        Tmp := fOrderedByName[J];
        fOrderedByName[J] := fOrderedByName[I];
        fOrderedByName[I] := Tmp;
        if P=I then P := J else if P=J then P := I;
        inc(I); dec(J);
      end;
    until I>J;
    if L<J then
      QuickSortByName(L,J);
    L := I;
  until I >= R;
end;

function TSQLPropInfoList.ByRawUTF8Name(const aName: RawUTF8): TSQLPropInfo;
var i: integer;
begin
  i := IndexByName(pointer(aName));
  if i<0 then
    result := nil else
    result := fList[i];
end;

function TSQLPropInfoList.ByName(aName: PUTF8Char): TSQLPropInfo;
var i: integer;
begin
  i := IndexByName(aName);
  if i<0 then
    result := nil else
    result := fList[i];
end;

function TSQLPropInfoList.IndexByName(aName: PUTF8Char): integer;
var i,cmp,L,R: integer;
begin
  if (self<>nil) and (aName<>nil) and (fCount>0) then
  if fCount<5 then begin
    for result := 0 to fCount-1 do
      if StrIComp(pointer(fList[result].fName),aName)=0 then
        exit;
  end else begin
    if fOrderedByName=nil then begin
      SetLength(fOrderedByName,fCount);
      for i := 0 to fCount-1 do
        fOrderedByName[i] := i;
      QuickSortByName(0,fCount-1);
    end;
    L := 0;
    R := fCount-1;
    repeat
      result := (L+R)shr 1;
      cmp := StrIComp(pointer(fList[fOrderedByName[result]].fName),aName);
      if cmp=0 then begin
        result := fOrderedByName[result];
        exit;
      end;
      if cmp<0 then
        L := result+1 else
        R := result-1;
    until L>R;
  end;
  result := -1;
end;

function TSQLPropInfoList.IndexByName(const aName: RawUTF8): integer;
begin
  result := IndexByName(pointer(aName));
end;


{ TSQLTable }

function TSQLTable.FieldIndex(FieldName: PUTF8Char): integer;
begin
  if (self<>nil) and (fResults<>nil) and (FieldName<>nil) and (FieldCount>0) then
    if IsRowID(FieldName) then begin // will work for both 'ID' or 'RowID'
      result := fFieldIndexID;
      exit;
    end else
    if FieldCount<4 then begin
      for result := 0 to FieldCount-1 do
        if StrIComp(fResults[result],FieldName)=0 then
          exit;
    end else begin
      if fFieldNameOrder=nil then
        QuickSortIndexedPUTF8Char(fResults,FieldCount,fFieldNameOrder);
      result := FastFindIndexedPUTF8Char(fResults,FieldCount-1,fFieldNameOrder,
        FieldName,@StrIComp);
      exit;
    end;
  result := -1;
end;

function TSQLTable.FieldIndex(const FieldName: RawUTF8): integer;
begin
  result := FieldIndex(Pointer(FieldName));
end;

function TSQLTable.FieldValue(const FieldName: RawUTF8; Row: integer): PUTF8Char;
var Index: integer;
begin
  Index := FieldIndex(pointer(FieldName));
  if (Index<0) or (cardinal(Row-1)>=cardinal(RowCount)) then
    result := nil else                     
    result := fResults[Index+Row*FieldCount];
end;

procedure TSQLTable.SortBitsFirst(var Bits);
var oldIDColumn, oldResults: array of PUTF8Char;
    i, j, nSet, n: integer;
    R: PPUTF8Char;
begin
  if fIDColumn<>nil then begin
    n := length(fIDColumn);
    SetLength(oldIDColumn,n);
    move(fIDColumn[0],oldIDColumn[0],n*4);
  end;
  i := (RowCount+1)*FieldCount;
  SetLength(oldResults,i);
  move(fResults[0],oldResults[0],i*4);
  // put marked IDs first
  n := 1; // copy row data (first row=0 i.e. idents is left as it is)
  R := @fResults[FieldCount];
  j := FieldCount;
  for i := 1 to RowCount do begin
    if GetBit(Bits,i-1) then begin
      if fIDColumn<>nil then
        fIDColumn[n] := oldIDColumn[i];
      move(oldResults[j],R^,FieldCount*4);
      inc(n);
      inc(R,FieldCount);
    end;
    inc(j,FieldCount);
  end;
  nSet := n-1;
  // put unmarked IDs
  j := FieldCount;
  for i := 1 to RowCount do begin
    if not GetBit(Bits,i-1) then begin
      if fIDColumn<>nil then
        fIDColumn[n] := oldIDColumn[i];
      move(oldResults[j],R^,FieldCount*4);
      inc(n);
      inc(R,FieldCount);
    end;
    inc(j,FieldCount);
  end;
  assert(n-1=RowCount);
  // recalcultate Bits[]
  fillchar(Bits,(RowCount shr 3)+1,0);
  for i := 0 to nSet-1 do
    SetBit(Bits,i); // slow but accurate
end;

function TSQLTable.IDColumnHide: boolean;
var FID,R,F: integer;
    S,D1,D2: PPUTF8Char;
begin
  // 1. check if possible
  result := false;
  if (self=nil) or Assigned(fIDColumn) or (FieldCount<=1) then
    exit; // already hidden or not possible
  FID := fFieldIndexID;
  if FID<0 then
    exit; // no 'ID' field
  // 2. alloc new arrays of PUTF8Char
  dec(fFieldCount);
  R := RowCount+1;
  SetLength(fIDColumn,R);               // will contain the ID column data
  SetLength(fNotIDColumn,R*FieldCount); // will be the new fResults[]
  // 3. copy fResults[] into new arrays
  S := @fResults[0];
  D1 := @fNotIDColumn[0];
  D2 := @fIDColumn[0];
  for R := 0 to RowCount do
    for F := 0 to FieldCount do begin // we have FieldCount := FieldCount-1
      if F<>FID then begin
        D1^ := S^; // copy not ID column into fNotIDColumn[]
        inc(D1);
      end else begin
        D2^ := S^; // copy ID column into fIDColumn[]
        inc(D2);
      end;
      inc(S);
    end;
  // 4. TSQLTable data now points to new values without ID field
  result := true;
  fResults := @fNotIDColumn[0];
end;

function TSQLTable.IDColumnHiddenValue(Row: integer): integer;
begin
  if (self=nil) or (fResults=nil) or (Row<=0) or (Row>RowCount) then
    result := 0 else
    if Assigned(fIDColumn) then // get hidden ID column UTF-8 content
      result := GetInteger(fIDColumn[Row]) else begin
      result := fFieldIndexID;  // get ID column field index
      if result>=0 then
        result := GetInteger(fResults[Row*FieldCount+result]) else
        result := 0;
    end;
end;

procedure TSQLTable.IDArrayFromBits(const Bits; var IDs: TIntegerDynArray);
var n, i, FID: integer;
begin
  if not Assigned(fIDColumn) then begin
    FID := fFieldIndexID; // get ID column field index
    if FID<0 then
      exit;
  end else
    FID := 0; // make compiler happy
  n := GetBitsCount(Bits,RowCount);
  if n=RowCount then begin
    IDColumnHiddenValues(IDs); // all selected -> direct get all IDs
    exit;
  end;
  SetLength(IDs,n);
  if n=0 then
    exit;
  n := 0;
  if Assigned(fIDColumn) then begin
    for i := 1 to RowCount do
    if GetBit(Bits,i-1) then begin
      IDs[n] := GetInteger(fIDColumn[i]); // get hidden ID column UTF-8 content
      inc(n);
    end;
  end else begin
    inc(FID,FieldCount); // [i*FieldCount+FID] = [(i+1)*FieldCount+FID] below
    for i := 0 to RowCount-1 do
    if GetBit(Bits,i) then begin
      IDs[n] := GetInteger(fResults[i*FieldCount+FID]); // get ID column UTF-8 content
      inc(n);
    end;
  end;
end;

procedure TSQLTable.IDColumnHiddenValues(var IDs: TIntegerDynArray);
var n, i, FID: integer;
    U: PPUTF8Char;
begin
  n := RowCount;
  if not Assigned(fIDColumn) then begin
    FID := fFieldIndexID; // get ID column field index
    if FID<0 then
      n := 0;
  end else
    FID := 0;
  SetLength(IDs,n);
  if n=0 then
    exit;
  if Assigned(fIDColumn) then begin
    for i := 1 to RowCount do
      IDs[i-1] := GetInteger(fIDColumn[i]); // get hidden ID column UTF-8 content
  end else begin
    U := @fResults[FID+FieldCount];  // U^ = ID column UTF-8 content
    for i := 0 to RowCount-1 do begin
      IDs[i] := GetInteger(U^);
      inc(U,FieldCount);
    end;
  end;
end;

procedure TSQLTable.IDArrayToBits(var Bits; var IDs: TIntegerDynArray);
var i,FID: integer;
    U: PPUTF8Char;
    ID: Pointer;
    IDn: integer;
//    AllID: TIntegerDynArray;
begin
  if length(IDs)=RowCount then begin
    fillchar(Bits,(RowCount shr 3)+1,255); // all selected -> all bits set to 1
    exit;
  end;
  fillchar(Bits,(RowCount shr 3)+1,0);
  if IDs=nil then
    exit; // no selected -> all bits left to 0
  // we sort IDs to use FastFindIntegerSorted() and its fast binary search
  ID := @IDs[0];
  IDn := high(IDs);
  QuickSortInteger(ID,0,IDn);
  if not Assigned(fIDColumn) then begin
    FID := fFieldIndexID; // get ID column field index
    if FID<0 then
      exit; // no ID column -> unable to get bit index
  end else
    FID := 0; // make compiler happy
  if Assigned(fIDColumn) then begin
    for i := 1 to RowCount do
      if FastFindIntegerSorted(ID,IDn,GetInteger(fIDColumn[i]))>=0 then
        SetBit(Bits,i-1);
  end else begin
    U := @fResults[FID+FieldCount];  // U^ = ID column UTF-8 content
    for i := 0 to RowCount-1 do begin
      if FastFindIntegerSorted(ID,IDn,GetInteger(U^))>=0 then
        SetBit(Bits,i);
      inc(U,FieldCount);
    end;
  end;
{  // debugg:
  IDArrayFromBits(Bits,AllID);
  assert(length(AllID)=length(IDs));
  QuickSortInteger(@AllID[0],0,high(AllID));
  QuickSortInteger(@IDs[0],0,high(IDs));
  assert(comparemem(@AllID[0],@IDs[0],length(AllID)*4)); }
end;

function TSQLTable.RowFromID(aID: integer): integer;
var ID: RawUTF8;
    FID: integer;
    U: PPUTF8Char;
begin
  if self=nil then begin
    result := -1;
    exit;
  end;
  if (fResults<>nil) and (aID>0) then begin
    // search aID as UTF-8 in fIDColumn[] or fResults[]
    ID := {$ifndef ENHANCEDRTL}UInt32ToUtf8{$else}IntToStr{$endif}(aID);
    if Assigned(fIDColumn) then begin // get hidden ID column UTF-8 content
      for result := 1 to RowCount do
        if StrComp(fIDColumn[result],pointer(ID))=0 then
          exit;
    end else begin
      FID := fFieldIndexID;  // get ID column field index
      if FID>=0 then begin
        U := @fResults[FID+FieldCount];  // U^ = ID column UTF-8 content
        for result := 1 to RowCount do
          if StrComp(U^,pointer(ID))=0 then
            exit else
            inc(U,FieldCount);
      end;
    end;
  end;
  result := RowCount; // not found -> return last row index
end;

procedure TSQLTable.DeleteRow(Row: integer);
begin
  if (Row<1) or (Row>RowCount) then
    exit; // out of range
  if Assigned(fIDColumn) then
    if Row<RowCount then
      move(fIDColumn[Row+1],fIDColumn[Row],(RowCount-Row)*4);
  if Row<RowCount then begin
    Row := Row*FieldCount; // convert row index into position in fResults[]
    move(fResults[Row+FieldCount],fResults[Row],(RowCount*FieldCount-Row)*sizeof(pointer));
  end;
  dec(fRowCount);
end;

procedure TSQLTable.DeleteColumnValues(Field: integer);
var i: integer;
    U: PPUTF8Char;
begin
  if cardinal(Field)>=cardinal(FieldCount) then
    exit; // out of range
  U := @fResults[Field+FieldCount];  // U^ = column UTF-8 content for this field
  for i := 1 to RowCount do begin
    U^[0] := #0; // just void UTF-8 content text
    inc(U,FieldCount);
  end;
end;

function FieldPropFromTable(const aTable: TSQLRecordClass; const PropName: RawUTF8;
  EnumTypeInfo: PPointer): TSQLFieldType;
var f: TSQLPropInfo;
begin
  if IsRowID(pointer(PropName)) then
    result := sftInteger else
    with aTable.RecordProps do begin
      f := Fields.ByRawUTF8Name(PropName);
      if f=nil then
        result := sftUnknown else begin
        result := f.SQLFieldType;
        if EnumTypeInfo<>nil then begin
          EnumTypeInfo^ := nil;
          if f.InheritsFrom(TSQLPropInfoRTTI) then
          with TSQLPropInfoRTTI(f).PropInfo^.PropType^^ do
          case result of
            sftEnumerate:
              EnumTypeInfo^ := EnumBaseType;
            sftSet:
              EnumTypeInfo^ := SetEnumType;
          end;
        end;
      end;
    end;
end;

function FieldPropFromTables(const Tables: TSQLRecordClassDynArray;
  const PropName: RawUTF8; EnumTypeInfo: PPointer; out TableIndex: integer): TSQLFieldType;
var SubProp: RawUTF8;
    i,t: integer;
begin
  TableIndex := -1;
  if length(Tables)=1 then begin
    result := FieldPropFromTable(Tables[0],PropName,EnumTypeInfo);
    if result<>sftUnknown then
      TableIndex := 0;
  end else begin
    i := PosEx('.',PropName); 
    if i=0 then begin
      // no 'ClassName.PropertyName' format: find first exact property name
      for t := 0 to high(Tables) do begin
        result := FieldPropFromTable(Tables[t],PropName,EnumTypeInfo);
        if result<>sftUnknown then begin
          TableIndex := t;
          exit;
        end;
      end;
    end else begin
      // we expect property names as 'ClassName.PropertyName'
      dec(i);
      SubProp := copy(PropName,i+2,255); 
      for t := 0 to high(Tables) do
        if Tables[t]<>nil then // avoid GPF
        if IdemPropName( // found class?
          // new TObject.ClassName is UnicodeString (Delphi 20009) -> inline code with
          // vmtClassName = UTF-8 encoded text stored in a shortstring = -44
          PShortString(PPointer(PtrInt(Tables[t])+vmtClassName)^)^,
          pointer(PropName),i) then begin
        //if Tables[t].ClassNameIs(SubClass) then begin // not Delphi 2009 OK
          TableIndex := t;
          result := FieldPropFromTable(Tables[t],SubProp,EnumTypeInfo); // get property type
          exit;
        end;
    end;
    result := sftUnknown;
  end;
end;

procedure TSQLTable.InitFieldTypes;
var f,i: integer;
    T: TSQLFieldType;
    P: pointer;
    TableInd: integer;
begin
  SetLength(fFieldType,FieldCount);
  for f := 0 to FieldCount-1 do begin
    P := nil;
    // init fFieldType[] from fQueryTables[] and the field names in fResults[]
    if Assigned(QueryTables) then
      T := FieldPropFromTables(QueryTables,fResults[f],@P,TableInd) else begin
      TableInd := -1;
      T := sftUnknown;
    end;
    if T=sftUnknown then
      // not found from fQueryTables[]: get from content
      if IsRowID(fResults[f]) then
        T := sftInteger else
      for i := 1 to RowCount do begin
        T := UTF8ContentType(fResults[i*FieldCount+f]);
        if T<>sftUnknown then begin
          if (T in [sftInteger,sftFloat]) and (f in fFieldParsedAsString) then
            T := sftUTF8Text else // force string value not to be a number
          if T=sftInteger then
            T := sftCurrency; // we only checked the first field... best guess...
          break; // get first non null field content
        end;
      end;
    with fFieldType[f] do begin
      TableIndex := TableInd;
      ContentType := T;
      EnumTypeInfo := P;
    end;
  end;
end;

function TSQLTable.FieldType(Field: integer; EnumTypeInfo: PPointer): TSQLFieldType;
begin
  if (self<>nil) and (cardinal(Field)<cardinal(FieldCount)) then begin
    if not Assigned(fFieldType) then
      InitFieldTypes;
    result := fFieldType[Field].ContentType;
    if EnumTypeInfo<>nil then
      EnumTypeInfo^ := fFieldType[Field].EnumTypeInfo;
  end else
    result := sftUnknown;
end;

function TSQLTable.Get(Row, Field: integer): PUTF8Char;
const PCharNil: integer = 0;
begin
  if (self=nil) or (fResults=nil) or (cardinal(Row)>cardinal(RowCount)) or
     (cardinal(Field)>=cardinal(FieldCount)) then // cardinal() -> test <0
    result := @PCharNil else
    result := fResults[Row*FieldCount+Field];
end;

function TSQLTable.GetU(Row,Field: integer): RawUTF8;
var P: PUTF8Char;
begin
  if (self=nil) or (fResults=nil) or (cardinal(Row)>cardinal(RowCount)) or
     (cardinal(Field)>=cardinal(FieldCount)) then // cardinal() -> test <0
    result := '' else begin
    P := fResults[Row*FieldCount+Field];
    SetString(Result,PAnsiChar(P),StrLen(P));
  end;
end;

function TSQLTable.GetA(Row, Field: integer): WinAnsiString;
begin
  result := Utf8ToWinAnsi(Get(Row,Field));
end;

function TSQLTable.GetAsInteger(Row, Field: integer): integer;
begin
  result := GetInteger(Get(Row,Field));
end;

function TSQLTable.GetAsInt64(Row, Field: integer): Int64;
begin
  SetInt64(Get(Row,Field),result);
end;

function TSQLTable.GetS(Row, Field: integer): shortstring;
begin
  UTF8ToShortString(result,Get(Row,Field));
end;

function TSQLTable.GetString(Row, Field: integer): string;
var U: PUTF8Char;
begin
  U := Get(Row,Field);
  if U=nil then
    result := '' else
    {$ifdef UNICODE}
    UTF8DecodeToUnicodeString(U,StrLen(U),result);
    {$else}
    CurrentAnsiConvert.UTF8BufferToAnsi(U,StrLen(U),result);
    {$endif}
end;

function TSQLTable.GetSynUnicode(Row,Field: integer): SynUnicode;
var U: PUTF8Char;
begin
  result := '';
  U := Get(Row,Field);
  if U<>nil then
    UTF8ToSynUnicode(U,StrLen(U),result);
end;

function TSQLTable.GetCaption(Row, Field: integer): string;
begin
  GetCaptionFromPCharLen(Get(Row,Field),result);
end;

function BlobToTSQLRawBlob(P: PUTF8Char): TSQLRawBlob;
var Len, LenHex: integer;
begin
  result := '';
  Len := StrLen(P);
  if Len=0 then
    exit;
  if (P[0] in ['x','X']) and (P[1]='''') and (P[Len-1]='''') then begin
    // BLOB literals are string literals containing hexadecimal data and
    // preceded by a single "x" or "X" character. For example: X'53514C697465'
    LenHex := (Len-3) shr 1;
    SetLength(result,LenHex);
    if HexToBin(@P[2],pointer(result),LenHex) then
      exit; // valid hexa data
  end else
  if (PInteger(P)^ and $00ffffff=JSON_BASE64_MAGIC) and IsBase64(@P[3],Len-3) then begin
    // Base-64 encoded content ('\uFFF0base64encodedbinary')
    result := Base64ToBin(@P[3],Len-3);
    exit;
  end;
  // TEXT format
  SetString(result,PAnsiChar(P),Len);
end;

function BlobToStream(P: PUTF8Char): TStream;
begin
  Result := TRawByteStringStream.Create(BlobToTSQLRawBlob(P));
end;

function BlobToBytes(P: PUTF8Char): TBytes;
var Len, LenResult: integer;
begin
  result := nil;
  Len := StrLen(P);
  if Len=0 then
    exit;
  if (P[0] in ['x','X']) and (P[1]='''') and (P[Len-1]='''') then begin
    // BLOB literals format
    LenResult := (Len-3)shr 1;
    SetLength(Result,LenResult);
    if HexToBin(@P[2],pointer(Result),LenResult) then
      exit; // valid hexa data
  end else
  if (PInteger(P)^ and $00ffffff=JSON_BASE64_MAGIC) and IsBase64(@P[3],Len-3) then begin
    // Base-64 encoded content ('\uFFF0base64encodedbinary')
    inc(P,3);
    dec(Len,3);
    LenResult := Base64ToBinLength(pointer(P),len);
    SetLength(Result,LenResult);
    if LenResult>0 then
      Base64Decode(pointer(P),pointer(Result),Len shr 2);
    exit;
  end;
  // TEXT format
  SetLength(Result,Len);
  Move(P^,pointer(Result)^,Len);
end;

function TSQLRawBlobToBlob(const RawBlob: TSQLRawBlob): RawUTF8;
// BLOB literals are string literals containing hexadecimal data and
//  preceded by a single "x" or "X" character. For example: X'53514C697465'
begin
  result := TSQLRawBlobToBlob(pointer(RawBlob),length(RawBlob));
end;

function TSQLRawBlobToBlob(RawBlob: pointer; RawBlobLength: integer): RawUTF8; overload;
// BLOB literals are string literals containing hexadecimal data and
//  preceded by a single "x" or "X" character. For example: X'53514C697465'
var P: PAnsiChar;
begin
  result := '';
  if RawBlobLength<>0 then begin
    SetLength(result,RawBlobLength*2+3);
{$ifdef UNICODE2} // not needed: SetLength() did already set the codepage
    PWord(PtrUInt(result)-12)^ := CP_UTF8; // use only SetLength() -> force set code page
{$endif}
    P := pointer(result);
    P[0] := 'X';
    P[1] := '''';
    BinToHex(RawBlob,P+2,RawBlobLength);
    P[RawBlobLength*2+2] := '''';
  end;
end;

function isBlobHex(P: PUTF8Char): boolean;
// BLOB literals are string literals containing hexadecimal data and
// preceded by a single "x" or "X" character. For example: X'53514C697465'
var Len: integer;
begin
  if P=nil then begin
    result := false;
    exit;
  end;
  while P=' ' do inc(P);
  if (P[0] in ['x','X']) and (P[1]='''') then begin
    Len := (StrLen(P)-3) shr 1;
    result := (P[Len-1]='''') and HexToBin(@P[2],nil,Len);
    exit;
  end else begin
    result := false;
    exit;
  end;
end;

function TSQLTable.GetBlob(Row, Field: integer): TSQLRawBlob;
begin
  result := BlobToTSQLRawBlob(Get(Row,Field));
end;

function TSQLTable.GetBytes(Row,Field: integer): TBytes;
begin
  result := BlobToBytes(Get(Row,Field));
end;

function TSQLTable.GetStream(Row,Field: integer): TStream;
begin
  result := BlobToStream(Get(Row,Field));
end;

{$ifdef PUREPASCAL} 
function TSQLTable.GetDateTime(Row, Field: integer): TDateTime;
begin
  result := Iso8601ToDateTimePUTF8Char(Get(Row,Field),0)
end;
{$else}
function TSQLTable.GetDateTime(Row, Field: integer): TDateTime;
asm
  call TSQLTable.Get
  xor edx,edx // L=0 -> will call strlen()
  jmp Iso8601ToDateTimePUTF8Char
end;
{$endif}

procedure TSQLTable.GetRowValues(Field: integer; out Values: TRawUTF8DynArray);
var i: integer;
    U: PPUTF8Char;
begin
  Finalize(Values);
  if (self=nil) or (cardinal(Field)>cardinal(FieldCount)) then
    exit;
  SetLength(Values,RowCount);
  U := @fResults[FieldCount+Field]; // start reading after first Row (= Field Names)
  for i := 0 to RowCount-1 do begin
    SetString(Values[i],PAnsiChar(U^),StrLen(U^));
    inc(U,FieldCount); // go to next row
  end;
end;

procedure TSQLTable.GetRowValues(Field: integer; out Values: TIntegerDynArray);
var i: integer;
    U: PPUTF8Char;
begin
  Finalize(Values);
  if (self=nil) or (cardinal(Field)>cardinal(FieldCount)) then
    exit;
  SetLength(Values,RowCount);
  U := @fResults[FieldCount+Field]; // start reading after first Row (= Field Names)
  for i := 0 to RowCount-1 do begin
    Values[i] := GetInteger(U^);
    inc(U,FieldCount); // go to next row
  end;
end;

function TSQLTable.GetRowValues(Field: integer; Sep: AnsiChar): RawUTF8;
var i, L: integer;
    U: PPUTF8Char;
    P: PUTF8Char;
begin
  result := '';
  if (self=nil) or (cardinal(Field)>cardinal(FieldCount)) or (RowCount=0) then
    exit;
  L := 0;
  U := @fResults[FieldCount+Field]; // start reading after first Row (= Field Names)
  for i := 1 to RowCount do begin
    inc(L,StrLen(U^)+1);
    inc(U,FieldCount); // go to next row
  end;
  if L=0 then
    exit;
  SetLength(result,L-1); // L-1 = don't add a last ','
  P := pointer(result);
  U := @fResults[FieldCount+Field]; // start reading after first Row (= Field Names)
  for i := 1 to RowCount do begin
    L := StrLen(U^);
    move(U^^,P^,L);
    if i=RowCount then // don't add a last ','
      break;
    P[L] := Sep;
    inc(P,L+1);
    inc(U,FieldCount); // go to next row
  end;
end;

procedure TSQLTable.GetJSONValues(JSON: TStream; Expand: boolean;
  RowFirst: integer=0; RowLast: integer=0);
var W: TJSONWriter;
    F,R: integer;
    U: PPUTF8Char;
begin
  W := TJSONWriter.Create(JSON,Expand,false);
  try
    if (self=nil) or (FieldCount<=0) or (RowCount<=0) then begin
      W.CancelAllVoid;
      exit;
    end;
    // check range
    if RowLast=0 then
      RowLast := RowCount else
    if RowLast>RowCount then
      RowLast := RowCount;
    if RowFirst<=0 then 
      RowFirst := 1; // start reading after first Row (Row 0 = Field Names)
    // get col names and types
    SetLength(W.ColNames,FieldCount);
    for F := 0 to FieldCount-1 do
      W.ColNames[F] := fResults[F]; // first Row is field Names
    W.AddColumns(RowLast-RowFirst+1); // write or init field names (see JSON Expand)
    if Expand then
      W.Add('[');
    // write rows data
    U := @fResults[FieldCount*RowFirst];
    for R := RowFirst to RowLast do begin
      if Expand then
        W.Add('{');
      for F := 0 to FieldCount-1 do begin
        if Expand then
          W.AddString(W.ColNames[F]); // '"'+ColNames[]+'":'
        if U^=nil then
          W.AddShort('null') else
        if IsStringJSON(U^) then begin
          // IsStringJSON() is fast and safe: no need to guess exact value type
          W.Add('"');
          W.AddJSONEscape(U^,0);
          W.Add('"');
        end else
          W.AddNoJSONEscape(U^,0);
        W.Add(',');
        inc(U); // points to next value
      end;
      W.CancelLastComma; // cancel last ','
      if Expand then begin
        W.Add('}',',');
        if R<>RowLast then
          W.AddCR; // make expanded json more human readable
      end else
        W.Add(',');
    end;
    W.EndJSONObject(1,0); // "RowCount": set by W.AddColumns(RowLast-RowFirst+1)
  finally
    W.Free;
  end;
end;

procedure TSQLTable.GetCSVValues(Dest: TStream; Tab: boolean; CommaSep: AnsiChar=',';
  AddBOM: boolean=false);
var U: PPUTF8Char;
    F,R,FMax: integer;
    W: TTextWriter;
begin
  if (self=nil) or (FieldCount<=0) or (RowCount<=0) then
    exit;
  W := TTextWriter.Create(Dest,8196);
  try
    if AddBOM then
      W.AddShort(#$ef#$bb#$bf); // add UTF-8 Byte Order Mark
    if Tab then
      CommaSep := #9;
    FMax := FieldCount-1;
    U := pointer(fResults);
    for R := 0 to RowCount do
      for F := 0 to FMax do begin
        if Tab or (not IsStringJSON(U^)) then
          W.AddNoJSONEscape(U^) else begin
          W.Add('"');
          W.AddNoJSONEscape(U^);
          W.Add('"');
        end;
        if F=FMax then
          W.AddCR else
          W.Add(CommaSep);
        inc(U); // points to next value
      end;
    W.Flush;
  finally
    W.Free;
  end;
end;

function TSQLTable.GetJSONValues(Expand: boolean): RawUTF8;
var MS: TRawByteStringStream;
begin
  MS := TRawByteStringStream.Create;
  try
    GetJSONValues(MS,Expand); // create JSON data in MS
    result := MS.DataString;
  finally
    MS.Free;
  end;
end;

function TSQLTable.GetW(Row, Field: integer): RawUnicode;
begin
  result := UTF8DecodeToRawUnicode(Get(Row,Field),0);
end;

function TSQLTable.GetWP(Row, Field: integer; Dest: PWideChar; MaxDestChars: cardinal): integer;
var P: PUTF8Char;
begin
  P := Get(Row,Field);
  result := UTF8ToWideChar(Dest,P,MaxDestChars,0) shr 1; // bytes div 2
end;

function TSQLTable.LengthW(Row, Field: integer): integer;
begin // nil -> fast calculate unicode length, without any memory allocation
  result := Utf8ToUnicodeLength(Get(Row,Field));
end;

function UTF8CompareCurr64(P1,P2: PUTF8Char): PtrInt;
var V1,V2: Int64;
begin // faster than UTF8CompareDouble() for pure decimal (no exponent) values
  V1 := StrToCurr64(P1);
  V2 := StrToCurr64(P2);
  if V1<V2 then
    result := -1 else
    if V1=V2 then
      result := 0 else
      result := +1;
end;

function UTF8CompareBoolean(P1,P2: PUTF8Char): PtrInt;
label Z,P,N;
begin // assume 0 is FALSE, anything else is true
  if P1=P2  then goto Z else
  if P1=nil then goto P else
  if P2=nil then goto N else
  if (P1^=#0) or (PWord(P1)^=ord('0')) then
    if (P2^=#0) or (PWord(P2)^=ord('0')) then begin
Z:    result := 0;  // P1=false P2=false
      exit;
    end else begin
N:    result := -1; // P1=false P2=true
      exit;
    end else
    if (P2^<>#0) and (PWord(P2)^<>ord('0')) then
      goto Z        // P1=true P2=true
    else begin
P:    result := 1;  // P1=true P2=false
      exit;
    end;
end;

function UTF8CompareInt32(P1,P2: PUTF8Char): PtrInt;
var V1,V2: PtrInt;
begin
  if P1=P2 then begin
    result := 0;
    exit;
  end;
  V1 := GetInteger(P1);
  V2 := GetInteger(P2);
  if V1<V2 then
    result := -1 else
    if V1=V2 then
      result := 0 else
      result := +1;
end;

function UTF8CompareUInt32(P1,P2: PUTF8Char): PtrInt;
var V1,V2: PtrUInt;
begin
  if P1=P2 then begin
    result := 0;
    exit;
  end;
  V1 := GetCardinal(P1);
  V2 := GetCardinal(P2);
  if V1<V2 then
    result := -1 else
    if V1=V2 then
      result := 0 else
      result := +1;
end;

function UTF8CompareRecord(P1,P2: PUTF8Char): PtrInt;
var V1,V2,T1,T2: PtrUInt;
label er;
begin
  if P1=P2 then begin
    result := 0;
    exit;
  end;
  V1 := GetCardinal(P1);
  V2 := GetCardinal(P2);
  if V1=V2 then
    result := 0 else begin
    // special RecordRef / TRecordReference INTEGER sort
    T1 := V1 and 63;  // first sort by Table order
    T2 := V2 and 63;
    if T1<T2 then
      result := -1 else
      if T1>T2 then
        result := +1 else
        // we have T1=T2 -> same Table -> sort by ID
        if V1<V2 then
          result := -1 else
          if V1=V2 then
            result := 0 else
            result := +1;
  end;
end;

function UTF8CompareInt64(P1,P2: PUTF8Char): PtrInt;
var V1,V2: Int64;
begin
  if P1=P2 then begin
    result := 0;
    exit;
  end;
  SetInt64(P1,V1);
  SetInt64(P2,V2);
  if V1<V2 then
    result := -1 else
    if V1=V2 then
      result := 0 else
      result := +1;
end;

function UTF8CompareDouble(P1,P2: PUTF8Char): PtrInt;
var V1,V2: extended;
    Err: integer;
label er;
begin
  if P1=P2 then begin
    result := 0;
    exit;
  end;
  v1 := GetExtended(P1,Err);
  if Err<>0 then begin
er: result := UTF8IComp(P1,P2);
    exit;
  end;
  V2 := GetExtended(P2,Err);
  if Err<>0 then goto er;
  if V1<V2 then // we don't care about exact = for a sort: Epsilon check is slow
    result := -1 else
    result := +1;
end;

function UTF8CompareISO8601(P1,P2: PUTF8Char): PtrInt;
var V1,V2: Int64; // faster than Iso8601ToDateTimePUTF8Char: uses integer math
begin
  if P1=P2 then begin
    result := 0;
    exit;
  end;
  V1 := Iso8601ToSecondsPUTF8Char(P1,0);
  V2 := Iso8601ToSecondsPUTF8Char(P2,0);
  if (V1=0) or (V2=0) then // any invalid date -> compare as strings
    result := UTF8IComp(P1,P2) else
    if V1<V2 then
      result := -1 else
      if V1=V2 then
        result := 0 else
        result := +1;
end;

var
  /// simple wrapper to UTF-8 compare function for the SQLite3 field datatypes
  // - used internaly for field sorting (see TSQLTable.SortFields() method)
  // and for default User Interface Query (see TSQLRest.QueryIsTrue() method)
  SQLFieldTypeComp: array[TSQLFieldType] of TUTF8Compare  =
   (nil,                  // unknown
    nil,    // AnsiText will be set to AnsiIComp in initialization block below
{$ifdef USENORMTOUPPER}
    UTF8IComp,           // UTF8Text, 8 bits case insensitive compared
{$else}
    nil,    // UTF8Text will be set to AnsiIComp in initialization block below
{$endif}
    UTF8CompareUInt32,   // Enumerate
    UTF8CompareUInt32,   // Set
    UTF8CompareInt64,    // Integer
    UTF8CompareUInt32,   // ID
    UTF8CompareRecord,   // Record
    UTF8CompareBoolean,  // Boolean
    UTF8CompareDouble,   // Float
    UTF8CompareISO8601,  // DateTime
    UTF8CompareInt64,    // TimeLog
    UTF8CompareCurr64,   // Currency
    StrComp,             // Object (TEXT serialization)
{$ifdef USEVARIANTS}
    StrComp,             // Variant (TEXT serialization)
{$endif}
    nil,                 // Blob
    nil,                 // BlobDynArray
    nil,                 // BlobCustom
    nil,                 // UTF8Custom
{$ifdef PUBLISHRECORD}
    nil,                 // BlobRecord
{$endif}
    nil,
    UTF8CompareInt64,    // ModTime
    UTF8CompareInt64);   // CreateTime

type
  /// a static object is used for smaller recursive stack size and faster code
  // - these special sort implementation do the comparaison first by the
  // designed field, and, if the field value is identical, the ID value is
  // used (it will therefore sort by time all identical values)
  // - code generated is very optimized: stack and memory usage, CPU registers
  // prefered, multiplication avoided to calculate memory position from index,
  // hand tuned assembler...
  TUTF8QuickSort = {$ifndef UNICODE}object{$else}record{$endif}
  public
    // sort parameters
    fComp: TUTF8Compare;
    Results: PPUtf8CharArray;
    IDColumn: PPUtf8CharArray;
    Params: TSQLTableSortParams;
    CurrentRow: integer;
    // used to avoid multiplications to calculate data memory position from index
    // - CPU64 ready
    FieldCountNextPtr, FieldIndexNextPtr: PtrInt;
    // temp vars (avoid stack usage):
    PID: Integer;
    PP, CI, CJ: PPUTF8Char;
    I, J: PtrInt;
{$ifdef PUREPASCAL}
    Tmp: PUTF8Char;
{$endif}
    /// recursively perform the sort
    procedure QuickSort(L, R: Integer);
    /// compare value at index I with pivot value
    // - sort by ID if values are identical
    function CompI: integer;
    /// compare value at index J with pivot value
    // - sort by ID if values are identical
    function CompJ: integer;
    /// set the pivot value
    procedure SetPP(aPP: PPUTF8Char; aP: PtrInt);
  end;

procedure TUTF8QuickSort.SetPP(aPP: PPUTF8Char; aP: PtrInt);
begin
  PP := aPP;
  // PID must be updated every time PP is modified
  if Assigned(IDColumn) then
    PID := GetInteger(IDColumn[aP]) else
    PID := GetInteger(PPUTF8Char(PtrInt(aPP)-FieldIndexNextPtr)^);
end;

function TUTF8QuickSort.CompI: integer;
begin
  result := fComp(CI^,PP^);
  if result=0 then
    // same value -> sort by ID
    if Assigned(IDColumn) then
      result := GetInteger(IDColumn[I])-PID else
      result := GetInteger(PPUTF8Char(PtrInt(CI)-FieldIndexNextPtr)^)-PID;
end;

function TUTF8QuickSort.CompJ: integer;
begin
  result := fComp(CJ^,PP^);
  if result=0 then
    // same value -> sort by ID
    if Assigned(IDColumn) then
      result := GetInteger(IDColumn[J])-PID else
      result := GetInteger(PPUTF8Char(PtrInt(CJ)-FieldIndexNextPtr)^)-PID;
end;

procedure ExchgPtrUInt(P1,P2: PtrUInt; FieldCount: integer); 
{$ifdef PUREPASCAL}  // CPU64 will call this version e.g.
var B: PtrUInt;
    i: PtrUInt;
begin
  for i := 1 to FieldCount do begin
    B := PPtrUInt(P1)^;
    PPtrUInt(P1)^ := PPtrUInt(P2)^;
    PPtrUInt(P2)^ := B;
    inc(PPtrUInt(P1));
    inc(PPtrUInt(P2));
  end;
end;
{$else}
asm // eax=P1 edx=P2 ecx=FieldCount
    push esi
    push edi
@1: dec ecx
    mov esi,[eax]
    mov edi,[edx]
    mov [edx],esi
    mov [eax],edi
    lea eax,[eax+4]
    lea edx,[edx+4]
    jnz @1
    pop edi
    pop esi
end;
{$endif}

procedure TUTF8QuickSort.QuickSort(L, R: Integer);
  {$ifndef PUREPASCAL}
  procedure Exchg32(P: pointer; I,J: integer);
  asm // eax=P edx=I ecx=J
    push ebx
    lea edx,[eax+edx*4]
    lea ecx,[eax+ecx*4]
    mov eax,[edx]
    mov ebx,[ecx]
    mov [ecx],eax
    mov [edx],ebx
    pop ebx
  end;
  {$endif}
// code below is very fast and optimized
var P: PtrInt;
begin
  if @fComp<>nil then
  repeat
    I := L;
    CI := @Results[I*Params.FieldCount+Params.FieldIndex];
    J := R;
    CJ := @Results[J*Params.FieldCount+Params.FieldIndex];
    P := ((I+J) shr 1);
    SetPP(@Results[P*Params.FieldCount+Params.FieldIndex],P);
    repeat
      // this loop has no multiplication -> most of the time is spent in comp()
      if Params.Asc then begin // ascending order comparaison
        while compI<0 do begin
          inc(I);
          inc(PtrInt(CI),FieldCountNextPtr); // next row
        end;
        while compJ>0 do begin
          dec(J);
          dec(PtrInt(CJ),FieldCountNextPtr); // previous row
        end;
      end else begin // descending order comparaison
        while compI>0 do begin
          inc(I);
          inc(PtrInt(CI),FieldCountNextPtr); // next row
        end;
        while compJ<0 do begin
          dec(J);
          dec(PtrInt(CJ),FieldCountNextPtr); // previous row
        end;
      end;
      if I<=J then begin
        if I<>J then begin // swap elements
          if CurrentRow=J then // update current row number
            CurrentRow := I else
          if CurrentRow=I then
            CurrentRow := J;
          // full row exchange
          ExchgPtrUInt(PtrInt(CI)-FieldIndexNextPtr,PtrInt(CJ)-FieldIndexNextPtr,
            Params.FieldCount); // exchange PUTF8Char for whole I,J rows
          if Assigned(IDColumn) then begin // update hidden ID column also
          {$ifdef PUREPASCAL}
            Tmp := IDColumn[I];
            IDColumn[I] := IDColumn[J];
            IDColumn[J] := Tmp;
          {$else}
            Exchg32(IDColumn,I,J);
          {$endif}
          end;
        end;
        if PP=CI then
          SetPP(CJ,J) else
        if PP=CJ then
          SetPP(CI,I);
        inc(I);
        dec(J);
        inc(PtrInt(CI),FieldCountNextPtr);
        dec(PtrInt(CJ),FieldCountNextPtr);
      end else
        break;
    until I>J;
    P := I; // save I which will be overwritten by QuickSort() below
    if L<J then
      QuickSort(L, J);
    I := P;
    L := P;
  until I>=R;
end;

procedure TSQLTable.SortFields(Field: integer; Asc: boolean=true;
  PCurrentRow: PInteger=nil; FieldType: TSQLFieldType=sftUnknown;
  CustomCompare: TUTF8Compare=nil);
var Sort: TUTF8QuickSort; // fast static object for sorting
begin
  if FieldCount=0 then
    exit;
  if FieldType=sftUnknown then // guess the field type from first row
    FieldType := self.FieldType(Field,nil);
  if Assigned(CustomCompare) then
    Sort.fComp := CustomCompare else begin
    Sort.fComp := SQLFieldTypeComp[FieldType];
    if @Sort.fComp=nil then
      exit;
  end;
  // store sorting parameters for resort in TSQLTableJSON.FillFrom()
  fSortParams.FieldType := FieldType;
  fSortParams.FieldCount := FieldCount;
  fSortParams.FieldIndex := Field;
  fSortParams.Asc := Asc;
  // this sort routine is very fast, thanks to the dedicated static object
  Sort.Params := fSortParams;
  Sort.Results := fResults;
  Sort.IDColumn := @fIDColumn[0];
  Sort.FieldCountNextPtr := FieldCount*sizeof(PtrInt);
  Sort.FieldIndexNextPtr := Field*sizeof(PtrInt);
  if PCurrentRow=nil then
    Sort.CurrentRow := -1 else
    Sort.CurrentRow := PCurrentRow^;
  if RowCount>1 then
    Sort.QuickSort(1,RowCount); // ignore first row = field names -> (1,RowCount)
  if PCurrentRow<>nil then
    PCurrentRow^ := Sort.CurrentRow;
end;

type
  TUTF8QuickSortMulti = {$ifndef UNICODE}object{$else}record{$endif}
  public
    Results: PPUtf8CharArray;
    IDColumn: PPUtf8CharArray;
    FieldCount: integer;
    IndexMax: integer;
    Index: array of record
      ndx: integer;
      Comp: TUTF8Compare;
      Desc: boolean;
    end;
    // used for row content comparison
    function Compare(A,B: integer): integer;
    /// recursively perform the sort
    procedure QuickSort(L, R: Integer);
  end;

function TUTF8QuickSortMulti.Compare(A,B: integer): integer;
var i: integer;
begin
  result := 0;
  for i := 0 to IndexMax do
   with Index[i] do begin
     if ndx>=0 then
       result := Comp(Results[A*FieldCount+ndx],Results[B*FieldCount+ndx]) else
       // Fields[].ndx=-1 for hidden ID column
       result := GetInteger(IDColumn[A])-GetInteger(IDColumn[B]);
     if result<>0 then begin
       if Desc then
         result := -result; // descending order -> inverse comparison 
       exit;
     end;
   end;
end;

procedure TUTF8QuickSortMulti.QuickSort(L, R: Integer);
var I,J,P: integer;
    Tmp: PUTF8Char;
begin
  if L<R then
  repeat
    I := L;
    J := R;
    P := (L+R) shr 1;
    repeat
      while Compare(I,P)<0 do inc(I);
      while Compare(J,P)>0 do dec(J);
      if I<=J then begin
        if I<>J then begin // swap elements
          ExchgPtrUInt(PtrUInt(@Results[I*FieldCount]),
            PtrUInt(@Results[J*FieldCount]),FieldCount);
          if Assigned(IDColumn) then begin // update hidden ID column also
            Tmp := IDColumn[I];
            IDColumn[I] := IDColumn[J];
            IDColumn[J] := Tmp;
          end;
        end;
        if P=I then
          P := J else
        if P=J then
          P := I;
        inc(I);
        dec(J);
      end;
    until I>J;
    if L<J then
      QuickSort(L,J);
    L := I;
  until I >= R;
end;

procedure TSQLTable.SortFields(const Fields: array of integer;
  const Asc: array of boolean);
var Sort: TUTF8QuickSortMulti;
    i: integer;
begin
  if (self=nil) or (RowCount<=1) or (FieldCount<=0) or (length(Fields)=0) then
    exit;
  Sort.FieldCount := FieldCount;
  Sort.IndexMax := high(Fields);
  SetLength(Sort.Index,Sort.IndexMax+1);
  for i := 0 to Sort.IndexMax do
  with Sort.Index[i] do begin
    ndx := Fields[i];
    if ndx<0 then begin // Fields[]=-1 for ID column
      if not Assigned(fIDColumn) then begin // leave ndx<0 for hidden ID
        ndx := fFieldIndexID;  // use the ID column
        if ndx<0 then
          exit; // no ID column available
        Comp := @UTF8CompareUInt32;
      end;
      continue;
    end;
    Comp := SortCompare(ndx);
    if @Comp=nil then
      exit; // impossible to sort this kind of field (or invalid field index)
  end;
  for i := 0 to high(Asc) do
    if (i<=Sort.IndexMax) and not Asc[i] then
      Sort.Index[i].Desc := true;
  Sort.Results := fResults;
  Sort.IDColumn := @fIDColumn[0];
  Sort.QuickSort(1,RowCount); // ignore first row = field names -> (1,RowCount)
end;

function TSQLTable.SortCompare(Field: integer): TUTF8Compare;
begin
  result := SQLFieldTypeComp[FieldType(Field,nil)];
end;

procedure TSQLTable.Assign(source: TSQLTable);
begin
  fResults := source.fResults;
  fRowCount := source.fRowCount;
  fFieldCount := source.fFieldCount;
end;

constructor TSQLTable.Create(const Tables: array of TSQLRecordClass; const aSQL: RawUTF8);
var n: integer;
begin
  inherited Create;
  n := length(Tables);
  if n>0 then begin
    SetLength(fQueryTables,n);
    move(Tables[0],fQueryTables[0],n*sizeof(TClass));
  end;
  fQuerySQL := aSQL;
  fFieldIndexID := -1;
end;

destructor TSQLTable.Destroy;
begin
  fOwnedRecords.Free;
  inherited;
end;

function TSQLTable.QueryRecordType: TSQLRecordClass;
begin
  if (self<>nil) and (pointer(fQueryTables)<>nil) then
      result := fQueryTables[0] else
      result := nil;
end;

function TSQLTable.NewRecord(RecordType: TSQLRecordClass=nil): TSQLRecord;
begin
  result := nil;
  if self=nil then
    exit;
  if RecordType=nil then begin
    RecordType := QueryRecordType;
    if RecordType=nil then
      exit;
  end;
  result := RecordType.Create;
  if fOwnedRecords=nil then
    fOwnedRecords := TObjectList.Create;
  fOwnedRecords.Add(result);
end;

{$ifdef ISDELPHI2010} // Delphi 2009 generics are buggy
function TSQLTable.ToObjectList<T>: TObjectList<T>;
var R,Item: TSQLRecord;
    Row: PPUtf8Char;
    i: integer;
begin
  result := TObjectList<T>.Create; // TObjectList<T> will free each T instance
  if (self=nil) or (RowCount=0) then
    exit;
  R := TSQLRecordClass(T).Create;
  try
    R.FillPrepare(self);
    Row := @fResults[FieldCount];     // Row^ points to first row of data
    {$ifdef ISDELPHIXE3}
    result.Count := RowCount;         // faster than manual Add()
    for i := 0 to RowCount-1 do begin
      Item := TSQLRecordClass(T).Create;
      PPointerArray(result.List)[i] := Item;
    {$else}
    for i := 0 to RowCount-1 do begin
      Item := TSQLRecordClass(T).Create;
      Result.Add(Item);
    {$endif}
      R.fFill.Fill(pointer(Row),Item);
      Inc(Row,FieldCount); // next data row
    end;
  finally
    R.Free;
  end;
end;
{$endif}

procedure TSQLTable.ToObjectList(DestList: TObjectList; RecordType: TSQLRecordClass=nil);
var R: TSQLRecord;
    Row: PPUtf8Char;
    i: integer;
begin
  if DestList=nil then
    exit;
  DestList.Clear;
  if (self=nil) or (RowCount=0) then
    exit;
  if RecordType=nil then begin
    RecordType := QueryRecordType;
    if RecordType=nil then
      exit;
  end;
  R := RecordType.Create;
  try
    R.FillPrepare(self);
    DestList.Count := RowCount;       // faster than manual Add()
    Row := @fResults[FieldCount];     // Row^ points to first row of data
    for i := 0 to RowCount-1 do begin // TObjectList will free each instance
      DestList.List[i] := RecordType.Create;
      R.fFill.Fill(pointer(Row),TSQLRecord(DestList.List[i]));
      Inc(Row,FieldCount); // next data row
    end;
  finally
    R.Free;
  end;
end;

function TSQLTable.ToObjectList(RecordType: TSQLRecordClass=nil): TObjectList;
begin
  result := TObjectList.Create;
  ToObjectList(result,RecordType);
end;

{$ifdef USEVARIANTS}
var
  SQLTableRowVariantType: TCustomVariantType = nil;
{$endif}

function TSQLTable.Step(SeekFirst: boolean=false; RowVariant: PVariant=nil): boolean;
begin
  result := false;
  if (self=nil) or (fRowCount<=0) then
    exit; // nothing to iterate over
  if SeekFirst then
    fStepRow := 1 else
    if fStepRow>=fRowCount then
      exit else
      inc(fStepRow);
  result := true;
{$ifdef USEVARIANTS}
  if RowVariant=nil then
    exit;
  if SQLTableRowVariantType=nil then
    SQLTableRowVariantType := SynRegisterCustomVariantType(TSQLTableRowVariantType);
  if (PVarData(RowVariant)^.VType=SQLTableRowVariantType.VarType) and
     (PVarData(RowVariant)^.VPointer=self) then
    exit; // already initialized -> quick exit
  VarClear(RowVariant^);
  PVarData(RowVariant)^.VType := SQLTableRowVariantType.VarType;
  PVarData(RowVariant)^.VPointer := self;
{$endif USEVARIANTS}
end;

function TSQLTable.FieldBuffer(FieldIndex: Integer): PUTF8Char;
begin
  if (self=nil) or (cardinal(FieldIndex)>=cardinal(fFieldCount)) then
    raise ESQLTableException.CreateFmt('FieldBuffer(%d): invalid index',[FieldIndex]);
  if (fStepRow=0) or (fStepRow>fRowCount) then
    raise ESQLTableException.Create('FieldBuffer(): no prior valid Step');
  result := fResults[fStepRow*FieldCount+FieldIndex];
end;

function TSQLTable.FieldBuffer(const FieldName: RawUTF8): PUTF8Char;
var i: integer;
begin
  i := FieldIndex(FieldName);
  if i<0 then
    raise ESQLTableException.CreateFmt('FieldBuffer(%s): unknown field',[FieldName]);
  if (fStepRow=0) or (fStepRow>fRowCount) then
    raise ESQLTableException.CreateFmt('FieldBuffer(%s): no prior valid Step',[FieldName]);
  result := fResults[fStepRow*FieldCount+i];
end;

{$ifdef USEVARIANTS}
function TSQLTable.Field(FieldIndex: integer): variant;
begin
  if (self=nil) or (cardinal(FieldIndex)>=cardinal(fFieldCount)) then
    raise ESQLTableException.CreateFmt('FieldBuffer(%d): invalid index',[FieldIndex]);
  if (fStepRow=0) or (fStepRow>fRowCount) then
    raise ESQLTableException.Create('FieldBuffer(): no prior valid Step');
  GetVariant(fStepRow,FieldIndex,nil,result);
end;

function TSQLTable.Field(const FieldName: RawUTF8): variant;
var i: integer;
begin
  i := FieldIndex(FieldName);
  if i<0 then
    raise ESQLTableException.CreateFmt('Field(%s): unknown field',[FieldName]);
  result := Field(i);
end;
{$endif}

function TSQLTable.CalculateFieldLengthMean(var aResult: TIntegerDynArray;
  FromDisplay: boolean=false): integer;
procedure CalculateEnumerates(F: integer; P: PEnumType);
var R, i, n: integer;
    EnumCounts: array of integer; // slow GetCaption() will be called once
    U: PPUTF8Char;
begin
  if P=nil then
    exit; // no a true enumerate field
  // 1. count of every possible enumerated value into EnumCounts[]
  SetLength(EnumCounts,P^.MaxValue+1); // EnumCounts[] := 0
  U := @fResults[FieldCount+F]; // start reading after first Row (= Field Names)
  for R := 1 to RowCount do begin
    n := GetInteger(U^);
    if n<=P^.MaxValue then // update count of every enumerated value
      inc(EnumCounts[n]) else
      inc(EnumCounts[0]); // GetCaption(invalid index) displays first one
    inc(U,FieldCount); // points to next row
  end;
  // 2. update aResult[F] with displayed caption text length
  n := 0;
  for i := 0 to P^.MaxValue do
    if EnumCounts[i]<>0 then
      inc(n,length(P^.GetCaption(i))*EnumCounts[i]);
  aResult[F] := n; // store displayed total length
end;
var R,F,n: integer;
    U: PPUTF8Char;
    Tot: cardinal;
begin
  SetLength(aResult,FieldCount);
  if FromDisplay and (length(fFieldLengthMean)=FieldCount) then begin
    move(fFieldLengthMean[0],aResult[0],FieldCount*4);
    result := fFieldLengthMeanSum;
    exit;
  end;
  if RowCount=0 then begin
    // no data: calculate field length from first row (i.e. Field Names)
    U := @fResults[0];
    for F := 0 to FieldCount-1 do begin
      inc(aResult[F],Utf8FirstLineToUnicodeLength(U^));  // count
      inc(U); // points to next value
    end;
    Tot := 1;
  end else begin
    if not Assigned(fFieldType) then
      InitFieldTypes;
    U := @fResults[FieldCount]; // start reading after first Row
    for R := 1 to RowCount do // sum all lengths by field
      for F := 0 to FieldCount-1 do begin
        case fFieldType[F].ContentType of
        sftInteger, sftBlob, sftBlobCustom, sftUTF8Custom, sftRecord,
        sftID, sftSet, sftCurrency:
          inc(aResult[F],8);
        else inc(aResult[F],Utf8FirstLineToUnicodeLength(U^));
        end;
        inc(U); // points to next value
      end;
    if Assigned(fQueryTables) then begin
      // aResult[] must be recalculated from captions, if exists
      for F := 0 to FieldCount-1 do
      with fFieldType[F] do
        case ContentType of
        sftEnumerate:
          CalculateEnumerates(F,EnumTypeInfo);
        end;
    end;
    Tot := RowCount;
  end;
  result := 0;
  for F := 0 to FieldCount-1 do begin
    n := cardinal(aResult[F]) div Tot; // Mean = total/count
    if n=0 then n := 1;  // none should be 0
    aResult[F] := n;
    inc(result,n); // fast calculate mean sum
  end;
end;

function TSQLTable.FieldLengthMean(Field: integer): cardinal;
begin
  if (self=nil) or (cardinal(Field)>=cardinal(FieldCount)) or (fResults=nil) then
    result := 0 else begin
    if fFieldLengthMean=nil then
      // if not already calculated, do it now
      fFieldLengthMeanSum := CalculateFieldLengthMean(fFieldLengthMean);
    result := fFieldLengthMean[Field];
  end;
end;

function TSQLTable.FieldLengthMeanSum: cardinal;
begin
  if self=nil then
    result := 0 else begin
    if fFieldLengthMean=nil then
      FieldLengthMean(0); // initialize fFieldLengthMean[] and fFieldLengthMeanSum
    result := fFieldLengthMeanSum;
  end;
end;

function TSQLTable.FieldLengthMax(Field: integer; NeverReturnsZero: boolean): cardinal;
var i: integer;
    len: cardinal;
    U: PPUTF8Char;
begin
  result := 0;
  if (self<>nil) and (cardinal(Field)<cardinal(FieldCount)) then begin
    U := @fResults[FieldCount+Field]; // start reading after first Row
    for i := 1 to RowCount do begin
      len := StrLen(U^);
      if len>result then
        result := len;
      inc(U,FieldCount);
    end;
  end;
  if (result=0) and NeverReturnsZero then
    result := 1; // minimal not null length
end;

function TSQLTable.FieldTable(Field: integer): TClass;
begin
  if (self=nil) or (cardinal(Field)>=cardinal(FieldCount)) or (fQueryTables=nil) then
    result := nil else begin
    if not Assigned(fFieldType) then
       InitFieldTypes;
    Field := fFieldType[Field].TableIndex;
    if Field<0 then
      result := nil else
      result := fQueryTables[Field];
  end;
end;

procedure TSQLTable.SetFieldLengthMean(const Lengths: array of cardinal);
var F: integer;
    n: cardinal;
begin
  if (self=nil) or (length(Lengths)<>FieldCount) then
    exit;
  if fFieldLengthMean=nil then // if not already calculated, allocate array
    SetLength(fFieldLengthMean,FieldCount);
  fFieldLengthMeanSum := 0;
  for F := 0 to FieldCount-1 do begin
    n := Lengths[F];
    if n=0 then n := 1;  // none should be 0
    fFieldLengthMean[F] := n;
    inc(fFieldLengthMeanSum,n); // fast calculate mean sum
  end;
end;

procedure TSQLTable.FieldLengthMeanIncrease(aField, aIncrease: integer);
begin
  if (self=nil) or (cardinal(aField)>=cardinal(FieldCount)) then
    exit; // avoid GPF
  if fFieldLengthMean=nil then
    FieldLengthMean(0); // initialize fFieldLengthMean[] and fFieldLengthMeanSum
  inc(fFieldLengthMean[aField],aIncrease);
  inc(fFieldLengthMeanSum,aIncrease);
end;

function TSQLTable.SearchValue(const aUpperValue: RawUTF8;
  StartRow, FieldIndex: integer; Client: TObject; Lang: TSynSoundExPronunciation;
  UnicodeComparison: boolean): integer;
var U: PPUTF8Char;
    Kind: TSQLFieldType;
    Search: PAnsiChar;
    UpperUnicode: RawUnicode;
    UpperUnicodeLen: integer;
    EnumType: PEnumType;
    Value: PtrInt;
    err: integer;
    TimeLog: Int64;
    EnumValue: RawUTF8;
    s: string;
    P: PShortString;
    EnumValues: set of 0..63;
    Soundex: TSynSoundEx;
    CL: TSQLRest absolute Client;
    tmp: array[0..23] of AnsiChar;
begin
  result := 0;
  if (StartRow<=0) or (StartRow>RowCount) or (aUpperValue='') or
     (cardinal(FieldIndex)>=cardinal(FieldCount)) then
    exit;
  Search := pointer(aUpperValue);
  if Search^='%' then begin
    inc(Search);
    if Search^='%' then begin
      inc(Search);
      if Search^='%' then begin
        inc(Search);
        Lang := sndxSpanish;
      end else
        Lang := sndxFrench;
    end else
      Lang := sndxEnglish;
  end;
  if ((Lang<>sndxNone) and not Soundex.Prepare(Search,Lang)) then
    exit;
  result := StartRow;
  Kind := FieldType(FieldIndex,@EnumType);
  U := @fResults[FieldCount*StartRow+FieldIndex];
  // search in one specified field value
  if (Kind=sftEnumerate) and (EnumType<>nil) then begin
    // for enumerates: first search in all available values
    Int64(EnumValues) := 0;
    P := @EnumType^.NameList;
    for Value := 0 to EnumType^.MaxValue do begin
      EnumValue := TrimLeftLowerCaseShort(P);
      GetCaptionFromPCharLen(pointer(EnumValue),s);
      EnumValue := StringToUTF8(s);
      if ((Lang<>sndxNone) and SoundEx.UTF8(pointer(EnumValue))) or
         ((Lang=sndxNone) and FindUTF8(pointer(EnumValue),Search)) then 
        include(EnumValues,Value);
      inc(PtrUInt(P),ord(P^[0])+1);
    end;
    // then search directly from the INTEGER value
    if Int64(EnumValues)<>0 then
    while cardinal(result)<=cardinal(RowCount) do begin
      Value := GetInteger(U^,err);
      if (err=0) and (Value in EnumValues) then
        exit; // we found a matching field
      inc(U,FieldCount); // ignore all other fields -> jump to next row data
      inc(Result);
    end;
    result := 0; // not found
    exit;
  end;
  // special cases: conversion from INTEGER to text before search
  if Kind in [sftTimeLog,sftModTime,sftCreateTime] then
    while cardinal(result)<=cardinal(RowCount) do begin
      SetInt64(U^,TimeLog);
      if TimeLog<>0 then begin
        tmp[Iso8601(TimeLog).Text(tmp,true,' ')] := #0;
        if FindAnsi(tmp,Search) then
          exit;
      end;
      inc(U,FieldCount); // ignore all other fields -> jump to next row data
      inc(Result);
    end
  else
  if ((Kind in [sftRecord,sftID]) and
     (Client<>nil) and Client.InheritsFrom(TSQLRest) and (CL.Model<>nil)) then
    while cardinal(result)<=cardinal(RowCount) do begin
      Value := GetInteger(U^);
      if Value<>0 then begin
        if Kind=sftRecord then
          EnumValue := RecordRef(Value).Text(CL.Model) else
          EnumValue := U^; // sftID -> display ID number -> no sounded
        if Lang=sndxNone then begin
          if FindUTF8(pointer(EnumValue),Search) then exit;
        end else
          if SoundEx.UTF8(pointer(EnumValue)) then exit;
      end;
      inc(U,FieldCount); // ignore all other fields -> jump to next row data
      inc(Result);
    end
  else
  // by default, search as UTF-8 encoded text
  if Lang<>sndxNone then begin
    while cardinal(result)<=cardinal(RowCount) do
    if SoundEx.UTF8(U^) then
      exit else begin
      inc(U,FieldCount); // ignore all other fields -> jump to next row data
      inc(Result);
    end;
  end else
  if UnicodeComparison then begin
    // slowest but always accurate Unicode comparison
    UpperUnicode := UTF8DecodeToRawUnicodeUI(RawUTF8(Search),@UpperUnicodeLen);
    while cardinal(result)<=cardinal(RowCount) do
    if FindUnicode(pointer(Utf8DecodeToRawUnicode(U^,0)),
       pointer(UpperUnicode),UpperUnicodeLen) then
      exit else begin
      inc(U,FieldCount); // ignore all other fields -> jump to next row data
      inc(Result);
    end
  end else
    // default fast Win1252 search
    while cardinal(result)<=cardinal(RowCount) do
    if FindUTF8(U^,Search) then
      exit else begin
      inc(U,FieldCount); // ignore all other fields -> jump to next row data
      inc(Result);
    end;
  result := 0; // not found
end;

function TSQLTable.SearchValue(const aUpperValue: RawUTF8;
  StartRow: integer; FieldIndex: PInteger; Client: TObject; Lang: TSynSoundExPronunciation;
  UnicodeComparison: boolean): integer;
var F, Row: integer;
begin
  result := 0;
  if (self=nil) or (StartRow<=0) or (StartRow>RowCount) or (aUpperValue='') then
    exit;
  // search in all fields values
  for F := 0 to FieldCount-1 do begin
    Row := SearchValue(aUpperValue,StartRow,F,Client,Lang,UnicodeComparison);
    if (Row<>0) and ((result=0) or (Row<result)) then begin
      if FieldIndex<>nil then
        FieldIndex^ := F;
      result := Row;
    end;
  end;
end;

function TSQLTable.SearchFieldEquals(const aValue: RawUTF8; FieldIndex: integer): integer;
begin
  result := 0;
  if (self=nil) or (aValue='') or (cardinal(FieldIndex)>cardinal(fFieldCount)) then
    exit;
  for result := 1 to RowCount do
    if UTF8IComp(Get(result,FieldIndex),pointer(aValue))=0 then
      exit;
  result := 0;
end;

{$ifdef USEVARIANTS}
function TSQLTable.GetVariant(Row, Field: integer; Client: TObject): Variant;
begin
  GetVariant(Row,Field,Client,result);
end;

procedure TSQLTable.GetVariant(Row,Field: integer; Client: TObject; var result: variant);
var FT: TSQLFieldType;
    EnumType: PEnumType;
    err: integer;
    Value64: Int64;
    ValueRef: RecordRef absolute Value64;
    Value8601: Iso8601 absolute Value64;
    ValueCurrency: Currency absolute Value64;
begin
  if Row=0 then begin // Field Name
    result := sftUnknown;
    result := GetCaption(0,Field);
    exit;
  end;
  FT := FieldType(Field,@EnumType);
  case FT of
  sftCurrency: begin
    Value64 := StrToCurr64(Get(Row,Field));
    result := ValueCurrency;
  end;
  sftFloat: begin
    result := GetExtended(Get(Row,Field),err);
    if err=0 then
      exit;
  end;
  sftDateTime: begin
    result := Iso8601ToDateTimePUTF8Char(Get(Row,Field),0);
    exit;
  end;
  sftEnumerate, sftID, sftSet, sftInteger, sftTimeLog, sftModTime, sftCreateTime,
  sftRecord, sftBoolean: begin
    Value64 := GetInt64(Get(Row,Field),err);
    if err=0 then begin
      case FT of
      sftEnumerate:
        if EnumType=nil then
          result := Value64 else
          result := EnumType^.GetCaption(Value64);
      sftID, sftSet, sftInteger:
        result := Value64;
      sftTimeLog, sftModTime, sftCreateTime:
        result := Value8601.ToDateTime;
      sftRecord:
        if (Value64<>0) and
           (Client<>nil) and Client.InheritsFrom(TSQLRest) then // 'TableName ID'
          result := {$ifdef UNICODE}Ansi7ToString{$endif}(ValueRef.Text(TSQLRest(Client).Model)) else
          result := Value64; // display ID number if no table model
      sftBoolean:
        result := boolean(Value64);
      end;
      exit;
    end;
    // err<>0 -> not an integer -> will be displayed with GetString()
  end;
  end;
  // sftBlob and sftMany are not handled
  // sftBlobRecord, sftBlobCustom, sftBlobDynArray as binary string
  // sftUTF8Custom as text
  // sftObject or sftVariant as JSON serialization
  result := GetString(Row,Field);
end;
{$endif}

function TSQLTable.ExpandAsString(Row, Field: integer; Client: TObject;
  out Text: string): TSQLFieldType;
var EnumType: PEnumType;
    err: integer;
    Value: Int64;
    Ref: RecordRef absolute Value;
begin // Text was already forced to '' because was defined as "out" parameter
  if Row=0 then begin // Field Name
    result := sftUnknown;
    Text := GetCaption(0,Field);
    exit;
  end;
  result := FieldType(Field,@EnumType);
  case result of
  sftDateTime: begin
    Value := Iso8601ToSecondsPUTF8Char(Get(Row,Field),0);
    if Value<>0 then begin
      if Assigned(i18nDateText) then
        Text := i18nDateText(Value) else
        Text := {$ifdef UNICODE}Ansi7ToString{$endif}(Iso8601(Value).Text(true,' '));
      exit;
    end;
  end;
  sftBlob:
    Text := '???';
  sftEnumerate, sftSet, sftRecord, sftID, sftTimeLog, sftModTime, sftCreateTime: begin
    Value := GetInt64(Get(Row,Field),err);
    if err<>0 then
      // not an integer -> to be displayed as sftUTF8Text
      result := sftUTF8Text else
    case result of
      sftEnumerate: begin
        Text := EnumType^.GetCaption(Value);
        exit;
      end;
      sftTimeLog, sftModTime, sftCreateTime: begin
        if Value=0 then
          Text := '' else
        if Assigned(i18nDateText) then
          Text := i18nDateText(Value) else
          Text := {$ifdef UNICODE}Ansi7ToString{$endif}(Iso8601(Value).Text(true,' '));
        exit;
      end;
{      sftID, sftSet:
        result := sftUTF8Text; // will display INTEGER field as number }
      sftRecord:
        if (Value<>0) and 
           (Client<>nil) and Client.InheritsFrom(TSQLRest) then // 'TableName ID'
          Text := {$ifdef UNICODE}Ansi7ToString{$endif}(Ref.Text(TSQLRest(Client).Model)) else
          result := sftUTF8Text; // display ID number if no table model
    end;
  end;
  end;
  if Text='' then
    // returns the value as text by default
    Text := GetString(Row,Field);
end;

function TSQLTable.ExpandAsSynUnicode(Row,Field: integer; Client: TObject; out Text: SynUnicode): TSQLFieldType;
var s: string;
begin
  result := ExpandAsString(Row,Field,Client,s);
  Text := StringToSynUnicode(s);
end;

function TSQLTable.GetTimeLog(Row, Field: integer; Expanded: boolean;
  FirstTimeChar: AnsiChar): RawUTF8;
var Value: Iso8601;
begin
  SetInt64(Get(Row,Field),Value.Value);
  result := Value.Text(Expanded,FirstTimeChar);
end;


{$ifdef USEVARIANTS}

{ TSQLTableRowVariantType }

procedure TSQLTableRowVariantType.IntGet(var Dest: TVarData;
  const V: TVarData; Name: PAnsiChar);
var ndx: integer;
begin
  if (TVarData(V).VPointer=nil) or (Name=nil) then
    ESQLTableException.CreateFmt('Invalid TSQLTableRowVariantType.%s call',[Name]);
  with TSQLTable(TVarData(V).VPointer) do begin
    if (fStepRow=0) or (fStepRow>fRowCount) then
      raise ESQLTableException.CreateFmt('TSQLTableRowVariantType.%s: no prior valid Step',[Name]);
    ndx := FieldIndex(PUTF8Char(Name));
    if cardinal(ndx)>=cardinal(fFieldCount) then
      raise ESQLTableException.CreateFmt('TSQLTableRowVariantType.%s: unknown field',[Name]);
    GetVariant(fStepRow,ndx,nil,Variant(Dest));
  end;
end;

procedure TSQLTableRowVariantType.IntSet(const V, Value: TVarData; Name: PAnsiChar);
begin
  ESQLTableException.Create('TSQLTableRowVariantType is read-only');
end;

{$endif USEVARIANTS}


procedure Base64MagicToBlob(Base64: PUTF8Char; var result: RawUTF8);
begin
  // do not escape the result: returns e.g. X'53514C697465'
  result := TSQLRawBlobToBlob(Base64ToBin(PAnsiChar(Base64),StrLen(Base64)));
end;


{ TJSONObjectDecoder }

const
  EndOfJSONField = [',',']','}',':'];

function GetJSONArrayOrObjectAsQuotedStr(P: PUTF8Char; out PDest: PUTF8Char;
  EndOfObject: PUTF8Char): RawUTF8;
var Beg: PUTF8Char;
begin
  assert(EndOfObject<>nil);
  result := '';
  PDest := nil;
  Beg := P;
  P := GotoNextJSONObjectOrArray(P); // quick go to end of array of object
  if P=nil then
    exit;
  EndOfObject^ := P^;
  P^ := #0; // so Beg will be a valid ASCIIZ string
  PDest := P+1;
  result := QuotedStr(Beg,'''');
end;

procedure TJSONObjectDecoder.Decode(var P: PUTF8Char; const Fields: TRawUTF8DynArray;
  Params: TJSONObjectDecoderParams; RowID: integer; ReplaceRowIDWithID: boolean);
var EndOfObject: AnsiChar;

  procedure GetSQLValue(ndx: integer);
  var wasString: boolean;
      res: PUTF8Char;
      c: integer;
  begin
    res := P;
    if res=nil then begin
      FieldValues[ndx] := ''; // avoid GPF, but will return invalid SQL
      exit;
    end;
    while res^ in [#1..' '] do inc(res);
    if (PInteger(res)^=NULL_LOW) and
       (res[4] in [#0,#9,#10,#13,' ',',','}',']'])  then begin
      /// GetJSONField('null') returns '' -> check here to make a diff with '""'
      include(FieldNull,ndx);
      FieldValues[ndx] := 'null';
      inc(res,4);
      while res^ in [#1..' '] do inc(res);
      if res^=#0 then
        P := nil else begin
        EndOfObject := res^;
        res^ := #0;
        P := res+1;
      end;
    end else begin
      // first check if nested object or array
      case res^ of // handle JSON {object} or [array] in P
      '{','[':
        FieldValues[ndx] := GetJSONArrayOrObjectAsQuotedStr(res,P,@EndOfObject);
      else begin
        // handle JSON string, number or false/true in P
        res := GetJSONField(res,P,@wasString,@EndOfObject);
        if wasString then begin
          c := PInteger(res)^ and $00ffffff;
          if c=JSON_BASE64_MAGIC then
            case Params of
            pInlined: //untouched -> recognized as BLOB in SQLParamContent()
              FieldValues[ndx] := QuotedStr(res,'''');
            pQuoted: // \uFFF0base64encodedbinary -> 'X''hexaencodedbinary'''
              // if not inlined, it can be used directly in INSERT/UPDATE statements
              Base64MagicToBlob(res+3,FieldValues[ndx]);
            pNonQuoted: // returned directly as RawByteString
              FieldValues[ndx] := Base64ToBin(res+3);
            end else begin
            if c=JSON_SQLDATE_MAGIC then
              inc(res,3); // ignore \uFFF1 magic marker
            // regular string content
            if Params=pNonQuoted then
              // returned directly as RawUTF8
              FieldValues[ndx] := res else
              { escape SQL strings, cf. the official SQLite3 documentation:
                "A string is formed by enclosing the string in single quotes (').
                 A single quote within the string can be encoded by putting two
                 single quotes in a row - as in Pascal." }
              FieldValues[ndx] := QuotedStr(res,'''');
          end;
        end else
          // non string params (numeric or null/false/true) are passed untouched
          FieldValues[ndx] := res;
      end;
      end;
    end;
    Inc(FieldLen,length(FieldValues[ndx]));
  end;

var FieldName: RawUTF8;
    F: integer;
    FieldIsRowID: Boolean;
begin
  FieldCount := 0;
  FieldLen := 0;
  DecodedRowID := 0;
  FillChar(FieldNull,sizeof(FieldNull),0);
  InlinedParams := Params=pInlined;
  if pointer(Fields)=nil then begin
    // get "COL1"="VAL1" pairs, stopping at '}' or ']'
    DecodedFieldNames := @FieldNames;
    if RowID>0 then begin // insert explicit RowID
      if ReplaceRowIDWithID then
        FieldNames[0] := 'ID' else
        FieldNames[0] := 'RowID';
      FieldValues[0] := Int32ToUtf8(RowID);
      FieldCount := 1;
      FieldLen := Length(FieldNames[0])+Length(FieldValues[0]);
      DecodedRowID := RowID;
    end;
    if P<>nil then
    repeat
      FieldName := GetJSONField(P,P);
      if P=nil then break; // syntax error
      FieldIsRowID := IsRowId(pointer(FieldName));
      if FieldIsRowID then
        if RowID>0 then begin
          GetJSONField(P,P,nil,@EndOfObject); // ignore this if explicit RowID
          if EndOfObject in [#0,'}',']'] then
            break else continue;
        end else
        if ReplaceRowIDWithID then
          FieldName := 'ID';
      inc(FieldLen,length(FieldName));
      FieldNames[FieldCount] := FieldName;
      GetSQLValue(FieldCount); // update EndOfObject
      if FieldIsRowID then
        DecodedRowID := GetInteger(pointer(FieldValues[FieldCount]));
      inc(FieldCount);
      if FieldCount=MAX_SQLFIELDS then
        raise EParsingException.Create('Too many inlines in GetJSONObjectAsSQL');
    until EndOfObject in [#0,'}',']'];
  end else begin
    // get "VAL1","VAL2"...
    if P=nil then
      exit;
    if RowID>0 then
      raise EParsingException.Create('GetJSONObjectAsSQL(expanded) won''t handle RowID');
    if length(Fields)>MAX_SQLFIELDS then
      raise EParsingException.Create('Too many inlines in GetJSONObjectAsSQL');
    DecodedFieldNames := pointer(Fields);
    FieldCount := length(Fields);
    for F := 0 to FieldCount-1 do begin
      inc(FieldLen,length(Fields[F]));
      GetSQLValue(F); // update EndOfObject
    end;
  end;
end;

procedure TJSONObjectDecoder.Decode(JSON: RawUTF8; const Fields: TRawUTF8DynArray;
  Params: TJSONObjectDecoderParams; RowID: Integer=0; ReplaceRowIDWithID: Boolean=false);
var P: PUTF8Char;
begin
  if JSON='' then
    P := nil else begin
    P := @JSON[1]; // call UniqueString(JSON)
    while P^ in [#1..' ','{','['] do inc(P);
  end;
  Decode(P,Fields,Params,RowID,ReplaceRowIDWithID);
end;

function TJSONObjectDecoder.SameFieldNames(const Fields: TRawUTF8DynArray): boolean;
var i: integer;
begin
  result := false;
  if length(Fields)<>FieldCount then
    exit;
  for i := 0 to FieldCount-1 do
    if not IdemPropNameU(Fields[i],FieldNames[i]) then
      exit;
  result := true;
end;

procedure TJSONObjectDecoder.AssignFieldNamesTo(var Fields: TRawUTF8DynArray);
var i: integer;
begin
  SetLength(Fields,FieldCount);
  for i := 0 to FieldCount-1 do
    Fields[i] := FieldNames[i];
end;

function TJSONObjectDecoder.EncodeAsSQLPrepared(const TableName: RawUTF8;
  Occasion: TSQLOccasion): RawUTF8;
const SQL: array[boolean] of PUTF8Char = (
   'insert into %%', 'update % set % where ID=?');
var F: integer;
    P: PUTF8Char;
    tmp: RawUTF8;
begin
  result := '';
  if FieldCount<>0 then begin
    SetLength(tmp,FieldLen+2*FieldCount+12); // max length
    P := pointer(tmp);
    case Occasion of
    soUpdate: begin
      // returns 'COL1=?,COL2=?' (UPDATE SET format)
      for F := 0 to FieldCount-1 do begin
        P := AppendRawUTF8ToBuffer(P,DecodedFieldNames[F]);
        PInteger(P)^ := Ord('=')+Ord('?')shl 8+Ord(',')shl 16;
        inc(P,3);
      end;
      dec(P);
    end;
    soInsert: begin
      // returns ' (COL1,COL2) VALUES (?,?)' (INSERT format)
      PWord(P)^ := Ord(' ')+ord('(')shl 8;
      inc(P,2);
      for F := 0 to FieldCount-1 do begin
        P := AppendRawUTF8ToBuffer(P,DecodedFieldNames[F]);
        P^ := ',';
        inc(P);
      end;
      P := AppendRawUTF8ToBuffer(P-1,') VALUES (');
      for F := 1 to FieldCount do begin
        PWord(P)^ := Ord('?')+Ord(',')shl 8;
        inc(P,2);
      end;
      P[-1] := ')';
    end;
    else
      raise EORMException.Create('Invalid EncodeAsSQLPrepared() call');
    end;
    assert(P-pointer(tmp)<length(tmp));
    SetLength(tmp,P-pointer(tmp));
  end else
    if Occasion=soUpdate then
      exit else
      tmp := ' default values';
  result := FormatUTF8(SQL[Occasion=soUpdate],[TableName,tmp]);
end;

function TJSONObjectDecoder.EncodeAsSQL(Update: boolean): RawUTF8;
var F, Len: integer;
    P: PUTF8Char;
begin
  result := '';
  if FieldCount=0 then
    exit;
  if InlinedParams then
    Len := FieldLen+6*FieldCount else
    Len := FieldLen+2*FieldCount;
  if Update then begin
    // returns 'COL1='VAL1',COL2=VAL2' (UPDATE SET format)
    SetLength(result,Len-1); // -1 for last ','
    P := pointer(result);
    for F := 0 to FieldCount-1 do begin
      P := AppendRawUTF8ToBuffer(P,DecodedFieldNames[F]);
      if InlinedParams then begin
        PInteger(P)^ := Ord('=')+Ord(':')shl 8+Ord('(')shl 16;
        inc(P,3);
      end else begin
        P^ := '=';
        inc(P);
      end;
      P := AppendRawUTF8ToBuffer(P,FieldValues[F]);
      if InlinedParams then begin
        PWord(P)^ := Ord(')')+Ord(':')shl 8;
        P[2] := ',';
        // PInteger(P)^ := Ord(')')+Ord(':')shl 8+Ord(',')shl 16; may corrupt mem
        inc(P,3);
      end else begin
        P^ := ',';
        inc(P);
      end;
    end;
    dec(P);
    P^ := #0; // trim last ','
  end else begin
    // returns ' (COL1,COL2) VALUES ('VAL1',VAL2)' (INSERT format)
    SetLength(result,Len+11);
    P := pointer(result);
    PWord(P)^ := Ord(' ')+ord('(')shl 8;
    inc(P,2);
    for F := 0 to FieldCount-1 do begin
      P := AppendRawUTF8ToBuffer(P,DecodedFieldNames[F]);
      P^ := ',';
      inc(P);
    end;
    P := AppendRawUTF8ToBuffer(P-1,') VALUES (');
    for F := 0 to FieldCount-1 do begin
      if InlinedParams then begin
        PWord(P)^ := Ord(':')+Ord('(')shl 8;
        inc(P,2);
      end;
      P := AppendRawUTF8ToBuffer(P,FieldValues[F]);
      if InlinedParams then begin
        PWord(P)^ := Ord(')')+Ord(':')shl 8;
        P[2] := ',';
        inc(P,3);
      end else begin
        P^ := ',';
        inc(P);
      end;
    end;
    P[-1] := ')';
  end;
  Assert(P-pointer(result)=length(result));
end;


const
  FROMINLINED: array[boolean] of TJSONObjectDecoderParams = (
    pQuoted, pInlined);

function GetJSONObjectAsSQL(var P: PUTF8Char; const Fields: TRawUTF8DynArray;
  Update, InlinedParams: boolean; RowID: Integer=0; ReplaceRowIDWithID: Boolean=false): RawUTF8;
var Decoder: TJSONObjectDecoder;
begin
  Decoder.Decode(P,Fields,FROMINLINED[InlinedParams],RowID,ReplaceRowIDWithID);
  result := Decoder.EncodeAsSQL(Update);
end;

function GetJSONObjectAsSQL(JSON: RawUTF8; Update, InlinedParams: boolean;
 RowID: Integer=0; ReplaceRowIDWithID: Boolean=false): RawUTF8; overload;
var Decoder: TJSONObjectDecoder;
begin
  Decoder.Decode(JSON,nil,FROMINLINED[InlinedParams],RowID,ReplaceRowIDWithID);
  result := Decoder.EncodeAsSQL(Update);
end;

function Expect(var P: PUTF8Char; const Value: RawUTF8): boolean;
  {$ifdef HASINLINE}inline;{$endif}
var L: integer;
begin
  if P=nil then
    result := false else begin
    while P^ in [#1..' '] do inc(P);
    if Value='' then
      result := false else begin
      L := length(Value);
      result := CompareMem(P,pointer(Value),L);
      if result then
        inc(P,L);
    end;
  end;
end;

function GetJSONIntegerVar(var P: PUTF8Char): PtrInt;
var c: PtrUInt;
begin
  if P^ in [#1..' '] then repeat inc(P) until not(P^ in [#1..' ']);
  c := byte(P^)-48;
  if c>9 then
    result := 0 else begin
    result := c;
    inc(P);
    repeat
      c := byte(P^)-48;
      if c>9 then
        break;
      result := result*10+PtrInt(c);
      inc(P);
    until false;
  end;
end;

const
  FIELDCOUNT_PATTERN: RawUTF8 = '{"fieldCount":';
  ROWCOUNT_PATTERN: RawUTF8 = ',"rowCount":';
  VALUES_PATTERN: RawUTF8 = ',"values":[';

function UnJSONFirstField(var P: PUTF8Char): RawUTF8;
// expand=true: [ {"col1":val11} ] -> val11
// expand=false: { "fieldCount":1,"values":["col1",val11] } -> vall11
begin
  result := '';
  if P=nil then exit;
  if Expect(P,FIELDCOUNT_PATTERN) then begin
    // not expanded format
    if GetJSONIntegerVar(P)<>1 then
      exit; // wrong field count
    while P^<>'[' do if P^=#0 then exit else inc(P); // go to ["col1"
    inc(P); // go to "col1"
  end else begin
    // expanded format
    while P^<>'[' do if P^=#0 then exit else inc(P); // need an array of objects
    repeat inc(P); if P^=#0 then exit; until P^='{'; // go to object begining
  end;
  GetJSONField(P,P); // ignore field name
  result := GetJSONField(P,P); // get field value
end;

function IsNotAjaxJSON(P: PUTF8Char): Boolean;
begin
  result := Expect(P,FIELDCOUNT_PATTERN);
end;

function NotExpandedBufferRowCountPos(P,PEnd: PUTF8Char): PUTF8Char;
var i: integer;
begin
  result := nil;
  if (PEnd<>nil) and (PEnd-P>24) then
    for i := 1 to 24 do // search for "rowCount": at the end of the JSON buffer
    case PEnd[-i] of
    ']',',':
      exit;
    ':': begin
      if CompareMem(PEnd-i-11,pointer(ROWCOUNT_PATTERN),11) then
        result := PEnd-i+1;
      exit;
    end;
    end;
end;

function IsNotExpandedBuffer(var P: PUTF8Char; PEnd: PUTF8Char;
  var FieldCount,RowCount: integer): boolean;
  procedure GetRowCountNotExpanded(P: PUTF8Char);
  begin
    RowCount := 0;
    repeat
      // get a row
      P := GotoNextJSONItem(P,FieldCount);
      if P=nil then exit; // unexpected end
      inc(RowCount);
    until P[-1]=']'; // end of array
    if P^ in ['}',','] then begin // expected formated JSON stream
      if RowCount>0 then
        dec(RowCount); // first Row = field names -> data in rows 1..RowCount
    end else
      RowCount := -1; // bad format -> no data
  end;
var RowCountPos: PUTF8Char;
begin
  if not Expect(P,FIELDCOUNT_PATTERN) then begin
    result := false;
    exit;
  end;
  FieldCount := GetJSONIntegerVar(P);
  if Expect(P,ROWCOUNT_PATTERN) then
    RowCount := GetJSONIntegerVar(P) else begin
    RowCountPos := NotExpandedBufferRowCountPos(P,PEnd);
    if RowCountPos=nil then
      RowCount := -1 else // mark "rowCount":.. not available
      RowCount := GetCardinal(RowCountPos);
  end;
  result := (FieldCount<>0) and Expect(P,VALUES_PATTERN);
  if result and (RowCount<0) then
    GetRowCountNotExpanded(P); // returns RowCount=-1 if P^ is invalid
end;

function JSONIgnoreFieldName(P: PUTF8Char): PUTF8Char;
begin
  result := nil;
  if P^ in [#1..' '] then repeat inc(P) until not(P^ in [#1..' ']);
  if P^='"' then begin
    P := GotoJSONStringEnd(P);
    if P=nil then
      exit;
    inc(P);
  end;
  repeat
    if P^=#0 then exit else // unexpected end
    if P^=':' then break else // field name expected format is "FieldName":Value
    inc(P);
  until false;
  result := P+1;
end;

function JSONIgnoreFieldValue(P: PUTF8Char): PUTF8Char;
begin
  result := nil;
  if P=nil then exit;
  if P^ in [#1..' '] then repeat inc(P) until not(P^ in [#1..' ']);
  if P^='"' then begin
    P := GotoJSONStringEnd(P);
    if P=nil then
      exit;
    inc(P);
  end;
  repeat
    if P^=#0 then exit else // unexpected end
    if P^ in [',','}'] then break else // expect 'Value,' or 'Value}'
    inc(P);
  until false;
  result := P;
end;

function JSONIgnoreObject(P: PUTF8Char): PUTF8Char;
begin
  if P<>nil then begin
    while P^<>'{' do inc(P);
    if P^<>'{' then
      // expect '{"Name":Value,....}' object
      P := nil else
      if P[1]='}' then
        // it is a void object {}
        inc(P,2) else begin
        // ignore all "FieldName":Value pairs
        repeat
          P := JSONIgnoreFieldValue(JSONIgnoreFieldName(P+1));
          if P=nil then
            break;
          if P^=',' then inc(P);
          if P^ in [#1..' '] then repeat inc(P) until not(P^ in [#1..' ']);
        until P^='}';
        if P<>nil then
          if P^<>'}' then
            P := nil else // unexpected end
            inc(P); // returns position after the expected ending '}' delimiter
      end;
  end;
  result := P;
end;

function JSONGetObject(var P: PUTF8Char; ExtractID: PInteger;
  var EndOfObject: AnsiChar): RawUTF8;
var Beg, PC: PUTF8Char;
begin
  result := '';
  if P=nil then
    exit;
  while P^<>'{' do inc(P);
  Beg := P;
  P := JSONIgnoreObject(Beg);
  if (P<>nil) and not (P^ in EndOfJSONField) then
    P := nil;
  if P<>nil then begin
    EndOfObject := P^;
    inc(P); // ignore end of object, i.e. ',' or ']'
    if ExtractID<>nil then begin
      PC := Beg;
      while PC^<>'"' do
        if PC^=#0 then exit else inc(PC);
      if IdemPChar(PC,'"ID":') or IdemPChar(PC,'"ROWID":') then begin
        ExtractID^ := GetInteger(PosChar(PC,':')+1);
        PC := PosChar(PC,',');
        PC^ := '{';
        SetString(result,PAnsiChar(PC),P-PC-1); // extract the '"ID":203,' pair
        exit;
      end else
        ExtractID^ := 0;
    end;
    SetString(result,PAnsiChar(Beg),P-Beg-1);
  end;
end;


{ TSQLTableJSON }

function TSQLTableJSON.PrivateCopyChanged(aJSON: PUTF8Char; aLen: integer): boolean;
var Hash: cardinal;
begin
  Hash := crc32(0,pointer(aJSON),aLen);
  result := (fPrivateCopyHash=0) or (Hash=0) or (Hash<>fPrivateCopyHash);
  if not result then
    exit;
  SetString(fPrivateCopy,PAnsiChar(aJSON),aLen);
  fPrivateCopyHash := Hash;
end;

function TSQLTableJSON.ParseAndConvert(Buffer: PUTF8Char; BufferLen: integer): boolean;
function GetFieldCountExpanded(P: PUTF8Char): integer;
{$ifdef PUREPASCAL}
begin
  result := 0;
  repeat
    P := JSONIgnoreFieldValue(JSONIgnoreFieldName(P));
    if P=nil then begin // unexpected end
      result := 0;
      exit;
    end;
    inc(result);
    if P^='}' then break; // end of object
    inc(P);
  until false;
end;
{$else}
asm
    push ebx
    xor ebx,ebx
@1: call JSONIgnoreFieldName
    call JSONIgnoreFieldValue
    or eax,eax
    jz @z  // P=nil -> unexpected end
    inc ebx
    cmp byte ptr [eax],'}'
    lea eax,[eax+1]
    jnz @1 // end of object
@z: mov eax,ebx
    pop ebx
end;
{$endif}
var i, max, nfield, nrow, resmax, f: integer;
    EndOfObject: AnsiChar;
    P: PUTF8Char;
    wasString: Boolean;
begin
  result := false; // error on parsing
  fFieldIndexID := -1;
  if (self=nil) or (Buffer=nil) then
    exit;
  // go to start of object
  P := GotoNextNotSpace(Buffer);
  if IsNotExpandedBuffer(P,Buffer+BufferLen,fFieldCount,fRowCount) then begin
    // A. Not Expanded format
(* {"fieldCount":9,"values":["ID","Int","Test","Unicode","Ansi","ValFloat","ValWord",
    "ValDate","Next",0,0,"abcde+ef++","abcde+ef++","abcde+ef++",
    3.14159265300000E+0000,1203,"2009-03-10T21:19:36",0,..],"rowCount":20} *)
    // 1. check RowCount and DataLen
    if fRowCount<0 then begin // IsNotExpanded() notified wrong input
      fRowCount := 0; // may occur if P^ content was invalid
      exit;
    end;
    // 2. initialize and fill fResults[] PPUTF8CharArray memory
    max := (RowCount+1)*FieldCount;
    SetLength(fJSONResults,max);
    fResults := @fJSONResults[0];
    // unescape+zeroify JSONData + fill fResults[] to proper place
    dec(max);
    f := 0;
    for i := 0 to max do begin
      // get a field
      fJSONResults[i] := GetJSONField(P,P,@wasString);
      if (P=nil) and (i<>max) then
        exit; // failure (GetRowCountNotExpanded should have detect it)
      if (f>=0) and (i>=FieldCount) then begin
        if wasString then
          Include(fFieldParsedAsString,f); // mark column was "string"
        inc(f);
        if f=FieldCount then
          f := -1; // only check first row (should be consistent)
      end;
    end;
  end else begin
    // B. Expanded format
(* [{"ID":0,"Int":0,"Test":"abcde+ef++","Unicode":"abcde+ef++","Ansi":
    "abcde+ef++","ValFloat": 3.14159265300000E+0000,"ValWord":1203,
    "ValDate":"2009-03-10T21:19:36","Next":0},{..}] *)
    // 1. get fields count from first row
    while P^<>'[' do if P^=#0 then exit else inc(P); // need an array of objects
    repeat inc(P); if P^=#0 then exit; until P^='{'; // go to object beginning
    inc(P);
    nfield := GetFieldCountExpanded(P);
    if nField=0 then
      exit; // invalid data for first row
    // 2. get values (assume fields are always the same as in the first object)
    max := nfield; // index to start storing values in fResults[]
    resmax := nfield*2;
    SetLength(fJSONResults,resmax); // space for field names + 1 data row
    nrow := 0;
    repeat // unescape+zeroify JSONData + fill U[] with pointer to values
      for i := 0 to nfield-1 do begin
        if nrow=0 then // get field name from 1st Row
          fJSONResults[i] := GetJSONField(P,P) else
          P := JSONIgnoreFieldName(P);  // ignore field name for later rows
        if max>=resmax then begin // check space inside loop for GPF security
          inc(resmax,resmax shr 3+nfield shl 8);
          SetLength(fJSONResults,resmax); // enough space for 256 more rows
        end;
        if P=nil then break; // normal end: no more field name
        fJSONResults[max] := GetJSONField(P,P,@wasString,@EndOfObject); // get value
        if P=nil then begin
          nfield := 0;
          break; // unexpected end
        end;
        if (nrow=1) and wasString then // mark column was "string"
          Include(fFieldParsedAsString,max-nfield);
        inc(max);
      end;
      if P=nil then
        break; // unexpected end
      if EndOfObject<>'}' then
        break; // data field layout is not consistent: should never happen
      inc(nrow);
      while (P^<>'{') and (P^<>']') do // go to next object beginning
        if P^=#0 then
          exit else
          inc(P);
      if P^=']' then
        break else
        inc(P); // jmp '{'
    until false;
    if max<>(nrow+1)*nfield then begin // field count must be the same for all objects
      fFieldCount := 0;
      fRowCount := 0;
      exit; // data field layout is not consistent: should never happen
    end;
    // 3. save field pointers to fResults[]
    SetLength(fJSONResults,max); // resize to exact size
    fResults := @fJSONResults[0];
    fFieldCount := nfield;
    fRowCount := nrow;
  end;
  for i := 0 to fFieldCount-1 do
    if IsRowID(fResults[i]) then begin
      fFieldIndexID := i;
      break;
    end;
  result := true; // if we reached here, means successfull conversion from P^
end;

function TSQLTableJSON.UpdateFrom(const aJSON: RawUTF8; var Refreshed: boolean;
  PCurrentRow: PInteger): boolean;
var len: Integer;
begin
  len := length(aJSON);
  if PrivateCopyChanged(pointer(aJSON),len) then
    if ParseAndConvert(pointer(fPrivateCopy),len) then begin
     // parse success from new aJSON data -> need some other update?
     if Assigned(fIDColumn) then begin
       // ID column was hidden -> do it again
       Finalize(fIDColumn);
       IDColumnHide;
     end;
     with fSortParams do
       if FieldCount<>0 then
         // TSQLTable.SortFields() was called -> do it again
         SortFields(FieldIndex,Asc,PCurrentRow,FieldType);
     Refreshed := true;
     result := true;
    end else
      // parse error
      result := false else
    // data didn't change (fPrivateCopyHash checked)
    result := true;
end;

constructor TSQLTableJSON.Create(const Tables: array of TSQLRecordClass;
  const aSQL: RawUTF8; JSONBuffer: PUTF8Char; JSONBufferLen: integer);
begin // don't raise exception on error parsing
  inherited Create(Tables,aSQL);
  ParseAndConvert(JSONBuffer,JSONBufferLen);
end;

constructor TSQLTableJSON.Create(const Tables: array of TSQLRecordClass; const aSQL,
  aJSON: RawUTF8);
var len: integer;
begin
  len := length(aJSON);
  SetString(fPrivateCopy,PAnsiChar(pointer(aJSON)),len);
  Create(Tables,aSQL,pointer(fPrivateCopy),len);
end;


{ TINIWriter }

const
  sWriteObject1: PWinAnsiChar = #13'[%]'#13;
  sWriteObject2: PWinAnsiChar = '%%=%'#13;
  
procedure TINIWriter.WriteObject(Value: TObject; const SubCompName: RawUTF8='';
  WithSection: boolean=true);
var P: PPropInfo;
    i, V: integer;
    VT: shortstring; // for str()
    Obj: TObject;
    CP: PClassProp;
    WS: WideString;
begin
  if Value<>nil then begin
    if WithSection then
      // new TObject.ClassName is UnicodeString (Delphi 20009) -> inline code with
      // vmtClassName = UTF-8 encoded text stored in a shortstring = -44
      Add(sWriteObject1,[PShortString(PPointer(PPtrInt(Value)^+vmtClassName)^)^]);
    CP := InternalClassProp(PPointer(Value)^);
    if CP=nil then
      exit;
    P := @CP^.PropList;
    for i := 1 to CP^.PropCount do begin
      case P^.PropType^^.Kind of
        tkInt64{$ifdef FPC}, tkQWord{$endif}:
          Add(sWriteObject2,[SubCompName,P^.Name,GetInt64Prop(Value,pointer(P))]);
        {$ifdef FPC}tkBool,{$endif}
        tkEnumeration, tkInteger, tkSet: begin
          V := GetOrdProp(Value,pointer(P)); // pointer() to call typinfo
          if V<>P^.Default then
            Add(sWriteObject2,[SubCompName,P^.Name,V]);
        end;
        {$ifdef FPC}tkAString,{$endif} tkLString:
          Add(sWriteObject2,[SubCompName,P^.Name,P^.GetLongStrValue(Value)]);
        tkFloat: begin
          VT[0] := AnsiChar(ExtendedToString(VT,GetFloatProp(Value,pointer(P)),DOUBLE_PRECISION));
          Add(sWriteObject2,[SubCompName,P^.Name,VT]);
        end;
        tkWString: begin
          GetWideStrProp(Value,P,WS);
          Add(sWriteObject2,[SubCompName,P^.Name,WS]);
        end;
        {$ifdef UNICODE}
        tkUString: // write converted to UTF-8
          Add(sWriteObject2,[SubCompName,P^.Name,GetUnicodeStrProp(Value,pointer(P))]);
        {$endif}
        tkDynArray: begin
          Add(sWriteObject2,[SubCompName,P^.Name]);
          AddDynArrayJSON(P^.GetDynArray(Value));
          Add(#13);
        end;
        {$ifdef PUBLISHRECORD}
        tkRecord:
          Add(sWriteObject2,[SubCompName,P^.Name,BinToBase64WithMagic(
            RecordSave(P^.GetFieldAddr(Value)^,P^.PropType^))]);
        {$endif}
        tkClass: begin
          Obj := pointer(GetOrdProp(Value,pointer(P)));  // works also for CPU64
          if (Obj<>nil) and Obj.InheritsFrom(TPersistent) then
             WriteObject(Obj,SubCompName+RawUTF8(P^.Name)+'.',false);
        end;
        {$ifdef USEVARIANTS}
        tkVariant: // stored as JSON, e.g. '1.234' or '"text"'
          Add(sWriteObject2,[SubCompName,P^.Name,
            VariantSaveJSON(PVariant(P^.GetFieldAddr(Value))^)]);
        {$endif}
      end; // tkString (shortstring) is not handled
      P := P^.Next;
    end;
  end;
end;

function UTF8ContentType(P: PUTF8Char): TSQLFieldType;
var V: PUTF8Char;
    c: integer;
begin
  if P=nil then begin
    result := sftUnknown;
    exit;
  end;
  P := GotoNextNotSpace(P);
  V := P;
  if (PInteger(P)^=NULL_LOW) and (P[4]=#0) then
     result := sftUnknown else
  // don't check for 'false' or 'true' here, since their UTF-8 value is '0' or '1'
  if (P[0] in ['1'..'9']) or // is first char numeric?
     ((P[0]='0') and not (P[1] in ['0'..'9'])) or // '012' excluded by JSON
     ((P[0]='-') and (P[1] in ['0'..'9'])) then begin
    // check if P^ is a true numerical value
    result := sftInteger;
    repeat inc(P) until not (P^ in ['0'..'9']); // check digits
    if P^='.' then begin
      inc(P);
      if P^ in ['0'..'9'] then begin
        result := sftFloat;
        repeat inc(P) until not (P^ in ['0'..'9']); // check fractional digits
      end else begin
        result := sftUTF8Text; // invalid '23023.' value
        exit;
      end;
    end else
      if P-V>18 then begin
        Result := sftUTF8Text; // outside Int64 digits range
        exit; // even sftFloat precision won't be able to handle it
      end;
    if byte(P^) and $DF=ord('E') then begin
      result := sftFloat;
      inc(P);
      if P^='+' then inc(P) else
      if P^='-' then inc(P);
      while P^ in ['0'..'9'] do inc(P);
    end;
    P := GotoNextNotSpace(P);
    if P^<>#0 then // invalid numerical value -> test if not TDateTime
      if Iso8601ToSecondsPUTF8Char(V,0)<>0 then
        result := sftDateTime else
        result := sftUTF8Text;
    exit;
  end else begin
    c := PInteger(V)^ and $00ffffff;
    if (c=JSON_BASE64_MAGIC) or ((V[1]='''') and isBlobHex(V)) then
      result := sftBlob else
    if c=JSON_SQLDATE_MAGIC then
      result := sftDateTime else
      result := sftUTF8Text;
  end;
end;


{ TPropInfo }

function TPropInfo.GetSQLFromFieldValue(const FieldValue: RawUTF8): RawUTF8;
begin
  case PropType^^.Kind of
    tkLString,{$ifdef FPC}tkAString,{$endif}{$ifdef UNICODE}tkUString,{$endif}
    tkChar, tkWChar, tkWString:
      { escape SQL strings, cf. the official SQLite3 documentation:
       "A string constant is formed by enclosing the string in single quotes (').
       A single quote within the string can be encoded by putting two single
       quotes in a row - as in Pascal."
       Warning: in SQLite, double quotes are NOT identifying TEXT but a keyword }
      result := QuotedStr(FieldValue,'''');
{    tkInteger, tkClass, tkEnumeration, tkInt64, tkFloat, tkSet:
       these kind of values are stored as a numerical (floating-point) value }
    else
      result := FieldValue;
  end;
end;

function TPropInfo.SameValue(Item1,Item2: TObject; CaseInsensitive: boolean): boolean;
var tmp1,tmp2: RawByteString;
{$ifdef UNICODE}
    tmpU1,tmpU2: UnicodeString;
{$endif}
label Int;
begin
  if Item1=Item2 then begin
    result := true;
    exit;
  end else
  if (Item1=nil) or (Item2=nil) then begin
    result := false;
    exit;
  end else
  case PropType^^.Kind of
  tkEnumeration, tkInteger, tkSet, tkChar, tkWChar: begin
    result := GetOrdProp(Item1,pointer(@self))=GetOrdProp(Item2,pointer(@self));
    exit;
  end;
  tkFloat:
    if PropType^.FloatType in [ftDouble,ftCurr] then
      goto Int; // compare 8 bytes content at binary level
  tkInt64{$ifdef FPC}, tkQWord{$endif}: begin
Int:result := GetInt64Prop(Item1,pointer(@self))=GetInt64Prop(Item2,pointer(@self));
    exit;
  end;
  tkLString{$ifdef FPC},tkAString{$endif}: begin
    GetLongStrProp(Item1,pointer(@self),tmp1);
    GetLongStrProp(Item2,pointer(@self),tmp2);
    if CaseInsensitive then
      if PropType^=TypeInfo(RawUTF8) then
        result := UTF8IComp(pointer(tmp1),pointer(tmp2))=0 else
      if PropType^=TypeInfo(TSQLRawBlob) then
        result := tmp1=tmp2 else // BLOB is binary so always case sensitive
      if PropType^=TypeInfo(WinAnsiString) then
        result := AnsiIComp(pointer(tmp1),pointer(tmp2))=0 else
        result := StrIComp(pointer(tmp1),pointer(tmp2))=0 else
      result := tmp1=tmp2;
    exit;
  end;
  {$ifdef UNICODE}
  tkUString: begin
    tmpU1 := GetUnicodeStrProp(Item1,pointer(@self));
    tmpU2 := GetUnicodeStrProp(Item2,pointer(@self));
    if CaseInsensitive then
      result := AnsiICompW(pointer(tmpU1),pointer(tmpU2))=0 else
      result := tmpU1=tmpU2;
    exit;
  end;
  {$endif}
  tkDynArray: begin
    result := GetDynArray(Item1).Equals(GetDynArray(Item2));
    exit;
  end;
  end;
  GetValueVar(Item1,false,RawUTF8(tmp1),nil);
  GetValueVar(Item2,false,RawUTF8(tmp2),nil);
  result := tmp1=tmp2; // slow, always working implementation
end;

function TPropInfo.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var I64: Int64;
    tmp: RawByteString;
{$ifdef UNICODE}
    tmpU: UnicodeString;
{$endif}
    Up: array[byte] of AnsiChar; // avoid slow heap allocation
label Int;
begin
  if Instance<>nil then
  case PropType^^.Kind of
  tkEnumeration, tkInteger, tkSet, tkClass,
  tkChar, tkWChar: begin
    result := GetOrdProp(Instance,pointer(@self));
    exit;
  end;
  tkFloat:
    if PropType^.FloatType in [ftDouble,ftCurr] then
      goto Int; // hash from 8 bytes binary content
  tkInt64{$ifdef FPC}, tkQWord{$endif}: begin
Int:I64 := GetInt64Prop(Instance,pointer(@self));
    result := Int64Rec(I64).Lo xor Int64Rec(I64).Hi;
    exit;
  end;
  tkLString{$ifdef FPC},tkAString{$endif}: begin
    GetLongStrProp(Instance,pointer(@self),tmp);
    if CaseInsensitive then
      if PropType^=TypeInfo(RawUTF8) then
        result := crc32(0,Up,UTF8UpperCopy255(Up,tmp)-Up) else
        if PropType^=TypeInfo(TSQLRawBlob) then // binary is case sensitive
          result := crc32(0,pointer(tmp),length(tmp)) else
          result := crc32(0,Up,UpperCopy255(Up,tmp)-Up) else
      result := crc32(0,pointer(tmp),length(tmp));
    exit;
  end;
  {$ifdef UNICODE}
  tkUString: begin
    tmpU := GetUnicodeStrProp(Instance,pointer(@self));
    if CaseInsensitive then
      result := crc32(0,Up,UpperCopy255W(Up,tmpU)-Up) else
      result := crc32(0,pointer(tmpU),length(tmpU)*sizeof(char));
    exit;
  end;
  {$endif}
  tkDynArray: begin
    tmp := GetDynArray(Instance).SaveTo;
    result := crc32(0,pointer(tmp),length(tmp));
    exit;
  end;
  end else begin
    result := 1;
    exit; // return a default Hash for Instance=nil
  end;
  GetValueVar(Instance,false,RawUTF8(tmp),nil);
  result := crc32(0,pointer(tmp),length(tmp));
end;

procedure TPropInfo.NormalizeValue(var Value: RawUTF8);
var err, VInt: integer;
    VInt64: Int64;
    VFloat: double; // we force Double precision value, as SQLite3 does
label Int;
begin
  case PropType^^.Kind of
    tkInteger, tkSet: begin
Int:  VInt := GetInteger(pointer(Value),err);
      if err<>0 then
        Value := '' else
        Value := {$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(VInt);
    end;
    tkClass: // TSQLRecord field value is pointer(RecordID), not any Instance
      case PropType^^.ClassSQLFieldType of
        sftID: goto Int;
        sftObject: ; // already UTF-8 encoded -> already normalized
        else Value := '';
      end;
    {$ifdef FPC}tkBool,{$endif} tkEnumeration:
    // boolean use ToSQL=true format ('0' or '1')
    with PropType^^.EnumBaseType^ do begin
      VInt := GetInteger(pointer(Value),err);
      if err<>0 then // we allow a value stated as text -> convert into integer
        if {$ifdef FPC}PropType^^.Kind=tkBool{$else}PropType^=TypeInfo(boolean){$endif} then
          VInt := GetEnumNameValue(pointer(Value)) else
          VInt := GetEnumNameTrimedValue(pointer(Value));
      if cardinal(VInt)<=cardinal(MaxValue) then
        Value := {$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(VInt) else
        Value := '';
    end;
    {$ifdef FPC}tkAString,{$endif} {$ifdef UNICODE}tkUString,{$endif}
    tkLString, tkChar, tkWChar {$ifdef USEVARIANTS}, tkVariant{$endif}:
      ; // already UTF-8 encoded -> already normalized
    tkInt64{$ifdef FPC}, tkQWord{$endif}: begin
      VInt64 := GetInt64(pointer(Value),err); // works also with TTimeLog
      if err<>0 then
        Value := '' else
        Value := {$ifndef ENHANCEDRTL}Int64ToUtf8{$else}IntToStr{$endif}(VInt64);
    end;
    tkFloat:
    if PropType^=TypeInfo(Currency) then
      Value := Curr64ToStr(StrToCurr64(pointer(Value))) else
      if PropType^=TypeInfo(TDateTime) then
        Value := DateTimeToIso8601Text(Iso8601ToDateTime(Value)) else begin
{$ifdef ENHANCEDRTL}
        val(Value,VFloat,err);
{$else} VFloat := GetExtended(pointer(Value),err);
{$endif}if err<>0 then
          Value := '' else
          Value := ExtendedToStr(VFloat,DOUBLE_PRECISION);
      end;
    else Value := '';  // e.g. tkString (shortstring), tkWString or tkDynArray
  end;
end;

function TPropInfo.GetOrdValue(Instance: TObject): Integer;
begin
  if (Instance<>nil) and (@self<>nil) and
     (PropType^^.Kind in [
       tkInteger,tkEnumeration,tkSet,{$ifdef FPC}tkBool,{$endif}tkClass]) then
    result := GetOrdProp(Instance,pointer(@self)) else
    result := -1;
end;

function TPropInfo.GetInt64Value(Instance: TObject): Int64;
begin
  if (Instance<>nil) and (@self<>nil) then
  case PropType^^.Kind of
    tkInteger,tkEnumeration,tkSet,{$ifdef FPC}tkBool,{$endif}tkClass:
      result := GetOrdProp(Instance,pointer(@self));
    tkInt64{$ifdef FPC}, tkQWord{$endif}:
      result := GetInt64Prop(Instance,pointer(@self));
    else result := 0;
  end else
    result := 0;
end;

function TPropInfo.GetCurrencyValue(Instance: TObject): Currency;
begin
  if (Instance<>nil) and (@self<>nil) and (PropType^^.Kind=tkFloat) and
     (PropType^.FloatType=ftCurr) then
    PInt64(@result)^ := GetInt64Prop(Instance,pointer(@self)) else
    result := 0;
end;

function TPropInfo.GetExtendedValue(Instance: TObject): Extended;
begin
  if (Instance<>nil) and (@self<>nil) and (PropType^^.Kind=tkFloat) then
     result := GetFloatProp(Instance,pointer(@self)) else
     result := 0;
end;

procedure TPropInfo.SetExtendedValue(Instance: TObject; const Value: Extended);
begin
  if (Instance<>nil) and (@self<>nil) and (PropType^^.Kind=tkFloat) then
    SetFloatProp(Instance,pointer(@self),Value);
end;

function TPropInfo.GetDynArray(Instance: TObject): TDynArray;
begin
  result.Init(PropType^,GetFieldAddr(Instance)^);
end;

function TPropInfo.GetLongStrValue(Instance: TObject): RawUTF8;
var tmp: RawByteString;
begin
  result := '';
  if (Instance<>nil) and (@self<>nil) and
     (PropType^^.Kind in [{$ifdef FPC}tkAString,{$endif}tkLString]) then
    if PropType^=TypeInfo(RawUTF8) then
      GetLongStrProp(Instance,pointer(@self),RawByteString(result)) else begin
      GetLongStrProp(Instance,pointer(@self),tmp);
      if tmp<>'' then
        if PropType^=TypeInfo(WinAnsiString) then
          result := WinAnsiToUTF8(WinAnsiString(tmp)) else
        if PropType^=TypeInfo(RawUnicode) then
          RawUnicodeToUTF8(pointer(tmp),length(tmp)shr 1,result) else
        if PropType^=TypeInfo(TSQLRawBlob) then
          result := TSQLRawBlobToBlob(TSQLRawBlob(tmp)) else
          // not a known LongStr type -> use generic AnsiString
          result := CurrentAnsiConvert.AnsiToUTF8(tmp);
    end;
end;

procedure TPropInfo.GetRawByteStringValue(Instance: TObject; var Value: RawByteString);
begin
  if (Instance<>nil) and (@self<>nil) and
     (PropType^^.Kind in [{$ifdef FPC}tkAString,{$endif}tkLString]) then
    GetLongStrProp(Instance,pointer(@self),Value) else
    Value := '';
end;

procedure TPropInfo.SetLongStrValue(Instance: TObject; const Value: RawUTF8);
begin
  if (Instance<>nil) and (@self<>nil) and
     (PropType^^.Kind in [{$ifdef FPC}tkAString,{$endif}tkLString]) then
  if (Value='') or (PropType^=TypeInfo(RawUTF8)) then
    SetLongStrProp(Instance,pointer(@self),Value) else 
  if PropType^=TypeInfo(WinAnsiString) then
    SetLongStrProp(Instance,pointer(@self),UTF8ToWinAnsi(Value)) else
  if PropType^=TypeInfo(RawUnicode) then
    SetLongStrProp(Instance,pointer(@self),Utf8DecodeToRawUnicode(Value)) else
  if PropType^=TypeInfo(TSQLRawBlob) then
    SetLongStrProp(Instance,pointer(@self),BlobToTSQLRawBlob(pointer(Value))) else
    // not a known LongStr type -> use generic AnsiString
    SetLongStrProp(Instance,pointer(@self),AnsiString(UTF8ToString(Value)));
end;

function TPropInfo.GetGenericStringValue(Instance: TObject): string;
begin
  if (Instance=nil) or (@self=nil) then
    result := '' else
    case PropType^^.Kind of
      {$ifdef FPC}tkAString,{$endif} tkLString:
        result := UTF8ToString(GetLongStrValue(Instance));
{$ifdef UNICODE}
      tkUString:
        result := GetUnicodeStrProp(Instance,pointer(@self));
{$endif}
     else result := '';
     end;
end;

procedure TPropInfo.SetGenericStringValue(Instance: TObject; const Value: string);
begin
  if (Instance<>nil) and (@self<>nil) then
    case PropType^^.Kind of
      {$ifdef FPC}tkAString,{$endif}tkLString:
         SetLongStrValue(Instance,StringToUtf8(Value));
{$ifdef UNICODE}
       tkUString:
         SetUnicodeStrProp(Instance,pointer(@self),Value);
{$endif}
    end;
end;

{$ifdef UNICODE}

function TPropInfo.GetUnicodeStrValue(Instance: TObject): UnicodeString;
begin
  if (Instance<>nil) and (@self<>nil) and
     (PropType^^.Kind=tkUString) then
    result := GetUnicodeStrProp(Instance,pointer(@self));
end;

procedure TPropInfo.SetUnicodeStrValue(Instance: TObject; const Value: UnicodeString);
begin
  if (Instance<>nil) and (@self<>nil) and
     (PropType^^.Kind=tkUString) then
    SetUnicodeStrProp(Instance,pointer(@self),Value);
end;
{$endif}

procedure TPropInfo.SetOrdValue(Instance: TObject; Value: Integer);
begin
  if (Instance<>nil) and (@self<>nil) and
     (PropType^^.Kind in [
       tkInteger,tkEnumeration,tkSet,{$ifdef FPC}tkBool,{$endif}tkClass]) then
    SetOrdProp(Instance,pointer(@self),Value);
end;

procedure TPropInfo.SetInt64Value(Instance: TObject; Value: Int64);
begin
  if (Instance<>nil) and (@self<>nil) then
  case PropType^^.Kind of
    tkInteger,tkEnumeration,tkSet,{$ifdef FPC}tkBool,{$endif}tkClass:
      SetOrdProp(Instance,pointer(@self),Value);
    tkInt64{$ifdef FPC}, tkQWord{$endif}:
      SetInt64Prop(Instance,pointer(@self),Value);
  end;
end;

function TPropInfo.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
var PB: PByte absolute P;
    valid: boolean;
label I64, Int;
begin
  result := nil;
  if (P=nil) or (Instance=nil) then
    exit;
  case PropType^^.Kind of
    {$ifdef FPC}tkBool,{$endif}
    tkEnumeration, tkInteger, tkSet, tkChar, tkWChar: // SetOrdProp() properties
Int:  SetOrdProp(Instance,Pointer(@self),integer(FromVarUInt32(PB)));
    tkClass:
    case PropType^^.ClassSQLFieldType of
      sftID: goto int;
      sftObject: begin // unserialize object from JSON UTF-8 TEXT - not fast, but works
        JSONToObject(Instance,pointer(FromVarString(PB)),valid);
        if not valid then exit;
      end;
      else exit;
    end;
    tkInt64{$ifdef FPC}, tkQWord{$endif}:
I64:begin
      SetInt64Prop(Instance,Pointer(@self),PInt64(P)^);
      inc(P,sizeof(Int64));
    end;
    tkFloat:
      if PropType^.FloatType in [ftCurr,ftDouble] then
        goto I64 else begin
        SetFloatProp(Instance,Pointer(@self),PExtended(P)^);
        inc(P,sizeof(Extended));
      end;
    {$ifdef FPC}tkAString,{$endif} tkLString:
      SetLongStrProp(Instance,pointer(@self),FromVarString(PB));
    {$ifdef UNICODE}
    tkUString:
      SetUnicodeStrProp(Instance,pointer(@self),UTF8DecodeToUnicodeString(FromVarString(PB)));
    {$endif}
    tkDynArray:
      P := GetDynArray(Instance).LoadFrom(P);
    {$ifdef PUBLISHRECORD}
    tkRecord:
      P := RecordLoad(GetFieldAddr(Instance)^,P,PropType^);
    {$endif}
    {$ifdef USEVARIANTS}
    tkVariant:
      FromVarVariant(PByte(P),PVariant(GetFieldAddr(Instance))^);
    {$endif}
  end;
  result := P;
end;

procedure TPropInfo.GetBinary(Instance: TObject; W: TFileBufferWriter);
var VExt: Extended;
    V64:  Int64 absolute VExt;
    VStr: RawByteString;
label I64, Int;
begin
  case PropType^^.Kind of
    {$ifdef FPC}tkBool,{$endif}
    tkEnumeration, tkInteger, tkSet, tkChar, tkWChar: // GetOrdProp() properties
Int:  W.WriteVarUInt32(cardinal(GetOrdProp(Instance,Pointer(@self))));
    tkClass:
    case PropType^^.ClassSQLFieldType of
      sftID: goto int;
      sftObject: // serialize object as JSON UTF-8 TEXT - not fast, but works
        W.Write(ObjectToJSON(TObject(GetOrdProp(Instance,@self))));
    end;
    tkInt64{$ifdef FPC}, tkQWord{$endif}: begin
I64:   V64 := GetInt64Prop(Instance,Pointer(@self));
       W.Write(@V64,SizeOf(Int64));
     end;
    tkFloat:
      if PropType^.FloatType in [ftCurr,ftDouble] then
        goto I64 else begin
        VExt := GetFloatProp(Instance,Pointer(@self));
        W.Write(@VExt,sizeof(VExt));
      end;
    {$ifdef FPC}tkAString,{$endif} tkLString: begin
      GetLongStrProp(Instance,pointer(@self),VStr);
      W.Write(VStr);
    end;
    {$ifdef UNICODE}
    tkUString:
      W.Write(UnicodeStringToUtf8(GetUnicodeStrProp(Instance,pointer(@self))));
    {$endif}
    tkDynArray: begin
      VStr := GetDynArray(Instance).SaveTo;
      W.Write(pointer(VStr),length(VStr));
    end;
    {$ifdef PUBLISHRECORD}
    tkRecord: begin
      VStr := RecordSave(GetFieldAddr(Instance)^,PropType^);
      W.Write(pointer(VStr),length(VStr));
    end;
    {$endif}
    {$ifdef USEVARIANTS}
    tkVariant:
      W.Write(PVariant(GetFieldAddr(Instance))^);
    {$endif}
  end;
end;

{$ifndef LVCL}
procedure CopyCollection(Source, Dest: TCollection);
var i: integer;
begin
  if (Source=nil) or (Dest=nil) or (Source.ClassType<>Dest.ClassType) then
    exit;
  Dest.BeginUpdate;
  try
    Dest.Clear;
    for i := 0 to Source.Count-1 do
      CopyObject(Source.Items[i],Dest.Add); // Assign() fails
  finally
    Dest.EndUpdate;
  end;
end;
{$endif}

procedure TPropInfo.CopyValue(Source, Dest: TObject);
var Value: RawByteString;
    WS: WideString;
    S,D: TObject;
label I64, Int;
begin
  if (@self<>nil) and (Source<>nil) and (Dest<>Source) and (Dest<>nil) then
//    (PPointer(Source)^=PPointer(Dest)^) then // allow parent into child e.g.
  case PropType^^.Kind of
    {$ifdef FPC}tkBool,{$endif}
    tkEnumeration, tkInteger, tkSet, tkChar, tkWChar:
Int:  SetOrdProp(Dest,pointer(@self),GetOrdProp(Source,pointer(@self)));
    tkClass:
    case PropType^^.ClassSQLFieldType of
      sftID:
        // special case for TSQLRecord published properties (sftID, sftRecord)
        // -> these are not class instances, but INTEGER reference to records
        goto int;
      sftObject: begin
        // generic case: copy also class content (create instances)
        S := pointer(GetOrdProp(Source,pointer(@self)));
        D := pointer(GetOrdProp(Dest,pointer(@self)));
        // note: Get/SetOrdProp() works also for CPU64 (returns an PtrInt)
{$ifndef LVCL}
        if S.InheritsFrom(TCollection) then
          CopyCollection(TCollection(S),TCollection(D)) else
{$endif} begin
          D.Free; // release previous child
          if S=nil then
            D := nil else begin
            D := ClassInstanceCreate(S.ClassType); // create new child instance
            CopyObject(S,D); // copy child content
          end;
          SetOrdProp(Dest,pointer(@self),PtrInt(D));
        end;
      end;
    end;
    tkInt64{$ifdef FPC}, tkQWord{$endif}:
      // works also with TTimeLog, Double and Currency
I64:  SetInt64Prop(Dest,pointer(@self),GetInt64Prop(Source,pointer(@self)));
    tkFloat:
    if PropType^.FloatType in [ftDouble,ftCurr] then
      goto I64 else
      SetFloatProp(Dest,pointer(@self),GetFloatProp(Source,pointer(@self)));
    {$ifdef FPC}tkAString,{$endif} tkLString: begin
      GetLongStrProp(Source,pointer(@self),Value);
      SetLongStrProp(Dest,pointer(@self),Value);
    end;
    {$ifdef UNICODE}
    tkUString:
      SetUnicodeStrProp(Dest,pointer(@self),GetUnicodeStrProp(Source,pointer(@self)));
    {$endif}
    tkWString: begin
      GetWideStrProp(Source,@self,WS);
      SetWideStrProp(Dest,pointer(@self),WS);
    end;
    tkDynArray:
      GetDynArray(Dest).Copy(GetDynArray(Source));
    {$ifdef PUBLISHRECORD}
    tkRecord:
      RecordCopy(GetFieldAddr(Dest)^,GetFieldAddr(Source)^,PropType^);
    {$endif}
    {$ifdef USEVARIANTS}
    tkVariant: // do not handle getter/setter yet
      PVariant(GetFieldAddr(Dest))^ := PVariant(GetFieldAddr(Source))^;
    {$endif}
  end; // note: tkString (shortstring) not handled
end;

{$ifdef USEVARIANTS}
procedure TPropInfo.GetVariant(Instance: TObject; var Dest: Variant);
var V64: Int64;
begin
  if @self=nil then
    VarClear(Dest) else
  case PropType^^.Kind of
    {$ifdef FPC}
    tkBool:
      Dest := boolean(GetOrdProp(Instance,@self));
    tkEnumeration,
    {$else}
    tkEnumeration:
      if PropType^=TypeInfo(boolean) then
        Dest := boolean(GetOrdProp(Instance,@self)) else
        Dest := GetOrdProp(Instance,@self);
    {$endif}
    tkInteger, tkSet:
      Dest := GetOrdProp(Instance,@self);
    tkChar:
      Dest := AnsiChar(GetOrdProp(Instance,@self));
    tkWChar:
      Dest := WideChar(GetOrdProp(Instance,@self));
    tkInt64{$ifdef FPC}, tkQWord{$endif}: // works also with TTimeLog
      Dest := GetInt64Prop(Instance,pointer(@self));
    tkFloat:
    if PropType^=TypeInfo(Currency) then begin
      V64 := GetInt64Prop(Instance,pointer(@self));
      Dest := PCurrency(@V64)^;
    end else
      Dest := GetFloatProp(Instance,pointer(@self));
{$ifdef FPC}tkAString,{$endif} tkLString:
      Dest := UTF8ToString(GetLongStrValue(Instance));
    {$ifdef UNICODE}
    tkUString:
      Dest := GetUnicodeStrProp(Instance,pointer(@self));
    {$endif}
    tkDynArray:
      DynArrayToVariant(Dest,GetFieldAddr(Instance),PropType^);
    tkClass: // TSQLRecord field value is pointer(RecordID), not any Instance
      if PropType^^.ClassSQLFieldType=sftID then
        Dest := GetOrdProp(Instance,pointer(@self)) else // get RowID
        VarClear(Dest);
    {$ifdef USEVARIANTS}
    tkVariant:
      Dest := PVariant(GetFieldAddr(Instance))^;
    {$endif}
    else
      VarClear(Dest);
  end;
end;

procedure TPropInfo.SetVariant(Instance: TObject; const Source: Variant);
begin
  if @self<>nil then
  case PropType^^.Kind of
  tkDynArray:
    DynArrayFromVariant(PPointer(GetFieldAddr(Instance))^,Source,PropType);
  {$ifdef USEVARIANTS}
  tkVariant:
    PVariant(GetFieldAddr(Instance))^ := Source;
  {$endif}
  else
    SetValue(Instance,pointer(VariantToUtf8(Source)));
  end;
end;
{$endif}

function TPropInfo.GetValue(Instance: TObject; ToSQL: boolean; wasSQLString: PBoolean=nil): RawUTF8;
begin
  GetValueVar(Instance,ToSQL,result,wasSQLString);
end;

procedure TPropInfo.GetValueVar(Instance: TObject; ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
var w: WideChar;
    V: double; // we force Double precision value, as SQLite3 does
label Int, Blob;
begin
  if wasSQLString<>nil then
    wasSQLString^ := false;
  if @self=nil then
    result := '' else
  case PropType^^.Kind of
    {$ifdef FPC}tkBool,{$endif}tkEnumeration:
      if not ToSQL and
         ({$ifdef FPC}PropType^^.Kind=tkBool{$else}PropType^=TypeInfo(boolean){$endif}) then
        result := JSON_BOOLEAN[boolean(GetOrdProp(Instance,@self))] else
        goto Int; // custom enumerations are stored as integer
    tkClass: // TSQLRecord field value is pointer(RecordID), not any Instance
      case PropType^^.ClassSQLFieldType of
        sftID:     goto Int;  // get pointer(RowID)
        sftObject: begin // serialize object as JSON UTF-8 TEXT
          result := ObjectToJSON(TObject(GetOrdProp(Instance,@self)));
          if wasSQLString<>nil then
            wasSQLString^ := true;
        end;
        else result := 'null';
      end;
    tkInteger, tkSet:
Int:  result := {$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(GetOrdProp(Instance,@self));
    tkChar, tkWChar: begin
      w := WideChar(GetOrdProp(Instance,@self));
      if ToSQL and (w=#0) then
        // 'null' and not #0 to avoid end of SQL text - JSON will escape #0
        result := 'null' else begin
        RawUnicodeToUtf8(@w,1,result);
        if wasSQLString<>nil then
          wasSQLString^ := true;
      end;
    end;
    tkInt64{$ifdef FPC}, tkQWord{$endif}: // works also with TTimeLog
      result := {$ifndef ENHANCEDRTL}Int64ToUtf8{$else}IntToStr{$endif}(
        GetInt64Prop(Instance,pointer(@self)));
    tkFloat:
    if PropType^=TypeInfo(Currency) then
      result := Curr64ToStr(GetInt64Prop(Instance,pointer(@self))) else begin
      V := GetFloatProp(Instance,pointer(@self));
      if PropType^=TypeInfo(TDateTime) then begin
        result := DateTimeToIso8601Text(V);
        if wasSQLString<>nil then
          wasSQLString^ := true;
      end else
        result := ExtendedToStr(V,DOUBLE_PRECISION);
    end;
{$ifdef FPC}tkAString,{$endif} tkLString: begin
      if PropType^=TypeInfo(TSQLRawBlob) then begin
        GetLongStrProp(Instance,pointer(@self),RawByteString(result));
Blob:   if result='' then
          result := 'null' else begin
          if ToSQL then
            // encode as BLOB literals (e.g. "X'53514C697465'")
            result := TSQLRawBlobToBlob(TSQLRawBlob(result)) else
            // JSON content is e.g. '\uFFF0base64encodedbinary'
            result := BinToBase64WithMagic(result);
          if wasSQLString<>nil then
            wasSQLString^ := true;
        end;
      end else
        // generic conversion into UTF-8 text
        result := GetLongStrValue(Instance);
      if wasSQLString<>nil then
        wasSQLString^ := true;
    end;
    {$ifdef UNICODE}
    tkUString: begin
      result := UnicodeStringToUtf8(GetUnicodeStrProp(Instance,pointer(@self)));
      if wasSQLString<>nil then
        wasSQLString^ := true;
    end;
    {$endif}
    tkDynArray: begin
      result := GetDynArray(Instance).SaveTo;
      goto Blob;
    end;
    {$ifdef PUBLISHRECORD}
    tkRecord: begin
      result := RecordSave(GetFieldAddr(Instance)^,PropType^);
      goto Blob;
    end;
    {$endif}
    {$ifdef USEVARIANTS}
    tkVariant: begin
      result := VariantToUTF8(PVariant(GetFieldAddr(Instance))^);
      if wasSQLString<>nil then
        wasSQLString^ := true;
    end;
    {$endif}
    else // note: tkString (shortstring) not handled
      result := 'null';
  end;
end;

function TPropInfo.GetFieldAddr(Instance: TObject): pointer;
begin
  if PropWrap(GetProc).Kind<>$FF then
    // getter method -> check setter
    if PropWrap(SetProc).Kind<>$FF then
       // both are methods -> returns nil
      result := nil else
      //  field - Setter is the field offset in the instance data
      result := Pointer(PtrInt(Instance)+SetProc and $00FFFFFF) else
    // field - Getter is the field offset in the instance data
    result := Pointer(PtrInt(Instance)+GetProc and $00FFFFFF);
end;

function TPropInfo.SetFieldAddr(Instance: TObject): pointer;
begin
  if PropWrap(SetProc).Kind<>$FF then
    // setter method -> check getter
    if PropWrap(GetProc).Kind<>$FF then
       // both are methods -> returns nil
      result := nil else
      //  field - Getter is the field offset in the instance data
      result := Pointer(PtrInt(Instance)+GetProc and $00FFFFFF) else
    // field - Getter is the field offset in the instance data
    result := Pointer(PtrInt(Instance)+SetProc and $00FFFFFF);
end;

function TPropInfo.IsBlob: boolean;
begin
  if @self=nil then
    result := false else
  with PropType^^ do
    result := (Kind in [{$ifdef FPC}tkAString,{$endif}tkLString]) and
      (PropType^=TypeInfo(TSQLRawBlob));
end;

function TPropInfo.IsSimpleField: boolean;
begin
  result := (@self<>nil) and not(PropType^^.SQLFieldType in NOT_SIMPLE_FIELDS);
end;

function TPropInfo.IsStored(Instance: TObject): boolean;
type // function(Instance: TObject) trick does not work with CPU64 :(
  TStoredProc = function: Boolean of object;
var Call: TMethod;
begin
{$ifdef FPC} // extracted from IsStoredProp() function in typinfo.pp
  result := ((PropProcs shr 4) and 3=ptconst) and LongBool(StoredProc);
{$else}      // Delphi version
  if (StoredProc and (not PtrInt($ff)))=0 then
    result := boolean(StoredProc) else
  if Instance=nil then
    // field or method without Instance specified -> assume "stored true"
    result := true else
  if PropWrap(StoredProc).Kind=$ff then
    result := PBoolean(PtrInt(Instance)+StoredProc and $00FFFFFF)^ else begin
    if PropWrap(StoredProc).Kind=$fe then
      Call.Code := pointer((PPtrUInt(PPtrInt(Instance)^+SmallInt(StoredProc))^)) else
      Call.Code := pointer(StoredProc);
    Call.Data := Instance;
    result := TStoredProc(Call);
  end;
{$endif}
end;

{$ifdef FPC}

// extracted from typeinfo.pp
function aligntoptr(p : pointer): pointer; inline;
begin
{$ifdef FPC_REQUIRES_PROPER_ALIGNMENT}
   result := align(p,sizeof(p));
{$else FPC_REQUIRES_PROPER_ALIGNMENT}
   result := p;
{$endif FPC_REQUIRES_PROPER_ALIGNMENT}
end;

function TPropInfo.Next: PPropInfo;
begin
  result := aligntoptr(@Name[ord(Name[0])+1]);
end;
{$else}
{$ifdef HASINLINE}
function TPropInfo.Next: PPropInfo;
begin
  result := @Name[ord(Name[0])+1];
end;
{$else}
{$ifdef PUREPASCAL}
function TPropInfo.Next: PPropInfo;
begin
  result := @Name[ord(Name[0])+1];
end;
{$else}
function TPropInfo.Next: PPropInfo;
asm // very fast code
  movzx edx,byte ptr [eax].TPropInfo.Name
  lea eax,[eax+edx].TPropInfo.Name[1]
end;
{$endif}
{$endif}
{$endif}

procedure TPropInfo.SetValue(Instance: TObject; Value: PUTF8Char);
var V: Extended;
    Error: integer;
    ObjValid: boolean;
    I: integer;
begin
  if @self<>nil then
  case PropType^^.Kind of
    tkInteger, tkSet:
      SetOrdProp(Instance,pointer(@self),GetInteger(Value));
    {$ifdef FPC}tkBool,{$endif}tkEnumeration:
    if Value=nil then 
      SetOrdProp(Instance,pointer(@self),0) else begin
      I := GetInteger(pointer(Value),Error);
      with PropType^^.EnumBaseType^ do begin
        if Error<>0 then // we allow a value stated as text
          if {$ifdef FPC}PropType^^.Kind=tkBool{$else}PropType^=TypeInfo(boolean){$endif} then
            I := GetEnumNameValue(Value) else   // 'true' or 'false'
            I := GetEnumNameTrimedValue(Value); // -> convert into integer
        if cardinal(I)>cardinal(MaxValue) then
          I := 0;  // only set a valid value
        SetOrdProp(Instance,pointer(@self),I);
      end;
    end;
    tkChar, tkWChar:
      if (Value<>nil) and (PInteger(Value)^=NULL_LOW) then
        SetOrdProp(Instance,pointer(@self),0) else // ToSQL -> 'null' and not #0
        SetOrdProp(Instance,pointer(@self),GetUTF8Char(Value));
    tkInt64{$ifdef FPC}, tkQWord{$endif}: // works also with TTimeLog
      SetInt64Prop(Instance,pointer(@self),GetInt64(Value));
    tkFloat: begin
      if Value=nil then
        V := 0 else
        if PropType^=TypeInfo(Currency) then begin
          SetInt64Prop(Instance,pointer(@self),StrToCurr64(Value)); // fast conversion
          exit;
        end else
        if PropType^=TypeInfo(TDateTime) then
          V := Iso8601ToDateTimePUTF8Char(Value,0) else begin
{$ifdef ENHANCEDRTL}
          val(Value,V,Error);
{$else}   V := GetExtended(pointer(Value),Error);
{$endif}  if Error<>0 then
            V := 0;
        end;
      SetFloatProp(Instance,pointer(@self),V);
    end;
    {$ifdef FPC}tkAString,{$endif}
    tkLString:
      SetLongStrValue(Instance,RawUTF8(Value));
    {$ifdef UNICODE}
    tkUString: // fast UTF-8 decoding
      SetUnicodeStrProp(Instance,pointer(@self),UTF8DecodeToUnicodeString(Value,StrLen(Value)));
    {$endif}
    tkDynArray:
      GetDynArray(Instance).LoadFrom(pointer(BlobToTSQLRawBlob(Value)));
    {$ifdef PUBLISHRECORD}
    tkRecord:
      RecordLoad(GetFieldAddr(Instance)^,pointer(BlobToTSQLRawBlob(Value)),PropType^);
    {$endif}
    {$ifdef USEVARIANTS}
    tkVariant: // wasString=false -> try as number, otherwise store as text
      GetVariantFromJSON(Value,false,PVariant(GetFieldAddr(Instance))^);
    {$endif}
    // note: tkString (shortstring) and tkWString (WideString) not handled
    tkClass: // TSQLRecord field value is pointer(RecordID), not any Instance
      case PropType^^.ClassSQLFieldType of
      sftID: // set pointer(RowID)
        SetOrdProp(Instance,pointer(@self),GetInteger(Value));
      sftObject:
        JSONToObject(Instance,pointer(Value),ObjValid);
      end;
  end;
end;
                     
procedure TPropInfo.AppendName(var Text: RawUTF8; const Optional: RawUTF8='');
var L, L2, LOptional: PtrUInt;
begin
  L := PtrUInt(Text);
  if L<>0 then
    L := pInteger(L-4)^; // L := length(Text)
  L2 := L+ord(Name[0]);
  LOptional := length(Optional);
  SetLength(Text,L2+LOptional);
  move(Name[1],pointer(PtrUInt(Text)+L)^,ord(Name[0]));
  if LOptional<>0 then
    Move(pointer(Optional)^,PAnsiChar(PtrUInt(Text)+L2)^,LOptional);
end;

function TPropInfo.GetCaption: string;
var Tmp: array[byte] of AnsiChar;
    L: integer;
begin // GetCaptionFromPCharLen() expects ASCIIz -> use tmp[] buffer
  L := ord(Name[0]);
  Tmp[L] := #0;
  move(Name[1],Tmp[0],L);
  GetCaptionFromPCharLen(Tmp,result);
end;


{ TTypeInfo }

{$ifdef FPC}
function TTypeInfo.ClassType: PClassType;
begin // FPC can use memory alignment -> use GetTypeData() function
  if pointer(@self)<>nil then
    result := pointer(GetTypeData(pointer(@self))) else // use typinfo.pp function
    result := nil; // avoid GPF
end;
{$else}
{$ifdef PUREPASCAL}
function TTypeInfo.ClassType: PClassType;
begin
  result := @Name[ord(Name[0])+1];
end;
{$else}
function TTypeInfo.ClassType: PClassType;
asm // very fast code
  movzx edx,byte ptr [eax].TTypeInfo.Name
  lea eax,[eax+edx].TTypeInfo.Name[1]
end;
{$endif}
{$endif}

function TTypeInfo.ClassCreate: TObject;
begin
  result := ClassInstanceCreate(ClassType^.ClassType);
end;

{$ifdef FPC}
function TTypeInfo.RecordType: PRecordType; 
begin // FPC can use memory alignment -> use GetTypeData() function
  if pointer(@self)<>nil then
    result := pointer(GetTypeData(pointer(@self))) else // use typinfo.pp function
    result := nil; // avoid GPF
end;
{$else}
{$ifdef PUREPASCAL}
function TTypeInfo.RecordType: PRecordType;
begin
  result := @Name[ord(Name[0])+1];
end;
{$else}
function TTypeInfo.RecordType: PRecordType;
asm // very fast code
  movzx edx,byte ptr [eax].TTypeInfo.Name
  lea eax,[eax+edx].TTypeInfo.Name[1]
end;
{$endif}
{$endif}

function TTypeInfo.ClassSQLFieldType: TSQLFieldType;
var CT: PClassType;
begin
  {$ifdef FPC}
  CT := pointer(GetTypeData(pointer(@self))); // use typinfo.pp function
  {$else}
  CT := PClassType(@Name[ord(Name[0])+1]);
  {$endif}
  while true do // unrolled three InheritsFrom() calls
    if CT^.ClassType<>TSQLRecordMany then
    if CT^.ClassType<>TSQLRecord then
    if (CT^.ClassType<>TPersistent) and (CT^.ClassType<>TRawUTF8List) then
      if CT^.ParentInfo<>nil then
        {$ifdef FPC}
        CT := CT^.ParentInfo^^.ClassTypes // use typinfo.pp function
        {$else}
        with CT^.ParentInfo^^ do
          CT := @Name[ord(Name[0])+1] // get parent ClassType
        {$endif}
      else break
    else begin
      result := sftObject; // published properties, TStrings TRawUTF8List TCollection
      exit;
    end else begin
      result := sftID; // TSQLRecord field value is pointer(RecordID), not any Instance
      exit;
    end else begin
      result := sftMany; // no data is stored here, but in a pivot table
      exit;
    end;
  result := sftUnknown;
end;

{$ifdef FPC}
function TTypeInfo.EnumBaseType: PEnumType;
begin // FPC can use memory alignment -> use GetTypeData() function
  result := pointer(GetTypeData(PEnumType(GetTypeData(pointer(@self)))^.BaseType^);
end;
{$else}
{$ifdef PUREPASCAL}
function TTypeInfo.EnumBaseType: PEnumType;
begin
  with PEnumType(@Name[ord(Name[0])+1])^.BaseType^^ do
    result := @Name[ord(Name[0])+1];
end;
{$else}
function TTypeInfo.EnumBaseType: PEnumType;
asm // very fast code
  movzx edx,byte ptr [eax].TTypeInfo.Name
  mov eax,[eax+edx].TTypeInfo.Name[1].TEnumType.BaseType
  mov eax,[eax]
  movzx edx,byte ptr [eax].TTypeInfo.Name
  lea eax,[eax+edx].TTypeInfo.Name[1]
end;
{$endif}
{$endif}

{$ifdef PUREPASCAL}
function TTypeInfo.InheritsFrom(AClass: TClass): boolean;
var CT: PClassType;
begin
  CT := ClassType;
  while CT<>nil do begin
    if CT^.ClassType=pointer(AClass) then begin
      result := true;
      exit;
    end;
    if CT^.ParentInfo=nil then
      break else
      CT := CT^.ParentInfo^.ClassType;
  end;
  result := false;
end;
{$else}
function TTypeInfo.InheritsFrom(AClass: TClass): boolean;
asm // eax=PClassType edx=AClass
@1:movzx ecx,byte ptr [eax].TTypeInfo.Name
   lea eax,[eax+ecx].TTypeInfo.Name[1]
   cmp edx,[eax].TClassType.ClassType
   jz @2
   mov eax,[eax].TClassType.ParentInfo
   or eax,eax
   jz @3 // no parent
   mov eax,[eax] // get parent type info
   jmp @1
@2:mov al,1
@3:
end;
{$endif}

function TTypeInfo.SQLFieldType: TSQLFieldType;
begin // very fast, thanks to the TypeInfo() compiler-generated function
  case Kind of
    tkInteger:
      if @self=TypeInfo(TRecordReference) then begin
        result := sftRecord;
        exit; // direct exit is faster in generated asm code (Delphi 7 at least)
      end else begin
        result := sftInteger;
        exit;
      end;
    tkInt64:
      if @self=TypeInfo(TCreateTime) then begin
        result := sftCreateTime;
        exit;
      end else
      if @self=TypeInfo(TModTime) then begin
        result := sftModTime;
        exit;
      end else
      if @self=TypeInfo(TTimeLog) then begin
        result := sftTimeLog;
        exit;
      end else begin
        result := sftInteger;
        exit;
      end;
    {$ifdef FPC}
    tkBool: begin
      result := sftBoolean;
      exit;
    end;
    {$endif}
    tkSet: begin
      result := sftSet;
      exit;
    end;
    tkEnumeration:
      {$ifndef FPC}
      if @self=TypeInfo(Boolean) then begin
        result := sftBoolean;
        exit;
      end else
      {$endif}
      begin
        result := sftEnumerate;
        exit;
      end;
    tkFloat:
      if @self=TypeInfo(Currency) then begin
        result := sftCurrency;
        exit;
      end else
      if @self=TypeInfo(TDateTime) then begin
        result := sftDateTime;
        exit;
      end else begin
        result := sftFloat;
        exit;
      end;
      {$ifdef FPC}tkAString,{$endif} tkLString:
      if (@self=TypeInfo(RawUTF8)) or (@self=TypeInfo(RawUnicode)) then begin
        result := sftUTF8Text;
        exit;
      end else
      if @self=TypeInfo(TSQLRawBlob) then begin
        result := sftBlob;
        exit;
      end else begin
        result := sftAnsiText;
        exit;
      end;
    {$ifdef UNICODE}tkUString,{$endif} tkChar, tkWChar, tkWString: begin
      result := sftUTF8Text;
      exit;
    end;
    tkDynArray: begin
      result := sftBlobDynArray;
      exit;
    end;
    {$ifdef PUBLISHRECORD}
    tkRecord: begin
      result := sftBlobRecord;
      exit;
    end;
    {$endif}
    {$ifdef USEVARIANTS}
    tkVariant: begin
      result := sftVariant;
      exit;
    end;
    {$endif}
    tkClass: begin
      result := ClassSQLFieldType;
      exit;
    end;
    // note: tkString (shortstring) not handled
    else begin
      result := sftUnknown;
      exit;
    end;
  end;
end;

{$ifdef FPC}
function TTypeInfo.FloatType: TFloatType;
type PFloatType = ^TFloatType;
begin // FPC can use memory alignment -> use GetTypeData() function
  result := PFloatType(GetTypeData(pointer(@self)))^; // use typinfo.pp function
end;
{$else}
function TTypeInfo.FloatType: TFloatType;
begin
  result := TFloatType(Name[ord(Name[0])+1]);
end;
{$endif}

{$ifdef FPC}
function TTypeInfo.OrdType: TOrdType;
type POrdType = ^TOrdType;
begin // FPC can use memory alignment -> use GetTypeData() function
  result := POrdType(GetTypeData(pointer(@self)))^; // use typinfo.pp function
end;
{$else}
function TTypeInfo.OrdType: TOrdType;
begin
  result := TOrdType(Name[ord(Name[0])+1]);
end;
{$endif}

{$ifdef FPC}
function TTypeInfo.SetEnumType: PEnumType;
begin // FPC can use memory alignment -> use GetTypeData() function
  result := PTypeInfo(GetTypeData(pointer(@self))^.CompType^).EnumBaseType;
end;
{$else}
function TTypeInfo.SetEnumType: PEnumType;
begin
  result := PPTypeInfo(PPointer(@Name[ord(Name[0])+(1+sizeof(TOrdType))])^)^.EnumBaseType;
end;
{$endif}


{ TClassProp }

function TClassProp.FieldCountWithParents: integer;
var aClassType: TClass;
    CP: PClassProp;
begin
  result := 0;
  if @self=nil then
    exit;
  aClassType := TClass(@self);
  repeat
    CP := InternalClassProp(aClassType);
    if CP=nil then
      break; // no RTTI information (e.g. reached TObject level)
    inc(result,CP^.PropCount);
    aClassType := aClassType.ClassParent;
  until aClassType=nil;
end;

function TClassProp.FieldProp(const PropName: shortstring): PPropInfo;
var i: integer;
begin
  if @self<>nil then begin
    result := @PropList;
    for i := 1 to PropCount do
      if IdemPropName(result^.Name,PropName) then
        exit else
        result := result^.Next;
  end;
  result := nil;
end;

{ TClassType }

{$ifdef FPC}
function TClassType.ClassProp: PClassProp;
begin
  if pointer(@self)<>nil then
    result := aligntoptr(@UnitName[ord(UnitName[0])+1]) else
    result := nil; // avoid GPF
end;
{$else}
function TClassType.ClassProp: PClassProp;
begin
  if pointer(@self)<>nil then
    result := pointer(@UnitName[ord(UnitName[0])+1]) else
    result := nil; // avoid GPF
end;
{$endif}

function TClassType.RTTISize: integer;
var C: PClassProp;
    P: PPropInfo;
    i: Integer;
begin
  result := 0;
  C := ClassProp;
  if C=nil then
    exit;
  P := @C^.PropList;
  for i := 1 to C^.PropCount do
    P := P^.Next;
  result := PtrUInt(P)-PtrUInt(@self);
end;

{$ifdef PUREPASCAL}
function TClassType.InheritsFrom(AClass: TClass): boolean;
var P: PPTypeInfo;
begin
  result := true;
  if ClassType=AClass then
    exit;
  P := ParentInfo;
  while P<>nil do
    with P^.ClassType^ do
    if ClassType=AClass then
      exit else
      P := ParentInfo;
  result := false;
end;
{$else}
function TClassType.InheritsFrom(AClass: TClass): boolean;
asm // eax=PClassType edx=AClass
    cmp [eax].TClassType.ClassType,edx
    jz @3
@2: mov eax,[eax].TClassType.ParentInfo
    or eax,eax
    jz @0
@1: mov eax,[eax]
    movzx ecx,byte ptr [eax].TTypeInfo.Name
    lea eax,[eax+ecx].TTypeInfo.Name[1]
    cmp edx,[eax].TClassType.ClassType
    jnz @2
@3: mov al,1
@0:
end;
{$endif}


{ TEnumType }

function TEnumType.GetEnumName(const Value): PShortString;
var Ordinal: integer;
begin
  if MaxValue<=255 then
    Ordinal := byte(Value) else
    Ordinal := word(Value);
  result := GetEnumNameOrd(Ordinal);
end;

function TEnumType.GetEnumNameOrd(Value: Integer): PShortString;
// note: FPC doesn't align NameList (cf. GetEnumName() function in typinfo.pp)
{$ifdef PUREPASCAL}
begin
  result := @NameList;
  if cardinal(Value)<=cardinal(MaxValue) then
    while Value>0 do begin
      dec(Value);
      inc(PtrUInt(result),ord(result^[0])+1);
    end else
    result := @NULL_SHORTSTRING;
end;
{$else}
asm // eax=PEnumType edx=Value
    cmp edx,[eax].TEnumType.MaxValue
    lea eax,[eax].TEnumType.NameList
    ja @z
    or edx,edx
    jz @2
    xor ecx,ecx
@1: mov cl,[eax]
    dec edx
    lea eax,[eax+ecx+1]
    jnz @1
@2: ret
@z: lea eax,NULL_SHORTSTRING
end;
{$endif}

function TEnumType.GetEnumNameValue(const EnumName: ShortString): Integer;
var P: PShortString;
begin
  P := @NameList;
  for result := 0 to MaxValue do
    if IdemPropName(EnumName,P^) then
      exit else
      inc(PtrUInt(P),ord(P^[0])+1); // next enumeration item
  result := -1;
end;

function TEnumType.GetEnumNameValue(Value: PUTF8Char): Integer;
var P: PShortString;
    L: integer;
begin
  P := @NameList;
  L := StrLen(Value);
  if L<>0 then
    for result := 0 to MaxValue do
      if IdemPropName(P^,Value,L) then
        exit else
        inc(PtrUInt(P),ord(P^[0])+1); // next enumeration item
  result := -1;
end;

{$ifdef HASINLINE}
function TEnumType.GetEnumNameTrimed(const Value): RawUTF8;
begin
  result := TrimLeftLowerCaseShort(GetEnumName(Value));
end;
{$else}
{$ifdef PUREPASCAL}
function TEnumType.GetEnumNameTrimed(const Value): RawUTF8;
begin
  result := TrimLeftLowerCaseShort(GetEnumName(Value));
end;
{$else}
function TEnumType.GetEnumNameTrimed(const Value): RawUTF8;
asm
  push ecx
  call TEnumType.GetEnumName
  pop edx
  jmp TrimLeftLowerCaseShort
end;
{$endif}
{$endif}

function TEnumType.GetCaption(const Value): string;
// GetCaptionFromPCharLen() expect ASCIIz -> use temp RawUTF8
begin
  GetCaptionFromPCharLen(pointer(GetEnumNameTrimed(Value)),result);
end;

procedure TEnumType.AddCaptionStrings(Strings: TStrings; UsedValuesBits: Pointer=nil);
var i, L: integer;
    Line: array[byte] of AnsiChar;
    P: PAnsiChar;
    V: PShortString;
    s: string;
begin
  if @self=nil then
    exit;
  {$ifndef LVCL}
  Strings.BeginUpdate;
  try
  {$endif}
    V := @NameList;
    for i := MinValue to MaxValue do begin
      if (UsedValuesBits=nil) or
         GetBit(UsedValuesBits^,i) then begin
        L := ord(V^[0]);
        P := @V^[1];
        while (L>0) and (P^ in ['a'..'z']) do begin // ignore left lowercase chars
          inc(P);
          dec(L);
        end;
        if L=0 then begin
          L := ord(V^[0]);
          P := @V^[1];
        end;
        Line[L] := #0; // GetCaptionFromPCharLen() expect it as ASCIIZ
        move(P^,Line,L);
        GetCaptionFromPCharLen(Line,s);
        Strings.AddObject(s,pointer(i));
      end;
      inc(PtrUInt(V),length(V^)+1);
    end;
  {$ifndef LVCL}
  finally
    Strings.EndUpdate;
  end;
  {$endif}
end;

function TEnumType.GetCaptionStrings(UsedValuesBits: Pointer=nil): string;
var List: TStringList;
begin
  List := TStringList.Create;
  try
    AddCaptionStrings(List,UsedValuesBits);
    result := List.Text;
  finally
    List.Free;
  end;
end;

function TEnumType.GetEnumNameTrimedValue(const EnumName: ShortString): Integer;
var P: PUTF8Char;
    L: integer;
    V: PShortString;
begin
  V := @NameList;
  for result := 0 to MaxValue do begin
    L := ord(V^[0]);
    P := @V^[1];
    while (L>0) and (P^ in ['a'..'z']) do begin  // ignore left lowercase chars
      inc(P);
      dec(L);
    end;
    if L=0 then begin // no uppercase in this enum value caption -> try whole
      if IdemPropName(EnumName,V^) then
        exit;
    end else // P^ points to the first uppercase char in this enum value caption
      if IdemPropName(EnumName,P,L) then
        exit;
    inc(PtrUInt(V),length(V^)+1);
  end;
  result := -1;
end;

function TEnumType.GetEnumNameTrimedValue(Value: PUTF8Char): Integer;
var EnumName: shortstring; // temporary string
begin
  if Value=nil then
    result := -1 else begin
    EnumName := Value;
    result := GetEnumNameTrimedValue(EnumName);
  end;
end;


{ TSQLRecordFill }

procedure TSQLRecordFill.AddMap(aRecord: TSQLRecord; aField: TSQLPropInfo;
  aIndex: integer);
begin
  if (self<>nil) and (aRecord<>nil) then
    if fTableMapCount<length(fTableMap) then
      with fTableMap[fTableMapCount] do begin
        Dest := aRecord;
        DestField := aField;
        TableIndex := aIndex;
        inc(fTableMapCount);
      end else
{$ifdef WITHLOG}
     SQLite3Log.Add.Log(sllError,'Exceeds fTableMap[] size',aRecord);
{$endif}
end;

procedure TSQLRecordFill.AddMap(aRecord: TSQLRecord; const aFieldName: RawUTF8;
  aIndex: integer);
var aFieldIndex: integer;
begin
  if (self<>nil) and (aRecord<>nil) then
    if IsRowID(pointer(aFieldName)) then
      AddMap(aRecord,nil,aIndex) else
      with aRecord.RecordProps do begin
        aFieldIndex := Fields.IndexByName(aFieldName);
        if aFieldIndex>=0 then begin // only map if column name is a valid field
          include(fTableMapFields,aFieldIndex);
          AddMap(aRecord,Fields.List[aFieldIndex],aIndex);
        end;
      end;
end;

destructor TSQLRecordFill.Destroy;
begin
  try
    UnMap; // release fTable instance if necessary
  finally
    inherited;
  end;
end;

function TSQLRecordFill.Fill(aRow: integer): Boolean;
begin
  if (self=nil) or (Table=nil) or (cardinal(aRow)>cardinal(Table.RowCount)) then
    Result := False else begin
    Fill(@Table.fResults[aRow*Table.FieldCount]);
    Result := True;
  end;
end;

function TSQLRecordFill.Fill(aRow: integer; aDest: TSQLRecord): Boolean;
begin
  if (self=nil) or (aDest=nil) or
     (Table=nil) or (cardinal(aRow)>cardinal(Table.RowCount)) then
    Result := False else begin
    Fill(@Table.fResults[aRow*Table.FieldCount],aDest);
    Result := True;
  end;
end;

procedure TSQLRecordFill.Fill(aTableRow: PPUtf8CharArray);
var f: integer;
begin
  if (self<>nil) and (aTableRow<>nil) then
    for f := 0 to fTableMapCount-1 do
      with fTableMap[f] do
        if DestField=nil then
          Dest.ID := GetInteger(aTableRow[TableIndex]) else
          DestField.SetValue(Dest,aTableRow[TableIndex],false);
end;

procedure TSQLRecordFill.Fill(aTableRow: PPUtf8CharArray; aDest: TSQLRecord);
var f: integer;
begin
  if (self<>nil) and (aTableRow<>nil) then
  for f := 0 to fTableMapCount-1 do
    with fTableMap[f] do
      if DestField=nil then
        aDest.ID := GetInteger(aTableRow[TableIndex]) else
        DestField.SetValue(aDest,aTableRow[TableIndex],false);
end;

procedure TSQLRecordFill.Map(aRecord: TSQLRecord; aTable: TSQLTable;
  aCheckTableName: TSQLCheckTableName);
var f: integer;
    ColumnName: PUTF8Char;
    FieldName: shortstring;
    Props: TSQLRecordProperties;
begin
  if (aTable=nil) or (aTable.fResults=nil) then // avoid any GPF
    exit;
  fTable := aTable;
  Props := aRecord.RecordProps;
  for f := 0 to aTable.FieldCount-1 do begin
    ColumnName := aTable.fResults[f];
    if aCheckTableName=ctnNoCheck then
      FieldName := ColumnName else
      if IdemPChar(ColumnName,pointer(Props.SQLTableNameUpperWithDot)) then
        FieldName := ColumnName+length(Props.SQLTableNameUpperWithDot) else
        if aCheckTableName=ctnMustExist then
          continue else
          FieldName := ColumnName;
    AddMap(aRecord,FieldName,f);
  end;
  fFillCurrentRow := 1; // point to first data row (0 is field names)
end;

procedure TSQLRecordFill.UnMap;
var i: integer;
begin
  if self=nil then
    exit;
  fTableMapCount := 0;
  fFillCurrentRow :=  0;
  // release TSQLRecordMany.fDestID^ instances set by TSQLRecord.FillPrepareMany()
  for i := 0 to high(fTableMapRecordManyInstances) do
  with fTableMapRecordManyInstances[i] do begin
    TObject(fDestID^).Free;
    fDestID^ := 0;
    fSourceID^ := 0;
  end;
  SetLength(fTableMapRecordManyInstances,0);
  FillChar(fTableMapFields,sizeof(fTableMapFields),0);
  SetLength(fTableMapFieldsColNames,0);
  // free any previous fTable if necessary
  if Table<>nil then
  try
    if Table.OwnerMustFree then
      Table.Free;
  finally
    fTable := nil;
  end;
end;

procedure TSQLRecordFill.SetMappedFieldsExpandedJSONWriter(aClass: TSQLRecordClass;
  W: TJSONWriter);
var i,n: integer;
begin // update ID, TModTime and FillPrepare mapped fields
  if (self=nil) or (W=nil) or (aClass=nil) then
    exit;
  if fTableMapRecordManyInstances<>nil then
    raise EBusinessLayerException.Create('SetMappedFieldsExpandedJSONWriter after FillPrepareMany');
  if fTableMapFieldsColNames=nil then
  with aClass.RecordProps do begin // init fTableMapFields[Max,ColNames] from mapping
    n := 1;
    for i := 0 to Fields.Count-1 do
      if Fields.List[i].SQLFieldType=sftModTime then begin
        Include(fTableMapFields,i);
        inc(n);
      end else
      if i in fTableMapFields then
        inc(n);
    SetLength(fTableMapFieldsColNames,n);
    fTableMapFieldsColNames[0] := '"RowID":';
    n := 1;
    for i := 0 to Fields.Count-1 do
      if i in fTableMapFields then begin // as in TJSONWriter.AddColumns
        fTableMapFieldsColNames[n] := '"'+Fields.List[i].fName+'":';
        fTableMapFieldsMax := i;
        inc(n);
      end;
    assert(length(fTableMapFieldsColNames)=n);
  end;
  W.Expand := true;
  W.WithID := true;
  W.FieldMax := fTableMapFieldsMax;
  W.Fields := fTableMapFields;
  W.ColNames := fTableMapFieldsColNames;
end;


{ TSQLRecord }

constructor TSQLRecord.Create;
var i: integer;
begin
  // auto-instanciate any TSQLRecordMany instance
  with RecordProps do
    if pointer(ManyFields)<>nil then
    for i := 0 to high(ManyFields) do
      ManyFields[i].SetInstance(self,TSQLRecordClass(ManyFields[i].ObjectClass).Create);
end;

function TSQLRecord.CreateCopy: TSQLRecord;
var i: integer;
begin
  // create new instance
  if self=nil then begin
    result := nil;
    exit;
  end;
  result := RecordClass.Create;
  // copy properties content
  result.fID := fID;
  with RecordProps do
    for i := 0 to Fields.Count-1 do
    with Fields.List[i] do
    if SQLFieldType in COPIABLE_FIELDS then
      CopyValue(self,Result);
end;

constructor TSQLRecord.Create(aClient: TSQLRest; aID: integer; ForUpdate: boolean=false);
begin
  Create;
  if aClient<>nil then
    aClient.Retrieve(aID,self,ForUpdate);
end;

constructor TSQLRecord.Create(aClient: TSQLRest; aPublishedRecord: TSQLRecord; ForUpdate: boolean);
begin
  Create;
  if aClient<>nil then
    aClient.Retrieve(aPublishedRecord.ID,self,ForUpdate);
end;

constructor TSQLRecord.Create(aClient: TSQLRest; const aSQLWhere: RawUTF8);
begin
  Create;
  if aClient<>nil then
    aClient.Retrieve(aSQLWhere,self);
end;

constructor TSQLRecord.Create(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
  const BoundsSQLWhere: array of const);
begin
  Create;
  if aClient<>nil then
    aClient.Retrieve(FormatUTF8(FormatSQLWhere,[],BoundsSQLWhere),self);
end;

constructor TSQLRecord.Create(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
  const ParamsSQLWhere, BoundsSQLWhere: array of const);
begin
  Create;
  if aClient<>nil then
    aClient.Retrieve(FormatUTF8(FormatSQLWhere,ParamsSQLWhere,BoundsSQLWhere),self);
end;

class procedure TSQLRecord.InitializeTable(Server: TSQLRestServer; const FieldName: RawUTF8);
var f: integer;
begin // is not part of TSQLRecordProperties because has been declared as virtual
  if (self<>nil) and (Server<>nil) then
  with RecordProps do
  for f := 0 to Fields.Count-1 do
    with Fields.List[f] do
    if SQLFieldType in [sftRecord, sftID] then
      if (Name='') or IdemPropNameU(FieldName,Name) then
          Server.CreateSQLIndex(self,Name,false);
end;

procedure TSQLRecord.FillFrom(aRecord: TSQLRecord);
var i, f: integer;
    S, D: TSQLRecordProperties;
begin
  if (self=nil) or (aRecord=nil) or not InheritsFrom(aRecord.ClassType) then
    exit;
  if PSQLRecordClass(aRecord)^=PSQLRecordClass(Self)^ then
    fID := aRecord.fID;
  S := aRecord.RecordProps;
  D := RecordProps;
  for i := 0 to S.Fields.Count-1 do
  with S.Fields.List[i] do
  if SQLFieldType in COPIABLE_FIELDS then
    for f := 0 to D.Fields.Count-1 do
      if IdemPropNameU(D.Fields.List[f].Name,Name) then begin
        CopyValue(aRecord,Self);
        break;
      end;
end;

procedure TSQLRecord.FillFrom(Table: TSQLTable; Row: integer);
begin
  try
    FillPrepare(Table);
    if Table.InternalState<>fInternalState then
      fInternalState := Table.InternalState;
    FillRow(Row);
  finally
    FillClose; // avoid GPF in TSQLRecord.Destroy
  end;
end;

procedure TSQLRecord.FillFrom(const JSONTable: RawUTF8; Row: integer);
var Table: TSQLTableJSON;
    PrivateCopy: RawUTF8;
begin
  PrivateCopy := JSONTable;
  Table := TSQLTableJSON.Create([],'',@PrivateCopy[1],length(PrivateCopy));
  try
    FillFrom(Table,Row);
  finally
    Table.Free;
  end;
end;

procedure TSQLRecord.FillFrom(const JSONRecord: RawUTF8);
var tmp: pointer; // FillFrom() modifies the buffer memory: work on a copy
    P: PUTF8Char;
    L: integer;
begin
  P := pointer(JSONRecord);
  if P<>nil then begin
    L := PInteger(P-4)^+1; // +1 for last #0
    getmem(tmp,L);
    try
      move(P^,tmp^,L); // make a working copy of the JSON text (including #1)
      FillFrom(tmp); // now we can safely call FillFrom()
    finally
      Freemem(tmp);
    end;
  end;
end;

procedure TSQLRecord.FillFrom(P: PUTF8Char);
(* two possible formats = first not expanded, 2nd is expanded (most usefull)
 {"fieldCount":9,"values":["ID","Int","Test","Unicode","Ansi","ValFloat","ValWord",
  "ValDate","Next",0,0,"abcde+ef++","abcde+ef++","abcde+ef++",
  3.14159265300000E+0000,1203,"2009-03-10T21:19:36",0]}
 {"ID":0,"Int":0,"Test":"abcde+ef++","Unicode":"abcde+ef++","Ansi":
 "abcde+ef++","ValFloat": 3.14159265300000E+0000,"ValWord":1203,
 "ValDate":"2009-03-10T21:19:36","Next":0} *)
var F: array[0..MAX_SQLFIELDS-1] of PUTF8Char; // store field/property names
    wasString: boolean;
    i, n: integer;
    Prop, Value: PUTF8Char;
begin
  // go to start of object
  if P=nil then
    exit;
  while P^<>'{' do
    if P^=#0 then exit else inc(P);
  if Expect(P,FIELDCOUNT_PATTERN) then begin
    // not expanded format
    n := GetJSONIntegerVar(P)-1;
    if cardinal(n)>high(F) then
      exit;
    if Expect(P,ROWCOUNT_PATTERN) then
      GetJSONIntegerVar(P); // just ignore "rowCount":.. here
    if not Expect(P,VALUES_PATTERN) then
      exit;
    for i := 0 to n do
      F[i] := GetJSONField(P,P); // get field names
    for i := 0 to n do begin
      Value := GetJSONField(P,P,@wasString);
      FillValue(F[i],Value,wasString); // set properties from values
    end;
  end else
  if P^='{' then begin
    // expanded format
    inc(P);
    repeat
      Prop := GetJSONField(P,P);  // get field name
      if P=nil then break;
      Value := GetJSONField(P,P,@wasString); // get value
      FillValue(Prop,Value,wasString); // set property from value
    until P=nil;
  end;
end;

procedure TSQLRecord.FillPrepare(Table: TSQLTable; aCheckTableName: TSQLCheckTableName);
begin
  if self=nil then
    exit;
  if fFill=nil then
    fFill := TSQLRecordFill.Create else
    fFill.UnMap;
  fFill.Map(self,Table,aCheckTableName);
end;

function TSQLRecord.FillPrepare(aClient: TSQLRest; const aSQLWhere: RawUTF8;
  const aCustomFieldsCSV: RawUTF8; aCheckTableName: TSQLCheckTableName): boolean;
var T: TSQLTable;
begin
  result := false;
  FillClose; // so that no further FillOne will work
  if (self=nil) or (aClient=nil) then
    exit;
  if aCustomFieldsCSV='' then
    T := aClient.InternalListRecordsJSON(RecordClass,aSQLWhere) else
    T := aClient.InternalListJSON(RecordClass,aCustomFieldsCSV,aSQLWhere);
  if T=nil then
    exit;
  T.OwnerMustFree := true;
  FillPrepare(T,aCheckTableName);
  result := true;
end;

function TSQLRecord.FillPrepare(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
  const BoundsSQLWhere: array of const; const aCustomFieldsCSV: RawUTF8=''): boolean;
begin
  if (FormatSQLWhere=nil) or (high(BoundsSQLWhere)<0) then
    result := false else
    result := FillPrepare(aClient,FormatUTF8(FormatSQLWhere,[],BoundsSQLWhere),
      aCustomFieldsCSV);
end;

function TSQLRecord.FillPrepare(aClient: TSQLRest;
  FormatSQLWhere: PUTF8Char; const ParamsSQLWhere, BoundsSQLWhere: array of const;
  const aCustomFieldsCSV: RawUTF8): boolean;
begin
  if (FormatSQLWhere=nil) or ((high(ParamsSQLWhere)<0)and(high(BoundsSQLWhere)<0)) then
    result := false else
    result := FillPrepare(aClient,
      FormatUTF8(FormatSQLWhere,ParamsSQLWhere,BoundsSQLWhere),aCustomFieldsCSV);
end;

function TSQLRecord.FillPrepare(aClient: TSQLRest; const aIDs: TIntegerDynArray;
  const aCustomFieldsCSV: RawUTF8=''): boolean;
begin
  if aIDs=nil then
    result := false else
    result := FillPrepare(aClient,
      IntegerDynArrayToCSV(aIDs,length(aIDs),'ID in (',')'),aCustomFieldsCSV);
end;

procedure TSQLRecord.FillRow(aRow: integer; aDest: TSQLRecord=nil);
begin
  if self<>nil then
    if aDest=nil then
      fFill.Fill(aRow) else
      if fFill.fTableMapRecordManyInstances=nil then
        fFill.Fill(aRow,aDest) else
        raise EBusinessLayerException.Create('FillRow() forbidden after FillPrepareMany');
end;

function TSQLRecord.FillOne: boolean;
begin
  if (self=nil) or (fFill=nil) or (fFill.Table=nil) or
     (fFill.Table.RowCount=0) or // also check if FillTable is emtpy
     (cardinal(fFill.FillCurrentRow)>cardinal(fFill.Table.RowCount)) then
    result := false else begin
    FillRow(fFill.FillCurrentRow);
    inc(fFill.fFillCurrentRow);
    result := true;
  end;
end;

function TSQLRecord.FillRewind: boolean;
begin
  if (self=nil) or (fFill=nil) or (fFill.Table=nil) or (fFill.Table.RowCount=0) then
    result := false else begin
    fFill.fFillCurrentRow := 1;
    result := true;
  end;
end;

procedure TSQLRecord.FillClose;
begin
  if self<>nil then
    fFill.UnMap;
end;

procedure TSQLRecord.FillValue(PropName: PUTF8Char; Value: PUTF8Char; wasString: boolean);
var field: TSQLPropInfo;
begin
  if self<>nil then
    if IsRowID(pointer(PropName)) then
      fID := GetInteger(Value) else begin
      field := RecordProps.Fields.ByName(PropName);
      if field<>nil then
        field.SetValue(self,Value,wasString);
    end;
end;

function TSQLRecord.SetFieldVarDatas(const Values: TVarDataDynArray): boolean;
var max, field: integer;
begin
  result := false;
  max := high(Values);
  with RecordProps do begin
    // expect exact Values[] type match with FieldType[]
    if max<>Fields.Count-1 then // must match field count
      exit else
    for field := 0 to max do
      if SQLFieldTypeToVType[Fields.List[field].SQLFieldType]<>Values[field].VType then
        exit;
    // now we can safely update field values
    for field := 0 to max do
      Fields.List[field].SetFieldVarData(self,Values[field]);
  end;
  result := true;
end;

procedure TSQLRecord.GetBinaryValues(W: TFileBufferWriter);
var f: integer;
begin
  with RecordProps do
    for f := 0 to Fields.Count-1 do
      Fields.List[f].GetBinary(self,W);
end;

function TSQLRecord.SetBinaryValues(var P: PAnsiChar): boolean;
var f: integer;
begin
  result := false;
  with RecordProps do
    for f := 0 to Fields.Count-1 do begin
      P := Fields.List[f].SetBinary(self,P);
      if P=nil then
        exit;
    end;
  result := true;
end;

procedure TSQLRecord.GetJSONValues(W: TJSONSerializer);
var i,n: integer;
label txt,txt1;
begin
  if self=nil then
    exit;
  // write the row data
  if W.Expand then begin
    W.Add('{');
    if W.WithID then
      W.AddString(W.ColNames[0]);
  end;
  if W.WithID then begin
    W.Add(fID);
    W.Add(',');
    n := 1;
  end else
    n := 0;
  with RecordProps do
  for i := 0 to Fields.Count-1 do
    if i in W.Fields then begin
      if W.Expand then begin
        W.AddString(W.ColNames[n]); // '"'+ColNames[]+'":'
        inc(n);
      end;
      Fields.List[i].GetJSONValues(Self,W);
      W.Add(',');
    end;
  W.CancelLastComma; // cancel last ','
  if W.Expand then
    W.Add('}');
end;

procedure TSQLRecord.GetJSONValues(JSON: TStream; Expand: boolean; withID: boolean;
  Occasion: TSQLOccasion);
var W: TJSONSerializer;
begin
  if self=nil then
    exit;
  // get col names and types
  with RecordProps do
    W := CreateJSONWriter(JSON,Expand,withID,SimpleFieldsBits[Occasion],0);
  if W<>nil then
  try
    // write the row data
    GetJSONValues(W);
    // end the JSON object
    if not Expand then
      W.AddNoJSONEscape(PAnsiChar(']}'),2);
    W.Flush;
  finally
    W.Free;
  end;
end;

function TSQLRecord.GetJSONValues(Expand: boolean; withID: boolean;
  Occasion: TSQLOccasion; UsingStream: TCustomMemoryStream=nil): RawUTF8;
var J: TRawByteStringStream;
begin
  if (not withID) and IsZero(RecordProps.SimpleFieldsBits[Occasion]) then
    // no simple field to write -> quick return
    result := '' else
  if UsingStream<>nil then begin
    UsingStream.Seek(0,soFromBeginning);
    GetJSONValues(UsingStream,Expand,withID,Occasion);
    SetString(result,PAnsiChar(UsingStream.Memory),UsingStream.Seek(0,soFromCurrent));
  end else begin
    J := TRawByteStringStream.Create;
    try
      GetJSONValues(J,Expand,withID,Occasion);
      result := J.DataString;
    finally
      J.Free;
    end;
  end;
end;

function GetVirtualTableSQLCreate(Props: TSQLRecordProperties): RawUTF8;
var i: integer;
    SQL: RawUTF8;
begin
  result := ''; // RowID is added by sqlite3_declare_vtab() for a Virtual Table 
  for i := 0 to Props.Fields.Count-1 do
  with Props.Fields.List[i] do begin
    SQL := Props.SQLFieldTypeToSQL(i);
    if SQL<>'' then
      result := result+Name+SQL;
  end;
  if result='' then
    result := ');' else
    pWord(@result[length(result)-1])^ := ord(')')+ord(';')shl 8;
end;

class function TSQLRecord.GetSQLCreate(aModel: TSQLModel): RawUTF8;
// not implemented in TSQLRecordProperties since has been made virtual
var i: integer;
    SQL: RawUTF8;
    M: TSQLVirtualTableClass;
    Props: TSQLModelRecordProperties;
begin
  if aModel=nil then
    raise EModelException.Create('Invalid GetSQLCreate call');
  Props := aModel.Props[self];
  with Props.Props do
  if Props.Kind<>rSQLite3 then begin
    // create a FTS3/FTS4/RTREE virtual table
    result := 'CREATE VIRTUAL TABLE '+SQLTableName+' USING ';
    case Props.Kind of
    rFTS3:  result := result+'fts3(';
    rFTS4:  result := result+'fts4(';
    rRTree: result := result+'rtree(ID,';
    rCustomForcedID, rCustomAutoID: begin
      M := aModel.VirtualTableModule(self);
      if M=nil then
        raise EModelException.CreateFmt('No registered module for %s',[Table.ClassName]);
      if Fields.Count=0 then
        raise EModelException.CreateFmt(
          'Virtual %s class % should have published properties',[M.ModuleName,ClassName]);
      result := result+M.ModuleName+'('+GetVirtualTableSQLCreate(RecordProps);
    end;
    end;
    case Props.Kind of
    rFTS3, rFTS4: begin
      for i := 0 to Fields.Count-1 do
        with Fields.List[i] do
        if SQLFieldType<>sftUTF8Text then
          raise EModelException.CreateFmt('%s.%s: FTS3/FTS4 field must be RawUTF8',
            [SQLTableName,Name]) else
          result := result+Name+',';
      if InheritsFrom(TSQLRecordFTS3Porter) or
         InheritsFrom(TSQLRecordFTS4Porter) then
        result := result+' tokenize=porter)' else
        result := result+' tokenize=simple)';
    end;
    rRTree: begin
      if (Fields.Count<3) or (Fields.Count>RTREE_MAX_DIMENSION*2+1) or
         (Fields.Count and 2<>1) then
        raise EModelException.CreateFmt('%d: %s RTREE expects an odd 3..%d column number',
          [Fields.Count,SQLTableName,RTREE_MAX_DIMENSION*2+1]);
      for i := 0 to Fields.Count-1 do
        with Fields.List[i] do
        if SQLFieldType<>sftFloat then
          raise EModelException.CreateFmt('%s.%s: RTREE field must be double',
            [SQLTableName,Name]) else
          result := result+Name+',';
      result[length(result)] := ')';
    end;
    end;
  end else begin
    // inherits from TSQLRecord: create a "normal" SQLite3 table
    result := 'CREATE TABLE '+SQLTableName+
      '(ID INTEGER PRIMARY KEY AUTOINCREMENT, ';
    // we always add an ID field which is an INTEGER PRIMARY KEY
    // column, as it is always created (as hidden ROWID) by the SQLite3 engine
    for i := 0 to Fields.Count-1 do
    with Fields.List[i] do begin
      SQL := SQLFieldTypeToSQL(i);
      if SQL<>'' then begin
        result := result+Name+SQL;
        if i in IsUniqueFieldsBits then
          insert(' UNIQUE',result,length(result)-1);
      end;
    end;
    pWord(@result[length(result)-1])^ := ord(')')+ord(';')shl 8;
  end;
end;

function TSQLRecord.GetSQLSet: RawUTF8;
var i: integer;
    V: RawUTF8;
    wasString: boolean;
begin
  result := '';
  if self=nil then
    exit;
  with RecordProps do
    for i := 0 to High(SimpleFields) do
    with SimpleFields[i] do begin
      // format is 'COL1='VAL1', COL2='VAL2'' }
      GetValueVar(self,true,V,@wasString);
      if wasString then
        V := QuotedStr(V);
      result := result+Name+'='+V+', ';
    end;
  if result<>'' then
    SetLength(result,length(result)-2);
end;

function TSQLRecord.GetSQLValues: RawUTF8;
var i: integer;
    V: RawUTF8;
    wasString: boolean;
begin
  result := '';
  if self<>nil then
  with RecordProps do
    if SimpleFields=nil then
      exit else begin
    if HasNotSimpleFields then // get 'COL1,COL2': no 'ID,' for INSERT (false below)
      result := SQLTableSimpleFieldsNoRowID; // always <> '*'
    result := result+' VALUES (';
    for i := 0 to high(SimpleFields) do
    with SimpleFields[i] do begin
      GetValueVar(self,true,V,@wasString);
      if wasString then
        V := QuotedStr(V);
      result := result+V+',';
    end;
    result[length(result)] := ')';
  end;
end;

class function TSQLRecord.CaptionName(Action: PRawUTF8=nil; ForHint: boolean=false): string;
begin
  if Action=nil then
    GetCaptionFromPCharLen(pointer(RecordProps.SQLTableName),result) else
    GetCaptionFromPCharLen(TrimLeftLowerCase(Action^),result);
end;

class function TSQLRecord.CaptionNameFromRTTI(Action: PShortString): string;
var tmp: RawUTF8;
begin
  if Action=nil then
    result := CaptionName(nil) else begin
    SetString(tmp,PAnsiChar(@Action^[1]),ord(Action^[0]));
    result := CaptionName(@tmp);
  end;
end;

function TSQLRecord.SameValues(Reference: TSQLRecord): boolean;
var O: TSQLPropInfo;
    i: integer;
    This,Ref: TSQLRecordProperties;
begin
  result := false;
  if (self=nil) or (Reference=nil) or
     (Reference.fID<>fID) then // ID field must be tested by hand
    exit;
  if self<>Reference then
  if (PSQLRecordClass(Reference)^=PSQLRecordClass(self)^) then begin
    // faster comparison on same exact class
    with RecordProps do
    for i := 0 to high(SimpleFields) do
      // compare not TSQLRawBlob/TSQLRecordMany fields
      with SimpleFields[i] do
        if CompareValue(self,Reference,false)<>0 then
          exit; // properties don't have the same value
  end else begin
    // comparaison of all properties of Reference against self
    This := RecordProps;
    Ref := Reference.RecordProps;
    for i := 0 to high(Ref.SimpleFields) do
    with Ref.SimpleFields[i] do begin
      // compare not TSQLRawBlob/TSQLRecordMany fields
      O := This.Fields.ByRawUTF8Name(Name);
      if O=nil then
        exit; // this Reference property doesn't exist in current object
      if GetValue(Reference,false,nil)<>O.GetValue(self,false,nil) then
        exit; // properties don't have the same value
    end;
  end;
  result := true;
end;

function TSQLRecord.SameRecord(Reference: TSQLRecord): boolean;
var i: integer;
begin
  result := false;
  if (self=nil) or (Reference=nil) or
     (PSQLRecordClass(Reference)^<>PSQLRecordClass(Self)^) or (Reference.fID<>fID) then
    exit;
  with RecordProps do
    for i := 0 to high(SimpleFields) do
      // compare not TSQLRawBlob/TSQLRecordMany fields
      with SimpleFields[i] do
        if CompareValue(self,Reference,false)<>0 then
          exit; // properties don't have the same value
  result := true;
end;

procedure TSQLRecord.ClearProperties;
var i: integer;
begin
  if self=nil then
    exit;
  fInternalState := 0;
  fID := 0;
  with RecordProps do
    for i := 0 to Fields.Count-1 do
    with Fields.List[i] do
    if SQLFieldType in COPIABLE_FIELDS then
       SetValue(self,nil,false);
end;

{$IFDEF PUREPASCAL}
function TSQLRecord.RecordClass: TSQLRecordClass; 
begin
  if self=nil then
    Result := nil else
    Result := PSQLRecordClass(Self)^;
end;
{$else}
function TSQLRecord.RecordClass: TSQLRecordClass;
asm
  or eax,eax; jz @z
  mov eax,[eax]
@z:
end;
{$endif}              

{$IFDEF PUREPASCAL}
function TSQLRecord.ClassProp: PClassProp;
begin
  if self<>nil then
    result := InternalClassProp(PPointer(Self)^) else
    result := nil; // avoid GPF
end;
{$else}
function TSQLRecord.ClassProp: PClassProp;
asm
  or eax,eax; jz @z // avoid GPF
  mov eax,[eax] // get ClassType of this TSQLRecord instance
  or eax,eax; jz @z // avoid GPF
  mov eax,[eax+vmtTypeInfo]
  or eax,eax; jz @z // avoid GPF
  movzx edx,byte ptr [eax].TTypeInfo.Name
  lea eax,[eax+edx].TTypeInfo.Name[1]
  movzx edx,byte ptr [eax].TClassType.UnitName
  lea eax,[eax+edx].TClassType.UnitName[1].TClassProp
@z:
end;
{$endif}

function TSQLRecord.RecordReference(Model: TSQLModel): TRecordReference;
begin
  if (self=nil) or (fID<=0) then
    result := 0 else begin
    result := Model.GetTableIndexExisting(PSQLRecordClass(Self)^);
    if result>63 then // TRecordReference handle up to 64=1 shl 6 tables
      result := 0 else
      inc(result,fID shl 6);
  end;
end;

destructor TSQLRecord.Destroy;
var i: integer;
begin
  if fFill<>nil then
    fFill.Free; // call UnMap -> release fTable instance if necessary
  with RecordProps do
    // free all TSQLRecordMany instances created by TSQLRecord.Create
    if pointer(ManyFields)<>nil then
    for i := 0 to high(ManyFields) do
      ManyFields[i].GetInstance(self).Free;
  inherited;
end;

function TSQLRecord.SimplePropertiesFill(const aSimpleFields: array of const): boolean;
var i: integer;
    tmp: RawUTF8;
begin
  if self=nil then
    result := false else // means error
    with RecordProps do
    if length(SimpleFields)<>length(aSimpleFields) then
      result := false else begin
      for i := 0 to high(aSimpleFields) do begin
        VarRecToUTF8(aSimpleFields[i],tmp); // will work for every handled type
        SimpleFields[i].SetValue(self,pointer(tmp),false);
      end;
      result := True;
    end;
end;

constructor TSQLRecord.CreateAndFillPrepare(aClient: TSQLRest;
  const aSQLWhere: RawUTF8; const aCustomFieldsCSV: RawUTF8='');
var aTable: TSQLTable;
begin
  Create;
  if aCustomFieldsCSV='' then
    aTable := aClient.InternalListRecordsJSON(RecordClass,aSQLWhere) else
    aTable := aClient.InternalListJSON(RecordClass,aCustomFieldsCSV,aSQLWhere);
  if aTable=nil then
    exit;
  aTable.OwnerMustFree := true;
  FillPrepare(aTable);
end;

constructor TSQLRecord.CreateAndFillPrepare(aClient: TSQLRest;
  FormatSQLWhere: PUTF8Char; const BoundsSQLWhere: array of const;
  const aCustomFieldsCSV: RawUTF8='');
begin
  CreateAndFillPrepare(aClient,FormatUTF8(FormatSQLWhere,[],BoundsSQLWhere),
    aCustomFieldsCSV);
end;

constructor TSQLRecord.CreateAndFillPrepare(aClient: TSQLRest;
  FormatSQLWhere: PUTF8Char; const ParamsSQLWhere,
  BoundsSQLWhere: array of const; const aCustomFieldsCSV: RawUTF8);
begin
  CreateAndFillPrepare(aClient,
    FormatUTF8(FormatSQLWhere,ParamsSQLWhere,BoundsSQLWhere),aCustomFieldsCSV);
end;

constructor TSQLRecord.CreateAndFillPrepare(aClient: TSQLRest;
  const aIDs: TIntegerDynArray; const aCustomFieldsCSV: RawUTF8='');
begin
  Create;
  FillPrepare(aClient,aIDs,aCustomFieldsCSV);
end;

constructor TSQLRecord.CreateAndFillPrepare(const aJSON: RawUTF8);
var aTable: TSQLTable;
begin
  Create;
  aTable := TSQLTableJSON.Create([RecordClass],'',aJSON);
  aTable.OwnerMustFree := true;
  FillPrepare(aTable);
end;

constructor TSQLRecord.CreateAndFillPrepareMany(aClient: TSQLRest;
  aFormatSQLJoin: PUTF8Char; const aParamsSQLJoin, aBoundsSQLJoin: array of const);
begin
  Create;
  FillPrepareMany(aClient,aFormatSQLJoin,aParamsSQLJoin,aBoundsSQLJoin);
end;

function TSQLRecord.FillPrepareMany(aClient: TSQLRest;
  aFormatSQLJoin: PUTF8Char; const aParamsSQLJoin, aBoundsSQLJoin: array of const): boolean;
var aSQLFields, aSQLFrom, aSQLWhere, aSQL: RawUTF8;
    aField: string[3];
    aMany: RawUTF8;
    f, n, i, SQLFieldsCount: Integer;
    Props: TSQLRecordProperties;
    T: TSQLTable;
    SQLFields: array of record
      SQL: string[3];
      Prop: TSQLPropInfo;
      Instance: TSQLRecord;
    end;
    M: TSQLRecordMany;
    D: TSQLRecord;
    P: PUTF8Char;
    Objects: array of TSQLRecord;
    ObjectsClass: array of TSQLRecordClass;

  function AddField(aProp: TSQLPropInfo): Boolean;
  begin
    if SQLFieldsCount>=MAX_SQLFIELDS then
      result := false else
      with SQLFields[SQLFieldsCount] do begin
        SQL := aField;
        Prop := aProp;
        Instance := Objects[f];
        inc(SQLFieldsCount);
        result := true;
      end;
  end;
  function ProcessField(var P: PUTF8Char): RawUTF8;
  var B: PUTF8Char;
      field: TSQLPropInfo;
      i: integer;
      M: TSQLRecordMany;
      aManyField: string[63];
    function GetManyField(F: PUTF8Char): boolean;
    var B: PUTF8Char;
    begin
      result := true;
      B := F;
      while ord(F^) in IsIdentifier do inc(F); // go to end of sub-field name
      if B=F then begin
        result := false;
        exit;
      end;
      dec(B,2); // space for 'C.'
      SetString(aManyField,B,F-B);
      aManyField[2] := '.';
      P := F;
    end;
  begin
    B := P;
    while ord(P^) in IsIdentifier do inc(P); // go to end of field name
    SetString(result,B,P-B);
    if (result='') or IdemPropNameU(result,'AND') or IdemPropNameU(result,'OR') or
       IdemPropNameU(result,'LIKE') or IdemPropNameU(result,'NOT') or
       IdemPropNameU(result,'NULL') then
      exit;
    if not IsRowID(pointer(result)) then begin
      i := Props.Fields.IndexByName(result);
      if i<0 then
        exit;
      field := Props.Fields.List[i];
      if field.SQLFieldType=sftMany then begin
        M := TSQLPropInfoRTTIInstance(field).GetInstance(self) as TSQLRecordMany;
        assert(M<>nil);
        for i := 0 to n-1 do
        if Objects[i*2+1]=M then begin
          if IdemPChar(P,'.DEST.') then begin // special case of Many.Dest.*
            if GetManyField(P+6) then begin
              aManyField[1] := AnsiChar(i*2+67);
              result := RawUTF8(aManyField);
              exit; // Categories.Dest.Name=? -> C.Name=?
            end;
          end else
          if (P^='.') and GetManyField(P+1) then begin
            aManyField[1] := AnsiChar(i*2+66);
            result := RawUTF8(aManyField);
            exit;  // Categories.Kind=? -> CC.Kind=?
          end;
        end;
        exit;
      end;
    end;
    result := 'A.'+result; // Owner=? -> A.Owner=?
  end;

begin
  result := false;
  FillClose; // so that no further FillOne will work
  if (self=nil) or (aClient=nil) then
    exit;
  // reset TSQLRecordFill object
  if fFill=nil then
    fFill := TSQLRecordFill.Create else
    fFill.UnMap;
  // compute generic joined SQL statement and initialize Objects*[]+SQLFields[]
  SetLength(SQLFields,MAX_SQLFIELDS);
  Props := RecordProps;
  n := Length(Props.ManyFields);
  SetLength(Objects,n*2+1);
  SetLength(ObjectsClass,n*2+1);
  Objects[0] := self;
  ObjectsClass[0] := PSQLRecordClass(self)^;
  SetLength(fFill.fTableMapRecordManyInstances,n);  // fFill.UnMap will release memory
  for f := 0 to n-1 do begin
    M := TSQLRecordMany(Props.ManyFields[f].GetInstance(self));
    assert(M<>nil,'TSQLRecord.Create should have created TSQLRecordMany instances');
    fFill.fTableMapRecordManyInstances[f] := M;
    Objects[f*2+1] := M;
    ObjectsClass[f*2+1] := PSQLRecordClass(M)^;
    with M.RecordProps do begin
      Assert((fRecordManySourceProp.ObjectClass=PClass(self)^)
         and (fRecordManyDestProp.ObjectClass<>nil));
      ObjectsClass[f*2+2] := TSQLRecordClass(fRecordManyDestProp.ObjectClass);
      D := TSQLRecordClass(fRecordManyDestProp.ObjectClass).Create;
      // let TSQLRecordMany.Source and Dest point to real instances
      M.fSourceID^ := PtrInt(self);
      M.fDestID^ := PtrInt(D);
    end;
    Objects[f*2+2] := TSQLRecord(M.fDestID^);
    if Props.fSQLFillPrepareMany='' then begin
      aMany := AnsiChar(f*2+66); // Many=B,D,F...
      if aSQLWhere<>'' then
        aSQLWhere := aSQLWhere+' and ';
      aSQLWhere := FormatUTF8('%%.Source=A.RowID and %.Dest=%.RowID',
        [aSQLWhere,aMany,aMany,AnsiChar(f*2+67){Dest=C,E,G..}]);
    end;
  end;
  SQLFieldsCount := 0;
  aField := 'A00';
  for f := 0 to high(ObjectsClass) do
    with ObjectsClass[f].RecordProps do begin
      PWord(@aField[2])^ := ord('I')+ord('D')shl 8;
      if not AddField(nil) then
        Exit; // try to add the ID field
      if Props.fSQLFillPrepareMany='' then begin
        if aSQLFields<>'' then
          aSQLFields := aSQLFields+',';
          aSQLFields := FormatUTF8('%%.RowID %',[aSQLFields,aField[1],aField]);
      end;
      for i := 0 to high(SimpleFields) do
      with SimpleFields[i] do begin
        if (f and 1=0) {self/dest} or
           not(IdemPropNameU(Name,'SOURCE') or
               IdemPropNameU(Name,'DEST')) {many} then begin
          PWord(@aField[2])^ := TwoDigitLookupW[i];
          if not AddField(SimpleFields[i]) then
            Exit; // try to add this simple field
          if Props.fSQLFillPrepareMany='' then
            aSQLFields := FormatUTF8('%,%.% %',[aSQLFields,aField[1],Name,aField]);
        end;
      end;
      if Props.fSQLFillPrepareMany='' then begin
        if aSQLFrom<>'' then
          aSQLFrom := aSQLFrom+',';
        aSQLFrom := aSQLFrom+SQLTableName+' '+RawUTF8(aField[1]);
      end;
      inc(aField[1]);
    end;
  if Props.fSQLFillPrepareMany<>'' then
    aSQL := Props.fSQLFillPrepareMany else begin
    aSQL := FormatUTF8('select % from % where %',[aSQLFields,aSQLFrom,aSQLWhere]);
    Props.fSQLFillPrepareMany := aSQL;
  end;
  // process aFormatSQLJoin,aParamsSQLJoin and aBoundsSQLJoin parameters
  if aFormatSQLJoin<>nil then begin
    aSQLWhere := '';
    repeat
      P := aFormatSQLJoin;
      while not (ord(P^) in IsIdentifier) do begin
        case P^ of
        '"':  repeat inc(P) until P^ in [#0,'"'];
        '''': repeat inc(P) until P^ in [#0,''''];
        end;
        if P^=#0 then break;
        inc(P);
      end;
      if P<>aFormatSQLJoin then begin // append ' ',')'..
        SetString(aSQLFrom,aFormatSQLJoin,P-aFormatSQLJoin);
        aSQLWhere := aSQLWhere+aSQLFrom;
        aFormatSQLJoin := P;
      end;
      if P^=#0 then break;
      aSQLWhere := aSQLWhere+ProcessField(aFormatSQLJoin);
    until aFormatSQLJoin^=#0;
    aSQL := aSQL+' and ('+FormatUTF8(pointer(aSQLWhere),aParamsSQLJoin,aBoundsSQLJoin)+')';
  end;
  // execute SQL statement and retrieve data
  T := aClient.ExecuteList(ObjectsClass,aSQL);
  if (T=nil) or (T.fResults=nil) then
    exit;
  fFill.fTable := T;
  T.OwnerMustFree := true;
  // map fields
  assert(T.FieldCount=SQLFieldsCount);
  for i := 0 to SQLFieldsCount-1 do
    assert(IdemPropName(SQLFields[i].SQL,T.fResults[i],StrLen(T.fResults[i])));
  for i := 0 to SQLFieldsCount-1 do
    with SQLFields[i] do
      fFill.AddMap(Instance,Prop,i);
  fFill.fFillCurrentRow := 1; // point to first data row (0 is field names)
  result := true;
end;

function TSQLRecord.GetID: integer;
begin
  if PtrUInt(self)<PtrUInt(SystemInfo.lpMinimumApplicationAddress) then
    // was called from a TSQLRecord property (sftID type)
    // (will return 0 if current instance is nil)
    result := PtrUInt(self) else
    // was called from a real TSQLRecord instance
    result := fID;
end;

function TSQLRecord.GetIDAsPointer: pointer;
begin
  if PtrUInt(self)<PtrUInt(SystemInfo.lpMinimumApplicationAddress) then
    // was called from a TSQLRecord property (sftID type)
    // (will return 0 if current instance is nil)
    result := self else
    // was called from a real TSQLRecord instance
    {$ifdef CPU64}
    PtrInt(result) := fId;
    {$else}
    result := pointer(fID);
    {$endif}
end;

class procedure TSQLRecord.InternalRegisterCustomProperties(Props: TSQLRecordProperties);
begin
  // do nothing by default
end;

function TSQLRecord.GetHasBlob: boolean;
begin
  if Self=nil then
    result := false else
    result := RecordProps.BlobFields<>nil;
end;

function TSQLRecord.GetSimpleFieldCount: integer;
begin
  if Self=nil then
    result := 0 else
    result := length(RecordProps.SimpleFields);
end;

function TSQLRecord.GetFillCurrentRow: integer;
begin
  if (self=nil) or (fFill=nil) then
    result := 0 else
    result := fFill.FillCurrentRow;
end;

function TSQLRecord.GetTable: TSQLTable;
begin
  if (self=nil) or (fFill=nil) then
    result := nil else
    result := fFill.Table;
end;

function TSQLRecord.GetFieldValue(const PropName: RawUTF8): RawUTF8;
var P: TSQLPropInfo;
begin
  result := '';
  if self=nil then
    exit;
  P := RecordProps.Fields.ByName(pointer(PropName));
  if P<>nil then
    P.GetValueVar(self,False,result,nil);
end;

procedure TSQLRecord.SetFieldValue(const PropName: RawUTF8; Value: PUTF8Char);
var P: TSQLPropInfo;
begin
  if self=nil then
    exit;
  P := RecordProps.Fields.ByName(pointer(PropName));
  if P<>nil then
    P.SetValue(self,Value,false);
end;

{$ifdef USEVARIANTS}
function TSQLRecord.GetFieldVariant(const PropName: string): Variant;
var P: TSQLPropInfo;
begin
  if self=nil then
    P := nil else
    P := RecordProps.Fields.ByRawUTF8Name({$ifdef UNICODE}StringToUTF8{$endif}(PropName));
  if P=nil then
    VarClear(result) else
    P.GetVariant(self,result);
end;

procedure TSQLRecord.SetFieldVariant(const PropName: string;
  const Source: Variant);
var P: TSQLPropInfo;
begin
  if self=nil then
    P := nil else
    P := RecordProps.Fields.ByRawUTF8Name({$ifdef UNICODE}StringToUTF8{$endif}(PropName));
  if P<>nil then
    P.SetVariant(self,Source);
end;
{$endif}

function PropsCreate(aTable: TSQLRecordClass): TSQLRecordProperties;
var PVMT: pointer;
begin // private sub function makes the code faster in most case
  if not aTable.InheritsFrom(TSQLRecord) then
    // invalid call
    result := nil else begin
    // create the properties information from RTTI
    result := TSQLRecordProperties.Create(aTable);
    // store the TSQLRecordProperties instance into AutoTable unused VMT entry
    PVMT := pointer(PtrInt(aTable)+vmtAutoTable);
    if PPointer(PVMT)^<>nil then
      raise ESynException.CreateFmt('%s.AutoTable VMT entry already set',
        [PShortString(PPointer(PtrInt(aTable)+vmtClassName)^)^]);
    PatchCodePtrUInt(PVMT,PtrUInt(result),true); // LeaveUnprotected=true 
    // register to the internal garbage collection (avoid memory leak)
    GarbageCollectorFreeAndNil(PVMT^,result); // set to nil at finalization
  end;
end;

// since "var class" are not available in Delphi 6-7, and is inherited by
// the children classes under latest Delphi versions (i.e. the "var class" is
// shared by all inherited classes, whereas we want one var per class), we reused
// one of the unused magic VMT slots (i.e. the one for automated methods,
// AutoTable, a relic from Delphi 2 that is generally not used anymore) - see
// http://hallvards.blogspot.com/2007/05/hack17-virtual-class-variables-part-ii.html

{$ifdef PUREPASCAL}
class function TSQLRecord.RecordProps: TSQLRecordProperties;
begin
  if Self<>nil then begin
    result := PPointer(PtrInt(Self)+vmtAutoTable)^;
    if result=nil then
      result := PropsCreate(self);
  end else
    result := nil;
end;
{$else}
class function TSQLRecord.RecordProps: TSQLRecordProperties;
asm
  or eax,eax
  jz @null
  mov edx,[eax+vmtAutoTable]
  or edx,edx
  jz PropsCreate
  mov eax,edx
@null:
end;
{$endif}

function TSQLRecord.Filter(const aFields: TSQLFieldBits): boolean;
var f, i: integer;
    Value, Old: RawUTF8;
begin
  result := IsZero(aFields);
  if (self=nil) or result then
    // avoid GPF and handle case if no field was selected
    exit;
  with RecordProps do
  if Filters=nil then
    // no filter set yet -> process OK
    result := true else begin
    for f := 0 to Fields.Count-1 do
      if (Fields.List[f].SQLFieldType in COPIABLE_FIELDS) and
         (Filters[f]<>nil) then
        with Filters[f] do
        for i := 0 to Count-1 do
        if TSynFilterOrValidate(List[i]).InheritsFrom(TSynFilter) then begin
          Fields.List[f].GetValueVar(self,false,Value,nil);
          Old := Value;
          TSynFilter(List[i]).Process(f,Value);
          if Old<>Value then
            // value was changed -> store modified
            Fields.List[f].SetValue(self,pointer(Value),false);
        end;
  end;
end;

function TSQLRecord.Filter(const aFields: array of RawUTF8): boolean;
var F: TSQLFieldBits;
begin
  if RecordProps.FieldIndexsFromRawUTF8(aFields,F) then
    // must always call the virtual Filter() method
    result := Filter(F) else
    result := false;
end;

class function TSQLRecord.SQLTableName: RawUTF8;
begin
  if self=nil then
    result := '' else
    result := RecordProps.SQLTableName;
end;

class function TSQLRecord.AddFilterOrValidate(const aFieldName: RawUTF8;
  aFilter: TSynFilterOrValidate): TSynFilterOrValidate;
begin
  result := RecordProps.AddFilterOrValidate(aFieldName,aFilter);
end;

function TSQLRecord.Validate(aRest: TSQLRest; const aFields: TSQLFieldBits;
  aInvalidFieldIndex: PInteger): string;
var f, i: integer;
    Value: RawUTF8;
    Validate: TSynValidate;
    ValidateRest: TSynValidateRest absolute Validate;
begin
  result := '';
  if (self=nil) or IsZero(aFields) then
    // avoid GPF and handle case if no field was selected
    exit;
  with RecordProps do
  for f := 0 to Fields.Count-1 do
  if Fields.List[f].SQLFieldType in COPIABLE_FIELDS then begin
    if (Filters<>nil) and (Filters[f]<>nil) then
      for i := 0 to Filters[f].Count-1 do begin
        Validate := TSynValidate(Filters[f].List[i]);
        if Validate.InheritsFrom(TSynValidate) then begin
          if Value='' then
            Fields.List[f].GetValueVar(self,false,Value,nil);
          if Validate.InheritsFrom(TSynValidateRest) then begin
            // set additional parameters
            ValidateRest.fProcessRec := self;
            ValidateRest.fProcessRest := aRest;
          end;
          if not Validate.Process(f,Value,result) then begin
            // TSynValidate process failed -> notify caller
            if aInvalidFieldIndex<>nil then
              aInvalidFieldIndex^ := f;
            if result='' then
              // no custom message -> show a default message
              result := format(sValidationFailed,[
                GetCaptionFromClass(Validate.ClassType)]);
            exit;
          end;
        end;
      end;
    Value := '';
  end;
end;

function TSQLRecord.Validate(aRest: TSQLRest; const aFields: array of RawUTF8;
  aInvalidFieldIndex: PInteger=nil): string;
var F: TSQLFieldBits;
begin
  if RecordProps.FieldIndexsFromRawUTF8(aFields,F) then
    // must always call the virtual Validate() method
    result := Validate(aRest,F,aInvalidFieldIndex) else
    result := '';
end;

function TSQLRecord.DynArray(const DynArrayFieldName: RawUTF8): TDynArray;
var F: integer;
begin
  with RecordProps do
    for F := 0 to high(DynArrayFields) do
      with DynArrayFields[F] do
      if IdemPropNameU(Name,DynArrayFieldName) then begin
        result := GetDynArray(self);
        exit;
      end;
  result.Void;
end;

function TSQLRecord.DynArray(DynArrayFieldIndex: integer): TDynArray;
var F: integer;
begin
  if DynArrayFieldIndex>0 then
    with RecordProps do
      for F := 0 to high(DynArrayFields) do
        with DynArrayFields[F] do
        if DynArrayIndex=DynArrayFieldIndex then begin
          result := GetDynArray(self);
          exit;
        end;
  result.Void;
end;

procedure TSQLRecord.ComputeFieldsBeforeWrite(aRest: TSQLRest; aOccasion: TSQLEvent);
var F: integer;
    types: TSQLFieldTypes;
    TimeStamp: TTimeLog;
begin
  if (self<>nil) and (aRest<>nil) then
    with RecordProps do begin
      integer(types) := 0;
      if sftModTime in HasTypeFields then
        include(types,sftModTime);
      if (sftCreateTime in HasTypeFields) and (aOccasion=seAdd) then
        include(types,sftCreateTime);
      if integer(types)<>0 then begin
        TimeStamp := aRest.ServerTimeStamp;
        for F := 0 to Fields.Count-1 do
        with TSQLPropInfoRTTIInt64(Fields.List[f]) do
        if SQLFieldType in types then
          SetInt64Prop(Self,Pointer(fPropInfo),TimeStamp);
      end;
    end;
end;


{ TSQLModelRecordProperties }

constructor TSQLModelRecordProperties.Create(aModel: TSQLModel;
  aTable: TSQLRecordClass; aKind: TSQLRecordVirtualKind);
var f: integer;
begin
  fModel := aModel;
  fProps := aTable.RecordProps;
  SetKind(aKind);
  with Props do
  for f := 0 to Fields.Count-1 do
  with Fields.List[f] do begin
    // pre-computation of SQL statements
    SQL.UpdateSet[true] := SQL.UpdateSet[true]+Name+'=?,';
    SQL.InsertSet := SQL.InsertSet+Name+',';
    if f in SimpleFieldsBits[soUpdate] then
      SQL.UpdateSet[false] := SQL.UpdateSet[false]+Name+'=?,';
    // filter + validation of unique fields, i.e. if marked as "stored false"
    if f in IsUniqueFieldsBits then begin
      // must trim() text value before storage, and validate for unicity
      if SQLFieldType in [sftUTF8Text,sftAnsiText] then
        AddFilterOrValidate(f,TSynFilterTrim.Create);
      // register unique field pre-validation
      AddFilterOrValidate(f,TSynValidateUniqueField.Create);
    end;
  end;
  SetLength(SQL.InsertSet,length(SQL.InsertSet)-1);
  SetLength(SQL.UpdateSet[true],length(SQL.UpdateSet[true])-1); // 'COL1=?,COL2=?'
  if SQL.UpdateSet[false]<>'' then
    SetLength(SQL.UpdateSet[false],length(SQL.UpdateSet[false])-1); // 'COL1=?,COL2=?'
  Props.InternalRegisterModel(aModel,aModel.GetTableIndex(aTable),self);
end;

constructor TSQLModelRecordProperties.CreateFrom(aModel: TSQLModel;
  aSource: TSQLModelRecordProperties);
begin
  inherited Create;
  fModel := aModel;
  fProps := aSource.fProps;
  fKind := aSource.Kind;
  SQL := aSource.SQL;
  ExternalDatabase := aSource.ExternalDatabase;
  ExternalTableName := aSource.ExternalTableName;
  Props.InternalRegisterModel(fModel,fModel.GetTableIndex(fProps.Table),self);
end;

procedure TSQLModelRecordProperties.SetKind(Value: TSQLRecordVirtualKind);
function IntSQLTableSimpleFields(withID, withTableName: boolean): RawUTF8;
const IDComma: array[TSQLRecordVirtualKind] of rawUTF8 =
  ('ID,','RowID,','RowID,','ID,','RowID,','RowID,');
// rSQLite3, rFTS3, rFTS4, rRTree, rCustomForcedID, rCustomAutoID
var TableName: RawUTF8;
    i: integer;
begin
  if withTableName then
    TableName := Props.SQLTableName+'.'; // calc TableName once
  if withID then
    if withTableName then
      result := TableName+IDComma[Kind] else
      result := IDComma[Kind] else
    result := '';
  for i := 0 to high(Props.SimpleFields) do begin
    if withTableName then
      result := result+TableName;
    result := result+Props.SimpleFields[i].Name+','; // valid simple fields
  end;
  if result<>'' then
{  if (result='') or (withID and (result='ID,')) or
    ((Kind=rSQlite3) and not Props.HasNotSimpleFields) then // use RowID for Virtual Tables
    if withTableName then
      result := TableName+'*' else
      result := '*' else }
    SetLength(result,length(result)-1); // trim last ','
end;
begin
  fKind := Value;
  SQL.TableSimpleFields[false,false] := IntSQLTableSimpleFields(false,false);
  assert(Props.SQLTableSimpleFieldsNoRowID=SQL.TableSimpleFields[false,false]);
  SQL.TableSimpleFields[false,true] := IntSQLTableSimpleFields(false,true);
  SQL.TableSimpleFields[true,false] := IntSQLTableSimpleFields(true,false);
  SQL.TableSimpleFields[true,true] := IntSQLTableSimpleFields(true,true);
  SQL.SelectAll[false] := SQLFromSelectWhere('*','');
  SQL.SelectAll[true] := SQL.SelectAll[false];
  if IdemPChar(PUTF8Char(pointer(SQL.SelectAll[true]))+7,'ROWID') then
    delete(SQL.SelectAll[true],8,3); // 'SELECT RowID,..' -> 'SELECT ID,'
end;

function SQLFromSelect(Table: TSQLRecordClass;
  const SQLSelect, SQLWhere, SQLSimpleFields: RawUTF8): RawUTF8;
begin
  if SQLSelect='*' then
     // don't send BLOB values to query: retrieve all other fields
    result := 'SELECT '+SQLSimpleFields  else
    result := 'SELECT '+SQLSelect;
  result := result+' FROM '+Table.RecordProps.SQLTableName;
  if SQLWhere<>'' then
    if IdemPChar(pointer(SQLWhere),'ORDER BY ') or
       IdemPChar(pointer(SQLWhere),'GROUP BY ') or
       IdemPChar(pointer(SQLWhere),'LIMIT ') then
      result := result+' '+SQLWhere else
      result := result+' WHERE '+SQLWhere;
  result := result+';';
end;

function TSQLModelRecordProperties.SQLFromSelectWhere(const SQLSelect,
  SQLWhere: RawUTF8): RawUTF8;
begin
  result := SQLFromSelect(Props.Table,SQLSelect,SQLWhere,
    SQL.TableSimpleFields[true,false]);
end;


{ TSQLModel }

procedure TSQLModel.SetTableProps(aIndex: integer);
var i, f, R: integer;
    Kind: TSQLRecordVirtualKind;
    Table: TSQLRecordClass;
    Props: TSQLModelRecordProperties;
    Search: TClass;
begin
  assert((cardinal(aIndex)<=cardinal(fTablesMax)) and (fTableProps[aIndex]=nil));
  Table := fTables[aIndex];
  if Table.InheritsFrom(TSQLRecordFTS4) then
    Kind := rFTS4 else
  if Table.InheritsFrom(TSQLRecordFTS3) then
    Kind := rFTS3 else
  if Table.InheritsFrom(TSQLRecordVirtualTableForcedID) then
    Kind := rCustomForcedID else
  if Table.InheritsFrom(TSQLRecordVirtual) then
    Kind := rCustomAutoID else
    Kind := rSQLite3;
  Props := TSQLModelRecordProperties.Create(self,Table,Kind);
  Props.Props.InternalRegisterModel(Self,aIndex,Props);
  if fCustomCollationForAllRawUTF8<>'' then
    Props.Props.SetCustomCollationForAllRawUTF8(fCustomCollationForAllRawUTF8);
  fTableProps[aIndex] := Props;
  fSortedTablesName[aIndex] := Props.Props.SQLTableName;
  fSortedTablesNameIndex[aIndex] := aIndex;
  with Props.Props.Fields do
  for f := 0 to Count-1 do begin
    case List[f].SQLFieldType of
    sftRecord, sftID: begin
      R := length(fRecordReferences);
      SetLength(fRecordReferences,R+1);
      with fRecordReferences[R] do begin
        TableIndex := aIndex;
        FieldType := List[f] as TSQLPropInfoRTTIInstance;
      end;
    end;
    sftMany: begin
      Search := (List[f] as TSQLPropInfoRTTIMany).ObjectClass;
      for i := 0 to fTablesMax do // manual search:  GetTableIndex() may fail
        if fTables[i]=Search then begin
          Search := nil;
          break;
        end;
      if Search<>nil then
        raise EModelException.CreateFmt('%s must include %s for %s.%s',
          [ClassName,Search.ClassName,Tables[aIndex].ClassName,List[f].Name]);
    end;
    end;
  end;
end;

function TSQLModel.GetTableProps(aClass: TSQLRecordClass): TSQLModelRecordProperties;
begin
  result := fTableProps[GetTableIndexExisting(aClass)];
end;

function TSQLModel.AddTable(aTable: TSQLRecordClass; aTableIndexCreated: PInteger=nil): boolean;
var n: integer;
begin
  if GetTableIndex(aTable)>=0 then begin
    result := false;
    exit;
  end;
  inc(fTablesMax);
  n := fTablesMax+1;
  SetLength(fTables,n);
  SetLength(fSortedTablesName,n);
  SetLength(fSortedTablesNameIndex,n);
  SetLength(fTableProps,n);
  fTables[fTablesMax] := aTable;
  SetTableProps(fTablesMax);
  QuickSortRawUTF8(fSortedTablesName,fTablesMax+1,@fSortedTablesNameIndex,StrIComp);
  if aTableIndexCreated<>nil then
    aTableIndexCreated^ := fTablesMax;
  result := true;
end;

constructor TSQLModel.Create(CloneFrom: TSQLModel);
var i: integer;
begin
  if CloneFrom=nil then
    raise EModelException.Create('TSQLModel.Create(CloneFrom=nil)');
  fTables := CloneFrom.fTables;
  fTablesMax := CloneFrom.fTablesMax;
  fRoot := CloneFrom.fRoot;
  fActions := CloneFrom.fActions;
  fEvents := CloneFrom.fEvents;
  fRestOwner := CloneFrom.fRestOwner;
  fSortedTablesName := CloneFrom.fSortedTablesName;
  fSortedTablesNameIndex := CloneFrom.fSortedTablesNameIndex;
  fRecordReferences := CloneFrom.fRecordReferences;
  fVirtualTableModule := CloneFrom.fVirtualTableModule;
  fCustomCollationForAllRawUTF8 := CloneFrom.fCustomCollationForAllRawUTF8;
  SetLength(fTableProps,fTablesMax+1);
  for i := 0 to fTablesMax do
    fTableProps[i] := TSQLModelRecordProperties.CreateFrom(
      self,CloneFrom.fTableProps[i]);
end;

constructor TSQLModel.Create(Owner: TSQLRest; TabParameters: PSQLRibbonTabParameters;
  TabParametersCount, TabParametersSize: integer;
  const NonVisibleTables: array of TSQLRecordClass;
  Actions, Events: PTypeInfo; const aRoot: RawUTF8);
var i: integer;
    Tables: array of TSQLRecordClass;
begin
  if (TabParameters=nil) or (TabParametersCount<=0) or
     (cardinal(TabParametersSize)<sizeof(TSQLRibbonTabParameters)) then
    raise EModelException.Create('TSQLModel.Create(TabParameters?)');
  SetLength(Tables,TabParametersCount+length(NonVisibleTables));
  for i := 0 to TabParametersCount-1 do begin
    Tables[i] := TabParameters^.Table;
    inc(PtrUInt(TabParameters),TabParametersSize);
  end;
  for i := 0 to high(NonVisibleTables) do
    Tables[i+TabParametersCount] := NonVisibleTables[i];
  Create(Tables,aRoot);
  fRestOwner := Owner;
  SetActions(Actions);
  SetEvents(Events);
end;

constructor TSQLModel.Create(const Tables: array of TSQLRecordClass; const aRoot: RawUTF8);
var N, i: integer;
begin
  N := length(Tables);
  if N>sizeof(SUPERVISOR_ACCESS_RIGHTS.Get)*8 then // TSQLAccessRights bits size
    raise EModelException.CreateFmt('%s has too many Tables: %d>%d',
      [ClassName,N,sizeof(SUPERVISOR_ACCESS_RIGHTS.Get)*8]); // e.g. N>64
  // set the Tables to be associated with this Model, as TSQLRecord classes
  fTablesMax := N-1;
  SetLength(fTables,N);
  move(Tables[0],fTables[0],N*Sizeof(Tables[0]));
  SetLength(fSortedTablesName,N);
  SetLength(fSortedTablesNameIndex,N);
  SetLength(fTableProps,N);
  // initialize internal properties
  for i := 0 to fTablesMax do
    SetTableProps(i);
  QuickSortRawUTF8(fSortedTablesName,fTablesMax+1,@fSortedTablesNameIndex,StrIComp);
  // set the optional Root URI path of this Model
  if aRoot<>'' then
    if aRoot[length(aRoot)]='/' then
      fRoot := copy(aRoot,1,Length(aRoot)-1) else
      fRoot := aRoot;
end;

function TSQLModel.GetIsUnique(aTable: TSQLRecordClass; aFieldIndex: integer): boolean;
var i: integer;
begin
  i := GetTableIndex(aTable);
  if (i<0) or (Cardinal(aFieldIndex)>=MAX_SQLFIELDS) then
    Result := false else
    Result := aFieldIndex in TableProps[i].Props.IsUniqueFieldsBits;
end;

function TSQLModel.GetTableIndexFromSQLSelect(const SQL: RawUTF8;
  EnsureUniqueTableInFrom: boolean): integer;
var i,j,k: integer;
    TableName: RawUTF8;
begin
  i := PosI(' FROM ',SQL);
  if i>0 then begin
    inc(i,6);
    while SQL[i] in [#1..' '] do inc(i);
    j := 0;
    while ord(SQL[i+j]) in IsIdentifier do inc(j);
    if j>0 then begin
      k := i+j;
      while SQL[k] in [#1..' '] do inc(k);
      if (not EnsureUniqueTableInFrom) or (SQL[k]<>',') then begin 
        SetString(TableName,PAnsiChar(PtrInt(SQL)+i-1),j);
        result := GetTableIndex(TableName);
        exit;
      end;
    end;
  end;
  result := -1;
end;

function TSQLModel.GetTable(const SQLTableName: RawUTF8): TSQLRecordClass;
var i: integer;
begin
  i := GetTableIndex(SQLTableName);
  if i>=0 then
    result := Tables[i] else
    result := nil;
end;

function TSQLModel.GetTableExactClass(const TableName: RawUTF8): TSQLRecordClass;
var i: integer;
begin
  i := GetTableExactIndex(TableName);
  if i>=0 then
    result := Tables[i] else
    result := nil;
end;

function TSQLModel.GetTableIndex(aTable: TSQLRecordClass): integer;
var i: integer;
    Props: TSQLRecordProperties;
begin
  if (self<>nil) and (aTable<>nil) then begin
    Props := PPointer(PtrInt(aTable)+vmtAutoTable)^;
    if Props<>nil then
      // fastest O(1) search in all registered models
      for i := 0 to Props.fModelMax do
        if Props.fModel[i].Model=self then begin
          result := Props.fModel[i].TableIndex;
          exit;
        end;
    // manual search e.g. if fModel[] is not yet set
    for result := 0 to fTablesMax do
      if Tables[result]=aTable then
        exit;
  end;
  result := -1;
end;

function TSQLModel.GetTableIndexExisting(aTable: TSQLRecordClass): integer;
begin
  if aTable=nil then
    raise EModelException.Create('TSQLRecordClass=nil');
  result := GetTableIndex(aTable);
  if result<0 then
    raise EModelException.CreateFmt('Class %s missing in Model',
      [PShortString(PPointer(PtrInt(aTable)+vmtClassName)^)^]);
end;

function TSQLModel.GetTableExactIndex(const TableName: RawUTF8): integer;
var L: integer;
begin
  if self<>nil then begin
  L := length(TableName);
  for result := 0 to fTablesMax do
    if Tables[result]<>nil then // avoid GPF
    if IdemPropName(
       // new TObject.ClassName is UnicodeString (Delphi 20009) -> inline code with
       // vmtClassName = UTF-8 encoded text stored in a shortstring
       PShortString(PPointer(PtrInt(Tables[result])+vmtClassName)^)^,
       pointer(TableName),L) then
      exit;  // case insensitive search
  end;
  result := -1;
end;

function TSQLModel.GetTableIndex(const SQLTableName: RawUTF8): integer;
begin
  if (self<>nil) and (SQLTableName<>'') then begin
    // fast binary search
    result := FastFindPUTF8CharSorted(pointer(fSortedTablesName),fTablesMax,pointer(SQLTableName),StrIComp);
    if result>=0 then
      result := fSortedTablesNameIndex[result];
  end else
    result := -1;
end;

function TSQLModel.GetTableIndex(SQLTableName: PUTF8Char): integer;
begin
  if (self<>nil) and (SQLTableName<>nil) then begin
    // fast binary search
    result := FastFindPUTF8CharSorted(pointer(fSortedTablesName),fTablesMax,SQLTableName,StrIComp);
    if result>=0 then
      result := fSortedTablesNameIndex[result];
  end else
    result := -1;
end;

function TSQLModel.getURI(aTable: TSQLRecordClass): RawUTF8;
begin
  if (self<>nil) and (Root<>'') then
    result := Root+'/'+aTable.RecordProps.SQLTableName else
    result := aTable.RecordProps.SQLTableName;
end;

function TSQLModel.URIMatch(const URI: RawUTF8): boolean;
begin
  result := false;
  if (self=nil) or (fRoot='') or (URI='') then
    exit;
  if fRootUpper='' then
    UpperCaseCopy(fRoot,fRootUpper);
  if IdemPChar(pointer(URI),pointer(fRootUpper)) then
    if URI[length(fRootUpper)+1] in [#0,'/','?'] then
      result := true;
end;

function TSQLModel.SQLFromSelectWhere(const Tables: array of TSQLRecordClass;
   const SQLSelect, SQLWhere: RawUTF8): RawUTF8;
var i: integer;
    aProps: array[0..31] of TSQLModelRecordProperties;
begin
  if self=nil then
    raise EORMException.Create('Model required');
  if high(Tables)=0 then begin
    // fastest common call with one TSQLRecordClass
    result := Props[Tables[0]].SQLFromSelectWhere(SQLSelect,SQLWhere);
    exit;
  end;
  // 'SELECT T1.F1,T1.F2,T1.F3,T2.F1,T2.F2 FROM T1,T2 WHERE ..' e.g.
  if PtrUInt(high(Tables))>high(aProps) then
    raise EModelException.Create('SQLFromSelectWhere');
  for i := 0 to high(Tables) do
    aProps[i] := Props[Tables[i]]; // raise EModelException if not found
  if SQLSelect='*' then
     // don't send BLOB values to query: retrieve all other fields
    if high(Tables)=0 then
      result := 'SELECT '+aProps[0].SQL.TableSimpleFields[true,false] else begin
      result := 'SELECT '+aProps[0].SQL.TableSimpleFields[true,true];
      for i := 1 to high(Tables) do
        result := result+','+aProps[i].SQL.TableSimpleFields[true,true];
    end else
    result := 'SELECT '+SQLSelect;
  result := result+' FROM '+aProps[0].Props.SQLTableName;
  for i := 1 to high(Tables) do
    result := result+','+aProps[i].Props.SQLTableName;
  if SQLWhere<>'' then
    if IdemPChar(pointer(SQLWhere),'ORDER BY ') or
       IdemPChar(pointer(SQLWhere),'GROUP BY ') or
       IdemPChar(pointer(SQLWhere),'LIMIT ') then
      result := result+' '+SQLWhere else
      result := result+' WHERE '+SQLWhere;
  result := result+';';
end;

procedure TSQLModel.SetCustomCollationForAllRawUTF8(const aCollationName: RawUTF8);
var i: integer;
begin
  if self=nil then
    exit;
  if fCustomCollationForAllRawUTF8<>'' then
    raise EModelException.CreateFmt(
      'TSQLModel.SetCustomCollationForAllRawUTF8(%s) shall be called only once',
      [aCollationName]);
  fCustomCollationForAllRawUTF8 := aCollationName;
  for i := 0 to high(fTableProps) do
    fTableProps[i].fProps.SetCustomCollationForAllRawUTF8(aCollationName);
end;

function TSQLModel.NewRecord(const SQLTableName: RawUTF8): TSQLRecord;
var aClass: TSQLRecordClass;
begin
  aClass := Table[SQLTableName];
  if aClass=nil then
    result := nil else
    result := aClass.Create;
end;

procedure TSQLModel.SetActions(aActions: PTypeInfo);
begin
  if (aActions=nil) or not (aActions^.Kind=tkEnumeration) then
    fActions := nil else
    fActions := aActions^.EnumBaseType;
end;

procedure TSQLModel.SetEvents(aEvents: PTypeInfo);
begin
  if (aEvents=nil) or not (aEvents^.Kind=tkEnumeration) then
    fEvents := nil else
    fEvents := aEvents^.EnumBaseType;
end;

function TSQLModel.GetSQLCreate(aTableIndex: integer): RawUTF8;
begin
  if (self=nil) or (cardinal(aTableIndex)>cardinal(fTablesMax)) then
    result := '' else
    result := Tables[aTableIndex].GetSQLCreate(self);
end;

function TSQLModel.GetSQLAddField(aTableIndex, aFieldIndex: integer): RawUTF8;
begin
  if (self=nil) or (cardinal(aTableIndex)>cardinal(fTablesMax)) then
    result := '' else
    result := TableProps[aTableIndex].Props.SQLAddField(aFieldIndex);
end;

function TSQLModel.isLocked(aTable: TSQLRecordClass; aID: integer): boolean;
begin
  result := GetLocks(aTable)^.isLocked(aID);
end;

function TSQLModel.isLocked(aRec: TSQLRecord): boolean;
begin
  if aRec=nil then
    result := false else
    result := isLocked(PSQLRecordClass(aRec)^,aRec.fID);
end;

function TSQLModel.Lock(aTable: TSQLRecordClass; aID: integer): boolean;
begin
  if self=nil then
    result := false else begin
    if fLocks=nil then
      SetLength(fLocks,fTablesMax+1); // initialize fLocks[] if necessary
    result :=  GetLocks(aTable)^.Lock(aID);
  end;
end;

function TSQLModel.Lock(aTableIndex, aID: integer): boolean;
begin
  if (self=nil) or (Cardinal(aTableIndex)>cardinal(fTablesMax)) then
    result := false else begin
    if fLocks=nil then
      SetLength(fLocks,fTablesMax+1); // initialize fLocks[] if necessary
    result := fLocks[aTableIndex].Lock(aID);
  end;
end;

function TSQLModel.Lock(aRec: TSQLRecord): boolean;
begin
  if aRec=nil then
    result := false else
    result := Lock(PSQLRecordClass(aRec)^,aRec.fID);
end;

procedure TSQLModel.PurgeOlderThan(MinutesFromNow: cardinal);
var i: integer;
begin
  if fLocks<>nil then
    for i := 0 to high(fLocks) do
     fLocks[i].PurgeOlderThan(MinutesFromNow);
end;

function TSQLModel.UnLock(aTable: TSQLRecordClass; aID: integer): boolean;
begin
  if (self=nil) or (fLocks=nil) then
    result := false else
    result := GetLocks(aTable)^.UnLock(aID);
end;

function TSQLModel.UnLock(aTableIndex: integer; aID: integer): boolean;
begin
  if (self=nil) or (cardinal(aTableIndex)>=cardinal(length(fLocks))) then
    result := false else
    result := fLocks[aTableIndex].UnLock(aID);
end;

function TSQLModel.UnLock(aRec: TSQLRecord): boolean;
begin
  if aRec=nil then
    result := false else
    result := UnLock(PSQLRecordClass(aRec)^,aRec.fID);
end;

function TSQLModel.GetLocks(aTable: TSQLRecordClass): PSQLLocks;
begin
  if (self=nil) or (fLocks=nil) then
    result := nil else
    result := @fLocks[GetTableIndexExisting(aTable)];
end;

procedure TSQLModel.UnLockAll;
var i: integer;
begin
  for i := 0 to high(fLocks) do
    fLocks[i].Count := 0;
end;

function TSQLModel.getURIID(aTable: TSQLRecordClass; aID: integer): RawUTF8;
begin
  if self<>nil then
    if aTable=nil then
      result := Root else
      result := getURI(aTable) else
      result := '';
  if aID>0 then
    result := result+'/'+{$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(aID);
end;

function TSQLModel.getURICallBack(const aMethodName: RawUTF8; aTable: TSQLRecordClass; aID: integer): RawUTF8;
begin
  result := getURIID(aTable,aID)+'/'+aMethodName;
end;

function TSQLModel.ActionName(const Action): string;
begin
  if (Self=nil) or (fActions=nil) then
    result := '' else
    result := TSQLRecord.CaptionNameFromRTTI(fActions^.GetEnumName(byte(Action)));
end;

function TSQLModel.EventName(const Event): string;
begin
  if (Self=nil) or (fEvents=nil) then
    result := '' else
    result := TSQLRecord.CaptionNameFromRTTI(fEvents^.GetEnumName(byte(Event)));
end;

function TSQLModel.RecordReference(Table: TSQLRecordClass; ID: integer): TRecordReference;
begin
  if (self=nil) or (ID<=0) then
    result := 0 else begin
    result := GetTableIndexExisting(Table);
    if result>63 then // TRecordReference handle up to 64=1 shl 6 tables
      result := 0 else
      inc(result,ID shl 6);
  end;
end;

function TSQLModel.VirtualTableRegister(aClass: TSQLRecordClass;
  aModule: TSQLVirtualTableClass; const aExternalTableName: RawUTF8='';
  aExternalDataBase: TObject=nil): boolean;
var i: integer;
begin
  result := false;
  if aClass=nil then exit;
  i := GetTableIndexExisting(aClass);
  with TableProps[i] do begin
    if not (Kind in IS_CUSTOM_VIRTUAL) then
      if Kind=rSQLite3 then
        Kind := rCustomAutoID else
        raise EModelException.CreateFmt('Invalid VirtualTableRegister(%s) call: '+
          'impossible to set class as virtual',[aClass.ClassName]);
    ExternalDatabase := aExternalDataBase;
    if aExternalTableName='' then
      ExternalTableName := Props.SQLTableName else
      ExternalTableName := aExternalTableName;
  end;
  if high(fVirtualTableModule)<>fTablesMax then
    SetLength(fVirtualTableModule,fTablesMax+1);
  fVirtualTableModule[i] := aModule;
  result := true;
end;

function TSQLModel.VirtualTableModule(aClass: TSQLRecordClass): TSQLVirtualTableClass;
var i: integer;
begin
  result := nil;
  if (self=nil) or (fVirtualTableModule=nil) then
    exit;
  i := GetTableIndexExisting(aClass);
  if TableProps[i].Kind in IS_CUSTOM_VIRTUAL then
    result := fVirtualTableModule[i];
end;

destructor TSQLModel.Destroy;
var i,j: integer;
begin
  for i := 0 to fTablesMax do begin
    with TableProps[i].Props do
    for j := 0 to fModelMax do
      if fModel[j].Model=self then begin
        // un-associate this TSQLRecord with this model
        Move(fModel[j+1],fModel[j],(fModelMax-j)*sizeof(fModel[j]));
        dec(fModelMax);
        break;
      end;
    TableProps[i].Free;
  end;
  inherited;
end;


{ TSQLRest }

constructor TSQLRest.Create(aModel: TSQLModel);
begin
  fModel := aModel;
  fAcquireWriteTimeOut := 2000; // default AcquireWrite time out is 2 seconds 
  InitializeCriticalSection(fTransactionCriticalSession);
end;

destructor TSQLRest.Destroy;
begin
  if (fModel<>nil) and (fModel.fRestOwner=self) then
    // make sure we are the Owner (TSQLRestServerStatic has fModel<>nil e.g.)
    FreeAndNil(fModel);
  fServices.Free;
  fCache.Free;
  DeleteCriticalSection(fTransactionCriticalSession);
  inherited;
end;

function TSQLRest.MultiFieldValue(Table: TSQLRecordClass;
  const FieldName: array of RawUTF8; var FieldValue: array of RawUTF8;
  WhereID: integer): boolean;
begin
  result := MultiFieldValue(Table,FieldName,FieldValue,'RowID=:('+
    {$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(WhereID)+'):');
end;

function TSQLRest.OneFieldValue(Table: TSQLRecordClass; const FieldName,
  WhereClause: RawUTF8): RawUTF8;
var Res: array[0..0] of RawUTF8;
begin
  if MultiFieldValue(Table,[FieldName],Res,WhereClause) then
    result := Res[0] else
    result := '';
end;

function TSQLRest.OneFieldValue(Table: TSQLRecordClass; const FieldName: RawUTF8;
  FormatSQLWhere: PUTF8Char; const BoundsSQLWhere: array of const): RawUTF8;
begin
  result := OneFieldValue(Table,FieldName,FormatUTF8(FormatSQLWhere,[],BoundsSQLWhere));
end;

function TSQLRest.OneFieldValue(Table: TSQLRecordClass;
  const FieldName: RawUTF8; WhereClauseFmt: PUTF8Char;
  const Args, Bounds: array of const): RawUTF8;
begin
  result := OneFieldValue(Table,FieldName,FormatUTF8(WhereClauseFmt,Args,Bounds));
end;

function TSQLRest.OneFieldValue(Table: TSQLRecordClass;
  const FieldName: RawUTF8; WhereID: integer): RawUTF8;
var Res: array[0..0] of RawUTF8;
begin
  if (WhereID>0) and MultiFieldValue(Table,[FieldName],Res,'RowID=:('+
    {$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(WhereID)+'):') then
    result := Res[0] else
    result := '';
end;

function TSQLRest.OneFieldValues(Table: TSQLRecordClass; const FieldName,
  WhereClause: RawUTF8; var Data: TRawUTF8DynArray): boolean;
var i: integer;
    T: TSQLTableJSON;
begin
  SetLength(Data,0);
  result := false;
  T := InternalListJSON(Table,FieldName,WhereClause);
  if T<>nil then
  try
    if (T.FieldCount<>1) or (T.RowCount<=0) then
      exit;
    // get row values
    SetLength(Data,T.RowCount);
    for i := 1 to T.RowCount do // ignore fResults[0] i.e. field name
      Data[i-1] := T.fResults[i];
    result := true;
  finally
    T.Free;
  end;
end;

function TSQLRest.OneFieldValues(Table: TSQLRecordClass; const FieldName,
  WhereClause: RawUTF8; Strings: TStrings; IDToIndex: PInteger=nil): Boolean;
var Row, aID: integer;
    T: TSQLTableJSON;
begin
  result := false;
  if (Strings<>nil) and (self<>nil) and (Table<>nil) then
  try
    {$ifndef LVCL}
    Strings.BeginUpdate;
    {$endif}
    Strings.Clear;
    T := InternalListJSON(Table,SQLFromSelect(Table,'ID,'+FieldName,WhereClause,''));
    if T<>nil then
    try
      if (T.FieldCount=2) and (T.RowCount>0) then begin
        for Row := 1 to T.RowCount do begin // ignore Row 0 i.e. field names
          aID := GetInteger(T.Get(Row,0));
          Strings.AddObject(UTF8ToString(T.GetU(Row,1)),pointer(aID));
          if (IDToIndex<>nil) and (aID=IDToIndex^) then begin
            IDToIndex^ := Row-1;
            IDToIndex := nil; // set once
          end;
        end;
        result := true;
      end;
    finally
      T.Free;
    end;
  finally
    {$ifndef LVCL}
    Strings.EndUpdate;
    {$endif}
  end;
  if IDToIndex<>nil then
    IDToIndex^ := -1; // ID not found
end;

function TSQLRest.OneFieldValues(Table: TSQLRecordClass; const FieldName,
  WhereClause, Separator: RawUTF8): RawUTF8;
var i, Len, SepLen, L: integer;
    T: TSQLTableJSON;
    P: PUTF8Char;
begin
  result := '';
  T := InternalListJSON(Table,FieldName,WhereClause);
  if T<>nil then
  try
    if (T.FieldCount<>1) or (T.RowCount<=0) then
      exit;
    // calculate row values CSV needed memory
    SepLen := length(Separator);
    Len := 0;
    for i := 1 to T.RowCount do // ignore fResults[0] i.e. field name
      inc(Len,StrLen(T.fResults[i])+SepLen);
    dec(Len,SepLen);
    SetLength(result,Len);
    // add row values as CSV
    P := pointer(result);
    for i := 1 to T.RowCount do begin // ignore fResults[0] i.e. field name
      L := StrLen(T.fResults[i]);
      if L<>0 then begin
        move(T.fResults[i]^,P^,L);
        inc(P,L);
      end;
      if i=T.RowCount then
        break;
      move(pointer(Separator)^,P^,SepLen);
      inc(P,SepLen);
    end;
    assert(P-pointer(result)=Len);
  finally
    T.Free;
  end;
end;

function TSQLRest.OneFieldValues(Table: TSQLRecordClass; const FieldName,
  WhereClause: RawUTF8; var Data: TIntegerDynArray): boolean;
var T: TSQLTableJSON;
begin
  SetLength(Data,0);
  result := false;
  T := InternalListJSON(Table,FieldName,WhereClause);
  if T<>nil then
  try
    if (T.FieldCount<>1) or (T.RowCount<=0) then
      exit;
    T.GetRowValues(0,Data);
    result := true;
  finally
    T.Free;
  end;
end;

function TSQLRest.InternalListJSON(Table: TSQLRecordClass; const FieldName,
  WhereClause: RawUTF8): TSQLTableJSON;
begin
  if (self=nil) or (Table=nil) then
    result := nil else
    with Table.RecordProps do
    if (PosEx(RawUTF8(','),FieldName,1)=0) and not IsFieldName(FieldName) then
      result := nil else // prevent SQL error
      result := InternalListJSON(Table,SQLFromSelect(Table,FieldName,WhereClause,''));
end;     

function TSQLRest.InternalListRecordsJSON(Table: TSQLRecordClass;
  const WhereClause: RawUTF8): TSQLTableJSON;
begin
  if (self=nil) or (Table=nil) then
    result := nil else
    result := InternalListJSON(Table,
      Model.Props[Table].SQLFromSelectWhere('*',WhereClause));
end;

function TSQLRest.MultiFieldValues(Table: TSQLRecordClass; FieldNames: RawUTF8;
  const WhereClause: RawUTF8): TSQLTableJSON;
var P: PUTF8Char;
    aFieldName: RawUTF8;
begin
  Result := nil;
  if (self<>nil) and (Table<>nil) then
  with Model.Props[Table] do begin
    if FieldNames='' then
      // true,false -> include 'ID,'
      FieldNames := SQL.TableSimpleFields[true,false] else begin
      P := pointer(FieldNames);
      repeat
        aFieldName := Trim(GetNextItem(P));
        if not Props.IsFieldName(aFieldName) then
          exit; // invalid field name
      until P=nil;
    end;
    result := InternalListJSON(Table,SQLFromSelectWhere(FieldNames,WhereClause));
  end;
end;

function TSQLRest.MultiFieldValues(Table: TSQLRecordClass; const FieldNames: RawUTF8;
  WhereClauseFormat: PUTF8Char; const BoundsSQLWhere: array of const): TSQLTableJSON;
begin
  result := MultiFieldValues(Table,FieldNames,FormatUTF8(WhereClauseFormat,[],BoundsSQLWhere));
end;

function TSQLRest.MultiFieldValues(Table: TSQLRecordClass;
  const FieldNames: RawUTF8; WhereClauseFormat: PUTF8Char;
  const Args, Bounds: array of const): TSQLTableJSON;
begin
  result := MultiFieldValues(Table,FieldNames,FormatUTF8(WhereClauseFormat,Args,Bounds));
end;

function TSQLRest.MultiFieldValue(Table: TSQLRecordClass;
  const FieldName: array of RawUTF8; var FieldValue: array of RawUTF8;
  const WhereClause: RawUTF8): boolean;
var SQL: RawUTF8;
    i: integer;
    T: TSQLTableJSON;
begin
  result := false;
  if (self<>nil) and (Table<>nil) and (length(FieldName)=length(FieldValue)) then
  with Table.RecordProps do begin
    for i := 0 to high(FieldName) do
      if not IsFieldName(FieldName[i]) then
        exit else // prevent SQL error
        if SQL='' then
          SQL := 'SELECT '+FieldName[i] else
          SQL := SQL+','+FieldName[i];
    SQL := SQL+' FROM '+SQLTableName+' WHERE '+WhereClause+' LIMIT 1;';
    T := InternalListJSON(Table,SQL);
    if T<>nil then
    try
      if (T.FieldCount<>length(FieldName)) or (T.RowCount<=0) then
        exit;
      // get field values from the first (and unique) row
      for i := 0 to T.FieldCount-1 do
        FieldValue[i] := T.fResults[T.FieldCount+i];
      result := true;
    finally
      T.Free;
    end;
  end;
end;

function TSQLRest.Retrieve(const SQLWhere: RawUTF8; Value: TSQLRecord): boolean;
var T: TSQLTable;
begin
  if (self=nil) or (Value=nil) then
    T := nil else
    T := InternalListJSON(PSQLRecordClass(Value)^,Model.Props[PSQLRecordClass(Value)^].
      SQLFromSelectWhere('*',SQLWhere+' LIMIT 1'));
  if T=nil then
    result := false else
    try
      if T.RowCount>=1 then begin
        Value.FillFrom(T,1); // fetch data from first result row
        result := true;
      end else
        result := false;
    finally
      T.Free;
    end;
end;

function TSQLRest.RetrieveList(Table: TSQLRecordClass; FormatSQLWhere: PUTF8Char;
  const BoundsSQLWhere: array of const; const aCustomFieldsCSV: RawUTF8=''): TObjectList;
var SQL: RawUTF8;
    T: TSQLTable;
begin
  result := nil;
  if (self=nil) or (Table=nil) then
    exit;
  SQL := FormatUTF8(FormatSQLWhere,[],BoundsSQLWhere);
  if aCustomFieldsCSV<>'' then
    T := InternalListJSON(Table,aCustomFieldsCSV,SQL) else
    T := InternalListRecordsJSON(Table,SQL);
  if T<>nil then
  try
    result := TObjectList.Create;
    T.ToObjectList(result,Table);
  finally
    T.Free;
  end;
end;

function TSQLRest.Retrieve(WhereClauseFmt: PUTF8Char; const Args,Bounds: array of const;
  Value: TSQLRecord): boolean;
begin
  result := Retrieve(FormatUTF8(WhereClauseFmt,Args,Bounds),Value);
end;

function TSQLRest.Retrieve(Reference: TRecordReference; ForUpdate: boolean=false): TSQLRecord;
var aClass: TSQLRecordClass;
begin
  result := nil;
  if (self=nil) or (RecordRef(Reference).ID=0) then
    exit;
  aClass := RecordRef(Reference).Table(Model);
  if aClass=nil then
    exit;
  result := aClass.Create(self,RecordRef(Reference).ID,ForUpdate);
  if result.fID=0 then
    FreeAndNil(result); // error during value retrieval
end;

function TSQLRest.Retrieve(aPublishedRecord, aValue: TSQLRecord): boolean;
begin
  result := Retrieve(aPublishedRecord.ID,aValue);
end;

function TSQLRest.UnLock(Rec: TSQLRecord): boolean;
begin
  if (self=nil) or (Rec=nil) or (Rec.fID<=0) then
    result := false else
    result := UnLock(PSQLRecordClass(Rec)^,Rec.fID);
end;

procedure TSQLRest.Commit(SessionID: cardinal);
begin
  if self<>nil then begin
    EnterCriticalSection(fTransactionCriticalSession);
    try
      if (fTransactionActive<>0) and (fTransactionActive=SessionID) then begin
        fTransactionActive := 0; // by default, just release flag
        fTransactionTable := nil;
      end;
    finally
      LeaveCriticalSection(fTransactionCriticalSession);
    end;
  end;
end;

procedure TSQLRest.RollBack(SessionID: cardinal);
begin
  if self<>nil then begin
    EnterCriticalSection(fTransactionCriticalSession);
    try
      if (fTransactionActive<>0) and (fTransactionActive=SessionID) then begin
        fTransactionActive := 0; // by default, just release flag
        fTransactionTable := nil;
      end;
    finally
      LeaveCriticalSection(fTransactionCriticalSession);
    end;
  end;
end;

function TSQLRest.TransactionBegin(aTable: TSQLRecordClass; SessionID: cardinal): boolean;
begin
  result := false;
  if self<>nil then begin
    EnterCriticalSection(fTransactionCriticalSession);
    try
      if fTransactionActive=0 then begin // nested transactions are not allowed
        fTransactionActive := SessionID;
        fTransactionTable := aTable;
        result := true;
      end;
    finally
      LeaveCriticalSection(fTransactionCriticalSession);
    end;
  end;
end;

function TSQLRest.RecordCanBeUpdated(Table: TSQLRecordClass; ID: integer; Action: TSQLEvent;
  ErrorMsg: PRawUTF8 = nil): boolean;
begin
  result := true; // accept by default -> override this method to customize this
end;

function TSQLRest.Delete(Table: TSQLRecordClass; ID: integer): boolean;
begin
  result := RecordCanBeUpdated(Table,ID,seDelete);
end;

function TSQLRest.InternalDelete(Table: TSQLRecordClass; const SQLWhere: RawUTF8;
  var IDs: TIntegerDynArray): boolean;
var i: integer;
begin
  result := false;
  if (not OneFieldValues(Table,'RowID',SQLWhere,IDs)) or
     (IDs=nil) then
    exit;
  for i := 0 to high(IDs) do
    if not RecordCanBeUpdated(Table,IDs[i],seDelete) then
      exit;
  for i := 0 to high(IDs) do
    fCache.NotifyDeletion(Table,IDs[i]);
  result := true;
end;

function TSQLRest.Delete(Table: TSQLRecordClass; const SQLWhere: RawUTF8): boolean;
var IDs: TIntegerDynArray;
begin
  if InternalDelete(Table,SQLWhere,IDs) then
    result := EngineDeleteWhere(Table,SQLWhere,IDs) else
    result := false;
end;

function TSQLRest.Delete(Table: TSQLRecordClass; FormatSQLWhere: PUTF8Char;
  const BoundsSQLWhere: array of const): boolean;
begin
  result := Delete(Table,FormatUTF8(FormatSQLWhere,[],BoundsSQLWhere));
end;

function TSQLRest.Update(Value: TSQLRecord): boolean;
begin
  result := (Value<>nil) and (Value.fID<>0) and
    RecordCanBeUpdated(PSQLRecordClass(Value)^,Value.fID,seUpdate);
end;

function TSQLRest.Update(aTable: TSQLRecordClass; aID: integer;
  const aSimpleFields: array of const): boolean;
var Value: TSQLRecord;
begin
  result := false; // means error
  if (self=nil) or (aTable=nil) or (aID=0) then
    exit;
  Value := aTable.Create;
  try
    if not Value.SimplePropertiesFill(aSimpleFields) then
      exit;
    Value.fID := aID;
    result := Update(Value);
  finally
    Value.Free;
  end;
end;

function TSQLRest.Add(aTable: TSQLRecordClass; const aSimpleFields: array of const;
  ForcedID: integer=0): integer;
var Value: TSQLRecord;
begin
  result := 0; // means error
  if (self=nil) or (aTable=nil) then
    exit;
  Value := aTable.Create;
  try
    if Value.SimplePropertiesFill(aSimpleFields) then begin
      if ForcedID<>0 then
        Value.fID := ForcedID;
      result := Add(Value,true);
    end;
  finally
    Value.Free;
  end;
end;

procedure TSQLRest.QueryAddCustom(aTypeInfo: pointer; aEvent: TSQLQueryEvent;
  const aOperators: TSQLQueryOperators);
var Enum: PEnumType;
    i,n: integer;
begin
  if (self=nil) or not Assigned(aEvent)  or
     (aTypeInfo=nil) or (PTypeInfo(aTypeInfo)^.Kind<>tkEnumeration) then
    exit;
  Enum := PTypeInfo(aTypeInfo)^.EnumBaseType;
  n := length(QueryCustom);
  SetLength(QueryCustom,n+Enum^.MaxValue+1);
  for i := 0 to Enum^.MaxValue do
    with QueryCustom[i+n] do begin
      EnumType := Enum;
      EnumIndex := i;
      Event := aEvent;
      Operators := aOperators;
    end;
end;

class function TSQLRest.QueryIsTrue(aTable: TSQLRecordClass; aID: integer;
  FieldType: TSQLFieldType; Value: PUTF8Char; Operator: integer;
  Reference: PUTF8Char): boolean;
begin // use mostly the same fast comparison functions as for sorting  
  result := false;
  if aID=0 then
    exit; // invalid input field
  if Reference=nil then
    exit; // avoid most GPF
  if FieldType=sftMany then
    exit; // nothing is stored directly, but in a separate pivot table
  if FieldType in [sftUnknown,sftBlob,sftBlobDynArray,sftBlobCustom,sftObject,
    sftUTF8Custom{$ifdef PUBLISHRECORD},sftBlobRecord{$endif}
    {$ifdef USEVARIANTS},sftVariant{$endif}] then
    FieldType := sftUTF8Text; // unknown or blob fields are compared as UTF-8
  { TODO: handle sftBlobDynArray/sftBlobCustom/sftBlobRecord comparison }
  case TSQLQueryOperator(Operator) of
    qoNone:
      result := true;
    qoEqualTo:
      result := SQLFieldTypeComp[FieldType](Value,Reference)=0;
    qoNotEqualTo:
      result := SQLFieldTypeComp[FieldType](Value,Reference)<>0;
    qoLessThan:
      result := SQLFieldTypeComp[FieldType](Value,Reference)<0;
    qoLessThanOrEqualTo:
      result := SQLFieldTypeComp[FieldType](Value,Reference)<=0;
    qoGreaterThan:
      result := SQLFieldTypeComp[FieldType](Value,Reference)>0;
    qoGreaterThanOrEqualTo:
      result := SQLFieldTypeComp[FieldType](Value,Reference)>=0;
    qoEqualToWithCase:
      result := StrComp(Value,Reference)=0;
    qoNotEqualToWithCase:
      result := StrComp(Value,Reference)<>0;
    qoContains:
      result := PosIU(Reference,Value)<>0;
    qoBeginWith:
      result := IdemPCharU(Value,Reference);
    qoSoundsLikeEnglish,
    qoSoundsLikeFrench,
    qoSoundsLikeSpanish:
      result := PSynSoundEx(Reference)^.UTF8(Value);
  end;
end;

function TSQLRest.RetrieveBlob(Table: TSQLRecordClass; aID: integer;
  const BlobFieldName: RawUTF8;
  out BlobStream: THeapMemoryStream): boolean;
var BlobData: TSQLRawBlob;
begin
  BlobStream := THeapMemoryStream.Create;
  result := RetrieveBlob(Table,aID,BlobFieldName,BlobData);
  if not result or (BlobData='') then
    exit;
  BlobStream.Write(pointer(BlobData)^,length(BlobData));
  BlobStream.Seek(0,soFromBeginning); // rewind
end;

function TSQLRest.UpdateBlob(Table: TSQLRecordClass; aID: integer;
  const BlobFieldName: RawUTF8; BlobData: TStream): boolean;
var Blob: TSQLRawBlob;
    L: integer;
begin
  result := false;
  if (self=nil) or (BlobData=nil) then
    exit;
  L := BlobData.Seek(0,soFromEnd);
  SetLength(Blob,L);
  BlobData.Seek(0,soFromBeginning);
  if BlobData.Read(pointer(Blob)^,L)<>L then
    exit;
  result := UpdateBlob(Table,aID,BlobFieldName,Blob);
end;

function TSQLRest.UpdateBlob(Table: TSQLRecordClass; aID: integer;
  const BlobFieldName: RawUTF8; BlobData: pointer; BlobSize: integer): boolean;
var Blob: TSQLRawBlob;
begin
  if (self=nil) or (BlobData=nil) or (BlobSize<0) then
    result := false else begin
    SetString(Blob,PAnsiChar(BlobData),BlobSize);
    result := UpdateBlob(Table,aID,BlobFieldName,Blob);
  end;
end;

function TSQLRest.UpdateBlobFields(Value: TSQLRecord): boolean;
var BlobData: RawByteString;
    i: integer;
begin
  result := false;
  if (Value=nil) or (Value.fID<=0) then
    exit;
  with Value.RecordProps do
  if BlobFields<>nil then
    for i := 0 to high(BlobFields) do begin
      GetLongStrProp(Value,BlobFields[i].PropInfo,BlobData);
      if not EngineUpdateBlob(PSQLRecordClass(Value)^,Value.fID,BlobFields[i].PropInfo,BlobData) then
        exit;
    end;
  result := true;
end;

function TSQLRest.RetrieveBlobFields(Value: TSQLRecord): boolean;
var BlobData: TSQLRawBlob;
    i: integer;
begin
  result := false;
  if (Self=nil) or (Value=nil) or (Value.fID<=0) then
    exit;
  with Value.RecordProps do
  if BlobFields<>nil then
    for i := 0 to high(BlobFields) do
      if EngineRetrieveBlob(PSQLRecordClass(Value)^,Value.fID,BlobFields[i].PropInfo,BlobData) then
        SetLongStrProp(Value,BlobFields[i].PropInfo,BlobData) else
        exit;
  result := true;
end;

function TSQLRest.TableRowCount(Table: TSQLRecordClass): integer;
var T: TSQLTableJSON;
begin
  if (self=nil) or (Table=nil) then
    T := nil else
    T := InternalListJSON(Table,'SELECT Count(*) FROM '+Table.RecordProps.SQLTableName);
  if T<>nil then
  try
    Result := T.GetAsInteger(1,0);
  finally
    T.Free;
  end else
    Result := -1;
end;

function TSQLRest.TableHasRows(Table: TSQLRecordClass): boolean;
var T: TSQLTableJSON;
begin
  if (self=nil) or (Table=nil) then
    T := nil else
    T := InternalListJSON(Table,
      'SELECT RowID FROM '+Table.RecordProps.SQLTableName+' LIMIT 1');
  if T<>nil then
  try
    Result := T.RowCount>0;
  finally
    T.Free;
  end else
    Result := false;
end;

function TSQLRest.MainFieldValue(Table: TSQLRecordClass; ID: Integer;
   ReturnFirstIfNoUnique: boolean=false): RawUTF8;
begin
  if (self=nil) or (Table=nil) or (ID<=0) then
    result := '' else begin
    result := Table.RecordProps.MainFieldName(Table,ReturnFirstIfNoUnique);
    if result<>'' then
      result := OneFieldValue(Table,Result,ID);
  end;
end;

function TSQLRest.MainFieldID(Table: TSQLRecordClass; const Value: RawUTF8): integer;
var aMainField: integer;
begin
  result := 0;
  if (self<>nil) and (Value<>'') and (Table<>nil) then
  with Table.RecordProps do begin
    aMainField := MainField[false];
    if aMainField>=0 then
      result := GetInteger(pointer(OneFieldValue(Table,'RowID',
        Fields.List[aMainField].Name+'=:('+QuotedStr(Value,'''')+'):')));
  end;
end;

function TSQLRest.MainFieldIDs(Table: TSQLRecordClass; const Values: array of RawUTF8;
  var IDs: TIntegerDynArray): boolean;
var aMainField, id: integer;
begin
  SetLength(IDs,0);
  if (self<>nil) and (high(Values)>=0) and (Table<>nil) then
    if high(Values)=0 then begin // handle special case of one Values[] item
      id := MainFieldID(Table,Values[0]);
      if id>0 then begin
        SetLength(IDs,1);
        IDs[0] := id;
      end;
    end else
    with Table.RecordProps do begin // request all Values[] IDs at once
      aMainField := MainField[false];
      if aMainField>=0 then
        OneFieldValues(Table,'RowID',Fields.List[aMainField].Name+' in ('+
          RawUTF8ArrayToQuotedCSV(Values)+')',IDs);
    end;
  result := IDs<>nil;
end;

function TSQLRest.FTSMatch(Table: TSQLRecordFTS3Class;
  const WhereClause: RawUTF8; var DocID: TIntegerDynArray): boolean;
begin // FTS3 tables don't have any ID, but RowID or DocID
  result := OneFieldValues(Table,'RowID',WhereClause,DocID);
end;

function TSQLRest.FTSMatch(Table: TSQLRecordFTS3Class;
  const MatchClause: RawUTF8; var DocID: TIntegerDynArray;
  const PerFieldWeight: array of double): boolean;
var WhereClause: RawUTF8;
    i: integer;
begin
  result := false;
  with Table.RecordProps do
    if length(PerFieldWeight)<>length(SimpleFields) then
      exit else
    WhereClause := FormatUTF8('% MATCH :(''%''): ORDER BY rank(matchinfo(%)',
      [SQLTableName,MatchClause,SQLTableName]);
  for i := 0 to high(PerFieldWeight) do
    WhereClause := FormatUTF8('%,:(%):',[WhereClause,PerFieldWeight[i]]);
  result := FTSMatch(Table,WhereClause+') DESC',DocID);
end;

function TSQLRest.AcquireWrite(const aContext: TSQLRestServerCallBackParams): Boolean;
var Start, Now: Cardinal;
begin
  if self<>nil then begin
    Start := GetTickCount;
    repeat
      if TryEnterCriticalSection(fTransactionCriticalSession) then begin
        if (fTransactionActive=0) or (fTransactionActive=aContext.Session) then begin
          // no transaction or inside a transaction for this session -> OK
          result := true;
          exit; // continue inside Critical Section until ReleaseWrite
        end;
        LeaveCriticalSection(fTransactionCriticalSession);
      end;
      Now := GetTickCount;
      if (Now<Start) or (Now>Start+AcquireWriteTimeOut) then
        break; // wait up to 2 second by default
      Sleep(1); // retry every 1 ms
    until false;
  end;
  result := false;
end;

procedure TSQLRest.ReleaseWrite;
begin
  LeaveCriticalSection(fTransactionCriticalSession);
end;

function TSQLRest.GetServerTimeStamp: TTimeLog;
var Tix: cardinal;
begin
  Tix := GetTickCount shr 9; // resolution change 1 ms -> 512 ms 
  if fServerTimeStampCacheTix=Tix then
    result := fServerTimeStampCacheValue.Value else begin
    fServerTimeStampCacheTix := Tix;
    fServerTimeStampCacheValue.From(Now+fServerTimeStampOffset);
    result := fServerTimeStampCacheValue.Value;
  end;
end;

procedure TSQLRest.SetServerTimeStamp(const Value: TTimeLog);
begin
  fServerTimeStampOffset := PIso8601(@Value)^.ToDateTime-Now;
  if fServerTimeStampOffset=0 then
    fServerTimeStampOffset := 0.0001; // retrieve server date/time only once
end;

function TSQLRest.GetCache: TSQLRestCache;
begin
  if self=nil then
    result := nil else begin
    if fCache=nil then
      fCache := TSQLRestCache.Create(self);
    result := fCache;
  end;
end;

function TSQLRest.CacheWorthItForTable(aTableIndex: cardinal): boolean;
begin
  result := true; // always worth caching by default
end;

{$ifdef ISDELPHI2010} // Delphi 2009 generics support is buggy :(
function TSQLRest.Service<T>: T;
var service: TServiceFactory;
begin
  service := fServices.Info(TypeInfo(T));
  if (service=nil) or not service.Get(result) then
    result := Default(T);
end;
{$endif}


{ TSQLRestCacheEntry }

procedure TSQLRestCacheEntry.FlushCacheEntry(Index: Integer);
begin
  if cardinal(Index)<cardinal(Count) then
    if CacheAll then
      Value.Delete(Index) else
      with Values[Index] do begin
        TimeStamp := 0;
        JSON := '';
      end;
end;

procedure TSQLRestCacheEntry.FlushCacheAllEntries;
var i: integer;
begin
  if not CacheEnable then
    exit;
  EnterCriticalSection(Mutex);
  try
    if CacheAll then
      Value.Clear else
      for i := 0 to Count-1 do
      with Values[i] do begin
        TimeStamp := 0;
        JSON := '';
      end;
  finally
    LeaveCriticalSection(Mutex);
  end;
end;

procedure TSQLRestCacheEntry.SetJSON(aID: integer; const aJSON: RawUTF8);
var Rec: TSQLRestCacheEntryValue;
    i: integer;
begin
  EnterCriticalSection(Mutex);
  try
    Rec.ID := aID;
    Rec.TimeStamp := GetTickCount;
    Rec.JSON := aJSON;
    i := Value.Find(Rec);
    if i>=0 then
      Values[i] := Rec else
      if CacheAll then begin
        Value.Add(Rec);
        Value.Sort; // will sort by ID for faster retrieval
      end;
  finally
    LeaveCriticalSection(Mutex);
  end;
end;

procedure TSQLRestCacheEntry.SetJSON(aRecord: TSQLRecord);
begin  // soInsert = include all fields
  SetJSON(aRecord.fID,aRecord.GetJSONValues(true,false,soInsert));
end;

function TSQLRestCacheEntry.RetrieveJSON(aID: integer; var aJSON: RawUTF8): boolean;
var i: integer;
    Now: cardinal;
begin
  EnterCriticalSection(Mutex);
  try
    result := false;
    i := Value.Find(aID);
    if i>=0 then
      with Values[i] do
      if TimeStamp<>0 then begin // 0 when there is no JSON value cached
        Now := GetTickCount;
        if (TimeOut=0) or
           ((Now>=TimeStamp) and (Now<TimeStamp+TimeOut)) then begin
          aJSON := JSON;
          result := true; // found a non outdated serialized value in cache
        end else
          FlushCacheEntry(i);
      end;
  finally
    LeaveCriticalSection(Mutex);
  end;
end;

function TSQLRestCacheEntry.RetrieveJSON(aID: integer; aValue: TSQLRecord): boolean;
var JSON: RawUTF8;
begin
  if RetrieveJSON(aID,JSON) then begin
    aValue.FillFrom(JSON);
    aValue.fID := aID; // override RowID field if not present
    result := true;
  end else
    result := false;
end;


{ TSQLRestCache }

function TSQLRestCache.CachedEntries: cardinal;
var i,j: integer;
begin
  result := 0;
  if self<>nil then
    for i := 0 to high(fCache) do
      with fCache[i] do
      if CacheEnable then
      for j := 0 to Count-1 do
        if Values[j].TimeStamp<>0 then
          inc(result);
end;

function TSQLRestCache.CachedMemory: cardinal;
var i,j: integer;
begin
  result := 0;
  if self<>nil then
    for i := 0 to high(fCache) do
      with fCache[i] do
      if CacheEnable then
      for j := 0 to Count-1 do
        if Values[j].TimeStamp<>0 then
          inc(result,length(Values[j].JSON)+(sizeof(Values[j])+16));
end;

function TSQLRestCache.SetTimeOut(aTable: TSQLRecordClass; aTimeout: Integer): boolean;
var i: integer;
begin
  result := false;
  if (self=nil) or (aTable=nil) then
    exit;
  i := Rest.Model.GetTableIndexExisting(aTable);
  if Rest.CacheWorthItForTable(i) then
    if Cardinal(i)<Cardinal(Length(fCache)) then
      with fCache[i] do begin
        EnterCriticalSection(Mutex);
        TimeOut := aTimeOut;
        LeaveCriticalSection(Mutex);
        result := true;
      end;
end;

function TSQLRestCache.SetCache(aTable: TSQLRecordClass): boolean;
var i: integer;
begin
  result := false;
  if (self=nil) or (aTable=nil) then
    exit;
  i := Rest.Model.GetTableIndexExisting(aTable);
  if Rest.CacheWorthItForTable(i) then
    if Cardinal(i)<Cardinal(Length(fCache)) then
      with fCache[i] do begin
        // global cache of all records of this table
        EnterCriticalSection(Mutex);
        try
          CacheEnable := true;
          CacheAll := True;
          Value.Clear;
          result := true;
        finally
          LeaveCriticalSection(Mutex);
        end;
      end;
end;

function TSQLRestCache.SetCache(aTable: TSQLRecordClass; aID: Integer): boolean;
var i: integer;
    Rec: TSQLRestCacheEntryValue;
begin
  result := false;
  if (self=nil) or (aTable=nil) or (aID<=0) then
    exit;
  i := Rest.Model.GetTableIndexExisting(aTable);
  if Cardinal(i)>=Cardinal(Length(fCache)) then
    exit;
  if Rest.CacheWorthItForTable(i) then
    with fCache[i] do begin
      EnterCriticalSection(Mutex);
      try
        CacheEnable := true;
        if not CacheAll then begin
          i := Value.Find(aID);
          if i<0 then begin
            Rec.ID := aID;
            Rec.TimeStamp := 0;
            Value.Add(Rec);
            Value.Sort; // will sort by ID for faster retrieval
          end;
        end;
      finally
        LeaveCriticalSection(Mutex);
      end;
    end;
  result := True;
end;

function TSQLRestCache.SetCache(aRecord: TSQLRecord): boolean;
begin
  if (self=nil) or (aRecord=nil) or (aRecord.fID<=0) then
    result := false else
    result := SetCache(PSQLRecordClass(aRecord)^,aRecord.fID);
end;

constructor TSQLRestCache.Create(aRest: TSQLRest);
var i: integer;
begin
  if aRest=nil then
    EBusinessLayerException.CreateFmt('%s.Create',[ClassName]);
  fRest := aRest;
  SetLength(fCache,length(fRest.Model.Tables));
  for i := 0 to high(fCache) do
    with fCache[i] do begin
      Value.Init(TypeInfo(TSQLRestCacheEntryValueDynArray),Values,@Count);
      Value.Compare := SortDynArrayInteger; // will search/sort by ID
      InitializeCriticalSection(Mutex);
    end;
end;

destructor TSQLRestCache.Destroy;
var i: integer;
begin
  for i := 0 to high(fCache) do
    DeleteCriticalSection(fCache[i].Mutex);
  inherited;
end;

procedure TSQLRestCache.Clear;
var i: integer;
begin
  if self<>nil then
  for i := 0 to high(fCache) do
  with fCache[i] do begin
    EnterCriticalSection(Mutex);
    try
      Value.Clear;
      CacheAll := false;
      CacheEnable := false;
      TimeOut := 0;
    finally
      LeaveCriticalSection(Mutex);
    end;
  end;
end;

procedure TSQLRestCache.Flush;
var i: integer;
begin
  if self<>nil then
  for i := 0 to high(fCache) do
    fCache[i].FlushCacheAllEntries; // include *CriticalSection(Mutex)
end;

procedure TSQLRestCache.Flush(aTable: TSQLRecordClass);
begin
  if self<>nil then // includes *CriticalSection(Mutex):
    fCache[fRest.Model.GetTableIndexExisting(aTable)].FlushCacheAllEntries;
end;

procedure TSQLRestCache.Flush(aTable: TSQLRecordClass; aID: integer);
begin
  if self<>nil then
    with fCache[fRest.Model.GetTableIndexExisting(aTable)] do
    if CacheEnable then begin
      EnterCriticalSection(Mutex);
      try
        FlushCacheEntry(Value.Find(aID));
      finally
        LeaveCriticalSection(Mutex);
      end;
    end;
end;

procedure TSQLRestCache.Notify(aTable: TSQLRecordClass; aID: integer;
  const aJSON: RawUTF8; aAction: TSQLOccasion);
begin
  if (self<>nil) and (aTable<>nil) and (aID>0) then
    Notify(fRest.Model.GetTableIndex(aTable),aID,aJSON,aAction);
end;

procedure TSQLRestCache.Notify(aRecord: TSQLRecord; aAction: TSQLOccasion);
var aTableIndex: cardinal;
begin
  if (self=nil) or (aRecord=nil) or (aRecord.fID<=0) or
     not (aAction in [soInsert,soUpdate]) then
    exit;
  aTableIndex := fRest.Model.GetTableIndex(PSQLRecordClass(aRecord)^);
  if aTableIndex<Cardinal(Length(fCache)) then
    with fCache[aTableIndex] do
      if CacheEnable then
        SetJSON(aRecord);
end;

procedure TSQLRestCache.Notify(aTableIndex: integer; aID: integer;
  const aJSON: RawUTF8; aAction: TSQLOccasion);
begin
  if (self<>nil) and (aID>0) and (aAction in [soSelect,soInsert,soUpdate]) and
     (aJSON<>'') and (Cardinal(aTableIndex)<Cardinal(Length(fCache))) then
    with fCache[aTableIndex] do
      if CacheEnable then
        SetJSON(aID,aJSON);
end;

procedure TSQLRestCache.NotifyDeletion(aTableIndex, aID: integer);
begin
  if (self<>nil) and (aID>0) and
     (Cardinal(aTableIndex)<Cardinal(Length(fCache))) then
    with fCache[aTableIndex] do
    if CacheEnable then begin
      EnterCriticalSection(Mutex);
      try
        FlushCacheEntry(Value.Find(aID));
      finally
        LeaveCriticalSection(Mutex);
      end;
    end;
end;

procedure TSQLRestCache.NotifyDeletion(aTable: TSQLRecordClass; aID: integer);
begin
  if (self<>nil) and (aTable<>nil) and (aID>0) then
    NotifyDeletion(fRest.Model.GetTableIndex(aTable),aID);
end;

function TSQLRestCache.Retrieve(aID: Integer; aValue: TSQLRecord): boolean;
var TableIndex: cardinal;
begin
  result := false;
  if (self=nil) or (aValue=nil) or (aID<=0) then
    exit;
  TableIndex := fRest.Model.GetTableIndex(PSQLRecordClass(aValue)^);
  if TableIndex<Cardinal(Length(fCache)) then
    with fCache[TableIndex] do
    if CacheEnable and RetrieveJSON(aID,aValue) then
      result := true;
end;

function TSQLRestCache.Retrieve(aTableIndex, aID: integer): RawUTF8;
begin
  result := '';
  if (self<>nil) and (aID>0) and
     (Cardinal(aTableIndex)<Cardinal(Length(fCache))) then
    with fCache[aTableIndex] do
    if CacheEnable then
      RetrieveJSON(aID,result);
end;


{ TSQLRestClientURI }

function TSQLRestClientURI.EngineExecute(const SQL: RawUTF8): boolean;
begin
  result := URI(Model.Root,'POST',nil,nil,@SQL).Lo=HTML_SUCCESS;
end;

function TSQLRestClientURI.URIGet(Table: TSQLRecordClass; ID: integer;
  var Resp: RawUTF8; ForUpdate: boolean=false): Int64Rec;
const METHOD: array[boolean] of RawUTF8 = ('GET','LOCK');
begin
  result := URI(Model.getURIID(Table,ID),METHOD[ForUpdate],@Resp,nil,nil);
end;

function TSQLRestClientURI.UnLock(Table: TSQLRecordClass; aID: integer): boolean;
begin
  if (self=nil) or not Model.UnLock(Table,aID) then
    result := false else // was not locked by the client
    result := URI(Model.getURIID(Table,aID),'UNLOCK').Lo=HTML_SUCCESS;
end;

function TSQLRestClientURI.ExecuteList(const Tables: array of TSQLRecordClass;
  const SQL: RawUTF8): TSQLTableJSON;
var Resp: RawUTF8;
begin
  if self=nil then
    result := nil else
  with URI(Model.Root,'GET',@Resp,nil,@SQL) do
    if Lo=HTML_SUCCESS then begin // GET with SQL sent
      if high(Tables)=0 then
        result := TSQLTableJSON.Create([Tables[0]],SQL,Resp) else
        result := TSQLTableJSON.Create(Tables,SQL,Resp);
      result.fInternalState := Hi;
    end else // get data
    result := nil;
end;

function TSQLRestClientURI.ServerInternalState: cardinal;
begin
  if (Self=nil) or (Model=nil) then // avoid GPF
    result := cardinal(-1) else
    result := URI(Model.Root,'STATE').Hi;
end;

function TSQLRestClientURI.ServerCacheFlush(aTable: TSQLRecordClass; aID: integer): boolean;
var aResp: RawUTF8;
begin
  if (Self=nil) or (Model=nil) then // avoid GPF
    result := false else
    result := CallBackGet('CacheFlush',[],aResp,aTable,aID)=HTML_SUCCESS;
end;

function TSQLRestClientURI.ServerTimeStampSynchronize: boolean;
var status: integer;
    aResp: RawUTF8;
begin
  fServerTimeStampOffset := 0.0001; // avoid endless recursive call
  status := CallBackGet('TimeStamp',[],aResp);
  result := (status=HTML_SUCCESS);
  if result then
    SetServerTimeStamp(GetInt64(pointer(aResp))) else begin
{$ifdef WITHLOG}
    SQLite3Log.Add.Log(sllWarning,'/TimeStamp call failed -> Server not available');
{$endif}
    fLastErrorMessage := 'Server not available  - '+Trim(fLastErrorMessage);
  end;
end;

function TSQLRestClientURI.UpdateFromServer(const Data: array of TObject; out Refreshed: boolean;
  PCurrentRow: PInteger): boolean;
// notes about refresh mechanism:
// - if server doesn't implement InternalState, its value is 0 -> always refresh
// - if any TSQLTableJSON or TSQLRecord belongs to a TSQLRestServerStatic,
// the Server stated fInternalState=cardinal(-1) for them -> always refresh
var i: integer;
    State: cardinal;
    Resp: RawUTF8;
    T: TSQLTableJSON;
    TRefreshed: boolean; // to check for each Table refresh
const TState: array[boolean] of TOnTableUpdateState = (tusNoChange,tusChanged);
begin
  result := self<>nil;
  Refreshed := false;
  if not result then
    exit; // avoid GPF
  State := ServerInternalState; // get revision state from server
  for i := 0 to high(Data) do
    if Data[i]<>nil then
    if TObject(Data[i]).InheritsFrom(TSQLTableJSON) then begin
      T := TSQLTableJSON((Data[i]));
      if (T.QuerySQL<>'') and (T.InternalState<>State) then begin // refresh needed?
        with URI(Model.Root,'GET',@Resp,nil,@T.QuerySQL) do
          if Lo=HTML_SUCCESS then begin // GET with SQL sent
            if Assigned(OnTableUpdate) then
              OnTableUpdate(T,tusPrepare);
            TRefreshed := false;
            if not T.UpdateFrom(Resp,TRefreshed,PCurrentRow) then
              result := false else // mark error retrieving new content
              T.fInternalState := Hi;
            if TRefreshed then
              Refreshed := true;
            if Assigned(OnTableUpdate) then
              OnTableUpdate(T,TState[TRefreshed]);
          end
          else result := false; // mark error retrieving new content
        end;
    end else
    if TObject(Data[i]).InheritsFrom(TSQLRecord) then
    with TSQLRecord(Data[i]) do
      if (fID<>0) and (InternalState<>State) then begin // refresh needed?
        if not Refresh(fID,TSQLRecord(Data[i]),Refreshed) then
          result := false; // mark error retrieving new content
      end;
end;

function TSQLRestClientURI.List(const Tables: array of TSQLRecordClass;
  const SQLSelect, SQLWhere: RawUTF8): TSQLTableJSON;
var Resp, SQL: RawUTF8;
    U: RawUTF8;
    InternalState: cardinal;
begin
  result := nil;
  if high(Tables)<0 then exit;
  // GET Collection
  SQL := Model.SQLFromSelectWhere(Tables,SQLSelect,SQLWhere);
  if high(Tables)=0 then begin
    // one Table -> use REST protocol (SQL as parameters)
    if not IsRowID(pointer(SQLSelect)) then
      // ID selected by default
      U := '?select='+UrlEncode(SQLSelect) else
      U := '';
    if SQLWhere<>'' then begin
      if U<>'' then
        U := U+'&where=' else
        U := U+'?where=';
      U := U+UrlEncode(SQLWhere);
    end;
    with URI(Model.URI[TSQLRecordClass(Tables[0])]+U,'GET',@Resp) do
      if Lo<>HTML_SUCCESS then
        exit else
        InternalState := Hi;
    result := TSQLTableJSON.Create([Tables[0]],SQL,Resp); // get data
  end else begin
    // multiple tables -> send SQL statement as HTTP body
    with URI(Model.Root,'GET',@Resp,nil,@SQL) do
      if Lo<>HTML_SUCCESS then
        exit else
        InternalState := Hi;
    result := TSQLTableJSON.Create(Tables,SQL,Resp); // get data
  end;
  result.fInternalState := InternalState;
end;

function TSQLRestClientURI.InternalListJSON(Table: TSQLRecordClass; const SQL: RawUTF8): TSQLTableJSON;
begin
  result := ExecuteList([Table],SQL);
end;

procedure TSQLRestClientURI.SessionClose;
var tmp: RawUTF8;
begin
  if (self<>nil) and (fSessionUser<>nil) and
     (fSessionID<>CONST_AUTHENTICATION_SESSION_NOT_STARTED) then begin
    // notify session closed to server
    CallBackGet('auth',['UserName',fSessionUser.LogonName,'Session',fSessionID],tmp);
    fSessionID := CONST_AUTHENTICATION_SESSION_NOT_STARTED;
    FreeAndNil(fSessionUser);
  end;
end;

constructor TSQLRestClientURI.Create(aModel: TSQLModel);
begin
  inherited Create(aModel);
  fSessionID := CONST_AUTHENTICATION_NOT_USED;
end;

destructor TSQLRestClientURI.Destroy;
var t,i,aID: integer;
    Table: TSQLRecordClass;
begin
  fBatch.Free;
  try
    // unlock all still locked records by this client
    if Model<>nil then
    for t := 0 to high(Model.Locks) do begin
      Table := Model.Tables[t];
      with Model.Locks[t] do
      for i := 0 to Count-1 do begin
        aID := ID[i];
        if aID<>0 then // 0 is empty after unlock
          self.UnLock(Table,aID);
      end;
    end;
    SessionClose; // if not already notified
  finally
    // release memory and associated classes
    fSessionUser.Free;
    try
      InternalClose;
    finally
      inherited Destroy; // fModel.Free if owned by this TSQLRest instance
    end;
  end;
end;

procedure TSQLRestClientURI.Commit(SessionID: cardinal);
begin
  inherited Commit(CONST_AUTHENTICATION_NOT_USED); // reset fTransactionActive flag
  URI(Model.Root,'END');
end;

procedure TSQLRestClientURI.RollBack(SessionID: cardinal);
begin
  inherited RollBack(CONST_AUTHENTICATION_NOT_USED); // reset fTransactionActive flag
  URI(Model.Root,'ABORT');
end;

function TSQLRestClientURI.TransactionBegin(aTable: TSQLRecordClass;
  SessionID: cardinal): boolean;
begin
  result := inherited TransactionBegin(aTable,CONST_AUTHENTICATION_NOT_USED);
  if result then
    // fTransactionActive flag was not already set
    if aTable=nil then
      result := URI(Model.Root,'BEGIN').Lo=HTML_SUCCESS else
      result := URI(Model.URI[aTable],'BEGIN').Lo=HTML_SUCCESS;
end;

function TSQLRestClientURI.TransactionBeginRetry(aTable: TSQLRecordClass;
  Retries: integer): boolean;
begin
  if Retries>50 then
    Retries := 50; // avoid loop for more than 10 seconds
  repeat
    result := TransactionBegin(aTable);
    if result then
      exit;
    dec(Retries);
    if Retries<=0 then break;
    sleep(100);
  until false;
end;

const
  // log up to 20 KB of JSON response, to save space
  MAX_SIZE_RESPONSE_LOG = 20*1024;

function TSQLRestClientURI.CallBackGet(const aMethodName: RawUTF8;
  const aParameters: array of const; out aResponse: RawUTF8;
  aTable: TSQLRecordClass; aID: integer; aResponseHead: PRawUTF8): integer;
var header, params: RawUTF8;
begin
  if self=nil then
    result := HTML_UNAVAILABLE else begin
{$ifdef WITHLOG}
    SQLite3Log.Enter(Self,pointer(aMethodName));
{$endif}
    params := UrlEncode(aParameters);
    result := URI(Model.getURICallBack(aMethodName,aTable,aID)+params,'GET',
      @aResponse,@header).Lo;
    if aResponseHead<>nil then
      aResponseHead^ := header;
{$ifdef WITHLOG}
    if aResponse<>'' then
    with SQLite3Log.Family do
      if sllServiceReturn in Level then
        if IsHTMLContentTypeTextual(pointer(header)) then
          SynLog.Log(sllServiceReturn,aResponse,nil,MAX_SIZE_RESPONSE_LOG) else
          SynLog.Log(sllServiceReturn,'% bytes "%"',[length(aResponse),header]);
{$endif}
  end;
end;

{$ifdef SSPIAUTH}
const
  /// maximum number of Windows Authentication context to be handled
  // - 32 should be big enough
  MAXSSPIAUTHCONTEXTS = 32;
{$endif}

function TSQLRestClientURI.SetUser(const aUserName, aPassword: RawUTF8;
  aHashedPassword: Boolean=false): boolean;
var aNonce, aClientNonce, aSessionKey: RawUTF8;
    i: integer;
    U: TSQLAuthUser;
{$ifdef SSPIAUTH}
    SecCtx: TSecContext;
    InData, OutData: RawByteString;
    Response: RawUTF8;
    Values: TPUtf8CharDynArray;
    SecCtxId: RawUTF8;
{$endif}
begin
  result := false;
  if self=nil then
    exit;
  fSessionID := CONST_AUTHENTICATION_SESSION_NOT_STARTED;
  fSessionIDHexa8 := '';
  fSessionPrivateKey := 0;
  FreeAndNil(fSessionUser);
  try
    U := TSQLAuthUser.Create;
    try
      // 1. authenticate the user
      U.LogonName := trim(aUserName);
      if U.LogonName='' then begin
{$ifdef SSPIAUTH} // try Windows authentication with the current logged user
        InvalidateSecContext(SecCtx);
        try
          while ClientSSPIAuth(SecCtx, InData, OutData) do begin
            // 1st call will return SecCtxId, 2nd call aSessionKey
            if CallBackGet('auth',['UserName','','id',SecCtxId,'data',BinToBase64(OutData)],
              Response,nil,0)<>HTML_SUCCESS then
               exit;
            JSONDecode(Response,['result','id','data','logonname'], Values);
            aSessionKey := Values[0];
            U.LogonName := Values[3];
            if aSessionKey<>'' then
              break; 
            SecCtxId := Values[1];
            InData := Base64ToBin(Values[2]);
          end;
        finally
          FreeSecContext(SecCtx);
        end;
        U.PasswordHashHexa := SecCtxId; // override any password with context
        // authenticated by Windows on the server side: use the returned
        // aSessionKey + PasswordHashHexa to sign the URI, as usual
{$else}
        exit; // mORMot internal authentication expects a LogonName
{$endif}
      end
      else begin
        if aHashedPassword then
          U.PasswordHashHexa := aPassword else
          U.PasswordPlain := aPassword; // PasswordHashHexa := SHA256('salt'+aPassword);
        aNonce := CallBackGetResult('auth',['UserName',U.LogonName]);
        if aNonce='' then
          exit;
        aClientNonce := SHA256(NowToString);
        aSessionKey := CallBackGetResult('auth',['UserName',U.LogonName,'Password',
           Sha256(Model.Root+aNonce+aClientNonce+U.LogonName+U.PasswordHashHexa),
           'ClientNonce',aClientNonce]);
      end;
      // 2. register the user session to the TSQLRestClientURI instance
      i := PosEx(RawUTF8('+'),aSessionKey,1);
      if i=0 then
        exit; // expect SessionID+HexaSessionPrivateKey
      fSessionID := GetCardinal(pointer(aSessionKey));
      if fSessionID=0 then
        exit;
      fSessionIDHexa8 := CardinalToHex(fSessionID);
      fSessionPrivateKey := crc32(crc32(0,Pointer(aSessionKey),length(aSessionKey)),
        pointer(U.PasswordHashHexa),length(U.PasswordHashHexa));
      fSessionUser := U;
      U := nil;
      result := true;
    finally
      U.Free;
    end;
  finally
    if Assigned(OnSetUser) then
      OnSetUser(self); // always notify of user change, even if failed
   end;
end;

procedure TSQLRestClientURI.SetLastException(E: Exception; ErrorCode: integer);
begin
  fLastErrorCode := ErrorCode;
  if E=nil then begin
    fLastErrorException := nil;
    if ErrorCode=HTML_SUCCESS then
      fLastErrorMessage := '' else
      StatusCodeToErrorMsg(ErrorCode,fLastErrorMessage);
  end else begin
    fLastErrorException := PPointer(E)^;
    StringToUTF8(E.Message,fLastErrorMessage);
  end;
end;

function TSQLRestClientURI.URI(const url, method: RawUTF8;
  Resp, Head, SendData: PRawUTF8): Int64Rec;
var Retry: integer;
    aUserName, aPassword: string;
    aUrl, aResp: RawUTF8;
begin
  if self=nil then begin
    Int64(result) := HTML_UNAVAILABLE;
    SetLastException(nil,HTML_UNAVAILABLE);
    exit;
  end;
  fLastErrorMessage := '';
  fLastErrorException := nil;
  if fServerTimeStampOffset=0 then
    if not ServerTimeStampSynchronize then begin
      Int64(result) := HTML_UNAVAILABLE;
      exit; // if /TimeStamp is not available, server is down!
    end;
  for Retry := -1 to MaximumAuthentificationRetry do
  try
    aUrl := SessionSign(url);
    result := InternalURI(aUrl,method,@aResp,Head,SendData);
    if result.Lo=HTML_NOTIMPLEMENTED then begin // InternalCheckOpen failed
      InternalClose; // force recreate connection
      result := InternalURI(aUrl,method,@aResp,Head,SendData); // try again
    end;
    if Resp<>nil then
      Resp^ := aResp;
    fLastErrorCode := result.Lo;
    if not (result.Lo in [HTML_SUCCESS,HTML_CREATED]) then
      if aResp='' then
        StatusCodeToErrorMsg(result.Lo,fLastErrorMessage) else
        fLastErrorMessage := aResp;
    if (result.Lo<>HTML_FORBIDDEN) or not Assigned(OnAuthentificationFailed) then
      break;
    // "403 Forbidden" in case of authentication failure -> try relog
    if not OnAuthentificationFailed(Retry+2,aUserName,aPassword) or
       not SetUser(StringToUTF8(aUserName),StringToUTF8(aPassword)) then
      break;
  except
    on E: Exception do begin
      Int64(result) := HTML_NOTIMPLEMENTED; // 501
      SetLastException(E,HTML_NOTIMPLEMENTED);
      exit;
    end;
  end;
end;

function TSQLRestClientURI.SessionSign(const url: RawUTF8): RawUTF8;
  procedure Sign; // avoid try..finally if authentication is not needed
  var Nonce: RawUTF8;
      Tix: cardinal;
  begin // timestamps have 256 ms resolution
    if PosEx(RawUTF8('?'),url,1)=0 then
      result := url+'?session_signature=' else
      result := url+'&session_signature=';
    Tix := GetTickCount;
    if Tix<fSessionLastTickCount then // wrap around 0 after 49.7 days
      inc(fSessionTickCountOffset,1 shl(32-8)); // allows 35 years timing
    fSessionLastTickCount := Tix;
    Nonce := CardinalToHex(Tix shr 8+fSessionTickCountOffset);
    result := result+fSessionIDHexa8+Nonce+CardinalToHex(
      crc32(crc32(fSessionPrivateKey,Pointer(Nonce),length(Nonce)),Pointer(url),length(url)));
    // Hexa8(SessionID)+Hexa8(TimeStamp)+
    // Hexa8(crc32('SessionID+HexaSessionPrivateKey'+Sha256('salt'+PassWord)+
    //   Hexa8(TimeStamp)+url))
  end;
begin
  if (fSessionID=0) or (fSessionUser=nil) then
    result := url else
    Sign;
end;

function TSQLRestClientURI.CallBackGetResult(const aMethodName: RawUTF8;
  const aParameters: array of const; aTable: TSQLRecordClass; aID: integer): RawUTF8;
var aResponse: RawUTF8;
begin
  if CallBackGet(aMethodName,aParameters,aResponse,aTable,aID)=HTML_SUCCESS then
    result := JSONDecode(aResponse) else
    result := '';
end;

function TSQLRestClientURI.CallBackPut(const aMethodName,
  aSentData: RawUTF8; out aResponse: RawUTF8; aTable: TSQLRecordClass;
  aID: integer; aResponseHead: PRawUTF8): integer;
begin
  if self=nil then
    result := HTML_UNAVAILABLE else begin
{$ifdef WITHLOG}
    SQLite3Log.Enter(self,pointer(aMethodName));
{$endif}
    result := URI(Model.getURICallBack(aMethodName,aTable,aID),
      'PUT',@aResponse,aResponseHead,@aSentData).Lo;
{$ifdef WITHLOG}
    SQLite3Log.Add.Log(sllServiceReturn,'result=%',result);
{$endif}
  end;
end;

function TSQLRestClientURI.ServiceRegister(const aInterfaces: array of PTypeInfo;
  aInstanceCreation: TServiceInstanceImplementation=sicSingle;
  const aContractExpected: RawUTF8=''): boolean;
begin
  result := False;
  if (self=nil) or (high(aInterfaces)<0) then
    exit;
  if fServices=nil then
    fServices := TServiceContainerClient.Create(self);
  result := (fServices as TServiceContainerClient).AddInterface(
    aInterfaces,aInstanceCreation,aContractExpected);
end;

function TSQLRestClientURI.ServiceRegister(aInterface: PTypeInfo;
  aInstanceCreation: TServiceInstanceImplementation=sicSingle;
  const aContractExpected: RawUTF8=''): TServiceFactory;
begin
  result := nil;
  if (self=nil) or (aInterface=nil) then begin
    SetLastException;
    exit;
  end;
  if fServices=nil then
    fServices := TServiceContainerClient.Create(self);
  with fServices as TServiceContainerClient do
  try
    result := AddInterface(aInterface,aInstanceCreation,aContractExpected);
  except
    on E: Exception do
      SetLastException(E);
  end;
end;

function TSQLRestClientURI.ServiceRegisterClientDriven(aInterface: PTypeInfo;
  out Obj; const aContractExpected: RawUTF8=''): boolean;
var Factory: TServiceFactory;
begin
  Factory := ServiceRegister(aInterface,sicClientDriven,aContractExpected);
  if Factory<>nil then begin
    result := true;
    Factory.Get(Obj);
  end else
    result := false;
end;

procedure TSQLRestClientURI.BatchAbort;
begin
  if self<>nil then begin
    fBatchCount := 0;
    fBatchTable := nil;
    FreeAndNil(fBatch);
  end;
end;

function TSQLRestClientURI.BatchAdd(Value: TSQLRecord; SendData: boolean;
  ForceID: boolean=false): integer;
var Props: TSQLRecordProperties;
begin
  result := -1;
  if (self=nil) or (Value=nil) or (fBatch=nil) then
    exit; // invalid parameters, or not opened BATCH sequence
  Props := Value.RecordProps;
  if fBatchTable<>nil then
    if Value.RecordClass<>fBatchTable then
      exit else // '{"Table":[...,"POST":{object},...]}'
      fBatch.AddShort('"POST":') else begin
      fBatch.AddShort('"POST@'); // '[...,"POST@Table":{object}',...]'
      fBatch.AddString(Props.SQLTableName);
      fBatch.Add('"',':');
    end;
  if SendData then begin
    if Model.Props[PSQLRecordClass(Value)^].Kind in INSERT_WITH_ID then
      ForceID := true; // same format as TSQLRestClient.Add
    Props.SetSimpleFieldsExpandedJSONWriter(fBatch,(Value.fID<>0) and ForceID,soInsert);
    Value.ComputeFieldsBeforeWrite(self,seAdd); // update TModTime/TCreateTime fields
    Value.GetJSONValues(fBatch);
    if ForceID then
      fCache.Notify(Value,soInsert);
  end else
    fBatch.Add('{','}'); // '{"Table":[...,"POST":{},...]}'
  fBatch.Add(',');
  result := fBatchCount;
  inc(fBatchCount);
end;

function TSQLRestClientURI.BatchCount: integer;
begin
  if self=nil then
    result := 0 else
    result := fBatchCount;
end;

function TSQLRestClientURI.BatchDelete(ID: integer): integer;
begin
  if (self=nil) or (fBatchTable=nil) or
     (ID<=0) or not RecordCanBeUpdated(fBatchTable,ID,seDelete) then begin
    result := -1; // invalid parameters, or not opened BATCH sequence
    exit;
  end;
  fCache.NotifyDeletion(fBatchTable,ID);
  fBatch.AddShort('"DELETE":'); // '{"Table":[...,"DELETE":ID,...]}'
  fBatch.Add(ID);
  fBatch.Add(',');
  result := fBatchCount;
  inc(fBatchCount);
end;

function TSQLRestClientURI.BatchDelete(Table: TSQLRecordClass; ID: integer): integer;
begin
  if (self=nil) or (fBatch=nil) or (Table=nil) or
     (ID<=0) or not RecordCanBeUpdated(Table,ID,seDelete) then begin
    result := -1; // invalid parameters, or not opened BATCH sequence
    exit;
  end;
  fCache.NotifyDeletion(Table,ID);
  fBatch.AddShort('"DELETE@'); // '[...,"DELETE@Table":ID,...]}'
  fBatch.AddString(Table.RecordProps.SQLTableName);
  fBatch.Add('"',':');
  fBatch.Add(ID);
  fBatch.Add(',');
  result := fBatchCount;
  inc(fBatchCount);
end;

function TSQLRestClientURI.BatchSend(var Results: TIntegerDynArray): integer;
var Data, Resp: RawUTF8;
    R: PUTF8Char;
    i: integer;
begin
  if (self=nil) or (fBatch=nil) then // no opened BATCH sequence
    result := HTML_BADREQUEST else
  try
    if fBatchCount>0 then begin // if something to send
      fBatch.CancelLastComma;
      fBatch.Add(']');
      if fBatchTable<>nil then
        fBatch.Add('}'); // end sequence array '{"Table":["cmd":values,...]}'
      fBatch.SetText(Data);
      if fBatchTable<>nil then
        // URI is 'ModelRoot/TableName/0' with POST method
        result := URI(Model.URI[fBatchTable]+'/0','POST',@Resp,nil,@Data).Lo else
        // URI is 'ModelRoot/Batch' with PUT method
        result := URI(Model.Root+'/Batch','PUT',@Resp,nil,@Data).Lo;
      if result<>HTML_SUCCESS then
        exit;
      // returned Resp shall be an array of integers: '[200,200,...]'
      R := pointer(Resp);
      if R<>nil then
        while R^<>'[' do inc(R);
      result := HTML_BADREQUEST;
      if (R=nil) or (R^<>'[') then
        // invalid response
        exit;
      SetLength(Results,fBatchCount);
      if IdemPChar(R,'["OK"]') then begin // to save bandwith if no adding
        for i := 0 to fBatchCount-1 do
          Results[i] := HTML_SUCCESS;
      end else begin
        inc(R); // jump first '['
        for i := 0 to fBatchCount-1 do begin
          Results[i] := GetJSONIntegerVar(R);
          while R^ in [#1..' '] do inc(R);
          case R^ of
            ',': inc(R);
            ']': break;
            else exit;
          end;
        end;
        if R^<>']' then
          exit;
      end;
    end;
    result := HTML_SUCCESS; // returns OK
  finally
    BatchAbort;
  end;
end;

function TSQLRestClientURI.BatchStart(aTable: TSQLRecordClass): boolean;
begin
  if (self=nil) or (fBatchCount>0) or (fBatch<>nil) then begin
    // already opened BATCH sequence
    result := false;
    exit;
  end;
  fBatch := TJSONSerializer.CreateOwnedStream;
  if aTable<>nil then begin
    fBatch.Add('{'); // sending data is '{"Table":["cmd":values,...]}'
    fBatch.AddFieldName(aTable.SQLTableName);
  end;
  fBatch.Add('[');
  fBatchTable := aTable;
  fBatchCount := 0;
  result := true;
end;

function TSQLRestClientURI.BatchUpdate(Value: TSQLRecord): integer;
var FillPrepareFields: boolean;
    Props: TSQLRecordProperties;
begin
  result := -1;
  if (self=nil) or (Value=nil) or (fBatch=nil) or (Value.fID<=0) or
     not RecordCanBeUpdated(Value.RecordClass,Value.fID,seUpdate) or
     not BeforeUpdateEvent(Value) then
    exit; // invalid parameters, or not opened BATCH sequence
  Props := Value.RecordProps;
  if fBatchTable<>nil then
    if Value.RecordClass<>fBatchTable then
      exit else // '{"Table":[...,"PUT":{object},...]}'
      fBatch.AddShort('"PUT":') else begin
      fBatch.AddShort('"PUT@'); // '[...,"PUT@Table":{object}',...]'
      fBatch.AddString(Props.SQLTableName);
      fBatch.Add('"',':');
    end;
  // same format as TSQLRestClientURI.Update, BUT including the ID
  FillPrepareFields := (Value.fFill<>nil) and (Value.fFill.Table<>nil) and
     (Value.fFill.fTableMapRecordManyInstances=nil);
  if FillPrepareFields then
    // update ID, TModTime and FillPrepare-mapped fields
    Value.fFill.SetMappedFieldsExpandedJSONWriter(Value.RecordClass,fBatch) else
    // update all simple fields (also for FillPrepareMany)
    Value.RecordClass.RecordProps.SetSimpleFieldsExpandedJSONWriter(fBatch,true,soUpdate);
  Value.ComputeFieldsBeforeWrite(self,seUpdate); // update sftModTime fields
  Value.GetJSONValues(fBatch);
  fBatch.Add(',');
  if FillPrepareFields then // may not contain all fields -> delete from cache
    fCache.NotifyDeletion(Value.RecordClass,Value.fID) else
    fCache.Notify(Value,soUpdate);
  result := fBatchCount;
  inc(fBatchCount);
end;

function TSQLRestClientURI.EngineAdd(Table: TSQLRecordClass;
  const SentData: RawUTF8): integer;
var P: PUTF8Char;
    Head: RawUTF8;
begin
  result := 0;
  if URI(Model.URI[Table],'POST',nil,@Head,@SentData).Lo<>HTML_CREATED then
    exit; // response must be '201 Created'
  P := pointer(Head); // we need to check the headers
  if P<>nil then
  repeat
    // find ID from 'Location: Member Entry URI' header entry
    if IdemPChar(P,'LOCATION:') then begin // 'Location: root/People/11012' e.g.
      inc(P,9);
      while P^>#13 do inc(P); // go to end of line
      P^ := #0; // make line asciiz, even if ended with #13
      while P[-1] in ['0'..'9'] do dec(P); // get all number chars
      if P[-1]='-' then dec(P); 
      result := GetInteger(P); // get numerical value at the end of the URI
      exit;
    end;
    while not (P^ in [#0,#13]) do inc(P);
    if P^=#0 then break else inc(P);
    if P^=#10 then inc(P);
  until false;
end;

function TSQLRestClientURI.EngineDelete(Table: TSQLRecordClass; ID: integer): boolean;
begin
  result := URI(Model.getURIID(Table,ID),'DELETE').Lo=HTML_SUCCESS;
end;

function TSQLRestClientURI.EngineDeleteWhere(Table: TSQLRecordClass;
  const SQLWhere: RawUTF8; const IDs: TIntegerDynArray): boolean;
begin  // ModelRoot/TableName?where=WhereClause to delete members
  result := URI(Model.getURI(Table)+'?where='+UrlEncode(SQLWhere),'DELETE').Lo=HTML_SUCCESS;
end;

function TSQLRestClientURI.EngineList(const SQL: RawUTF8;
  ForceAJAX: Boolean; ReturnedRowCount: PPtrInt): RawUTF8;
begin
  if (self=nil) or (SQL='') or (ReturnedRowCount<>nil) or
     (URI(Model.Root,'GET',@result,nil,@SQL).Lo<>HTML_SUCCESS) then
    result := ''
end;

function TSQLRestClientURI.EngineRetrieve(TableModelIndex, ID: integer;
  ForUpdate: boolean; var InternalState: cardinal; var Resp: RawUTF8): boolean;
begin
  if cardinal(TableModelIndex)<=cardinal(Model.fTablesMax) then
  with URIGet(Model.Tables[TableModelIndex],ID,Resp,ForUpdate) do
    if Lo=HTML_SUCCESS then begin
      InternalState := Hi;
      result := true;
    end else
      result := false else
      result := false;
end;

function TSQLRestClientURI.EngineRetrieveBlob(Table: TSQLRecordClass;
  aID: integer; BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean;
begin
  if (self=nil) or (aID<=0) or (BlobField=nil) then
    result := false else
    // URI is 'ModelRoot/TableName/ID/BlobFieldName' with GET method
    result := URI(Model.getURICallBack(BlobField^.Name,Table,aID),
      'GET',@BlobData).Lo=HTML_SUCCESS;
end;

function TSQLRestClientURI.EngineUpdate(Table: TSQLRecordClass;
  ID: integer; const SentData: RawUTF8): boolean;
begin
  result := URI(Model.getURIID(Table,ID),'PUT',nil,nil,@SentData).Lo=HTML_SUCCESS;
end;

function TSQLRestClientURI.EngineUpdateBlob(Table: TSQLRecordClass;
  aID: integer; BlobField: PPropInfo;
  const BlobData: TSQLRawBlob): boolean;
var Head: RawUTF8;
begin
  Head := 'Content-Type: application/octet-stream';
  if (self=nil) or (aID<=0) or (BlobField=nil) then
    result := false else
    // PUT ModelRoot/TableName/ID/BlobFieldName 
    result := URI(FormatUTF8('%/%/%',[Model.URI[Table],aID,BlobField^.Name]),
       'PUT',nil,@Head,@BlobData).Lo=HTML_SUCCESS;
end;

function TSQLRestClientURI.EngineUpdateField(Table: TSQLRecordClass;
  const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean;
begin
  if (self=nil) or (Table=nil) then
    result := false else
    // PUT ModelRoot/TableName?setname=..&set=..&wherename=..&where=..
    result := URI(FormatUTF8('%?setname=%&set=%&wherename=%&where=%',
      [Model.URI[Table],SetFieldName,UrlEncode(SetValue),WhereFieldName,
       UrlEncode(WhereValue)]),'PUT').Lo=HTML_SUCCESS;
end;


{ TSQLRestServer }

{$ifdef MSWINDOWS}
const
  ServerPipeNamePrefix: TFileName = '\\.\pipe\mORMot_';

var
  GlobalURIRequestServer: TSQLRestServer = nil;

function URIRequest(url, method, SendData: PUTF8Char; Resp, Head: PPUTF8Char): Int64Rec; cdecl;
function StringToPCharCopy(const s: RawUTF8): PUTF8Char;
var L: integer;
begin
  L := length(s);
  if L=0 then
    result := nil else begin
    inc(L); // copy also last #0 from s
    if USEFASTMM4ALLOC then
      GetMem(result,L) else
      result := pointer(GlobalAlloc(GMEM_FIXED,L));
    move(pointer(s)^,result^,L);
  end;
end;
var call: TSQLRestServerURIParams;
begin
  if GlobalURIRequestServer=nil then begin
    Int64(result) := HTML_NOTIMPLEMENTED; // 501 
    exit;
  end;
  call.Url := url;
  call.Method := method;
  call.InHead := 'RemoteIP: 127.0.0.1'#13#10'ConnectionID: 0001';
  if Head<>nil then
    call.InHead := RawUTF8(Head^)+#13#10+call.InHead;
  call.InBody := SendData;
  call.RestAccessRights := @SUPERVISOR_ACCESS_RIGHTS;
  GlobalURIRequestServer.URI(call);
  result.Lo := call.OutStatus;
  result.Hi := call.OutInternalState;
  if Head<>nil then
    Head^ := StringToPCharCopy(call.OutHead);
  if Resp<>nil then
    Resp^ := StringToPCharCopy(call.OutBody); 
end;

function ReadString(Handle: cardinal): RawUTF8;
var L, Read: cardinal;
    P: PUTF8Char;
begin
  result := '';
  if (FileRead(Handle,L,4)=4) and (L<>0) then begin
    SetLength(result,L);
    P := pointer(result);
    repeat
      Read := FileRead(Handle,P^,L);
      if Read=0 then begin
        sleep(100); // nothing available -> wait a little and retry
        Read := FileRead(Handle,P^,L);
        if Read=0 then begin // server may be down -> abort
          raise ECommunicationException.Create('ReadString');
          exit;
        end;
      end;
      inc(P,Read);
      dec(L,Read);
    until L=0; // loop until received all expected data
  end;
end;

procedure WriteString(Handle: cardinal; const Text: RawUTF8);
var L: cardinal;
begin
  L := length(Text);
  if L=0 then
    // write cardinal 0 if Text=''
    FileWrite(Handle,L,4) else
    // write length+content at once
    FileWrite(Handle,pointer(PtrInt(Text)-4)^,L+4);
end;

function TSQLRestServer.ExportServerNamedPipe(const ServerApplicationName: TFileName): boolean;
var PipeName: TFileName;
    Pipe: THandle;
begin
  result := false;
  if fExportServerNamedPipeThread<>nil then
    exit; // only one ExportServer() by running process
  if {$ifdef UNICODE}IdemPCharW{$else}IdemPChar{$endif}(pointer(ServerApplicationName),'\\') then
    PipeName := ServerApplicationName else
    PipeName := ServerPipeNamePrefix+ServerApplicationName;
  Pipe := FileOpen(PipeName,fmOpenReadWrite); // is this pipe existing?
  if Pipe<>Invalid_Handle_Value then begin
    WriteString(Pipe,''); // send integer=0 -> force server disconnect
    FileClose(Pipe);
    exit; // only one pipe server with this name at once
  end;
  fExportServerNamedPipeThread := TSQLRestServerNamedPipe.Create(self, PipeName);
  NoAJAXJSON := true; // use smaller JSON size in this not HTTP use (never AJAX)
  result := true; // success
end;

function TSQLRestServer.ExportServerMessage(const ServerWindowName: string): boolean;
begin
  result := false;
  if (self=nil) or (fServerWindow<>0) then
    exit;  // only one ExportServerMessage() by running process
  fServerWindow := CreateInternalWindow(ServerWindowName,self);
  if fServerWindow=0 then
    exit; // impossible to create window -> fail
  fServerWindowName := ServerWindowName;
  result := true;
end;

const
  MAGIC_SYN: cardinal = $A5ABA5AB;

procedure TSQLRestServer.AnswerToMessage(var Msg: TWMCopyData);
var call: TSQLRestServerURIParams;
    P: PUTF8Char;
    Res: packed record
      Magic: cardinal;
      Status: cardinal;
      InternalState: cardinal;
    end;
    Data: TCopyDataStruct;
    Header, ResStr: RawUTF8;
begin
  Msg.Result := HTML_NOTFOUND;
  if (self=nil) or (Msg.From=0) then
    exit;
  P := Msg.CopyDataStruct^.lpData;
  if (P=nil) or (Msg.CopyDataStruct^.cbData<=7) then
    exit;
  if PCardinal(P)^<>MAGIC_SYN then
    exit; // invalid layout: a broadcasted WM_COPYDATA message? :(
  inc(P,4);
  // #1 is a field delimiter below, since Get*Item() functions return nil for #0
  Msg.Result := HTML_SUCCESS; // Send something back
  call.Url := GetNextItem(P,#1);
  call.Method := GetNextItem(P,#1);
  call.InHead := GetNextItem(P,#1);
  Header := 'RemoteIP: 127.0.0.1'#13#10'ConnectionID: '+CardinalToHex(Msg.From);
  if call.InHead='' then
    call.InHead := Header else
    call.InHead := call.InHead+#13#10+Header;
  with Msg.CopyDataStruct^ do
    SetString(call.InBody,P,PtrInt(cbData)-(P-lpData));
  call.RestAccessRights := @SUPERVISOR_ACCESS_RIGHTS;
  // note: it's up to URI overriden method to implement access rights
  URI(call);
  Res.Magic := MAGIC_SYN;
  Res.Status := call.OutStatus;
  Res.InternalState := call.OutInternalState;
  SetString(ResStr,PAnsiChar(@Res),sizeof(Res));
  ResStr := ResStr+call.OutHead+#1+call.OutBody;
  Data.dwData := fServerWindow;
  Data.cbData := length(ResStr);
  Data.lpData := pointer(ResStr);
  SendMessage(Msg.From,WM_COPYDATA,fServerWindow,PtrInt(@Data));
end;

function TSQLRestServer.CloseServerNamedPipe: boolean;
begin
  if fExportServerNamedPipeThread<>nil then begin
    fExportServerNamedPipeThread.Terminate;
    Sleep(200); // we have sleep(128) in TSQLRestServerNamedPipe.EngineExecute
    FreeAndNil(fExportServerNamedPipeThread);
    result := true;
  end else
    result := false;
end;

function TSQLRestServer.CloseServerMessage: boolean;
begin
  result := ReleaseInternalWindow(fServerWindowName,fServerWindow);
end;

function TSQLRestServer.ExportServer: boolean;
begin
  if (fServerWindow<>0) or (fExportServerNamedPipeThread<>nil) then
    result := false else // another server was running
  if (GlobalURIRequestServer=nil) or (GlobalURIRequestServer=self) then begin
    GlobalURIRequestServer := self;
    result := true;
  end else
    result := false;
end;

{$endif MSWINDOWS}

constructor TSQLRestServer.Create(aModel: TSQLModel; aHandleUserAuthentication: boolean);
var i,n: integer;
    C: PtrInt;
    M: PMethodInfo;
//    RI: PReturnInfo; // such RTTI info not available at least in Delphi 7
begin
  // specific server initialization
  fVirtualTableDirect := true; // faster direct Static call by default
  fAuthUserIndex := aModel.GetTableIndex(TSQLAuthUser);
  fAuthGroupIndex := aModel.GetTableIndex(TSQLAuthGroup);
  if aHandleUserAuthentication then begin
    fHandleAuthentication := true;
    // we need both AuthUser+AuthGroup tables for authentication -> create now
    if fAuthUserIndex<0 then
      aModel.AddTable(TSQLAuthUser,@fAuthUserIndex);
    if fAuthGroupIndex<0 then
      aModel.AddTable(TSQLAuthGroup,@fAuthGroupIndex);
  end;
  // abstract MVC initalization
  inherited Create(aModel);
  fStats := TSQLRestServerStats.Create;
  URIPagingParameters := PAGINGPARAMETERS_YAHOO;
  InitializeCriticalSection(fSessionCriticalSection);
{$ifdef SSPIAUTH}
  InitializeCriticalSection(fSSPIAuthCriticalSection);
  fSSPIAuthCounter := 1;
{$endif}
  // retrieve published methods
  fPublishedMethods.Init(false);
  C := PtrInt(ClassType);
  while C<>0 do begin
    M := PPointer(C+vmtMethodTable)^;
    if M<>nil then begin
      {$ifdef FPC}
      n := PCardinal(M)^;
      inc(PCardinal(M));
      for i := 1 to n do begin
        fPublishedMethods.Add(M^.Name^,'',PtrInt(M^.Addr));
        inc(M);
      end;
      {$else}
      n := PWord(M)^;
      inc(PWord(M));
      for i := 1 to n do begin
{        RI := M^.ReturnInfo;
        if (RI=nil) or
           ((RI<>nil) and (RI^.ParamCount=1) and (RI^.CallingConvention=ccRegister) and
            (RI^.ReturnType<>nil) and (RI^.ReturnType^.Kind=tkInteger) and
            (RI^.Param^.ParamType^=TypeInfo(TSQLRestServerCallBackParams)) and
            (pfVar in RI^.Param^.Flags)) then }
        fPublishedMethods.Add(M^.Name,'',PtrInt(M^.Addr));
        inc(PByte(M),M^.Len);
      end;
      {$endif}
    end;
    C := PPtrInt(C+vmtParent)^;
    if C=0 then
      break else
      C := PPtrInt(C)^;
  end;
  ServiceMethodByPassAuthentication('Auth');
  ServiceMethodByPassAuthentication('TimeStamp');
end;

destructor TSQLRestServer.Destroy;
var i: integer;
begin
{$ifdef WITHLOG}
  if not InheritsFrom(TSQLRestServerStatic) then
    SQLite3Log.Add.Log(sllInfo,Stats.DebugMessage,self);
{$endif}
{$ifdef MSWINDOWS}
  if GlobalURIRequestServer=self then begin
    GlobalURIRequestServer := nil;
    sleep(200); // way some time any request is finished in another thread
  end;
  // close any running named-pipe or GDI-messages server instance
  CloseServerNamedPipe;
  CloseServerMessage;
{$endif}
  for i := 0 to high(fStaticData) do
    // free all TSQLRestServerStatic objects and update file if necessary
    fStaticData[i].Free;
  fSessions.Free;
  DeleteCriticalSection(fSessionCriticalSection);
{$ifdef SSPIAUTH}
  for i := 0 to High(fSSPIAuthContexts) do
    FreeSecContext(fSSPIAuthContexts[i]);
  DeleteCriticalSection(fSSPIAuthCriticalSection);
{$endif}
  fStats.Free;
  inherited;
end;

function TSQLRestServer.GetStaticDataServer(aClass: TSQLRecordClass): TSQLRestServerStatic;
begin
  if (self<>nil) and (fStaticData<>nil) then
   result := fStaticData[Model.GetTableIndexExisting(aClass)] else
   result := nil;
end;

function TSQLRestServer.GetStaticDataServerOrVirtualTable(aClass: TSQLRecordClass): TSQLRestServerStatic;
begin
  if (fStaticData=nil) and (fStaticVirtualTable=nil) then
    result := nil else
    result := GetStaticDataServerOrVirtualTable(Model.GetTableIndexExisting(aClass));
end;

function TSQLRestServer.GetStaticDataServerOrVirtualTable(aTableIndex: integer): TSQLRestServerStatic;
begin
  result := nil;
  if aTableIndex>=0 then begin
    if fStaticData<>nil then
      result := fStaticData[aTableIndex];
    if (result=nil) and fVirtualTableDirect and (fStaticVirtualTable<>nil) then
      result := fStaticVirtualTable[aTableIndex];
  end;
end;

function TSQLRestServer.GetVirtualTable(aClass: TSQLRecordClass): TSQLRestServerStatic;
var i: integer;
begin
  result := nil;
  if fStaticVirtualTable<>nil then begin
    i := Model.GetTableIndexExisting(aClass);
    if (i>=0) and (Model.TableProps[i].Kind in IS_CUSTOM_VIRTUAL) then
      result := fStaticVirtualTable[i];
  end;
end;

function TSQLRestServer.StaticDataCreate(aClass: TSQLRecordClass;
  const aFileName: TFileName; aBinaryFile: boolean;
  aServerClass: TSQLRestServerStaticClass): TSQLRestServerStatic;
var i: integer;
begin
  result := nil;
  i := Model.GetTableIndexExisting(aClass);
  if fStaticData<>nil then
    result := fStaticData[i];
  if result<>nil then
    // class already registered -> update file name
    result.fFileName := aFileName else begin
    // class not already registered -> register now
    if aServerClass=nil then
      aServerClass := TSQLRestServerStaticInMemory; // default in-memory engine
    result := aServerClass.Create(aClass,self,aFileName,aBinaryFile);
    if fStaticData=nil then
      SetLength(fStaticData,length(Model.Tables));
    fStaticData[i] := result;
  end;
end;

procedure TSQLRestServer.FlushInternalDBCache;
begin
  // do nothing by default
end;

function SQLGetOrder(const SQL: RawUTF8): RawUTF8;
var P: PUTF8Char;
    i: integer;
begin
  i := PosI('ORDER BY ',SQL);
  if i>0 then begin
    inc(i,9);
    while SQL[i] in [#1..' '] do inc(i); // trim left
    result := copy(SQL,i,maxInt);
    P := PosChar(Pointer(Result),' ');
    if P=nil then
      P := PosChar(Pointer(Result),';');
    if P<>nil then
      SetLength(result,P-pointer(Result)); // trim right
  end;
  if result='' then // by default, a SQLite3 query is ordered by ID
    result := 'RowID';
end;

procedure TSQLRestServer.SetNoAJAXJSON(const Value: boolean);
var i: integer;
begin
  fNoAJAXJSON := Value;
  for i := 0 to high(fStaticData) do
    if fStaticData[i]<>nil then
      fStaticData[i].NoAJAXJSON := Value; // set JSON format for static also
end;

function TSQLRestServer.InternalAdaptSQL(TableIndex: integer; var SQL: RawUTF8): TSQLRestServerStatic;
begin
  result := nil;
  if (self<>nil) and (TableIndex>=0) then begin // SQL refers to this unique table
    if fStaticData<>nil then
      // no SQLite3 module available for fStaticData[] -> we need to
      // retrieve manualy any static table from the SQL SELECT statement
      result := fStaticData[TableIndex];
    if (result=nil) and fVirtualTableDirect and (fStaticVirtualTable<>nil) then begin
      result := fStaticVirtualTable[TableIndex];
      // virtual table may need adaptation (e.g. RowID -> ID)
      if (result<>nil) and not result.AdaptSQLForEngineList(SQL) then
        // complex request will use SQlite3 virtual engine module
        result := nil;
    end;
  end;
end;

function TSQLRestServer.InternalListRawUTF8(TableIndex: integer; const SQL: RawUTF8): RawUTF8;
var aSQL: RawUTF8;
    Static: TSQLRestServerStatic;
begin
  aSQL := SQL;
  Static := InternalAdaptSQL(TableIndex,aSQL);
  if Static<>nil then
     // this SQL statement is handled by direct connection, faster adaptation
    result := Static.EngineList(aSQL) else
    // complex TSQLVirtualTableJSON/External queries will rely on virtual table
    result := EngineList(SQL);
  if result='[]'#$A then
    result := '';
end;

function TSQLRestServer.InternalListJSON(Table: TSQLRecordClass; const SQL: RawUTF8): TSQLTableJSON;
var JSON: RawUTF8;
begin
  JSON := InternalListRawUTF8(Model.GetTableIndexExisting(Table),SQL);
  if JSON<>'' then
    result := TSQLTableJSON.Create([Table],SQL,JSON) else
    result := nil;
end;

function TSQLRestServer.Retrieve(aID: integer; Value: TSQLRecord;
  ForUpdate: boolean): boolean;
var TableIndex: integer; // used by EngineRetrieve() for SQL statement caching
    Resp: RawUTF8;
    Static: TSQLRestServerStatic;
begin // this version handles locking and use fast EngineRetrieve() method
  // check parameters
  result := false;
  if Value=nil  then
    exit; // avoid GPF
  Value.fID := 0;
  if (self=nil) or (aID=0) then
    exit;
  TableIndex := Model.GetTableIndexExisting(PSQLRecordClass(Value)^);
  // try to lock before retrieval (if ForUpdate)
  if ForUpdate and not Model.Lock(TableIndex,aID) then
    exit;
  // try to retrieve existing JSON from internal cache
  Resp := fCache.Retrieve(TableIndex,aID);
  if Resp='' then begin
    // get JSON object '{...}' in Resp from corresponding EngineRetrieve() method
    Static := GetStaticDataServerOrVirtualTable(TableIndex);
    if Static<>nil then
      Resp := Static.EngineRetrieve(TableIndex,aID) else
      Resp := EngineRetrieve(TableIndex,aID);
    if Resp='' then
      exit;
  end;
  // fill Value from JSON if was correctly retrieved
  Value.FillFrom(Resp);
  result := true;
end;

function TSQLRestServer.ExecuteList(const Tables: array of TSQLRecordClass; const SQL: RawUTF8): TSQLTableJSON;
var JSON: RawUTF8;
begin
  JSON := EngineList(SQL,false);
  if JSON<>'' then
    result := TSQLTableJSON.Create(Tables,SQL,JSON) else
    result := nil;
end;

function TSQLRestServer.UnLock(Table: TSQLRecordClass; aID: integer): boolean;
begin
  result := Model.UnLock(Table,aID);
end;

procedure TSQLRestServer.Commit(SessionID: cardinal);
var i: integer;
begin
  inherited Commit(SessionID);
  if self<>nil then
    for i := 0 to high(fStaticVirtualTable) do
    if fStaticVirtualTable[i]<>nil then
    with TSQLRestServerStaticInMemory(fStaticVirtualTable[i]) do 
      if InheritsFrom(TSQLRestServerStaticInMemory) and not CommitShouldNotUpdateFile then
        UpdateFile; // will do nothing if not Modified
end;

function TSQLRestServer.Add(Value: TSQLRecord; SendData: boolean;
  ForceID: boolean=false): integer;
var JSONValues: RawUTF8;
    Static: TSQLRestServerStatic;
begin
  if (self=nil) or (Value=nil) then begin
    result := 0;
    exit;
  end;
  if SendData then begin
    Value.ComputeFieldsBeforeWrite(self,seAdd); // update TModTime/TCreateTime fields
    if Model.Props[PSQLRecordClass(Value)^].Kind in INSERT_WITH_ID then
      ForceID := true;
    JSONValues := Value.GetJSONValues(true, // true=expanded
      (Value.fID<>0) and ForceID,soInsert);
  end else
    JSONValues := '';
  // on success, returns the new ROWID value; on error, returns 0
  Static := GetStaticDataServerOrVirtualTable(PSQLRecordClass(Value)^);
  if Static<>nil then // faster direct call
    result := Static.EngineAdd(PSQLRecordClass(Value)^,JSONValues) else
    result := EngineAdd(PSQLRecordClass(Value)^,JSONValues);
  // on success, Value.ID is updated with the new ROWID
  Value.fID := result;
  if SendData then
    fCache.Notify(PSQLRecordClass(Value)^,result,JSONValues,soInsert);
end;

function TSQLRestServer.Update(Value: TSQLRecord): boolean;
var JSONValues: RawUTF8;
    Static: TSQLRestServerStatic;
begin
  if (self=nil) or (Value=nil) or not inherited Update(Value) then begin
    result := false; // current user don't have enough right to update this record 
    exit;
  end;
  Value.ComputeFieldsBeforeWrite(self,seUpdate); // update sftModTime fields
  JSONValues := Value.GetJSONValues(true,false,soUpdate); // expanded + without ID
  fCache.Notify(Value,soUpdate); // JSONValues on update may not be enough for cache
  Static := GetStaticDataServerOrVirtualTable(PSQLRecordClass(Value)^);
  if Static<>nil then // faster direct call
    result := Static.EngineUpdate(PSQLRecordClass(Value)^,Value.fID,JSONValues) else
    result := EngineUpdate(PSQLRecordClass(Value)^,Value.fID,JSONValues);
end;

function TSQLRestServer.Delete(Table: TSQLRecordClass; ID: integer): boolean;
var Static: TSQLRestServerStatic;
begin
  if not inherited Delete(Table,ID) then begin  // call RecordCanBeUpdated()
    result := false;
    exit;
  end;
  fCache.NotifyDeletion(Table,ID);
  Static := GetStaticDataServerOrVirtualTable(Table);
  if Static<>nil then // faster direct call
    result := Static.EngineDelete(Table,ID) else
    result := EngineDelete(Table,ID);
  if result then
    // force relational database coherency (i.e. our FOREIGN KEY implementation)
    AfterDeleteForceCoherency(Table,ID);
end;

function TSQLRestServer.Delete(Table: TSQLRecordClass; const SQLWhere: RawUTF8): boolean;
var IDs: TIntegerDynArray;
    i: integer;
    Static: TSQLRestServerStatic;
begin
  result := false;
  if not InternalDelete(Table,SQLWhere,IDs) then
    exit;
  Static := GetStaticDataServerOrVirtualTable(Table);
  if Static<>nil then // faster direct call
    result := Static.EngineDeleteWhere(Table,SQLWhere,IDs) else
    result := EngineDeleteWhere(Table,SQLWhere,IDs);
  if result then
    // force relational database coherency (i.e. our FOREIGN KEY implementation)
    for i := 0 to high(IDs) do
      AfterDeleteForceCoherency(Table,IDs[i]);
end;

function TSQLRestServer.TableRowCount(Table: TSQLRecordClass): integer;
var Static: TSQLRestServerStatic;
begin
  Static := GetStaticDataServerOrVirtualTable(Table);
  if Static<>nil then // faster direct call
    result := Static.TableRowCount(Table) else
    result := inherited TableRowCount(Table);
end;

function TSQLRestServer.TableHasRows(Table: TSQLRecordClass): boolean;
var Static: TSQLRestServerStatic;
begin
  Static := GetStaticDataServerOrVirtualTable(Table);
  if Static<>nil then // faster direct call
    result := Static.TableHasRows(Table) else
    result := inherited TableHasRows(Table);
end;

function TSQLRestServer.RetrieveBlob(Table: TSQLRecordClass; aID: integer;
  const BlobFieldName: RawUTF8; out BlobData: TSQLRawBlob): boolean;
var Static: TSQLRestServerStatic;
    BlobField: PPropInfo;
begin
  result := false;
  if (self=nil) or (aID<=0) then
    exit;
  BlobField := Table.RecordProps.BlobFieldPropFromRawUTF8(BlobFieldName);
  if BlobField=nil then
    exit;
  Static := GetStaticDataServerOrVirtualTable(Table);
  if Static<>nil then // faster direct call
     result := Static.EngineRetrieveBlob(Table,aID,BlobField,BlobData) else
     result := EngineRetrieveBlob(Table,aID,BlobField,BlobData);
end;

function TSQLRestServer.UpdateBlob(Table: TSQLRecordClass; aID: integer;
  const BlobFieldName: RawUTF8; const BlobData: TSQLRawBlob): boolean;
var Static: TSQLRestServerStatic;
    BlobField: PPropInfo;
begin
  result := false;
  if (self=nil) or (aID<=0) or not RecordCanBeUpdated(Table,aID,seUpdate) then
    exit;
  BlobField := Table.RecordProps.BlobFieldPropFromRawUTF8(BlobFieldName);
  if BlobField=nil then
    exit;
  Static := GetStaticDataServerOrVirtualTable(Table);
  if Static<>nil then // faster direct call
     result := Static.EngineUpdateBlob(Table,aID,BlobField,BlobData) else
     result := EngineUpdateBlob(Table,aID,BlobField,BlobData);
end;

function TSQLRestServer.UpdateBlobFields(Value: TSQLRecord): boolean;
var Static: TSQLRestServerStatic;
begin
  if (Value=nil) or (Value.fID<=0) then
    result := false else begin
    Static := GetStaticDataServerOrVirtualTable(PSQLRecordClass(Value)^);
    if Static<>nil then // faster direct call
      result := Static.UpdateBlobFields(Value) else
      result := inherited UpdateBlobFields(Value);
  end;
end;

function TSQLRestServer.RetrieveBlobFields(Value: TSQLRecord): boolean;
var Static: TSQLRestServerStatic;
begin
  if Value=nil then
    result := false else begin
    Static := GetStaticDataServerOrVirtualTable(PSQLRecordClass(Value)^);
    if Static<>nil then // faster direct call
      result := Static.RetrieveBlobFields(Value) else
      result := inherited RetrieveBlobFields(Value);
  end;
end;

function TSQLRestServer.AfterDeleteForceCoherency(Table: TSQLRecordClass;
  aID: integer): boolean;
var T: integer;
    Tab: TSQLRecordClass;
    Where: PtrUInt;
    RecRef: TRecordReference;
    Static: TSQLRestServerStatic;
    W: RawUTF8;
begin
  result := true; // success if no property found
  {$ifndef CPU64}
  Where := 0; // make compiler happy
  {$endif}
  RecRef := RecordReference(Model,Table,aID);
  if RecRef<>0 then
  for T := 0 to high(Model.fRecordReferences) do
  with Model.fRecordReferences[T] do begin
    case FieldType.SQLFieldType of
    sftRecord: // TRecordReference published field
      Where := RecRef;
    sftID:     // TSQLRecord published field
      if FieldType.ObjectClass=Table then
        Where := aID else
        continue;
    else continue;
    end;
    // set Field=0 where Field references aID
    W := UInt32ToUTF8(Where);
    Tab := Model.Tables[TableIndex];
    Static := GetStaticDataServerOrVirtualTable(Tab);
    if Static<>nil then // fast direct call
       result := Static.EngineUpdateField(Tab,FieldType.Name,'0',FieldType.Name,W) else
       result := EngineUpdateField(Tab,FieldType.Name,'0',FieldType.Name,W);
  end;
end;

function TSQLRestServer.CreateSQLMultiIndex(Table: TSQLRecordClass;
  const FieldNames: array of RawUTF8; Unique: boolean; IndexName: RawUTF8=''): boolean;
var SQL: RawUTF8;
    i, TableIndex: integer;
    Props: TSQLRecordProperties;
    Static: TSQLRestServerStatic;
begin
  result := false;
  if (Self=nil) or InheritsFrom(TSQLRestServerStatic) or (high(FieldNames)<0) then
    exit; // avoid endless loop for TSQLRestServerStatic with no overriden method
  TableIndex := Model.GetTableIndexExisting(Table);
  if fStaticVirtualTable<>nil then begin
    Static := fStaticVirtualTable[TableIndex];
    if Static<>nil then begin
      if not Static.InheritsFrom(TSQLRestServerStaticInMemory) then
         // will try to create an index on the static table (e.g. for external DB)
         result := Static.CreateSQLMultiIndex(Table,FieldNames,Unique,IndexName);
      exit;
    end;
  end;
  Props := Model.TableProps[TableIndex].Props;
  for i := 0 to high(FieldNames) do
    if Props.Fields.IndexByName(FieldNames[i])<0 then
      exit; // wrong field name
  if Unique then
    SQL := 'UNIQUE ' else
    SQL := '';
  if IndexName='' then
    IndexName := RawUTF8ArrayToCSV(FieldNames,'');
  SQL := FormatUTF8('CREATE %INDEX IF NOT EXISTS Index%% ON %(%);',
    [SQL,Props.SQLTableName,IndexName,Props.SQLTableName,RawUTF8ArrayToCSV(FieldNames,',')]);
  result := EngineExecuteAll(SQL);
end;

function TSQLRestServer.CreateSQLIndex(Table: TSQLRecordClass; const FieldName: RawUTF8;
  Unique: boolean; const IndexName: RawUTF8=''): boolean;
begin
  result := CreateSQLMultiIndex(Table,[FieldName],Unique,IndexName);
end;

function TSQLRestServer.CreateSQLIndex(Table: TSQLRecordClass;
  const FieldNames: array of RawUTF8; Unique: boolean): boolean;
var i: integer;
begin
  result := true;
  for i := 0 to high(FieldNames) do
    if not CreateSQLMultiIndex(Table,[FieldNames[i]],Unique) then
     result := false;
end;

procedure TSQLRestServer.ServiceMethodByPassAuthentication(const aMethodName: RawUTF8);
var i: Integer;
begin
  if self=nil then
    exit;
  i :=  fPublishedMethods.Find(aMethodName);
  if i>=0 then
    AddInteger(fPublishedMethodsUnauthenticated,fPublishedMethodsUnauthenticatedCount,i,True);
end;

procedure StatusCodeToErrorMsg(Code: integer; var result: RawUTF8);
begin
  case Code of
    100:             result := 'Continue';
    HTML_SUCCESS:    result := 'OK';
    HTML_CREATED:    result := 'Created';
    202:             result := 'Accepted';
    203:             result := 'Non-Authoritative Information';
    204:             result := 'No Content';
    300:             result := 'Multiple Choices';
    301:             result := 'Moved Permanently';
    302:             result := 'Found';
    303:             result := 'See Other';
    HTML_NOTMODIFIED:result := 'Not Modified';
    307:             result := 'Temporary Redirect';
    HTML_BADREQUEST: result := 'Bad Request';
    401:             result := 'Unauthorized';
    HTML_FORBIDDEN:  result := 'Forbidden';
    HTML_NOTFOUND:   result := 'Not Found';
    HTML_NOTALLOWED: result := 'Method Not Allowed';
    406:             result := 'Not Acceptable';
    HTML_SERVERERROR:result := 'Internal Server Error';
    HTML_UNAVAILABLE:result := 'Service Unavailable';
    else             result := 'Invalid Request';
  end;
end;

procedure TSQLRestServerCallBackParams.FillInput;
var n,max: integer;
    P: PUTF8Char;
begin
  P := Parameters;
  n := 0;
  max := 0;
  repeat
    if n>=max then begin
      inc(max,16);
      SetLength(fInput,max);
    end;
    P := UrlDecodeNextNameValue(P,fInput[n],fInput[n+1]);
    if P=nil then
      break;
    inc(n,2);
  until P^=#0;
  SetLength(fInput,n);
end;

function TSQLRestServerCallBackParams.GetInputInt(const ParamName: RawUTF8): Int64;
var err: integer;
begin
  result := GetInt64(pointer(GetInputUTF8(ParamName)),err);
  if err<>0 then
    raise EParsingException.CreateFmt('Invalid parameter %s as Int64 in URI',[ParamName]);
end;

function TSQLRestServerCallBackParams.GetInputDouble(const ParamName: RawUTF8): double;
var err: integer;
begin
  result := GetExtended(pointer(GetInputUTF8(ParamName)),err);
  if err<>0 then
    raise EParsingException.CreateFmt('Invalid parameter %s as Double in URI',[ParamName]);
end;

function TSQLRestServerCallBackParams.GetInputUTF8(const ParamName: RawUTF8): RawUTF8;
var i: integer;
begin
  if (fInput=nil) and (Parameters<>nil) then
    FillInput;
  for i := 0 to (length(fInput)shr 1)-1 do
    if IdemPropNameU(ParamName,fInput[i*2]) then begin
      result := fInput[i*2+1];
      exit;
    end;
  raise EParsingException.CreateFmt('Parameter %s not found in URI',[ParamName]);
end;

{$ifdef USEVARIANTS}
function TSQLRestServerCallBackParams.GetInput(const ParamName: RawUTF8): variant;
begin
  GetVariantFromJSON(pointer(GetInputUTF8(ParamName)),false,Result);
end;
{$endif}

procedure TSQLRestServerCallBackParams.Returns(const Result: RawUTF8;
  Status: integer; const CustomHeader: RawUTF8; Handle304NotModified: boolean);
var clientHash, serverHash: RawUTF8;
begin
  if Status in [HTML_SUCCESS,HTML_CREATED] then begin
    Call.OutStatus := Status;
    Call.OutBody := Result;
    if CustomHeader<>'' then
      Call.OutHead := CustomHeader else
      if Call.OutHead='' then
        Call.OutHead := JSON_CONTENT_TYPE_HEADER;
    if Handle304NotModified and (Status=HTML_SUCCESS) and
       (Length(Result)>64) then begin
      clientHash := FindIniNameValue(pointer(Call.InHead),'IF-NONE-MATCH: ');
      serverHash := '"'+CardinalToHex(crc32(0,pointer(Result),Length(Result)))+'"';
      if clientHash<>serverHash then
        Call.OutHead := Call.OutHead+#13#10'ETag: '+serverHash else begin
        Call.OutBody := ''; // save bandwidth for "304 Not Modified"
        Call.OutStatus := HTML_NOTMODIFIED;
      end;
    end;
  end else
    Error(Result,Status);
end;

procedure TSQLRestServerCallBackParams.Returns(const NameValuePairs: array of const;
  Status: integer; Handle304NotModified: boolean);
begin
  Returns(JSONEncode(NameValuePairs),Status,'',Handle304NotModified);
end;

procedure TSQLRestServerCallBackParams.Results(const Values: array of const;
  Status: integer; Handle304NotModified: boolean);
var i,h: integer;
    result: RawUTF8;
begin
  h := high(Values);
  if h<0 then
    result := '{"result":null}' else
    with TTextWriter.CreateOwnedStream do
    try
      AddShort('{"result":');
      if h=0 then
        // result is one value
        AddJSONEscape(Values[0]) else begin
        // result is one array of values
        Add('[');
        i := 0;
        repeat
          AddJSONEscape(Values[i]);
          if i=h then break;
          Add(',');
          inc(i);
        until false;
        Add(']');
      end;
      Add('}');
      SetText(result);
    finally
      Free;
    end;
  Returns(result,Status,'',Handle304NotModified);
end;


procedure TSQLRestServerCallBackParams.Success(Status: integer);
begin
  if Status in [HTML_SUCCESS,HTML_CREATED] then
    Call.OutStatus := Status else
    Error('',Status);
end;

procedure TSQLRestServerCallBackParams.Error(Format: PUTF8Char;
  const Args: array of const; Status: integer);
begin
  Error(FormatUTF8(Format,Args),Status);
end;

procedure TSQLRestServerCallBackParams.Error(const ErrorMessage: RawUTF8; Status: integer);
var ErrorMsg: RawUTF8;
begin
  Call.OutStatus := Status;
  if Status in [HTML_SUCCESS,HTML_CREATED] then begin // not an error
    Call.OutBody := ErrorMessage;
    exit;
  end;
  if ErrorMessage='' then
    StatusCodeToErrorMsg(Status,ErrorMsg) else
    ErrorMsg := ErrorMessage;
  {$ifdef WITHLOG}
  Log.Log(sllServer,'% % ERROR=% (%)',
    [Call.Method,URIWithoutSignature,Call.OutStatus,ErrorMsg]);
  {$endif}
  with TTextWriter.CreateOwnedStream do
  try
    AddShort('{'#13#10'"ErrorCode":');
    Add(call.OutStatus);
    AddShort(','#13#10'"ErrorText":"');
    AddJSONEscape(pointer(ErrorMsg));
    AddShort('"'#13#10'}');
    SetText(Call.OutBody);
  finally
    Free;
  end;
end;


function TSQLRestServer.LaunchCallBack(var Ctxt: TSQLRestServerCallBackParams): boolean;
var Method: TMethod;
    Invoke: TSQLRestServerCallBack absolute Method;
begin
  result := false;
  if (Ctxt.MethodIndex<0) or (self=nil) then
    exit;
  Method.Code := pointer(fPublishedMethods.List[Ctxt.MethodIndex].Tag);
  // launch the method found
{$ifdef WITHLOG}
  Ctxt.Log.Log(sllServiceCall,fPublishedMethods.List[Ctxt.MethodIndex].Name,self);
{$endif}
  result := true; // mark method found and executed 
  try
    Method.Data := Self;
    Invoke(Ctxt);
    inc(fStats.fServices);
  except
    on E: Exception do // execution errors are intercepted and returned as such
      Ctxt.Error('Exception %: %',
       [PShortString(PPointer(PPtrInt(E)^+vmtClassName)^)^,E.Message],
       HTML_SERVERERROR);
  end;
end;

type
  TServiceInternalMethod = (imFree, imContract, imSignature);

const
  SERVICE_PSEUDO_METHOD: array[TServiceInternalMethod] of RawUTF8 = (
    '_free_','_contract_','_signature_');

function TSQLRestServer.ServiceRegister(
  aImplementationClass: TInterfacedClass; const aInterfaces: array of PTypeInfo;
  aInstanceCreation: TServiceInstanceImplementation): TServiceFactoryServer;
begin
  result := nil;
  if (self=nil) or (aImplementationClass=nil) or (high(aInterfaces)<0) then
    exit;
  if fServices=nil then
    fServices := TServiceContainerServer.Create(self);
  result := (fServices as TServiceContainerServer).
    AddImplementation(aImplementationClass,aInterfaces,aInstanceCreation);
end;

function TSQLRestServer.ServiceRegister(aClient: TSQLRest; const aInterfaces: array of PTypeInfo;
  aInstanceCreation: TServiceInstanceImplementation=sicSingle;
  const aContractExpected: RawUTF8=''): boolean;
begin
  result := False;
  if (self=nil) or (high(aInterfaces)<0) or (aClient=nil) then
    exit;
  if fServices=nil then
    fServices := TServiceContainerServer.Create(self);
  result := (fServices as TServiceContainerServer).AddInterface(
    aInterfaces,aInstanceCreation,aContractExpected);
end;

function TSQLRestServer.LaunchService(var Ctxt: TSQLRestServerCallBackParams): boolean;
var Service: TServiceFactory;
    method, JSON: RawUTF8;
    Values: TPUtf8CharDynArray;
    ServiceParams: PUTF8Char;
    i, m, ServiceID: integer;
    internal: TServiceInternalMethod;
begin
  result := false;
  if Services=nil then
    exit;
  // 1. retrieve request parameters according to routing scheme
  ServiceID := Ctxt.ID;
  case ServicesRouting of
  rmRest: begin
    i := Services.fListInterfaceMethod.IndexOf(Ctxt.URI);
    if i<0 then
      exit; // no specific message: it may be a valid request
    i := PtrInt(Services.fListInterfaceMethod.Objects[i]);
    m := i shr 16;
    Service := Services.Index(i and $ffff);
    if Service=nil then
      exit;
    if Ctxt.Call.InBody<>'' then  // parameters sent as JSON array (the Delphi/AJAX way)
      ServiceParams := pointer(Ctxt.Call.InBody) else begin
      JSON := UrlDecode(Ctxt.Parameters); // optional URI decoding (the HTML way)
      ServiceParams := pointer(JSON);
    end;
    if ServiceID<0 then
      ServiceID := 0;
    {$ifdef WITHLOG}
    Ctxt.Log.Log(sllServiceCall,Ctxt.URI,self);
    {$endif}
  end;
  rmJSON_RPC: begin
    Service := Services[Ctxt.URI];
    if Service=nil then // Unknown service
      exit; // not a valid JSON-RPC service
    JSON := Ctxt.Call.InBody; // in-place parsing -> private copy
    JSONDecode(JSON,['method','params','id'],Values,True);
    if Values[0]=nil then // Method name required
      exit; 
    result := true; // sounds like a valid JSON-RPC signature
    method := Values[0];
    ServiceParams := Values[1];
    ServiceID := GetCardinal(Values[2]);
    m := Service.fInterface.FindMethodIndex(method);
    if m>=0 then
      inc(m,length(SERVICE_PSEUDO_METHOD)) else begin
      for internal := low(TServiceInternalMethod) to high(TServiceInternalMethod) do
        if IdemPropNameU(method,SERVICE_PSEUDO_METHOD[internal]) then begin
          m := ord(internal);
          break;
        end;
      if m<0 then begin
        Ctxt.Error('Unknown method');
        exit;
      end;
    end;
    {$ifdef WITHLOG}
    Ctxt.Log.Log(sllServiceCall,'%.%',[Ctxt.URI,method],self);
    {$endif}
  end;
  else exit;
  end;
  // 2. this is a valid service call -> handle request
  if ServiceParams=nil then begin
    Ctxt.Error('Parameters required');
    exit;
  end;
  inc(fStats.fServices);
  case m of
  ord(imFree): // "method":"_free_" to release sicClientDriven..sicPerGroup
    if ServiceID<=0 then // expects an instance ID to be released
      exit else
      m := -1; // notify ExecuteMethod() to release the internal instance
  ord(imContract): begin // "method":"_contract_" to retrieve the implementation contract
    Ctxt.Returns('{"result":['+Service.ContractExpected+'],"id":0}');
    result := true;
    exit; // "id":0 for this method -> no instance was created
  end;
  ord(imSignature): begin // "method":"_signature_" to retrieve the implementation signature
    if TServiceContainerServer(Services).PublishSignature then begin
      Ctxt.Returns('{"result":['+Service.Contract+'],"id":0}');
      result := true; // "id":0 for this method -> no instance was created
    end;
    exit; // not allowed to publish signature
  end;
  else
    dec(m,length(SERVICE_PSEUDO_METHOD)); // index of operation in fMethods[]
  end;
  if (Ctxt.Session>CONST_AUTHENTICATION_NOT_USED) and (m>=0) and
     (Ctxt.SessionGroup-1 in Service.fExecution[m].Denied) then begin
    Ctxt.Error('Unauthorized method');
    exit;
  end;
  TServiceFactoryServer(Service).ExecuteMethod(Ctxt,m,ServiceID,ServiceParams);
  result := true; // notify method found (any error status is in aResult)
end;

function TSQLRestServer.RunBatch(aStatic: TSQLRestServerStatic;
  aTable: TSQLRecordClass; var aCall: TSQLRestServerCallBackParams): boolean;
var EndOfObject: AnsiChar;
    wasString, OK: boolean;
    TableName, Value, ErrMsg: RawUTF8;
    URIMethod, RunningBatchURIMethod: TSQLURIMethod;
    RunningBatchStatic: TSQLRestServerStatic; { TODO: allow nested batch between tables? }
    Sent, Method, MethodTable: PUTF8Char;
    Props: TSQLRecordProperties;
    i, ID, Count: integer;
    Results: TIntegerDynArray;
    RunTable: TSQLRecordClass;
    RunStatic: TSQLRestServerStatic;
begin
  result := false;
  Sent := pointer(aCall.Call.InBody);
  if (self=nil) or (Sent=nil) then
    exit;
  if aTable<>nil then begin
    // unserialize expected sequence array as '{"Table":["cmd":values,...]}'
    while Sent^<>'{' do inc(Sent);
    if Sent^<>'{' then
      exit;
    inc(Sent);
    TableName := GetJSONField(Sent,Sent,@wasString,@EndOfObject);
    Props := aTable.RecordProps;
    if not wasString or (EndOfObject<>':') or (Sent=nil) or
       not IdemPropNameU(Props.SQLTableName,TableName) then
      exit;
  end; // or '["cmd@Table":values,...]'
  while Sent^<>'[' do inc(Sent);
  if Sent^<>'[' then
    exit;
  inc(Sent);
  RunningBatchStatic := nil;
  RunningBatchURIMethod := mNone;
  Count := 0;
  try // to protect InternalBatchStart/Stop locking
    repeat
      // retrieve method name and associated (static) table
      Method := GetJSONField(Sent,Sent,@wasString,@EndOfObject);
      if not wasString or (EndOfObject<>':') or (Sent=nil) or (Method=nil) then
        exit;
      MethodTable := PosChar(Method,'@');
      if MethodTable=nil then begin // e.g. '{"Table":[...,"POST":{object},...]}'
        RunTable := aTable;
        RunStatic := aStatic;
      end else begin                // e.g. '[...,"POST@Table":{object},...]'
        i := Model.GetTableIndex(MethodTable+1);
        if i<0 then
          exit;
        RunTable := Model.Tables[i];
        RunStatic := GetStaticDataServerOrVirtualTable(i);
      end;
      if Count>=length(Results) then
        SetLength(Results,Count+256+Count shr 3);
      // get CRUD method (ignoring @ char if appended after method name)
      if IdemPChar(Method,'DELETE') then
        URIMethod := mDELETE else
      if IdemPChar(Method,'POST') then
        URIMethod := mPOST else
      if IdemPChar(Method,'PUT') then
        URIMethod := mPUT else
        URIMethod := mNone;
      // handle batch request sending (if any pending)
      if (RunningBatchStatic<>nil) and  
         ((RunStatic<>RunningBatchStatic) or (RunningBatchURIMethod<>URIMethod)) then begin
        RunningBatchStatic.InternalBatchStop; // send pending statements
        RunningBatchStatic := nil;
      end;
      if (RunStatic<>nil) and (RunStatic<>RunningBatchStatic) and
         RunStatic.InternalBatchStart(URIMethod) then begin
        RunningBatchStatic := RunStatic;
        RunningBatchURIMethod := URIMethod;
      end;
      // process CRUD method operation
      case URIMethod of
      mDELETE: begin // '{"Table":[...,"DELETE":ID,...]}' or '[...,"DELETE@Table":ID,...]'
        ID := GetInteger(GetJSONField(Sent,Sent,@wasString,@EndOfObject));
        if (ID<=0) or wasString or
           not RecordCanBeUpdated(RunTable,ID,seDelete,@ErrMsg) then begin
          aCall.Error(ErrMsg,HTML_NOTMODIFIED);
          exit;
        end;
        if RunStatic<>nil then
          OK := RunStatic.EngineDelete(RunTable,ID) else
          OK := EngineDelete(RunTable,ID);
        if OK then begin
          fCache.NotifyDeletion(RunTable,ID);
          if (RunningBatchStatic<>nil) or
             AfterDeleteForceCoherency(RunTable,ID) then
            Results[Count] := HTML_SUCCESS; // 200 OK
        end;
      end;
      mPOST: begin // '{"Table":[...,"POST":{object},...]}' or '[...,"POST@Table":{object},...]'
        Value := JSONGetObject(Sent,nil,EndOfObject);
        if (Sent=nil) or
           not RecordCanBeUpdated(RunTable,0,seAdd,@ErrMsg)  then begin
          aCall.Error(ErrMsg,HTML_NOTMODIFIED);
          exit;
        end;
        if RunStatic<>nil then
          ID := RunStatic.EngineAdd(RunTable,Value) else
          ID := EngineAdd(RunTable,Value);
        Results[Count] := ID;
        fCache.Notify(RunTable,ID,Value,soInsert);
      end;
      mPUT: begin // '{"Table":[...,"PUT":{object},...]}' or '[...,"PUT@Table":{object},...]'
        Value := JSONGetObject(Sent,@ID,EndOfObject);
        if (Sent=nil) or (Value='') then
          exit;
        if RunStatic<>nil then
          OK := RunStatic.EngineUpdate(RunTable,ID,Value) else
          OK := EngineUpdate(RunTable,ID,Value);
        if OK then begin
          Results[Count] := HTML_SUCCESS; // 200 OK
          fCache.NotifyDeletion(RunTable,ID); // Value does not have CreateTime e.g.
          // or may be complete -> update won't work as expected -> delete from cache
        end;
      end;
      else exit; // unknown method
      end;
      inc(Count);
    until EndOfObject=']';
  finally
    if RunningBatchStatic<>nil then
      RunningBatchStatic.InternalBatchStop; // send pending statements
  end;
  if aTable<>nil then begin // '{"Table":["cmd":values,...]}' format
    if Sent=nil then
      exit;
    while Sent^<>'}' do inc(Sent);
    result := Sent^='}';
  end else
    result := true;
  // send back operation status array
  for i := 0 to Count-1 do
    if Results[i]<>HTML_SUCCESS then begin
      aCall.Call.OutBody := IntegerDynArrayToCSV(Results,Count,'[',']');
      exit;
    end;
  aCall.Call.OutBody := '["OK"]';  // to save bandwith if no adding
end;

function StringToMethod(const method: RawUTF8): TSQLURIMethod;
const NAME: array[mGET..high(TSQLURIMethod)] of string[7] = (
  'GET','POST','PUT','DELETE','BEGIN','END','ABORT','LOCK','UNLOCK','STATE');
var URIMethodUp: string[7];
begin
  if Length(method)<7 then begin
    URIMethodUp[0] := AnsiChar(UpperCopy(@URIMethodUp[1],method)-@URIMethodUp[1]);
    for result := low(NAME) to high(NAME) do
      if URIMethodUp=NAME[result] then
        exit;
  end;
  result := mNone;
end;

procedure TSQLRestServer.URI(var Call: TSQLRestServerURIParams);
var BlobFieldName: RawUTF8;
    Static: TSQLRestServerStatic;
    Engine: TSQLRestServer;
    i,j,L,SessionSignaturePos: integer;
    SQLSelect, SQLWhere, SQLSort, SQLDir, SQL, ErrMsg: RawUTF8;
    ResultList: TSQLTableJSON;
    SQLStartIndex, SQLResults, SQLTotalRowsCount: integer;
    NonStandardSQLSelectParameter, NonStandardSQLWhereParameter: boolean;
    StaticKind: (sNone, sInMemory, sVirtual);
    SQLisSelect, OK: boolean;
    URI: TSQLRestServerCallBackParams;
    Session: TAuthSession;
    SessionAccessRights: TSQLAccessRights; // session may be deleted meanwhile
    P: PUTF8Char;
    Blob: PPropInfo;
{$ifdef WITHSTATPROCESS}
    timeStart,timeEnd: Int64;
{$endif}

begin
{$ifdef WITHSTATPROCESS}
  QueryPerformanceCounter(timeStart);
{$endif}
  // 0. initialize internal memory structures
  URI.Call := @Call;
  Call.OutInternalState := InternalState; // other threads may change it
  L := length(Call.url);
  inc(fStats.fIncomingBytes,L+length(call.method)+length(call.InHead)+length(call.InBody)+12);
  SessionSignaturePos := L-(17+24+1);
  if (SessionSignaturePos<0) or // signature should be LAST parameter in URL
     not IdemPChar(PUTF8Char(pointer(Call.url))+SessionSignaturePos,'SESSION_SIGNATURE=') then
    SessionSignaturePos := 0;
{$ifdef WITHLOG}
  if SessionSignaturePos=0 then
    URI.URIWithoutSignature := Call.Url else
    URI.URIWithoutSignature := Copy(Call.Url,1,SessionSignaturePos-1);
  URI.Log := SQLite3Log.Enter(Self,pointer(URI.URIWithoutSignature),true);
{$endif}
  // 1. retrieve URI expecting 'ModelRoot[/TableName[/ID[/BlobFieldName]]]' format
  i := 0;
  if (Call.url<>'') and (Call.url[1]='/') then inc(i); // URL may be '/path'
  j := length(Model.Root);
  if (i+j>L) or (not(Call.url[i+j+1] in [#0,'/','?'])) or
     (StrCompIL(pointer(PtrInt(Call.url)+i),pointer(Model.Root),j,0)<>0) then begin
    URI.Error('Invalid Root',HTML_NOTFOUND);
    inc(fStats.fInvalid);
    exit; // bad ModelRoot -> caller can try another TSQLRestServer
  end;
  Call.OutStatus := HTML_BADREQUEST; // default error code is 400 BAD REQUEST
  URI.URI := copy(Call.url,j+i+2,maxInt);
  i := PosEx(RawUTF8('/'),URI.URI,1);
  if i>0 then begin
    URI.Parameters := @URI.URI[i+1];
    URI.ID := GetNextItemCardinal(URI.Parameters,'/');
    if (URI.ID>0) and (URI.Parameters<>nil) then begin
      // for URL like "ModelRoot/TableName/ID/BlobFieldName"
      P := PosChar(URI.Parameters,'?');
      if P=nil then
        BlobFieldName := URI.Parameters else
        SetString(BlobFieldName,PAnsiChar(URI.Parameters),P-URI.Parameters);
    end;
    SetLength(URI.URI,i-1);
    j := PosEx(RawUTF8('?'),Call.url,1);
    if j>0 then // '?select=...&where=...' or '?where=...'
      URI.Parameters := @Call.url[j+1] else
      URI.Parameters := nil;
  end else begin
    URI.ID := -1;
    i := PosEx(RawUTF8('?'),Call.url,1);
    if i>0 then begin // '?select=...&where=...' or '?where=...'
      URI.Parameters := @Call.url[i+1];
      i := PosEx(RawUTF8('?'),URI.URI);
      if i>0 then
        dec(i);
      SetLength(URI.URI,i);
    end else
      URI.Parameters := nil; // no parameter
  end;
  URI.TableIndex := Model.GetTableIndex(URI.URI);
  Engine := self;
  Static := nil;
  StaticKind := sNone;
  if URI.TableIndex<0 then begin
    URI.Table := nil;
    URI.MethodIndex := fPublishedMethods.Find(URI.URI);
  end else begin
    URI.MethodIndex := -1;
    URI.Table := Model.Tables[URI.TableIndex];
    if fStaticData<>nil then
      Static := fStaticData[URI.TableIndex]; // fast retrieve TSQLRestServerStatic
    if Static<>nil then
      StaticKind := sInMemory else
      if fVirtualTableDirect and (fStaticVirtualTable<>nil) then
        if fStaticVirtualTable[URI.TableIndex]<>nil then begin
          Static := fStaticVirtualTable[URI.TableIndex];
          StaticKind := sVirtual;
        end;
    if Static<>nil then
      Engine := Static;
  end;
  // 2. handle security
  Session := nil;
  if HandleAuthentication then begin
    URI.Session := CONST_AUTHENTICATION_SESSION_NOT_STARTED;
    // check session_signature=... parameter
    if URI.Parameters<>nil then begin
      // expected format is 'session_signature='Hexa8(SessionID)+Hexa8(TimeStamp)+
      // Hexa8(crc32('SessionID+HexaSessionPrivateKey'+Sha256('salt'+PassWord)+
      //   Hexa8(TimeStamp)+url))
      if (SessionSignaturePos>0) and // should be LAST parameter in URL
         HexDisplayToCardinal(
           PAnsiChar(pointer(Call.url))+SessionSignaturePos+18,URI.Session) then begin
        EnterCriticalSection(fSessionCriticalSection);
        try
          Session := SessionAccess(URI);
          if Session.IsValidURL(Call.url,SessionSignaturePos-1) then begin
            // supplied RestAccessRights is ignored and replaced by the user rights
            {$ifdef WITHLOG}
            URI.Log.Log(sllUserAuth,'%/%',[Session.User.LogonName,URI.Session],self);
            {$endif}
            move(Session.fAccessRights,SessionAccessRights,sizeof(TSQLAccessRights));
            Call.RestAccessRights := @SessionAccessRights;
          end else
            // mark invalid query authentication
            Session := nil;
        finally
          LeaveCriticalSection(fSessionCriticalSection);
        end;
      end;
    end;
    if (Session=nil) and ((URI.MethodIndex<0) or
      not IntegerScanExists(pointer(fPublishedMethodsUnauthenticated),
        fPublishedMethodsUnauthenticatedCount,URI.MethodIndex)) then begin
      // /auth + /timestamp are e.g. allowed services without signature
      URI.Error('',HTML_FORBIDDEN); // 403 in case of authentication failure
      // 401 Unauthorized response MUST include a WWW-Authenticate header,
      // which is not what we used, so we won't send 401 error code but 403
      inc(fStats.fInvalid);
      exit; // authentication error -> caller can try to open another session
    end;
  end else begin // default unique session if authentication is not enabled
    URI.Session := CONST_AUTHENTICATION_NOT_USED;
    URI.SessionUser := 0;
    URI.SessionGroup := 0;
  end;
  // 3. call appropriate database commands
  URI.Method := StringToMethod(call.method);
  case URI.Method of
  mLOCK,mGET: begin
    if URI.Table=nil then begin
      if (URI.Method<>mLOCK) and
          // GET ModelRoot/MethodName + parameters sent in URI
         ((URI.MethodIndex<0) or not LaunchCallBack(URI)) then
        if (URI.URI='') or not (reService in Call.RestAccessRights^.AllowRemoteExecute) or
           // GET ModelRoot/Service.Method[/ID] + parameters sent as JSON or in URI
           not LaunchService(URI) then begin
          if (Call.InBody='') and (URI.Parameters<>nil) and
             (reUrlEncodedSQL in Call.RestAccessRights^.AllowRemoteExecute) then begin
            // GET with a SQL statement sent in URI, as sql=....
            while not UrlDecodeValue(URI.Parameters,'SQL=',SQL,@URI.Parameters) do
              if URI.Parameters=nil then break;
          end else
            // GET with a SQL statement sent as UTF-8 body
            SQL := Call.InBody;
          SQLisSelect := isSelect(pointer(SQL));
          if (SQL<>'') and
            (SQLisSelect or (reSQL in Call.RestAccessRights^.AllowRemoteExecute)) then begin
            // no user check for SELECT: see TSQLAccessRights.GET comment
            Static := InternalAdaptSQL(Model.GetTableIndexFromSQLSelect(SQL,false),SQL);
            if Static<>nil then
              Engine := Static;
            Call.OutBody := Engine.EngineList(SQL);
            // security note: only first statement is run by EngineList()
            if Call.OutBody<>'' then begin // got JSON list '[{...}]' ?
              Call.OutStatus := HTML_SUCCESS;  // 200 OK
              if not SQLisSelect then
                inc(fStats.fModified);
            end;
          end;
        end;
    end else
    // here, Table<>nil and TableIndex in [0..MAX_SQLTABLES-1]
    if not (URI.TableIndex in Call.RestAccessRights^.GET) then // check User Access
      Call.OutStatus := HTML_NOTALLOWED else begin
      if URI.ID>0 then begin
        // GET ModelRoot/TableName/ID[/BlobFieldName] to retrieve one member,
        // with or w/out locking, or a specified BLOB field content
        if URI.Method=mLOCK then // LOCK is to be followed by PUT -> check user
          if not (URI.TableIndex in Call.RestAccessRights^.PUT) then
            Call.OutStatus := HTML_NOTALLOWED else
            if Model.Lock(URI.TableIndex,URI.ID) then
              URI.Method := mGET; // mark successfully locked
        if URI.Method<>mLOCK then
          if BlobFieldName<>'' then begin
            // GET ModelRoot/TableName/ID/BlobFieldName: retrieve BLOB field content
            Blob := URI.Table.RecordProps.BlobFieldPropFromRawUTF8(BlobFieldName);
            if Blob<>nil then begin
              if Engine.EngineRetrieveBlob(URI.Table,URI.ID,Blob,TSQLRawBlob(Call.OutBody)) then begin
                Call.OutHead := HEADER_CONTENT_TYPE+
                  GetMimeContentType(pointer(Call.OutBody),Length(Call.OutBody));
                Call.OutStatus := HTML_SUCCESS; // 200 OK
              end;
            end else begin
              // GET ModelRoot/TableName/ID/MethodName: try MethodName
              URI.MethodIndex := fPublishedMethods.Find(BlobFieldName);
              if URI.MethodIndex>=0 then
                LaunchCallBack(URI);
            end;
          end else begin
            // GET ModelRoot/TableName/ID: retrieve a member content, JSON encoded
            Call.OutBody := fCache.Retrieve(URI.TableIndex,URI.ID);
            if Call.OutBody='' then begin
              // get JSON object '{...}'
              Call.OutBody := Engine.EngineRetrieve(URI.TableIndex,URI.ID);
              // cache if expected
              fCache.Notify(URI.TableIndex,URI.ID,Call.OutBody,soSelect);
            end;
            if Call.OutBody<>'' then // if something was found
              Call.OutStatus := HTML_SUCCESS; // 200 OK
          end;
      end else
      // ModelRoot/TableName with 'select=..&where=' or YUI paging
      if URI.Method<>mLOCK then begin // LOCK not available here
        SQLSelect := 'RowID'; // if no select is specified (i.e. ModelRoot/TableName)
        // all IDs of this table are returned to the client
        SQLTotalRowsCount := 0;
        if URI.Parameters<>nil then begin // '?select=...&where=...' or '?where=...'
          SQLStartIndex := 0;
          SQLResults := 0;
          if URI.Parameters^<>#0 then begin
            NonStandardSQLSelectParameter := StrComp(URIPagingParameters.Select,
              PAGINGPARAMETERS_YAHOO.Select)<>0;
            NonStandardSQLWhereParameter := StrComp(URIPagingParameters.Where,
              PAGINGPARAMETERS_YAHOO.Where)<>0;
            repeat
              UrlDecodeValue(URI.Parameters,URIPagingParameters.Sort,SQLSort);
              UrlDecodeValue(URI.Parameters,URIPagingParameters.Dir,SQLDir);
              UrlDecodeInteger(URI.Parameters,URIPagingParameters.StartIndex,SQLStartIndex);
              UrlDecodeInteger(URI.Parameters,URIPagingParameters.Results,SQLResults);
              UrlDecodeValue(URI.Parameters,URIPagingParameters.Select,SQLSelect);
              if NonStandardSQLSelectParameter and (SQLSelect='') then
                UrlDecodeValue(URI.Parameters,PAGINGPARAMETERS_YAHOO.Select,SQLSelect);
              if NonStandardSQLWhereParameter and (SQLWhere='') then
                UrlDecodeValue(URI.Parameters,PAGINGPARAMETERS_YAHOO.Where,SQLWhere);
              UrlDecodeValue(URI.Parameters,URIPagingParameters.Where,SQLWhere,@URI.Parameters);
            until URI.Parameters=nil;
          end;
          // let SQLite3 do the sort and the paging (will be ignored by Static)
          if (SQLSort<>'') and
             not ContainsUTF8(pointer(SQLWhere),'ORDER BY') then begin
            if SameTextU(SQLDir,'DESC') then
              SQLSort := SQLSort+' DESC'; // allow DESC, default is ASC
            SQLWhere := SQLWhere+' ORDER BY '+SQLSort;
          end;
          SQLWhere := trim(SQLWhere);
          if (SQLResults<>0) and not ContainsUTF8(pointer(SQLWhere),'LIMIT ') then begin
            if (URIPagingParameters.SendTotalRowsCountFmt<>nil) then begin
              ResultList := InternalListJSON(URI.Table,
                Model.TableProps[URI.TableIndex].SQLFromSelectWhere('Count(*)',SQLWhere));
              if ResultList<>nil then begin
                SQLTotalRowsCount := ResultList.GetAsInteger(1,0);
                ResultList.Free;
              end;
            end;
            SQLWhere := FormatUTF8('% LIMIT % OFFSET %',[SQLWhere,SQLResults,SQLStartIndex]);
          end;
        end;
        SQL := Model.TableProps[URI.TableIndex].SQLFromSelectWhere(SQLSelect,trim(SQLWhere));
        Call.OutBody := InternalListRawUTF8(URI.TableIndex,SQL);
        if Call.OutBody<>'' then begin // got JSON list '[{...}]' ?
          Call.OutStatus := HTML_SUCCESS;  // 200 OK
          if URIPagingParameters.SendTotalRowsCountFmt<>nil then
            if NoAJAXJSON then begin
              P := pointer(Call.OutBody);
              L := length(Call.OutBody);
              P := NotExpandedBufferRowCountPos(P,P+L);
              j := 0;
              if P<>nil then
                j := P-pointer(Call.OutBody)-11 else
                 for i := 1 to 10 do
                   if Call.OutBody[L]='}' then begin
                     j := L;
                     break;
                   end else
                   dec(L);
              if j>0 then
                Insert(FormatUTF8(URIPagingParameters.SendTotalRowsCountFmt,
                  [SQLTotalRowsCount]),Call.OutBody,j);
            end else begin// expanded format -> as {"values":[...],"total":n}
              if SQLTotalRowsCount=0 then // avoid sending fields array
                Call.OutBody := '[]' else
                Call.OutBody := trim(Call.OutBody);
              Call.OutBody := '{"values":'+Call.OutBody+
                FormatUTF8(URIPagingParameters.SendTotalRowsCountFmt,[SQLTotalRowsCount])+'}';
            end;
        end;
      end;
    end;
  end;
  mUNLOCK: begin
    // ModelRoot/TableName/ID to unlock a member
    if not (URI.TableIndex in Call.RestAccessRights^.PUT) then
      Call.OutStatus := HTML_NOTALLOWED else
    if (URI.Table<>nil) and (URI.ID>0) and
       Model.UnLock(URI.Table,URI.ID) then
      Call.OutStatus := HTML_SUCCESS; // 200 OK
  end;
  mSTATE: begin
    // STATE method for TSQLRestClientURI.ServerInternalState
    // this method is called with Root (-> Table=nil -> Static=nil)
    // we need a specialized method in order to avoid fStats.Invalid increase
    Call.OutStatus := HTML_SUCCESS;
    for i := 0 to high(fStaticData) do
      if fStaticData[i]<>nil then
        if fStaticData[i].RefreshedAndModified then begin
          inc(InternalState); // force refresh
          break;
        end;
  end else
  // write methods (mPOST, mPUT, mDELETE...) are handled separately
  if (URI.Table<>nil) or (URI.Method<>mPOST) or // check thread-safe call of service
     not (reService in Call.RestAccessRights^.AllowRemoteExecute) or
     // POST ModelRoot/Service.Method[/ID] + parameters sent as JSON or in URI
     not LaunchService(URI) then
  // now we have to handle a write to the DB (POST/PUT/DELETE...)
  if AcquireWrite(URI) then // make it thread-safe and transaction-safe
  try
    case URI.Method of
    mPOST: begin       // POST=ADD=INSERT
      if URI.Table=nil then begin
        // ModelRoot with free SQL statement sent as UTF-8 (only for Admin group)
        // security note: multiple SQL statements can be run in EngineExecuteAll()
        if (reSQL in Call.RestAccessRights^.AllowRemoteExecute) and
           EngineExecuteAll(Call.InBody) then begin
          Call.OutStatus := HTML_SUCCESS; // 200 OK
          inc(fStats.fModified);
        end;
      end else
      // here, Table<>nil and TableIndex in [0..MAX_SQLTABLES-1]
      if not (URI.TableIndex in Call.RestAccessRights^.POST) then // check User
        Call.OutStatus := HTML_NOTALLOWED else
      if URI.ID<0 then begin
        // ModelRoot/TableName with possible JSON SentData: create a new member
        URI.ID := Engine.EngineAdd(URI.Table,Call.InBody);
        if URI.ID<>0 then begin
          Call.OutStatus := HTML_CREATED; // 201 Created
          Call.OutHead := 'Location: '+URI.URI+'/'+
            {$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(URI.ID);
          fCache.Notify(URI.TableIndex,URI.ID,Call.InBody,soInsert);
          inc(fStats.fModified);
        end;
      end else
        // ModelRoot/TableName/0 = BATCH sequence '{"Table":["cmd":values,...]}'
        if not (URI.TableIndex in Call.RestAccessRights^.PUT) or
           not (URI.TableIndex in Call.RestAccessRights^.DELETE) then // POST already checked
          Call.OutStatus := HTML_NOTALLOWED else
          if RunBatch(Static,URI.Table,URI) then
            Call.OutStatus := HTML_SUCCESS;
    end;
    mPUT: begin        // PUT=UPDATE
      if URI.MethodIndex>=0 then
        // PUT ModelRoot/MethodName (e.g. ModelRoot/Batch)
        LaunchCallBack(URI) else
      if URI.ID>0 then begin
        // PUT ModelRoot/TableName/ID[/BlobFieldName] to update member/BLOB content
        if not (URI.TableIndex in Call.RestAccessRights^.PUT) then // check User
          Call.OutStatus := HTML_NOTALLOWED else
        if not RecordCanBeUpdated(URI.Table,URI.ID,seUpdate,@ErrMsg) then
          Call.OutStatus := HTML_NOTMODIFIED else begin
          OK := false;
          if BlobFieldName<>'' then begin
            // PUT ModelRoot/TableName/ID/BlobFieldName: update BLOB field content
            Blob := URI.Table.RecordProps.BlobFieldPropFromRawUTF8(BlobFieldName);
            if Blob<>nil then begin
              OK := Engine.EngineUpdateBlob(URI.Table,URI.ID,Blob,Call.InBody);
            end else begin
              // PUT ModelRoot/TableName/ID/MethodName: try MethodName
              URI.MethodIndex := fPublishedMethods.Find(BlobFieldName);
              if URI.MethodIndex>=0 then
                LaunchCallBack(URI);
            end;
          end else begin
            // ModelRoot/TableName/ID with JSON SentData: update a member
            OK := Engine.EngineUpdate(URI.Table,URI.ID,Call.InBody);
            if OK then
              fCache.NotifyDeletion(URI.TableIndex,URI.ID); // flush (no CreateTime in JSON)
          end;
          if OK then begin
            Call.OutStatus := HTML_SUCCESS; // 200 OK
            inc(fStats.fModified);
          end;
        end;
      end else
      if URI.Parameters<>nil then // e.g. from TSQLRestClient.EngineUpdateField
        // PUT ModelRoot/TableName?setname=..&set=..&wherename=..&where=..
        if not (URI.TableIndex in Call.RestAccessRights^.PUT) then // check User
          Call.OutStatus := HTML_NOTALLOWED else begin
          repeat
            UrlDecodeValue(URI.Parameters,'SETNAME=',SQLSelect);
            UrlDecodeValue(URI.Parameters,'SET=',SQLDir);
            UrlDecodeValue(URI.Parameters,'WHERENAME=',SQLSort);
            UrlDecodeValue(URI.Parameters,'WHERE=',SQLWhere,@URI.Parameters);
          until URI.Parameters=nil;
          if (SQLSelect<>'') and (SQLDir<>'') and (SQLSort<>'') and (SQLWhere<>'') then
            if Engine.EngineUpdateField(URI.Table,SQLSelect,SQLDir,SQLSort,SQLWhere) then begin
              Call.OutStatus := HTML_SUCCESS; // 200 OK
              inc(fStats.fModified);
            end;
        end;
    end;
    mDELETE:
      if URI.Table<>nil then
        if URI.ID>0 then
          // ModelRoot/TableName/ID to delete a member
          if not (URI.TableIndex in Call.RestAccessRights^.DELETE) then // check User
            Call.OutStatus := HTML_NOTALLOWED else
          if not RecordCanBeUpdated(URI.Table,URI.ID,seDelete,@ErrMsg) then
            Call.OutStatus := HTML_NOTMODIFIED else begin
            if Engine.EngineDelete(URI.Table,URI.ID) and
               AfterDeleteForceCoherency(URI.Table,URI.ID) then begin
              Call.OutStatus := HTML_SUCCESS; // 200 OK
              fCache.NotifyDeletion(URI.TableIndex,URI.ID);
              inc(fStats.fModified);
            end;
          end else
        if URI.Parameters<>nil then
          if (not (URI.TableIndex in Call.RestAccessRights^.DELETE)) or
             (not (reUrlEncodedDelete in Call.RestAccessRights^.AllowRemoteExecute)) then
            Call.OutStatus := HTML_NOTALLOWED else begin
            // ModelRoot/TableName?where=WhereClause to delete members
            repeat
              if UrlDecodeValue(URI.Parameters,'WHERE=',SQLWhere,@URI.Parameters) then begin
                SQLWhere := trim(SQLWhere);
                if SQLWhere<>'' then begin
                  if Delete(URI.Table,SQLWhere) then begin
                    Call.OutStatus := HTML_SUCCESS; // 200 OK
                    inc(fStats.fModified);
                  end;
                end;
                break;
              end;
            until URI.Parameters=nil;
          end;
    mBEGIN: begin      // BEGIN TRANSACTION
      // TSQLVirtualTableJSON/External will rely on SQLite3 module
      // and also TSQLRestServerStaticInMemory, since COMMIT/ROLLBACK have Static=nil
      if TransactionBegin(URI.Table,URI.Session) then begin
        if (Static<>nil) and (StaticKind=sVirtual) then
          Static.TransactionBegin(URI.Table,URI.Session) else
        if (Static=nil) and (fTransactionTable<>nil) then begin
          Static := StaticVirtualTable[fTransactionTable];
          if Static<>nil then
            Static.TransactionBegin(URI.Table,URI.Session);
        end;
        Call.OutStatus := HTML_SUCCESS; // 200 OK
      end;
    end;
    mEND: begin        // END=COMMIT
      // this method is called with Root (-> Table=nil -> Static=nil)
      if fTransactionTable<>nil then
        Static := StaticVirtualTable[fTransactionTable];
      Commit(URI.Session);
      if Static<>nil then
        Static.Commit(URI.Session);
      Call.OutStatus := HTML_SUCCESS; // 200 OK
    end;
    mABORT: begin      // ABORT=ROLLBACK
      // this method is called with Root (-> Table=nil -> Static=nil)
      if fTransactionTable<>nil then
        Static := StaticVirtualTable[fTransactionTable];
      RollBack(URI.Session);
      if Static<>nil then
        Static.RollBack(URI.Session);
      Call.OutStatus := HTML_SUCCESS; // 200 OK
    end;
    end;
  finally
    ReleaseWrite;
  end else
    // AcquireWrite(SessionID) returned false (e.g. endless transaction)
    Call.OutStatus := HTML_TIMEOUT; // 408 Request Time-out
  end;
  // 4. returns expected result to the client
  if Call.OutStatus in [HTML_SUCCESS,HTML_CREATED] then begin
    inc(fStats.fResponses);
    {$ifdef WITHLOG}
    URI.Log.Log(sllServer,'% % -> %',[Call.Method,URI.URI,Call.OutStatus],self);
    {$endif}
  end else begin
    inc(fStats.fInvalid);
    if Call.OutBody='' then // if no custom error message, compute it now as JSON
      URI.Error(ErrMsg,Call.OutStatus);
  end;
  inc(fStats.fOutcomingBytes,length(Call.OutHead)+length(Call.OutBody)+16);
  if (Static<>nil) and (StaticKind=sInMemory) then
    // force always refresh for Static table
    Call.OutInternalState := cardinal(-1) else
    // database state may have changed above
    Call.OutInternalState := InternalState;
{$ifdef WITHSTATPROCESS}
  QueryPerformanceCounter(timeEnd);
  inc(fStats.ProcessTimeCounter,timeEnd-timeStart);
{$endif}
end;

procedure TSQLRestServer.Stat(var Ctxt: TSQLRestServerCallBackParams);
begin
  Ctxt.Returns(Stats.DebugMessage); // transmitted as JSON object
end;

procedure TSQLRestServer.TimeStamp(var Ctxt: TSQLRestServerCallBackParams);
begin
  Ctxt.Returns(Int64ToUtf8(ServerTimeStamp),HTML_SUCCESS,TEXT_CONTENT_TYPE_HEADER);
end;

procedure TSQLRestServer.CacheFlush(var Ctxt: TSQLRestServerCallBackParams);
begin
  if Ctxt.Table=nil then
    Cache.Flush else
    if Ctxt.ID=0 then
      Cache.Flush(Ctxt.Table) else
      Cache.SetCache(Ctxt.Table,Ctxt.ID);
  Ctxt.Success;
end;

procedure TSQLRestServer.Batch(var Ctxt: TSQLRestServerCallBackParams);
begin
  if (Ctxt.Method=mPUT) and RunBatch(nil,nil,Ctxt) then
    Ctxt.Success else
    Ctxt.Error; 
end;

function Nonce(Previous: boolean): RawUTF8;
var Tix: cardinal;
    tmp: RawByteString;
begin
  Tix := GetTickCount div (1000*60*5); // valid for 5*60*1000 ms = 5 minutes
  if Previous then
    dec(Tix);
  SetString(tmp,PAnsiChar(@Tix),sizeof(Tix));
  result := SHA256(tmp);
end;

procedure TSQLRestServer.Auth(var Ctxt: TSQLRestServerCallBackParams);

procedure CreateNewSession(var User: TSQLAuthUser; var Ctxt: TSQLRestServerCallBackParams);
var Session: TAuthSession;
    i: integer;
begin
  if User.fID=0 then begin
    {$ifdef WITHLOG}
    Ctxt.Log.Log(sllUserAuth,
      'User.LogonName=% not found in AuthUser table',[User.LogonName],self);
    {$endif}
    exit; // unknown user -> error 404
  end;
  if (reOneSessionPerUser in Ctxt.Call^.RestAccessRights^.AllowRemoteExecute) and
     (fSessions<>nil) then
    for i := 0 to fSessions.Count-1 do
      if TAuthSession(fSessions.List[i]).User.fID=User.fID then begin
        {$ifdef WITHLOG}
        with TAuthSession(fSessions.List[i]) do
          Ctxt.Log.Log(sllUserAuth,'User.LogonName=% already connected from "%/%"',
            [User.LogonName,RemoteIP,ConnectionID],self);
        {$endif}
        Ctxt.Call^.OutStatus := HTML_NOTALLOWED;
        exit; // user already connected -> error 404
      end;
  Session := TAuthSession.Create(self,User,Ctxt.Call);
  try
    Ctxt.Returns(['result',Session.fPrivateSalt,'logonname',User.LogonName]);
    User := nil; // will be freed by TAuthSession.Destroy
    if fSessions=nil then
      fSessions := TObjectList.Create;
    fSessions.Add(Session);
    Session := nil; // will be freed by fSessions
  finally
    Session.Free;
  end;
  fStats.ClientConnect;
end;

var aUserName, aPassWord, aClientNonce, aSalt: RawUTF8;
    User: TSQLAuthUser;
    aSessionID: cardinal;
    i: integer;
{$ifdef SSPIAUTH}
    SecCtxId: Cardinal;
    InDataEnc: RawUTF8;
    CtxArr: TDynArray;
    Now: QWord;
    SecCtxIdx: Integer;
    OutData: RawByteString;
{$endif}
begin
  if not UrlDecodeNeedParameters(Ctxt.Parameters,'UserName') then begin
    Ctxt.Error('Expect UserName parameter');
    exit;
  end;
  EnterCriticalSection(fSessionCriticalSection);
  try
    if UrlDecodeNeedParameters(Ctxt.Parameters,'Session') then begin
      // GET ModelRoot/auth?UserName=...&Session=... -> release session
      while Ctxt.Parameters<>nil do begin
        UrlDecodeValue(Ctxt.Parameters,'USERNAME=',aUserName);
        UrlDecodeCardinal(Ctxt.Parameters,'SESSION=',aSessionID,@Ctxt.Parameters);
      end;
      if (fSessions<>nil) and 
         // allow only to delete its own session - ticket [7723fa7ebd]
         (aSessionID=Ctxt.Session) then
        for i := 0 to fSessions.Count-1 do
          with TAuthSession(fSessions.List[i]) do
          if fIDCardinal=aSessionID then begin
            SessionDelete(i);
            Ctxt.Success;
            break;
          end;
      exit; // unknown session -> error 404
    end else
    if UrlDecodeNeedParameters(Ctxt.Parameters,'PassWord,ClientNonce') then begin
      // GET ModelRoot/auth?UserName=...&PassWord=...&ClientNonce=... -> handshaking
      while Ctxt.Parameters<>nil do begin
        UrlDecodeValue(Ctxt.Parameters,'USERNAME=',aUserName);
        UrlDecodeValue(Ctxt.Parameters,'PASSWORD=',aPassWord);
        UrlDecodeValue(Ctxt.Parameters,'CLIENTNONCE=',aClientNonce,@Ctxt.Parameters);
      end;
      User := TSQLAuthUser.Create(self,'LogonName=?',[aUserName]);
      try
        // check if match TSQLRestClientURI.SetUser() algorithm
        aSalt := aClientNonce+User.LogonName+User.PasswordHashHexa;
        if (aPassWord<>SHA256(Model.Root+Nonce(false)+aSalt)) and
           // if didn't try with current nonce, try with previous 5 minutes nonce
           (aPassWord<>SHA256(Model.Root+Nonce(true)+aSalt)) then
          exit;
        // now client is authenticated -> create a session
        CreateNewSession(User,Ctxt);
      finally
        User.Free;
      end;
{$ifdef SSPIAUTH}
    end else
    if UrlDecodeNeedParameters(Ctxt.Parameters,'ID,DATA') then begin
      // GET ModelRoot/auth?UserName=&id=...&data=... -> windows SSPI auth
      while Ctxt.Parameters<>nil do begin
        UrlDecodeCardinal(Ctxt.Parameters,'ID=',SecCtxId);
        UrlDecodeValue(Ctxt.Parameters,'DATA=',InDataEnc,@Ctxt.Parameters);
      end;
      EnterCriticalSection(fSSPIAuthCriticalSection);
      try
        CtxArr.Init(TypeInfo(TSecContexts), fSSPIAuthContexts);
        // check for outdated auth context
        Now := GetTickCount;
        for i := High(fSSPIAuthContexts) downto 0 do
          if Int64Rec(Now).Lo<fSSPIAuthContexts[i].Created then
            // GetTickCount 32 bit potential overflow after 49 days
            fSSPIAuthContexts[i].Created := Int64Rec(Now).Lo else
          if Now>QWord(fSSPIAuthContexts[i].Created)+QWord(30000)  then begin
            FreeSecContext(fSSPIAuthContexts[i]);
            CtxArr.Delete(i);
          end;
        // if no auth context specified, create a new one
        SecCtxIdx := -1;
        if SecCtxId <> 0 then begin
          for i := 0 to High(fSSPIAuthContexts) do
            if fSSPIAuthContexts[i].ID=SecCtxId then begin
              SecCtxIdx := i;
              break;
            end;
          // invalid or outdated id
          if SecCtxIdx<0 then
            exit;
        end;
        if SecCtxIdx<0 then begin
          // 1st call: create SecCtxId
          if High(fSSPIAuthContexts)>MAXSSPIAUTHCONTEXTS then begin
            {$ifdef WITHLOG}
            SQLite3Log.Family.SynLog.Log(sllUserAuth,
              'Too many Windows Authenticated session in pending state: MAXSSPIAUTHCONTEXTS=%',
              [MAXSSPIAUTHCONTEXTS],self);
            {$endif}
            exit;
          end;
          SecCtxIdx := CtxArr.New; // add a new entry to fSSPIAuthContexts[]
          InvalidateSecContext(fSSPIAuthContexts[SecCtxIdx]);
          fSSPIAuthContexts[SecCtxIdx].ID := fSSPIAuthCounter;
          Inc(fSSPIAuthCounter);
        end;
        // call SSPI provider
        if ServerSSPIAuth(fSSPIAuthContexts[SecCtxIdx], Base64ToBin(InDataEnc), OutData) then begin
          Ctxt.Returns(['result','','id',Int64(fSSPIAuthContexts[SecCtxIdx].ID),
            'data',BinToBase64(OutData)]);
          exit; // 1st call: send back OutData to the client
        end;
        // 2nd call: user was authenticated -> release used context
        ServerSSPIAuthUser(fSSPIAuthContexts[SecCtxIdx], aUserName);
        {$ifdef WITHLOG}
        SQLite3Log.Family.SynLog.Log(sllUserAuth,
          'Windows Authentication success for %',[aUserName],self);
        {$endif}
        FreeSecContext(fSSPIAuthContexts[SecCtxIdx]);
        CtxArr.Delete(SecCtxIdx);
      finally
        LeaveCriticalSection(fSSPIAuthCriticalSection);
      end;
      if aUserName='' then
        exit;
      // now client is authenticated -> create a session for aUserName
      User := TSQLAuthUser.Create(self,'LogonName=?',[aUserName]);
      try
        User.PasswordHashHexa := UInt32ToUtf8(SecCtxId); // override with context
        CreateNewSession(User,Ctxt);
      finally
        User.Free;
      end;
{$endif}
    end else
      // only UserName=... -> return hexadecimal nonce content valid for 5 minutes
      Ctxt.Results([Nonce(false)]);
  finally
    LeaveCriticalSection(fSessionCriticalSection);
  end;
end;

procedure TSQLRestServer.SessionDelete(aSessionIndex: integer);
begin
  if (self<>nil) and (cardinal(aSessionIndex)<cardinal(fSessions.Count)) then
  with TAuthSession(fSessions.List[aSessionIndex]) do begin
    if Services is TServiceContainerServer then
      TServiceContainerServer(Services).OnCloseSession(IDCardinal);
    {$ifdef WITHLOG}
    SQLite3Log.Family.SynLog.Log(sllUserAuth,'Deleted session %/% from %/%',
      [User.LogonName,IDCardinal,RemoteIP,ConnectionID],self);
    {$endif}
    fSessions.Delete(aSessionIndex);
    fStats.ClientDisconnect;
  end;
end;

function TSQLRestServer.SessionAccess(var aContext: TSQLRestServerCallBackParams): TAuthSession;
var i: integer;
    Now: cardinal;
begin // caller shall be locked via fSessionCriticalSection
  if (self<>nil) and (fSessions<>nil) then begin
    // first check for outdated sessions to be deleted
    Now := GetTickCount;
    for i := fSessions.Count-1 downto 0 do
      with TAuthSession(fSessions.List[i]) do
        if Now<LastAccess then // 32 bit overflow occured
          fLastAccess := Now else
        if QWord(Now)>QWord(LastAccess)+QWord(TimeOut) then
          SessionDelete(i);
    // retrieve session
    for i := 0 to fSessions.Count-1 do begin
      result := TAuthSession(fSessions.List[i]);
      if result.IDCardinal=aContext.Session then begin
        result.fLastAccess := Now; // refresh session access timestamp
        aContext.SessionUser := result.User.fID;
        aContext.SessionGroup := result.User.GroupRights.fID;
        exit;
      end;
    end;
  end;
  result := nil;
end;

function TSQLRestServer.SessionGetUser(aSessionID: Cardinal): TSQLAuthUser;
var i: integer;
begin
  result := nil;
  if (self=nil) or (fSessions=nil) then
    exit;
  EnterCriticalSection(fSessionCriticalSection);
  try
    for i := 0 to fSessions.Count-1 do
      with TAuthSession(fSessions.List[i]) do
      if IDCardinal=aSessionID then begin
        if User<>nil then begin
          result := TSQLAuthUser.Create; // manual copy excluding GroupRights
          result.fID := User.fID;
          result.LogonName := User.LogonName;
          result.DisplayName := User.DisplayName;
          result.PasswordHashHexa := User.PasswordHashHexa;
          result.Data := User.Data;
        end;
        Break;  
      end;
  finally
    LeaveCriticalSection(fSessionCriticalSection);
  end;
end;

function TSQLRestServer.CacheWorthItForTable(aTableIndex: cardinal): boolean;
begin
  if self=nil then
    result := false else
    result := (aTableIndex>=cardinal(length(fStaticData))) or
      (not fStaticData[aTableIndex].InheritsFrom(TSQLRestServerStaticInMemory));
end;

procedure TSQLRestServer.EndCurrentThread(Sender: TObject);
var i: integer;
    Inst: TServiceFactoryServerInstance;
begin
 if fStaticVirtualTable<>nil then
   for i := 0 to high(fStaticVirtualTable) do
     if fStaticVirtualTable[i]<>nil then
       fStaticVirtualTable[i].EndCurrentThread(self);
  if Services<>nil then begin
    Inst.InstanceID := GetCurrentThreadId;
    for i := 0 to Services.Count-1 do
      with TServiceFactoryServer(Services.fList.Objects[i]) do
      if InstanceCreation=sicPerThread then
        InternalInstanceRetrieve(Inst,-1); // aMethodIndex=-1 to Free it
  end;
end;

procedure TSQLRestServer.BeginCurrentThread(Sender: TThread);
var i: integer;
begin
 ServiceContext.RunningThread := Sender;
 if fStaticVirtualTable<>nil then
   for i := 0 to high(fStaticVirtualTable) do
     if fStaticVirtualTable[i]<>nil then
       fStaticVirtualTable[i].BeginCurrentThread(Sender);
end;

function TSQLRestServer.InternalUpdateEvent(aEvent: TSQLEvent; aTable: TSQLRecordClass;
  aID: integer): boolean;
begin
  if Assigned(OnUpdateEvent) then
    result := OnUpdateEvent(self,aEvent,aTable,aID) else
    result := true; // true on success, false if error (but action continues)
end;

function CurrentServiceContext: TServiceRunningContext;
begin
  result := ServiceContext;
end;


{$ifdef MSWINDOWS}

{ TSQLRestClientURIDll }

constructor TSQLRestClientURIDll.Create(aModel: TSQLModel; const DllName: TFileName);
var aRequest: TURIMapRequest;
    aDLL: cardinal;
begin
  aDLL := LoadLibrary(pointer(DllName));
  if aDLL=0 then
    raise ECommunicationException.Create(DllName);
  aRequest := GetProcAddress(aDLL,'URIRequest');
  if (@aRequest=nil) or (aRequest(nil,nil,nil,nil,nil).Lo<>HTML_NOTFOUND) then begin
    FreeLibrary(aDLL);
    raise ECommunicationException.CreateFmt('%s doesn''t export a valid URIRequest function',[DllName]);
  end;
  Create(aModel,aRequest);
  fLibraryHandle := aDLL;
end;

constructor TSQLRestClientURIDll.Create(aModel: TSQLModel; aRequest: TURIMapRequest);
begin
  inherited Create(aModel);
  Func := aRequest;
end;

destructor TSQLRestClientURIDll.Destroy;
begin
  if fLibraryHandle<>0 then
    FreeLibrary(fLibraryHandle);
  inherited;
end;

function TSQLRestClientURIDll.InternalURI(const url, method: RawUTF8;
  Resp, Head, SendData: PRawUTF8): Int64Rec;
var pSend, pResp, pHead: PUTF8Char;
    ppHead, ppResp: PPUTF8Char;
begin
  if @Func=nil then begin
    Int64(result) := HTML_NOTIMPLEMENTED; // 501 (no valid application or library)
    exit;
  end;
  pResp := nil;
  pHead := nil;
  if SendData=nil then
    pSend := nil else
    pSend := pointer(SendData^);
  try
    // initialize response pointers if necessary
    if Resp<>nil then
      ppResp := @pResp else
      ppResp := nil;
    if Head<>nil then
      ppHead := @pHead else
      ppHead := nil;
    // call the server
    result := Func(pointer(url),pointer(method),pSend,ppResp,ppHead);
    // copy the pResp,pHead PAnsiChar response into local ansistrings
    if Resp<>nil then
      Resp^ := pResp;
    if Head<>nil then
      Head^ := pHead;
  finally // always release response memory allocated by the server
    if pResp<>nil then
      if USEFASTMM4ALLOC then
        Freemem(pResp) else
        GlobalFree(cardinal(pResp));
    if pHead<>nil then
      if USEFASTMM4ALLOC then
        Freemem(pHead) else
        GlobalFree(cardinal(pHead));
  end;
end;

function TSQLRestClientURIDll.InternalCheckOpen: boolean;
begin
  result := true; // success
end;

procedure TSQLRestClientURIDll.InternalClose;
begin
end;

{$endif MSWINDOWS}


{$ifdef MSWINDOWS}

{$ifdef ANONYMOUSNAMEDPIPE}

// it should be necessary to Edit settings under Local Security Policy -> Local
// policies -> Security options -> Edit settings under "Network access" to allow
// for anonymous connections.

// BUT even with the pipe name added to the
//  SYSTEM\CurrentControlSet\Services\lanmanserver\parameters\NullSessionPipes
// registry key, code below didn't work

function GetUserSid(var SID: PSID; var Token: THandle): boolean;
var TokenUserSize: DWORD;
    TokenUserP: PSIDAndAttributes;
begin
  result := false;
  if not OpenThreadToken(GetCurrentThread, TOKEN_QUERY, True, Token) then
    if (GetLastError <> ERROR_NO_TOKEN) or
       not OpenProcessToken(GetCurrentProcess, TOKEN_QUERY, Token) then
      Exit;
  TokenUserP := nil;
  TokenUserSize := 0;
  try
    if not GetTokenInformation(Token, TokenUser, nil, 0, TokenUserSize) and
       (GetLastError <> ERROR_INSUFFICIENT_BUFFER) then
      Exit;
    TokenUserP := AllocMem(TokenUserSize);
    if not GetTokenInformation(Token, TokenUser, TokenUserP,
       TokenUserSize, TokenUserSize) then
      Exit;
    SID := TokenUserP^.Sid;
    result := true;
  finally
    FreeMem(TokenUserP);
  end;
end;

{$ALIGN ON}
type
    ACE_HEADER = record
      AceType: BYTE;
      AceFlags: BYTE;
      AceSize: WORD;
    end;
    ACCESS_ALLOWED_ACE = record
      Header: ACE_HEADER;
      Mask: ACCESS_MASK;
      SidStart: DWORD;
    end;
{$A8}

procedure InitializeSecurity(var SA: TSecurityAttributes; var SD);
const
  SECURITY_NT_AUTHORITY: TSIDIdentifierAuthority = (Value: (0, 0, 0, 0, 0, 5));
  SECURITY_ANONYMOUS_LOGON_RID = ($00000007);
  ACL_REVISION = 2;
var pSidAnonymous, pSidOwner: PSID;
    dwAclSize: integer;
    ACLP: PACL;
    Token: THandle;
begin
  fillchar(SD,SECURITY_DESCRIPTOR_MIN_LENGTH,0);
  // Initialize the new security descriptor
  if InitializeSecurityDescriptor(@SD, SECURITY_DESCRIPTOR_REVISION) and
      GetUserSid(pSidOwner,Token) then begin
    AllocateAndInitializeSid(SECURITY_NT_AUTHORITY,1,
      SECURITY_ANONYMOUS_LOGON_RID,0,0,0,0,0,0,0,pSidAnonymous);
    try
      dwAclSize := sizeof(TACL) +
        2 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
        GetLengthSid(pSidAnonymous) + GetLengthSid(pSidOwner) ;
      ACLP := AllocMem(dwAclSize);
      try
        InitializeAcl(ACLP^,dwAclSize,ACL_REVISION);
        if not AddAccessAllowedAce(ACLP^,ACL_REVISION,
           GENERIC_ALL,pSidOwner) then
          exit;
        if not AddAccessAllowedAce(ACLP^,ACL_REVISION,
           GENERIC_READ or GENERIC_WRITE,pSidAnonymous) then
          exit;
        if SetSecurityDescriptorDacl(@SD,true,ACLP,false) then begin
           // Set up the security attributes structure
           SA.nLength := sizeof(TSecurityAttributes);
           SA.lpSecurityDescriptor := @SD;
           SA.bInheritHandle := true;
           exit; // mark OK
        end;
      finally
        FreeMem(ACLP);
      end;
    finally
      FreeSid(pSidAnonymous);
      CloseHandle(Token);
    end;
  end;
  fillchar(SA,sizeof(SA),0); // mark error: no security
end;

{$else}

{$ifndef NOSECURITYFORNAMEDPIPECLIENTS}

{$if CompilerVersion >= 22.0} // fix Delphi XE incompatilibility
function InitializeSecurityDescriptor(pSecurityDescriptor: PSecurityDescriptor;
  dwRevision: DWORD): BOOL; stdcall; external advapi32;
function SetSecurityDescriptorDacl(pSecurityDescriptor: PSecurityDescriptor;
  bDaclPresent: BOOL; pDacl: PACL; bDaclDefaulted: BOOL): BOOL; stdcall; external advapi32;
{$ifend}

procedure InitializeSecurity(var SA: TSecurityAttributes; var SD);
begin
  fillchar(SD,SECURITY_DESCRIPTOR_MIN_LENGTH,0);
  // Initialize the new security descriptor
  if InitializeSecurityDescriptor(@SD, SECURITY_DESCRIPTOR_REVISION) then begin
     // Add a NULL descriptor ACL to the security descriptor
     if SetSecurityDescriptorDacl(@SD, true, nil, false) then begin
        // Set up the security attributes structure
        SA.nLength := sizeof(TSecurityAttributes);
        SA.lpSecurityDescriptor := @SD;
        SA.bInheritHandle := true;
        exit; // mark OK
     end;
  end;
  fillchar(SA,sizeof(SA),0); // mark error: no security
end;

{$endif NOSECURITYFORNAMEDPIPECLIENTS}

{$endif ANONYMOUSNAMEDPIPE}


{ TSQLRestServerNamedPipe }

constructor TSQLRestServerNamedPipe.Create(aServer: TSQLRestServer;
  const PipeName: TFileName);
begin
  inherited Create(false);
  fServer := aServer;
  fPipeName := PipeName;
  fChild := TList.Create;
//  writeln('TSQLRestServerNamedPipe ',PipeName,' ThreadID=',ThreadID);
end;

destructor TSQLRestServerNamedPipe.Destroy;
var i: integer;
begin
  //writeln('TSQLRestServerNamedPipe.Destroy');
  for i := 0 to fChild.Count-1 do // close any still opened pipe
    if fChild[i]<>nil then begin
      {writeln('fChildCount=',fChildCount,' TSQLRestServerNamedPipeResponse=',
        integer(TSQLRestServerNamedPipeResponse),'.Terminated=',
        BoolToStr(TSQLRestServerNamedPipeResponse(fChild[i]).Terminated,true));}
      TSQLRestServerNamedPipeResponse(fChild[i]).Terminate;
    end;
  while fChildCount>0 do
    Sleep(64); // wait for all TSQLRestServerNamedPipeResponse.Destroy
  fChild.Free;
  inherited;
end;

procedure TSQLRestServerNamedPipe.Execute;
var aPipe: cardinal;
    Available: cardinal;
    {$ifndef NOSECURITYFORNAMEDPIPECLIENTS}
    fPipeSecurityAttributes: TSecurityAttributes;
    fPipeSecurityDescriptor: array[0..SECURITY_DESCRIPTOR_MIN_LENGTH] of byte;
    {$endif}
begin // see http://msdn.microsoft.com/en-us/library/aa365588(v=VS.85).aspx
  //writeln('TSQLRestServerNamedPipe=',integer(TSQLRestServerNamedPipe),'.Execute');
  {$ifndef NOSECURITYFORNAMEDPIPECLIENTS}
  InitializeSecurity(fPipeSecurityAttributes,fPipeSecurityDescriptor);
  {$endif}
  while not Terminated do begin
    //writeln('TSQLRestServerNamedPipe.CreateNamedPipe(',fPipeName,')');
    aPipe := CreateNamedPipe(pointer(fPipeName),
      PIPE_ACCESS_DUPLEX,
      PIPE_TYPE_BYTE or PIPE_READMODE_BYTE or PIPE_WAIT,
      PIPE_UNLIMITED_INSTANCES, 0, 0, 0,
      {$ifdef NOSECURITYFORNAMEDPIPECLIENTS}nil{$else}@fPipeSecurityAttributes{$endif});
    if aPipe=INVALID_HANDLE_VALUE then
      break;
    while not Terminated do
      if PeekNamedPipe(aPipe,nil,0,nil,@Available,nil) then
        if (Available>=4) then begin
          // PeekNamedPipe() made an implicit ConnectNamedPipe(aPipe,nil)
          InterlockedIncrement(fChildCount);
          TSQLRestServerNamedPipeResponse.Create(fServer,self,aPipe);
          aPipe := 0; // aPipe will be closed in TSQLRestServerNamedPipeResponse
          break;
        end
        else break // invalid request
      else Sleep(128); // doesn't slow down connection but decreases CSwitch
    if aPipe<>0 then begin
      DisconnectNamedPipe(aPipe);
      CloseHandle(aPipe);
    end;
  end;
end;


{ TSQLRestServerNamedPipeResponse }

constructor TSQLRestServerNamedPipeResponse.Create(aServer: TSQLRestServer;
  aMasterThread: TSQLRestServerNamedPipe; aPipe: cardinal);
begin
  inherited Create(false);
  fServer := aServer;
  fMasterThread := aMasterThread;
  with fMasterThread.fChild do begin
    fMasterThreadChildIndex := IndexOf(nil); // get free position in fChild[]
    if fMasterThreadChildIndex<0 then
      fMasterThreadChildIndex := Add(self) else
      Items[fMasterThreadChildIndex] := self;
  end;
  fPipe := aPipe;
  FreeOnTerminate := true;
{$ifdef LVCL}
  OnTerminate := fServer.EndCurrentThread;
{$endif}
end;

{$ifndef LVCL}
procedure TSQLRestServerNamedPipeResponse.DoTerminate;
begin
  fServer.EndCurrentThread(self); // will release any thread-specific resource
end;
{$endif}

destructor TSQLRestServerNamedPipeResponse.Destroy;
begin
  if fMasterThread<>nil then
    with fMasterThread do begin
      fChild[fMasterThreadChildIndex] := nil;
      InterlockedDecrement(fChildCount);
    end;
  inherited;
end;

procedure TSQLRestServerNamedPipeResponse.Execute;
var call: TSQLRestServerURIParams;
    Code: integer;
    Ticks, Sleeper, ClientTimeOut: cardinal;
    Header: RawUTF8;
    Available: cardinal;
begin
  if (fPipe=0) or (fPipe=INVALID_HANDLE_VALUE) or (fServer=nil) then
    exit;
  Header := 'RemoteIP: 127.0.0.1'#13#10'ConnectionID: '+CardinalToHex(fPipe); 
  fServer.BeginCurrentThread(self);
  Ticks := 0;
  Sleeper := 0;
  ClientTimeOut := GetTickCount+30*60*1000; // disconnect client after 30 min of inactivity
  try
    while not Terminated do
    if // (WaitForSingleObject(fPipe,200)=WAIT_OBJECT_0) and  = don't wait
       PeekNamedPipe(fPipe,nil,0,nil,@Available,nil) and (Available>=4) then begin
      FileRead(fPipe,Code,4);
      if (Code=integer(MAGIC_SYN)) // magic word for URI like request
        and not Terminated then
        try
          call.Url := ReadString(fPipe);
          call.Method := ReadString(fPipe);
          call.InHead := ReadString(fPipe);
          if call.InHead='' then
            call.InHead := Header else
            call.InHead := call.InHead+#13#10+Header;
          call.InBody := ReadString(fPipe);
          call.RestAccessRights := @SUPERVISOR_ACCESS_RIGHTS;
          // it's up to URI overriden method to implement access rights
          fServer.URI(call);
          FileWrite(fPipe,call.OutStatus,sizeof(cardinal)*2);
          WriteString(fPipe,call.OutHead);
          WriteString(fPipe,call.OutBody);
          FlushFileBuffers(fPipe); // Flush the pipe to allow the client to read
          Ticks := GetTickCount+20; // start sleeping after 20 ms
          ClientTimeOut := Ticks+30*60*1000;
          if ClientTimeOut<Ticks then // avoid 32 bits overflow
            ClientTimeOut := 30*60*1000;
          Sleeper := 0;
          Sleep(0);
        except
          on Exception do // error in ReadString() or fServer.URI()
            break; // disconnect client
        end else
          break; // invalid magic word: disconnect client
    end else
    if (Ticks=0) or (GetTickCount>Ticks) then begin
      if Sleeper<128 then
        inc(Sleeper,16);
      Sleep(Sleeper); // doesn't slow down connection but decreases CSwitch
      Ticks := 0;
      if GetTickCount>ClientTimeOut then
        break; // disconnect client after 30 min of inactivity
    end else
      Sleep(0);
  finally
    DisconnectNamedPipe(fPipe);
    CloseHandle(fPipe);
  end;
end;


{ TSQLRestClientURINamedPipe }

function ImpersonateAnonymousToken(ThreadHandle: THANDLE): BOOL; stdcall; external advapi32;

const
  /// how many times we may retry to connect to the named pipe server
  // - each retry may take up to 1200 ms
  NAMEDPIPE_RETRYCOUNT_IFBUSY = 5;

constructor TSQLRestClientURINamedPipe.Create(aModel: TSQLModel;
  const ApplicationName: TFileName);
begin
  inherited Create(aModel);
  if {$ifdef UNICODE}IdemPCharW{$else}IdemPChar{$endif}(pointer(ApplicationName),'\\') then
    fPipeName := ApplicationName else // caller specified a full path
    fPipeName := ServerPipeNamePrefix+ApplicationName;
  InitializeCriticalSection(fLock);
end;

destructor TSQLRestClientURINamedPipe.Destroy;
begin
  inherited Destroy;
  DeleteCriticalSection(fLock);
end;

function TSQLRestClientURINamedPipe.InternalCheckOpen: boolean;
procedure InternalCreateClientPipe;
var Pipe: THandle;
    Retry: cardinal;
{$ifdef WITHLOG}
    Log: ISynLog;
{$endif}
procedure CreatePipe;
begin
  Pipe := CreateFile(pointer(fPipeName), GENERIC_READ or GENERIC_WRITE,
{$ifdef ANONYMOUSNAMEDPIPE}
    FILE_SHARE_READ or FILE_SHARE_WRITE,
    nil, OPEN_EXISTING, SECURITY_SQOS_PRESENT or SECURITY_ANONYMOUS, 0);
{$else}
    0, {$ifdef NOSECURITYFORNAMEDPIPECLIENTS}nil{$else}@fPipeSecurityAttributes{$endif},
    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL or FILE_FLAG_OVERLAPPED, 0);
{$endif}
end;
begin
{$ifdef WITHLOG}
  Log := SQLite3Log.Enter;
{$endif}
{$ifdef ANONYMOUSNAMEDPIPE}
  if not ImpersonateAnonymousToken(GetCurrentThread) then
     raise Exception.Create('ImpersonateAnonymousToken');
  try
{$else}
  {$ifndef NOSECURITYFORNAMEDPIPECLIENTS}
  InitializeSecurity(fPipeSecurityAttributes,fPipeSecurityDescriptor);
  {$endif}
{$endif}
  CreatePipe;
  if (Pipe=INVALID_HANDLE_VALUE) or (Pipe=ERROR_PIPE_BUSY) then
    for Retry := 1 to NAMEDPIPE_RETRYCOUNT_IFBUSY do begin
      if WaitNamedPipe(pointer(fPipeName),1000) then begin
        // 1000 since we have sleep(128) in TSQLRestServerNamedPipe.EngineExecute
        CreatePipe;
        if Pipe<>ERROR_PIPE_BUSY then
          break;
      end;
      sleep(200); // wait for TSQLRestServerNamedPipe.EngineExecute to be reached
    end;
  if (Pipe=INVALID_HANDLE_VALUE) or (Pipe=ERROR_PIPE_BUSY) then begin
    {$ifdef WITHLOG}
    Log.Log(sllError,'"%" when connecting to %',[
      SysErrorMessage(GetLastError),fPipeName]);
    {$endif}
    exit;
  end;
{$ifdef ANONYMOUSNAMEDPIPE}
  finally
    RevertToSelf; // we just needed to be anonymous during pipe connection
  end;
{$endif}
  fServerPipe := Pipe;
end;
begin
  if fServerPipe<>0 then begin
    result := true;
    exit; // only reconnect if forced by InternalClose call or at first access
  end;
  InternalCreateClientPipe; // local sub-procedure to reduce stack overhead 
  result := fServerPipe<>0;
end;

procedure TSQLRestClientURINamedPipe.InternalClose;
begin
  if fServerPipe<>0 then begin   // inherited; may use pipe -> close after
    WriteString(fServerPipe,''); // send integer=0 -> force server disconnect
    FileClose(fServerPipe);
  end;
end;

function TSQLRestClientURINamedPipe.InternalURI(const url, method: RawUTF8;
  Resp, Head, SendData: PRawUTF8): Int64Rec;
var s: RawUTF8;
    Card: cardinal;
{.$define TSQLRestClientURIDll_TIMEOUT} // to be tried over slow networks if errors
{$ifdef TSQLRestClientURIDll_TIMEOUT}
    i: integer;
{$endif}
{$ifdef WITHLOG}
    Log: ISynLog;
{$endif}
begin
{$ifdef WITHLOG}
  Log := SQLite3Log.Enter(self);
{$endif}
  Int64(result) := HTML_NOTIMPLEMENTED; // 501 (no valid application or library)
  EnterCriticalSection(fLock);
  try
    if InternalCheckOpen then
    try
      Card := MAGIC_SYN; // magic word
      if FileWrite(fServerPipe,Card,4)<>4 then begin // "The pipe is being closed"
        WaitNamedPipe(pointer(fPipeName),500);
        if FileWrite(fServerPipe,Card,4)<>4 then begin
          FileClose(fServerPipe);
          WaitNamedPipe(pointer(fPipeName),500);
          fServerPipe := FileOpen(fPipeName,fmOpenReadWrite); // recreate connection
          if (fServerPipe=Invalid_Handle_Value) or
             (FileWrite(fServerPipe,Card,4)<>4) then begin
            Card := GetLastError;
            {$ifdef WITHLOG}
            Log.Log(sllLastError,'PipeName=%',[fPipeName],self);
            {$endif}
            if fServerPipe<>Invalid_Handle_Value then
              FileClose(fServerPipe);
            fServerPipe := 0;
            exit; // no existing pipe
          end;
        end;
      end;
      // send the request
      if url='' then
        s := '';
      WriteString(fServerPipe,url);
      WriteString(fServerPipe,method);
      if Head=nil then
        WriteString(fServerPipe,'') else
        WriteString(fServerPipe,Head^);
      if SendData=nil then
        WriteString(fServerPipe,'') else
        WriteString(fServerPipe,SendData^);
      FlushFileBuffers(fServerPipe);
      // receive the answer
{$ifdef TSQLRestClientURIDll_TIMEOUT}
      for i := 0 to 25 do // wait up to 325 ms
        if PeekNamedPipe(fServerPipe,nil,0,nil,@Card,nil) and
           (Card>=sizeof(result)) then begin
          FileRead(fServerPipe,result,sizeof(result));
          s := ReadString(fServerPipe);
          if Head<>nil then
            Head^ := s;
          s := ReadString(fServerPipe);
          if Resp<>nil then
            Resp^ := s;
          exit;
        end else
        Sleep(i);
      Int64(result) := HTML_TIMEOUT; // 408 Request Timeout Error
{$else}
      if FileRead(fServerPipe,result,sizeof(result))=sizeof(result) then begin
        // FileRead() waits till response arrived
        s := ReadString(fServerPipe);
        if Head<>nil then
          Head^ := s;
        s := ReadString(fServerPipe);
        if Resp<>nil then
          Resp^ := s;
      end else
        Int64(result) := HTML_NOTFOUND;
{$endif}
     except
       on E: Exception do begin // error in ReadString()
         {$ifdef WITHLOG}
         Log.Log(sllLastError,'% for PipeName=%',[E,fPipeName],self);
         {$endif}
         Int64(result) := HTML_NOTIMPLEMENTED; // 501 (no valid application or library)
         WriteString(fServerPipe,''); // try to notify the server of client logout
         FileClose(fServerPipe);
         fServerPipe := 0;
       end;
     end;
  finally
    LeaveCriticalSection(fLock);
  end;
{$ifdef WITHLOG}
  Log.Log(sllClient,'% % result.Lo=% .Hi=%',[method,url,result.Lo,result.Hi],self);
{$endif}
end;


{$endif MSWINDOWS}


{ TSQLRestServerStats }

function TSQLRestServerStats.Changed: boolean;
begin
  result := fLastIncomingBytes<>IncomingBytes;
  if result then
    fLastIncomingBytes := IncomingBytes;
end;

procedure TSQLRestServerStats.ClientConnect;
begin
  inc(fClientsCurrent);
  if fClientsCurrent>fClientsMax then
    fClientsMax := fClientsCurrent;
  inc(fIncomingBytes,4); // change IncomingBytes to trigger message update
end;

procedure TSQLRestServerStats.ClientDisconnect;
begin
  if fClientsCurrent>0 then
    dec(fClientsCurrent);
  inc(fIncomingBytes,4); // change IncomingBytes to trigger message update
end;

function TSQLRestServerStats.DebugMessage: RawUTF8;
begin
  result := ObjectToJSON(self,[woHumanReadable]);
end;

function TSQLRestServerStats.ModifPercent: cardinal;
begin
  if Responses=0 then
    result := 0 else
    result := (Modified*100)div Responses;
end;

{$ifdef WITHSTATPROCESS}
function TSQLRestServerStats.GetProcessTimeString: RawUTF8;
var Freq: Int64;
begin
  QueryPerformanceFrequency(Freq); // performance-counter frequency in counts per second
  if (self=nil) or (Freq=0) then
    result := '0' else
    result := MicroSecToString((ProcessTimeCounter*(1000*1000))div Freq);
end;
{$endif}


{ TSQLRestServerStaticRecordBased }

function TSQLRestServerStaticRecordBased.EngineAdd(Table: TSQLRecordClass;
  const SentData: RawUTF8): integer;
var Rec: TSQLRecord;
begin
  if (self=nil) or (Table<>fStoredClass) then begin
    result := 0; // mark error
    exit;
  end;
  Lock(true);
  try
    Rec := fStoredClass.Create;
    Rec.FillFrom(SentData);
    result := AddOne(Rec,Rec.fID>0);
    if result<=0 then
      Rec.Free; // on success, will be freed by fValue TObjectList
  finally
    UnLock;
  end;
end;

function TSQLRestServerStaticRecordBased.EngineUpdate(
  Table: TSQLRecordClass; ID: integer; const SentData: RawUTF8): boolean;
var Rec: TSQLRecord;
begin
  // this implementation won't handle partial fields update (e.g. BatchUpdate
  // after FillPrepare) - but TSQLRestServerStaticInMemory.EngineUpdate will
  if (self=nil) or (Table<>fStoredClass) then begin
    result := false; // mark error
    exit;
  end;
  Lock(true);
  try
    Rec := fStoredClass.Create;
    try
      Rec.FillFrom(SentData);
      result := UpdateOne(Rec);
    finally
      Rec.Free;
    end;
  finally
    UnLock;
  end;
end;

function TSQLRestServerStaticRecordBased.UpdateOne(ID: integer;
  const Values: TVarDataDynArray): boolean;
var Rec: TSQLRecord;
begin
  if self=nil then begin
    result := false; // mark error
    exit;
  end;
  Lock(true);
  try
    Rec := fStoredClass.Create;
    try
      Rec.SetFieldVarDatas(Values);
      Rec.fID := ID;
      result := UpdateOne(Rec);
    finally
      Rec.Free;
    end;
  finally
    UnLock;
  end;
end;


{ TSQLRestServerStatic }

function TSQLRestServerStaticInMemory.AddOne(Rec: TSQLRecord; ForceID: boolean): integer;
var ndx,i: integer;
begin
  if (self=nil) or (Rec=nil) then begin
    result := -1; // mark error
    exit;
  end;
  if ForceID then
    if Rec.fID=0 then
      raise EORMException.Create('AddOne called with ForceID=0') else
      result := Rec.fID else begin
    if fValue.Count=0 then
      result := 1 else // default ID for a void table
      result := TSQLRecord(fValue[fValue.Count-1]).fID+1; // new ID compute
    Rec.fID := result;
  end;
  ndx := fValue.Add(Rec);
  if fUniqueFields<>nil then
    for i := 0 to fUniqueFields.Count-1 do
    if not TListFieldHash(fUniqueFields.List[i]).JustAdded then begin
      fValue.List[ndx] := nil; // avoid GPF within Delete()
      fValue.Delete(ndx);
      result := -1; // duplicate unique fields -> error
      exit;
    end;
  fModified := true;
  if Owner<>nil then
     Owner.InternalUpdateEvent(seAdd,PSQLRecordClass(Rec)^,result);
end;

function TSQLRestServerStaticInMemory.UniqueFieldsUpdateOK(aRec: TSQLRecord; aUpdateIndex: integer): boolean;
var i,ndx: integer;
begin
  if fUniqueFields<>nil then begin
    result := false;
    with fUniqueFields do
      for i := 0 to Count-1 do begin
        ndx := TListFieldHash(List[i]).Find(aRec);
        if (ndx>=0) and (ndx<>aUpdateIndex) then
          exit; // duplicate found at another entry
      end;
  end;
  result := true;
end;

function TSQLRestServerStaticInMemory.UniqueFieldHash(aFieldIndex: integer): TListFieldHash;
var i: integer;
begin
  if (fUniqueFields<>nil) and
     (cardinal(aFieldIndex)<cardinal(fStoredClassRecordProps.Fields.Count)) then
    with fUniqueFields do
      for i := 0 to Count-1 do begin
        result := List[i];
        if result.FieldIndex=aFieldIndex then
          exit;
      end;
  result := nil;
end;

constructor TSQLRestServerStaticInMemory.Create(aClass: TSQLRecordClass; aServer: TSQLRestServer;
  const aFileName: TFileName = ''; aBinaryFile: boolean=false);
var JSON: RawUTF8;
    Stream: TStream;
    F: integer;
begin
  inherited Create(aClass,aServer,aFileName,aBinaryFile);
  if (fStoredClassProps<>nil) and (fStoredClassProps.Kind in INSERT_WITH_ID) then
    raise EModelException.CreateFmt('%s: %s virtual table can''t be static',
      [fStoredClassRecordProps.SQLTableName,aClass.ClassName]);
  fBinaryFile := aBinaryFile;
  fValue := TObjectList.Create;
  fSearchRec := fStoredClass.Create;
  fIDSorted := true; // sorted by design of this class (may change in children)
  if (ClassType<>TSQLRestServerStaticInMemory) and (fStoredClassProps<>nil) then
    with fStoredClassProps do begin // used by AdaptSQLForEngineList() method
      fBasicUpperSQLWhere := UpperCase(SQL.SelectAll[false]);
      fBasicUpperSQLWhere[length(fBasicUpperSQLWhere)] := ' '; // ';' -> ' '
      fBasicUpperSQLWhere := fBasicUpperSQLWhere+'WHERE ';
    end;
  fBasicSQLCount := 'SELECT COUNT(*) FROM '+fStoredClassRecordProps.SQLTableName;
  fBasicSQLHasRows := 'SELECT RowID FROM '+fStoredClassRecordProps.SQLTableName+' LIMIT 1';
  if not IsZero(fIsUnique) then begin
    fUniqueFields := TObjectList.Create;
    with fStoredClassRecordProps do
    for F := 0 to Fields.Count-1 do
      if F in fIsUnique then
        // CaseInsensitive=true just like
        fUniqueFields.Add(TListFieldHash.Create(fValue,F,Fields.List[F],true));
  end;
  if (fFileName<>'') and FileExists(fFileName) then begin
    if aBinaryFile then begin
      Stream := TSynMemoryStreamMapped.Create(fFileName);
      try
        LoadFromBinary(Stream)
      finally
        Stream.Free;
      end;
    end else begin
      Stream := TFileStream.Create(fFileName,fmOpenRead);
      try
        SetLength(JSON,Stream.Size);
        Stream.Read(pointer(JSON)^,length(JSON));
        LoadFromJSON(JSON);
      finally
        Stream.Free;
      end;
    end;
  end;
end;

function TSQLRestServerStaticInMemory.EngineDelete(Table: TSQLRecordClass; ID: integer): boolean;
var i,F: integer;
begin
  if (self=nil) or (ID<=0) or (Table<>fStoredClass) or
     not RecordCanBeUpdated(Table,ID,seDelete) then begin
    result := false;
    exit;
  end;
  Lock(True);
  try
    i := IDToIndex(ID);
    if i<0 then
      result := false else begin
      if fUniqueFields<>nil then
        for F := 0 to fUniqueFields.Count-1 do
          TListFieldHash(fUniqueFields.List[F]).Invalidate;
      if Owner<>nil then
         Owner.InternalUpdateEvent(seDelete,Table,ID); // notify BEFORE deletion
      fValue.Delete(i); // TObjectList.Delete() will Free record
      fModified := true;
      result := true;
    end;
  finally
    UnLock;
  end;
end;

function TSQLRestServerStaticInMemory.EngineDeleteWhere(Table: TSQLRecordClass;
  const SQLWhere: RawUTF8; const IDs: TIntegerDynArray): boolean;
var ndx: TIntegerDynArray;
    n,i: integer;
begin // RecordCanBeUpdated() has already been called
  result := false;
  n := length(IDs);
  SetLength(ndx,n);
  dec(n);
  Lock(True);
  try
    for i := 0 to n do begin
      ndx[i] := IDToIndex(IDs[i]);
      if ndx[i]<0 then
        exit;
    end;
    if fUniqueFields<>nil then
      for i := 0 to fUniqueFields.Count-1 do
        TListFieldHash(fUniqueFields.List[i]).Invalidate;
    if Owner<>nil then
      for i := 0 to n do
        Owner.InternalUpdateEvent(seDelete,Table,IDs[i]); // notify BEFORE deletion
    QuickSortInteger(pointer(ndx),0,n); // deletion a bit faster in reverse order
    for i := n downto 0 do
      fValue.Delete(ndx[i]);
    fModified := true;
    result := true;
  finally
    UnLock;
  end;
end;

destructor TSQLRestServerStaticInMemory.Destroy;
begin
  UpdateFile;
  fValue.Free; // TObjectList.Destroy will free all stored TSQLRecord instances
  fUniqueFields.Free;
  fSearchRec.Free;
  inherited Destroy;
end;

function TSQLRestServerStaticInMemory.GetCount: integer;
begin
  if Self<>nil then
    result := fValue.Count else
    result := 0;
end;

function TSQLRestServerStaticInMemory.GetID(Index: integer): integer;
begin
  with fValue do
    if (self=nil) or (cardinal(Index)>=cardinal(Count)) then
      result := 0 else
      result := TSQLRecord(List[Index]).fID;
end;

function TSQLRestServerStaticInMemory.GetItem(Index: integer): TSQLRecord;
begin
  if self<>nil then
    with fValue do
      if cardinal(Index)>=cardinal(Count) then
        raise EORMException.Create('GetItem out of range') else
        result := List[Index] else
    result := nil;
end;

procedure TSQLRestServerStaticInMemory.GetJSONValuesEvent(aDest: pointer;
  aRec: TSQLRecord; aIndex: integer);
var W: TJSONSerializer absolute aDest;
begin
  aRec.GetJSONValues(W);
  W.Add(',');
end;

procedure TSQLRestServerStaticInMemory.AddIntegerDynArrayEvent(
  aDest: pointer; aRec: TSQLRecord; aIndex: integer);
var Ints: TList absolute aDest;
begin
  Ints.Add(pointer(aIndex));
end;

procedure TSQLRestServerStaticInMemory.DoNothingEvent(aDest: pointer; aRec: TSQLRecord; aIndex: integer);
begin
end;

function TSQLRestServerStaticInMemory.AdaptSQLForEngineList(var SQL: RawUTF8): boolean;
var P: PUTF8Char;
    Prop: RawUTF8;
begin
  result := inherited AdaptSQLForEngineList(SQL);
  if result then
    exit; // 'select * from table'
  if IdemPropNameU(fBasicSQLCount,SQL) or IdemPropNameU(fBasicSQLHasRows,SQL) then begin
    result := true;
    exit; // 'select count(*) from table' will be handled as static
  end;
  if (fBasicUpperSQLWhere='') or
     not IdemPChar(pointer(SQL),pointer(fBasicUpperSQLWhere)) then
    exit; 
  P := pointer(SQL);
  inc(P,length(fBasicUpperSQLWhere));
  P := GotoNextNotSpace(P);
  Prop := GetNextItem(P,'=');
  if (P=nil) or (fStoredClassRecordProps.Fields.IndexByName(Prop)<0) then
    exit;
  if PWord(P)^=ord(':')+ord('(') shl 8 then
    inc(P,2); // +2 to ignore :(...): parameter
  if P^ in ['''','"'] then
    P := GotoEndOfQuotedString(P) else
    repeat inc(P) until P^ in [#0..' ',';',')']; // go to end of value
  if PWord(P)^=ord(')')+ord(':')shl 8 then
    inc(P,2); // ignore :(...): parameter
  P := GotoNextNotSpace(P);
  if (P^ in [#0,';']) or IdemPChar(P,'LIMIT 1;') then
    result := true; // properly ended the WHERE clause as 'FIELDNAME=value'
end;

function TSQLRestServerStaticInMemory.FindWhereEqual(WhereField: integer;
  const WhereValue: RawUTF8; OnFind: TFindWhereEqualEvent; Dest: pointer;
  FoundLimit,FoundOffset: integer): PtrInt;
var i, ndx: integer;
    aValue: PtrInt;
    err, currentRow: integer;
    P: TSQLPropInfo;
    Hash: TListFieldHash;
    Offs: PtrInt;
begin
  result := 0;
  if FoundLimit<=0 then
    FoundLimit := maxInt;
  if Assigned(OnFind) then
  if WhereField=SYNTABLESTATEMENTWHEREID then begin
    if FoundOffset<=0 then begin // omit first FoundOffset rows
      aValue := GetInteger(pointer(WhereValue),err);
      if (err=0) and (aValue>0) then begin
        ndx := IDToIndex(aValue); // use fast binary search
        if ndx>=0 then begin
          OnFind(Dest,TSQLRecord(fValue.List[ndx]),ndx);
          result := 1;
        end;
      end;
    end;
  end else
  if cardinal(WhereField)<=cardinal(fStoredClassRecordProps.Fields.Count) then begin
    dec(WhereField); // WHERE WhereField=WhereValue (WhereField=RTTIfield+1)
    // use fUniqueFields[] hash array for O(1) search if available
    Hash := UniqueFieldHash(WhereField);
    if Hash<>nil then
      if FoundOffset>0 then // omit first FoundOffset rows, for ID unique field
        exit else
      with Hash do begin
        Field.SetValue(fSearchRec,pointer(WhereValue),false);
        ndx := Find(fSearchRec);
        if ndx>=0 then begin
          OnFind(Dest,fValue.List[ndx],ndx);
          result := 1;
        end;
        exit;
      end;
    // generic code below is as fast as possible, and works for all field types
    currentRow := 0;
    P := fStoredClassRecordProps.Fields.List[WhereField];
    if not (P.SQLFieldType in COPIABLE_FIELDS) then
      exit; // nothing to search (e.g. sftUnknown or sftMany)
    if ((P.SQLFieldType in [sftBoolean,sftEnumerate,sftSet,sftID,sftRecord
        {$ifdef CPU64},sftInteger]){$else}]){$endif} and P.InheritsFrom(TSQLPropInfoRTTI))
        {$ifndef CPU64}or (PPointer(P)^=TSQLPropInfoRTTIInt32){$endif} then begin
      // stored as a PtrInt value -> optimized search
      aValue := GetInteger(pointer(WhereValue),err);
      if err<>0 then
        exit;
      with TSQLPropInfoRTTI(P).PropInfo^ do
      if (PropType^^.Kind=tkClass) or
         ((PropType^^.Kind=tkInteger)and(PropType^^.OrdType=otSLong)) then
        if PropWrap(GetProc).Kind=$FF then begin
          // optimized version for fast retrieval of signed Int32 field value
          Offs := GetProc and $00FFFFFF; // no getter -> use PPtrInt()
          for i := 0 to fValue.Count-1 do
            if PInteger(PtrInt(fValue.List[i])+Offs)^=aValue then begin
              if FoundOffset>0 then begin // omit first FoundOffset rows
                inc(currentRow);
                if currentRow>FoundOffset then
                  FoundOffset := 0 else
                  continue;
              end;
              OnFind(Dest,TSQLRecord(fValue.List[i]),i);
              inc(result);
              if result>=FoundLimit then
                exit;
            end;
          exit;
        end;
      // not an Int32, or there is a getter procedure -> use GetOrdProp()
      for i := 0 to fValue.Count-1 do begin
        if GetOrdProp(TObject(fValue.List[i]),pointer(TSQLPropInfoRTTI(P).PropInfo))=aValue then begin
          if FoundOffset>0 then begin
            inc(currentRow);
            if currentRow>=FoundOffset then
              FoundOffset := 0 else
              continue;
          end;
          OnFind(Dest,fValue.List[i],i);
          inc(result);
          if result>=FoundLimit then
            exit;
        end;
      end;
      exit;
    end;
    // generic search of any value, using fast CompareValue() overriden method
    P.SetValue(fSearchRec,pointer(WhereValue),false);
    for i := 0 to fValue.Count-1 do  // ..,true)=SYSTEMNOCASE
      if P.CompareValue(fValue.List[i],fSearchRec,true)=0 then begin
        if FoundOffset>0 then begin
          inc(currentRow);
          if currentRow>=FoundOffset then
            FoundOffset := 0 else
            continue;
        end;
        OnFind(Dest,fValue.List[i],i);
        inc(result);
        if result>=FoundLimit then
          exit;
      end;
  end;
end;

function TSQLRestServerStaticInMemory.GetJSONValues(Stream: TStream; Expand, withID: boolean;
  const Fields: TSQLFieldBits; WhereField: integer; const WhereValue: RawUTF8;
  FoundLimit,FoundOffset: integer): PtrInt;
var i,KnownRowsCount: integer;
    W: TJSONSerializer;
begin // exact same format as TSQLTable.GetJSONValues()
  result := 0;
  if WhereField<0 then
    // no WHERE statement -> get all rows -> set rows count
    if (FoundLimit>0) and (fValue.Count>FoundLimit) then
      KnownRowsCount := FoundLimit else
      KnownRowsCount := fValue.Count else
    KnownRowsCount := 0;
  W := fStoredClassRecordProps.CreateJSONWriter(Stream,Expand,withID,Fields,KnownRowsCount);
  if W<>nil then
  try
    if Expand then
      W.Add('[');
    if WhereField<0 then begin
      // no WHERE statement -> all rows
      for i := 0 to KnownRowsCount-1 do begin
        if Expand then
          W.AddCR; // for better readibility
        TSQLRecord(fValue.List[i]).GetJSONValues(W);
        W.Add(',');
      end;
      result := fValue.Count;
    end else
      result := FindWhereEqual(WhereField,WhereValue,GetJSONValuesEvent,W,FoundLimit,FoundOffset);
    if (result=0) and W.Expand then begin
      // we want the field names at least, even with no data
      W.Expand := false; //  {"fieldCount":2,"values":["col1","col2"]}
      W.CancelAll;
      fStoredClassRecordProps.SetJSONWriterColumnNames(W,0);
    end;
    W.EndJSONObject(KnownRowsCount,result);
  finally
    W.Free;
  end;
end;

function TSQLRestServerStaticInMemory.IDToIndex(ID: integer): integer;
var L, R, cmp: integer;
begin
  if self<>nil then
  with fValue do begin
    R := Count-1;
    if fIDSorted and (R>=8) then begin
      // IDs are sorted -> use fast binary search algorithm
      L := 0;
      repeat
        result := (L + R) shr 1;
        cmp := TSQLRecord(List[result]).fID-ID;
        if cmp=0 then
          exit;
        if cmp<0 then
          L := result + 1 else
          R := result - 1;
      until (L > R);
    end else
      // IDs are not sorted -> compare all from beginning to end
      for result := 0 to R do
        if TSQLRecord(List[result]).fID=ID then
          exit;
  end;
  result := -1;
end;

function TSQLRestServerStaticInMemory.EngineList(const SQL: RawUTF8;
  ForceAJAX: Boolean=false; ReturnedRowCount: PPtrInt=nil): RawUTF8;
// - GetJSONValues/FindWhereEqual will handle basic REST commands (not all SQL)
// only valid SQL command is "SELECT Field1,Field2 FROM Table WHERE ID=120;",
// i.e one Table SELECT with one optional "WHERE fieldname = value" statement
// - handle also basic "SELECT Count(*) FROM TableName;" SQL statement
// Note: this is sufficient for OneFieldValue() and MultiFieldValue() to work
var MS: TRawByteStringStream;
    ResCount: PtrInt;
procedure SetCount(aCount: integer);
begin
  result := FormatUTF8('[{"Count(*)":%}]'#$A,[aCount]);
  ResCount := 1;
end;
begin
  ResCount := 0;
  if self=nil then begin
    result := '';
    exit;
  end;
  Lock(false);
  try
    if IdemPropNameU(fBasicSQLCount,SQL) then
      SetCount(fValue.Count) else
    if IdemPropNameU(fBasicSQLHasRows,SQL) then
      if fValue.Count=0 then begin
        result := '{"fieldCount":1,"values":["RowID"]}'#$A;
        ResCount := 0;
      end else begin
        result := '{"fieldCount":1,"values":["RowID",'+
          Int32ToUTF8(TSQLRecord(fValue.List[0]).fID)+'"]}'#$A;
        ResCount := 1;
      end else begin
      with fStoredClassRecordProps,
        TSynTableStatement.Create(SQL,Fields.IndexByName,
          fStoredClassRecordProps.SimpleFieldsBits[soSelect]) do
      try
        if (WhereValue='') or
           not IdemPropNameU(TableName,SQLTableName) then
          // invalid request -> return ''
          result := '' else
        if WhereField=SYNTABLESTATEMENTWHERECOUNT then
          // was "SELECT Count(*) FROM TableName;"
          SetCount(fValue.Count) else
        if IsZero(Fields) then
          if IsSelectCountWhere and (FoundLimit=0) and (FoundOffset=0) then
            // was "SELECT Count(*) FROM TableName WHERE ..."
            SetCount(FindWhereEqual(WhereField,WhereValue,DoNothingEvent,nil,0,0)) else
            // invalid "SELECT FROM Table" ?
            exit else begin
          // save rows as JSON, with appropriate search according to Where* arguments
          MS := TRawByteStringStream.Create;
          try
            ResCount := GetJSONValues(MS,ForceAJAX or (not NoAJAXJSON),
              withID,Fields,WhereField,WhereValue,FoundLimit,FoundOffset);
            result := MS.DataString;
          finally
            MS.Free;
          end;
        end;
      finally
        Free;
      end;
    end;
  finally
    UnLock;
  end;
  if ReturnedRowCount<>nil then
    ReturnedRowCount^ := ResCount;
end;

procedure TSQLRestServerStaticInMemory.LoadFromJSON(const aJSON: RawUTF8);
begin
  LoadFromJSON(Pointer(aJSON),length(aJSON));
end;

procedure TSQLRestServerStaticInMemory.LoadFromJSON(JSONBuffer: PUTF8Char; JSONBufferLen: integer);
  function IsSorted(U: PPUTF8Char; RowCount, FieldCount: integer): boolean;
  var i, aID, lastID: integer;
  begin
    result := false;
    lastID := 0;
    for i := 1 to RowCount do begin
      aID := GetInteger(U^);
      if aID<=lastID then
        exit else
        lastID := aID;
      inc(U,FieldCount);
    end;
    result := true;
  end;
var T: TSQLTableJSON;
begin
  fModified := false;
  fValue.Clear;
  T := TSQLTableJSON.Create([fStoredClass],'',JSONBuffer,JSONBufferLen);
  if T<>nil then  // use a temporary table
  try
    if T.fFieldIndexID<0 then
      exit; // no ID field -> load is impossible -> error
    // ensure ID were stored in an increasing order
    if not IsSorted(@T.fResults[T.fFieldIndexID+T.FieldCount],T.RowCount,T.FieldCount) then begin
      // force sorted by ID -> faster IDToIndex()
      T.SortFields(T.fFieldIndexID,true,nil,sftInteger);
      // if data is corrupted, IDs may not be unique -> check it now
      if not IsSorted(@T.fResults[T.fFieldIndexID+T.FieldCount],T.RowCount,T.FieldCount) then
        exit; // some duplicated ID fields -> error
    end;
    // create TSQLRecord instances with data from T
    T.ToObjectList(fValue,fStoredClass);
  finally
    T.Free;
  end;
end;

procedure TSQLRestServerStaticInMemory.SaveToJSON(Stream: TStream; Expand: Boolean);
begin
  if self<>nil then
    GetJSONValues(Stream,Expand,true,ALL_FIELDS,-1,'',0,0);
end;

function TSQLRestServerStaticInMemory.SaveToJSON(Expand: Boolean): RawUTF8;
var MS: TRawByteStringStream;
begin
  if self=nil then
    result := '' else begin
    MS := TRawByteStringStream.Create;
    try
      SaveToJSON(MS,Expand);
      result := MS.DataString;
    finally
      MS.Free;
    end;
  end;
end;

const
  TSQLRESTSERVERSTATICINMEMORY_MAGIC = $A5ABA5A5;

function TSQLRestServerStaticInMemory.LoadFromBinary(Stream: TStream): boolean;
var R: TFileBufferReader;
    MS: TMemoryStream;
    n, i, f: integer;
    FieldNames: TRawUTF8DynArray;
    IDs: TIntegerDynArray;
    P: PAnsiChar;
    aRecord: TSQLRecord;
    FieldTypes: array[0..MAX_SQLFIELDS-1] of TSQLFieldType;
begin
  result := false;
  if self=nil then
    exit;
  MS := StreamUnSynLZ(Stream,TSQLRESTSERVERSTATICINMEMORY_MAGIC);
  if MS<>nil then
  with fStoredClassRecordProps do
  try
    // check header: expect same exact RTTI
    R.OpenFrom(MS.Memory,MS.Size);
    if (R.ReadRawUTF8<>RawUTF8(ClassName)) or
       (R.ReadRawUTF8<>SQLTableName) or
       (R.ReadVarRawUTF8DynArray(FieldNames)<>Fields.Count) then
      exit;
    n := sizeof(TSQLFieldType)*Fields.Count;
    if R.Read(@FieldTypes,n)<>n then
      exit;
    for i := 0 to Fields.Count-1 do
      with Fields.List[i] do
      if (Name<>FieldNames[i]) or (SQLFieldType<>FieldTypes[i]) then
        exit;
    // read IDs
    fModified := false;
    fValue.Clear;
    fValue.Count := R.ReadVarUInt32Array(IDs); // faster than fValue.Add()
    for i := 0 to high(IDs) do begin
      aRecord := fStoredClass.Create;
      aRecord.fID := IDs[i];
      fValue.List[i] := aRecord;
    end;
    // read content, grouped by field (for better compression)
    P := R.CurrentMemory;
    for f := 0 to Fields.Count-1 do
      with Fields.List[f], fValue do
        for i := 0 to Count-1 do begin
          P := SetBinary(TSQLRecord(List[i]),P);
          if P=nil then begin
            fValue.Clear; // on error, reset whole 
            exit;
          end;
        end;
    Result := true;
  finally
    R.Close;
    MS.Free;
  end;
end;

function TSQLRestServerStaticInMemory.SaveToBinary(Stream: TStream): integer;
var W: TFileBufferWriter;
    MS: THeapMemoryStream;
    IDs: TIntegerDynArray;
    FieldNames: TRawUTF8DynArray;
    i, f: integer;
begin
  result := 0;
  if (self=nil) or (Stream=nil) then
    exit;
  MS := THeapMemoryStream.Create;
  W := TFileBufferWriter.Create(MS);
  with fStoredClassRecordProps do
  try
    // primitive magic and fields signature for file type identification
    W.Write(RawUTF8(ClassName));
    W.Write(SQLTableName);
    SetLength(FieldNames,Fields.Count);
    for i := 0 to Fields.Count-1 do
      FieldNames[i] := Fields.List[i].Name;
    W.WriteRawUTF8DynArray(FieldNames,Fields.Count);
    for i := 0 to Fields.Count-1 do
      W.Write(@Fields.List[i].fSQLFieldType,sizeof(TSQLFieldType));
    // write IDs
    SetLength(IDs,Count);
    with fValue do
      for i := 0 to Count-1 do
        IDs[i] := TSQLRecord(List[i]).fID;
    W.WriteVarUInt32Array(IDs,Count,wkSorted); // efficient ID storage
    // write content, grouped by field (for better compression)
    for f := 0 to Fields.Count-1 do
      with Fields.List[f], fValue do
        for i := 0 to Count-1 do
          GetBinary(TSQLRecord(List[i]),W);
    W.Flush;
    result := StreamSynLZ(MS,Stream,TSQLRESTSERVERSTATICINMEMORY_MAGIC);
  finally
    W.Free;
    MS.Free;
  end;
end;

function TSQLRestServerStaticInMemory.EngineRetrieve(TableModelIndex, ID: integer): RawUTF8;
var i: integer;
begin // TableModelIndex is not usefull here
  Lock(false);
  try
    i := IDToIndex(ID);
    if i<0 then
      result := '' else
      result := TSQLRecord(fValue.List[i]).GetJSONValues(true,true,soSelect);
  finally
    UnLock;
  end;
end;

function TSQLRestServerStaticInMemory.GetOne(aID: integer): TSQLRecord;
var i: integer;
begin
  i := IDToIndex(aID);
  if i<0 then
    result := nil else begin
    result := fStoredClass.Create;
    CopyObject(fValue.List[i],Result);
    result.fID := aID;
  end;
end;

function TSQLRestServerStaticInMemory.EngineUpdate(Table: TSQLRecordClass; ID: integer;
  const SentData: RawUTF8): boolean;
var i: integer;
    Orig,Rec: TSQLRecord;
begin
  // this implementation will handle partial fields update (e.g.
  // FillPrepare+BatchUpdate or TSQLRestServerRemoteDB.UpdateField)
  // but TSQLRestServerStaticRecordBased.EngineUpdate won't
  result := false;
  if (self=nil) or (Table<>fStoredClass) then
    exit;
  if SentData='' then begin
    result := True;
    exit;
  end;
  Lock(true);
  try
    i := IDToIndex(ID);
    if (i<0) or not RecordCanBeUpdated(Table,ID,seUpdate) then
      exit;
    if fUniqueFields<>nil then begin
      Orig := TSQLRecord(fValue.List[i]);
      Rec := Orig.CreateCopy; // copy since can be a partial update
      Rec.FillFrom(SentData); // overwrite updated properties
      if not UniqueFieldsUpdateOK(Rec,i) then begin
        Rec.Free; // stored false property duplicated value -> error
        exit;
      end;
      Orig.Free; // avoid memory leak
      TSQLRecord(fValue.List[i]) := Rec; // update item in list
    end else
      // direct in-place partial update
      TSQLRecord(fValue.List[i]).FillFrom(SentData);
    fModified := true;
    result := true;
    if Owner<>nil then
      Owner.InternalUpdateEvent(seUpdate,Table,ID);
  finally
    UnLock;
  end;
end;

function TSQLRestServerStaticInMemory.UpdateOne(Rec: TSQLRecord): boolean;
var i: integer;
begin
  result := false;
  if (Rec=nil) or (PSQLRecordClass(Rec)^<>fStoredClass) or (Rec.fID<=0) then
    exit;
  Lock(true);
  try
    i := IDToIndex(Rec.fID);
    if (i<0) or not RecordCanBeUpdated(fStoredClass,Rec.fID,seUpdate) then
      exit;
    if (fUniqueFields<>nil) and not UniqueFieldsUpdateOK(Rec,i) then
      exit; // stored false property duplicated value -> error
    CopyObject(Rec,fValue.List[i]);
    fModified := true;
    result := true;
    if Owner<>nil then
      Owner.InternalUpdateEvent(seUpdate,fStoredClass,Rec.fID);
  finally
    UnLock;
  end;
end;

function TSQLRestServerStaticInMemory.UpdateOne(ID: integer;
  const Values: TVarDataDynArray): boolean;
var i: integer;
    Orig,Rec: TSQLRecord;
begin
  result := false;
  if ID<=0 then
    exit;
  i := IDToIndex(ID);
  if (i<0) or not RecordCanBeUpdated(fStoredClass,ID,seUpdate) then
    exit;
  if fUniqueFields<>nil then begin
    Orig := TSQLRecord(fValue.List[i]);
    Rec := Orig.CreateCopy; // copy since can be a partial update
    if (not Rec.SetFieldVarDatas(Values)) or
       (not UniqueFieldsUpdateOK(Rec,i)) then begin
      Rec.Free; // stored false property duplicated value -> error
      exit;
    end;
    Orig.Free; // avoid memory leak
    TSQLRecord(fValue.List[i]) := Rec;
  end else
  if not TSQLRecord(fValue.List[i]).SetFieldVarDatas(Values) then
    exit;
  fModified := true;
  result := true;
  if Owner<>nil then
    Owner.InternalUpdateEvent(seUpdate,fStoredClass,ID);
end;

function TSQLRestServerStaticInMemory.EngineRetrieveBlob(Table: TSQLRecordClass;
  aID: integer; BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean;
var i: integer;
begin
  result := false;
  if (self=nil) or (Table<>fStoredClass) or not BlobField^.IsBlob then
    exit;
  Lock(false);
  try
    i := IDToIndex(aID);
    if i<0 then
      exit;
    // get result blob directly from RTTI property description
    GetLongStrProp(fValue.List[i],BlobField,RawByteString(BlobData));
    result := true;
  finally
    UnLock;
  end;
end;

function TSQLRestServerStaticInMemory.RetrieveBlobFields(Value: TSQLRecord): boolean;
var i,f: integer;
begin
  result := false;
  if (Value<>nil) and (Value.fID>0) and (PSQLRecordClass(Value)^=fStoredClass) then
  with Value.RecordProps do
  if BlobFields<>nil then begin
    Lock(false);
    try
      i := IDToIndex(Value.fID);
      if i<0 then
        exit;
      for f := 0 to high(BlobFields) do
        BlobFields[f].CopyValue(fValue.List[i],Value);
      result := true;
    finally
      UnLock;
    end;
  end;
end;

function TSQLRestServerStaticInMemory.EngineUpdateBlob(Table: TSQLRecordClass;
  aID: integer; BlobField: PPropInfo;
  const BlobData: TSQLRawBlob): boolean;
var i: integer;
begin
  result := false;
  if (self=nil) or  (Table<>fStoredClass) or not BlobField^.IsBlob then
    exit;
  Lock(true);
  try
    i := IDToIndex(aID);
    if (i<0) or not RecordCanBeUpdated(Table,aID,seUpdate) then
      exit;
    // set blob value directly from RTTI property description
    SetLongStrProp(fValue.List[i],BlobField,BlobData);
    result := true;
  finally
    UnLock;
  end;
end;

function TSQLRestServerStaticInMemory.UpdateBlobFields(Value: TSQLRecord): boolean;
var i,f: integer;
begin
  result := false;
  if (Value<>nil) and (Value.fID>0) and (PSQLRecordClass(Value)^=fStoredClass) then
  with Value.RecordProps do
  if BlobFields<>nil then begin
    Lock(true);
    try
      i := IDToIndex(Value.fID);
      if (i<0) or not RecordCanBeUpdated(Table,Value.fID,seUpdate) then
        exit;
      for f := 0 to high(BlobFields) do
        BlobFields[f].CopyValue(Value,fValue.List[i]);
      result := true;
    finally
      UnLock;
    end;
  end else
    result := true; // as TSQLRest.UpdateblobFields()
end;

function TSQLRestServerStaticInMemory.TableRowCount(Table: TSQLRecordClass): integer;
begin
  if Table<>fStoredClass then
    result := 0 else
    result := fValue.Count;
end;

function TSQLRestServerStaticInMemory.TableHasRows(Table: TSQLRecordClass): boolean;
begin
  if Table<>fStoredClass then
    result := false else
    result := fValue.Count>0;
end;

function TSQLRestServerStaticInMemory.EngineUpdateField(Table: TSQLRecordClass;
  const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean;
var SetField: TSQLPropInfo;
    WhereValueString, SetValueString: RawUTF8;
    Where: TList;
    i, ndx, WhereFieldIndex: integer;
    Rec: TSQLRecord;
begin
  result := false;
  if (self=nil) or (Table<>fStoredClass) or (SetFieldName='') or (SetValue='') or
     (WhereFieldName='') or (WhereValue='') then
    exit;
  // handle destination field RTTI
  SetField := fStoredClassRecordProps.Fields.ByRawUTF8Name(SetFieldName);
  if SetField=nil then
    exit; // don't allow setting ID field, which is Read Only
  if SetValue[1]='"' then
    UnQuoteSQLString(pointer(SetValue),SetValueString) else
    SetValueString := SetValue;
  // handle search field RTTI
  if IsRowID(pointer(WhereFieldName)) then begin
    WhereFieldIndex := 0;
    WhereValueString := WhereValue;
  end else begin
    WhereFieldIndex := fStoredClassRecordProps.Fields.IndexByName(WhereFieldName);
    if WhereFieldIndex<0  then
      exit;
    inc(WhereFieldIndex); // FindWhereEqual() expects index = RTTI+1
  end;
  if WhereValue[1]='"' then
    UnQuoteSQLString(pointer(WhereValue),WhereValueString) else
    WhereValueString := WhereValue;
  // search indexes, then apply updates
  Where := TList.Create;
  Lock(true);
  try 
    // find matching Where[]
    if FindWhereEqual(WhereFieldIndex,WhereValueString,AddIntegerDynArrayEvent,Where,0,0)=0 then
      exit; // Where.Count=0 -> nothing to update
    // check that all records can be updated
    for i := 0 to Where.Count-1 do
      if not RecordCanBeUpdated(Table,TSQLRecord(fValue.List[PtrInt(Where.List[i])]).fID,seUpdate) then
        exit; // one record update fails -> abort all
    if fUniqueFields<>nil then
      for i := 0 to fUniqueFields.Count-1 do
      with TListFieldHash(fUniqueFields.List[i]) do
        if Field=SetField then
          if Where.Count>1 then // unique field can't allow multiple sets
            exit else begin
            SetField.SetValue(fSearchRec,pointer(SetValueString),false);
            ndx := Find(fSearchRec);
            if (ndx>=0) and (ndx<>PtrInt(Where.List[0])) then
              exit; // duplicated entry error
          end;
    // update field value
    for i := 0 to Where.Count-1 do begin
      Rec := fValue.List[PtrInt(Where.List[i])];
      SetField.SetValue(Rec,pointer(SetValueString),false);
      fModified := true;
      if Owner<>nil then
        Owner.InternalUpdateEvent(seUpdate,Table,Rec.fID);
      result := true;
    end;
  finally
    UnLock;
    Where.Free;
  end;
end;

procedure TSQLRestServerStaticInMemory.UpdateFile;
var F: TFileStream;
begin
  if (self=nil) or not Modified or (FileName='') then
    exit;
  if fValue.Count=0 then
    DeleteFile(FileName) else begin
    F := TFileStream.Create(FileName,fmCreate);
    try
      if BinaryFile then
        SaveToBinary(F) else
        GetJSONValues(F,fExpandedJSON,true,ALL_FIELDS,-1,'',0,0);
      F.Size := F.Position; // truncate file
    finally
      F.Free;
    end;
  end;
  fModified := false;
end;

function TSQLRestServerStaticInMemory.SearchField(const FieldName, FieldValue: RawUTF8; var ResultID: TIntegerDynArray): boolean;
var n, WhereField: integer;
    {$ifdef CPU64}i: integer;{$endif}
    Where: TList;
begin
  result := false;
  SetLength(ResultID,0);
  if (self=nil) or (fValue.Count=0) then
    exit;
  if IsRowID(pointer(FieldName)) then
    WhereField := SYNTABLESTATEMENTWHEREID else begin
    WhereField := fStoredClassRecordProps.Fields.IndexByName(FieldName);
    if WhereField<0 then
      exit;
    inc(WhereField); // FindWhereEqual() expects index = RTTI+1
  end;
  Where := TList.Create;
  try
    n := FindWhereEqual(WhereField,FieldValue,AddIntegerDynArrayEvent,Where,0,0);
    if n=0 then
      exit;
    SetLength(ResultID,n);
    {$ifdef CPU64}
    with Where do
      for i := 0 to Count-1 do
        ResultID[i] := PPtrIntArray(List)^[i];
    {$else}
    move(Where.List[0],ResultID[0],n*sizeof(Integer));
    {$endif}
  finally
    Where.Free;
  end;
end;


{ TSQLRestServerStaticInMemoryExternal }

procedure TSQLRestServerStaticInMemoryExternal.FlushInternalDBCache;
begin
  if Owner<>nil then
    Owner.FlushInternalDBCache;
end;


{ TListFieldHash }

function TListFieldHash.Compare(Item1,Item2: TObject): boolean;
begin
  result := fProp.CompareValue(Item1,Item2,CaseInsensitive)=0;
end;

function TListFieldHash.Count: integer;
begin
  result := fValues.Count;
end;

constructor TListFieldHash.Create(aValues: TList; aFieldIndex: integer;
  aField: TSQLPropInfo; aCaseInsensitive: boolean);
begin
  fValues := aValues;
  fField := aFieldIndex;
  fProp := aField;
  fCaseInsensitive := aCaseInsensitive;
end;

function TListFieldHash.Hash(Item: TObject): cardinal;
begin
  result := fProp.GetHash(Item,CaseInsensitive);
  if result=0 then
    result := 1; // HASH=0 is used to indicate a void slot in fHash[]
end;

function TListFieldHash.Get(Index: integer): TObject;
begin
  with fValues do
    if cardinal(Index)<cardinal(Count) then
      result := List[Index] else
      result := nil;
end;


{ TSQLRestServerStatic }

constructor TSQLRestServerStatic.Create(aClass: TSQLRecordClass;
  aServer: TSQLRestServer; const aFileName: TFileName; aBinaryFile: boolean);
begin
  inherited Create(nil,false);
  if aClass=nil then
    raise EBusinessLayerException.CreateFmt('%s.Create expect a class',[ClassName]);
  fStoredClass := aClass;
  fStoredClassRecordProps := aClass.RecordProps;
  if aServer<>nil then begin
    fOwner := aServer;
    fModel := aServer.Model;
    fStoredClassProps := fModel.Props[aClass];
    fNoAJAXJSON := aServer.fNoAJAXJSON; // expanded as main Server
  end else
    // if no server is defined, simply use the first model using this class
    if fStoredClassRecordProps.fModel<>nil then
    with fStoredClassRecordProps.fModel[0] do begin
      fModel := Model;
      fStoredClassProps := Properties;
    end;
  fIsUnique := fStoredClassRecordProps.IsUniqueFieldsBits;
  fFileName := aFileName;
end;

function TSQLRestServerStatic.EngineExecuteAll(const aSQL: RawUTF8): boolean;
begin
  result := false; // not implemented in this basic REST static class
end;

function TSQLRestServerStatic.EngineUpdateField(Table: TSQLRecordClass;
  const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean;
begin
  result := false; // not implemented in this basic REST static class
end;

function TSQLRestServerStatic.SearchField(const FieldName: RawUTF8;
  FieldValue: Integer; var ResultID: TIntegerDynArray): boolean;
begin
  result := SearchField(FieldName,Int32ToUTF8(FieldValue),ResultID);
end;

function TSQLRestServerStatic.RecordCanBeUpdated(Table: TSQLRecordClass;
  ID: integer; Action: TSQLEvent; ErrorMsg: PRawUTF8 = nil): boolean;
begin
  result := (self<>nil) and
    ((Owner=nil) or Owner.RecordCanBeUpdated(Table,ID,Action,ErrorMsg));
end;

function TSQLRestServerStatic.RefreshedAndModified: boolean;
begin
  result := false; // no refresh necessary with "normal" static tables
end;

procedure TSQLRestServerStatic.Lock(WillModifyContent: boolean);
begin
  if self<>nil then begin
    EnterCriticalSection(fSessionCriticalSection);
    if WillModifyContent then
      FlushInternalDBCache;
  end;
end;

procedure TSQLRestServerStatic.UnLock;
begin
  if self<>nil then
    LeaveCriticalSection(fSessionCriticalSection);
end;

function TSQLRestServerStatic.InternalBatchStart(Method: TSQLURIMethod): boolean;
begin
  result := false;
end;

procedure TSQLRestServerStatic.InternalBatchStop;
begin
  // do nothing method
end;

function TSQLRestServerStatic.AdaptSQLForEngineList(var SQL: RawUTF8): boolean; 
begin
  if fStoredClassProps=nil then
    result := false else begin
    result := fStoredClassProps.SQL.SelectAll[false]=SQL;
    if result then
      SQL := fStoredClassProps.SQL.SelectAll[true];
  end;
end;


{ TSQLRestServerFullMemory }

constructor TSQLRestServerFullMemory.Create(aModel: TSQLModel;
  const aFileName: TFileName; aBinaryFile, aHandleUserAuthentication: boolean);
var t: integer;
begin
  fFileName := aFileName;
  fBinaryFile := aBinaryFile;
  inherited Create(aModel,aHandleUserAuthentication);
  fStaticDataCount := length(fModel.Tables);
  for t := 0 to fStaticDataCount-1 do
    StaticDataCreate(fModel.Tables[t]);
  LoadFromFile;
  for t := 0 to fStaticDataCount-1 do
    with TSQLRestServerStaticInMemory(fStaticData[t]) do
    if Count=0 then // emulates TSQLRestServerDB.CreateMissingTables
      StoredClass.InitializeTable(Self,'');
end;

destructor TSQLRestServerFullMemory.Destroy;
begin
  UpdateToFile;
  inherited;
end;

procedure TSQLRestServerFullMemory.LoadFromFile;
var JSON: RawUTF8;
    P, TableName, Data: PUTF8Char;
    t: integer;
    S: TFileStream;
    wasString: boolean;
begin
  if (self=nil) or (fFileName='') or not FileExists(fFileName) then
    exit;
  for t := 0 to fStaticDataCount-1 do
    TSQLRestServerStaticInMemory(fStaticData[t]).fValue.Clear;
  if fBinaryFile then begin
    S := TFileStream.Create(FileName,fmOpenRead or fmShareDenyNone);
    try
      if ReadStringFromStream(S)=RawUTF8(ClassName)+'00' then
      repeat
        t := Model.GetTableIndex(ReadStringFromStream(S));
      until (t<0) or not TSQLRestServerStaticInMemory(fStaticData[t]).LoadFromBinary(S);
    finally
      S.Free;
    end;
  end else begin // [{"AuthUser":[{....},{...}]},{"AuthGroup":[{...},{...}]}]
    JSON := StringFromFile(fFileName);
    if JSON='' then
      exit;
    P := pointer(JSON);
    while (P^<>'[') do if P^=#0 then exit else inc(P);
    inc(P);
    repeat
      while (P^<>']') and (P^<>'{') do if P^=#0 then exit else inc(P);
      if P^=']' then break else inc(P);
      TableName := GetJSONField(P,P,@wasString);
      if not wasString or (P=nil) then
        exit;
      t := Model.GetTableIndex(TableName);
      if t<0 then
        exit;
      Data := P;
      P := GotoNextJSONObjectOrArray(P);
      if P=nil then
        break else
        TSQLRestServerStaticInMemory(fStaticData[t]).LoadFromJSON(Data,P-Data);
    until false;
  end;
end;

procedure TSQLRestServerFullMemory.UpdateToFile;
const CHARS: array[0..6] of AnsiChar = '[{":,}]';
var S: TFileStream;                //   0123456
    t: integer;
    Modified: boolean;
begin
  if (self=nil) or (FileName='') then
    exit;
  Modified := false;
  for t := 0 to fStaticDataCount-1 do
    if TSQLRestServerStaticInMemory(fStaticData[t]).Modified then begin
      Modified := true;
      break;
    end;
  if not Modified then
    exit;
  S := TFileStream.Create(FileName,fmCreate);
  try
    if fBinaryFile then begin
      WriteStringToStream(S,RawUTF8(ClassName)+'00');
      for t := 0 to fStaticDataCount-1 do
      with TSQLRestServerStaticInMemory(fStaticData[t]) do begin
        WriteStringToStream(S,fStoredClassRecordProps.SQLTableName);
        SaveToBinary(S);
      end;
    end else begin
      S.Write(CHARS[0],1);
      for t := 0 to fStaticDataCount-1 do
      with TSQLRestServerStaticInMemory(fStaticData[t]) do begin
        S.Write(CHARS[1],2);
        with fStoredClassRecordProps do
          S.Write(pointer(SQLTableName)^,length(SQLTableName));
        S.Write(CHARS[2],2);
        SaveToJSON(S,true);
        S.Write(CHARS[5],1);
        if t<integer(fStaticDataCount-1) then
          S.Write(CHARS[4],1);
      end;
      S.Write(CHARS[6],1);
    end;
  finally
    S.Free;
  end;
end;

function TSQLRestServerFullMemory.EngineRetrieve(TableModelIndex, ID: integer): RawUTF8;
begin
  if cardinal(TableModelIndex)>=fStaticDataCount then
    result := '' else
    result := TSQLRestServerStaticInMemory(fStaticData[TableModelIndex]).EngineRetrieve(0,ID);
end;

function TSQLRestServerFullMemory.EngineList(const SQL: RawUTF8;
  ForceAJAX: Boolean=false; ReturnedRowCount: PPtrInt=nil): RawUTF8;
var TableIndex: integer;
begin
  TableIndex := Model.GetTableIndexFromSQLSelect(SQL,true);
  if TableIndex<0 then
    result := '' else
    result := TSQLRestServerStaticInMemory(fStaticData[TableIndex]).
      EngineList(SQL,ForceAJAX,ReturnedRowCount);
end;

function TSQLRestServerFullMemory.GetStatic(Table: TSQLRecordClass): TSQLRestServerStaticInMemory;
var t: cardinal;
begin
  t := fModel.GetTableIndexExisting(Table);
  if t<fStaticDataCount then
    result := TSQLRestServerStaticInMemory(fStaticData[t]) else
    result := nil;
end;

function TSQLRestServerFullMemory.EngineUpdate(Table: TSQLRecordClass; ID: integer;
  const SentData: RawUTF8): boolean;
begin
  result := GetStatic(Table).EngineUpdate(Table,ID,SentData);
end;

function TSQLRestServerFullMemory.EngineDelete(Table: TSQLRecordClass; ID: integer): boolean;
begin
  result := GetStatic(Table).EngineDelete(Table,ID);
end;

function TSQLRestServerFullMemory.EngineDeleteWhere(Table: TSQLRecordClass;
  const SQLWhere: RawUTF8; const IDs: TIntegerDynArray): boolean;
begin
  result := GetStatic(Table).EngineDeleteWhere(Table,SQLWhere,IDs);
end;

function TSQLRestServerFullMemory.EngineRetrieveBlob(Table: TSQLRecordClass; aID: integer;
  BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean;
begin
  result := GetStatic(Table).EngineRetrieveBlob(Table,aID,BlobField,BlobData);
end;

function TSQLRestServerFullMemory.EngineUpdateBlob(Table: TSQLRecordClass; aID: integer;
  BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean;
begin
  result := GetStatic(Table).EngineUpdateBlob(Table,aID,BlobField,BlobData);
end;

function TSQLRestServerFullMemory.EngineAdd(Table: TSQLRecordClass; const SentData: RawUTF8): integer;
begin
  result := GetStatic(Table).EngineAdd(Table,SentData);
end;

function TSQLRestServerFullMemory.EngineUpdateField(Table: TSQLRecordClass;
      const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean;
begin
  result := GetStatic(Table).EngineUpdateField(Table,SetFieldName,SetValue,
    WhereFieldName,WhereValue);
end;

function TSQLRestServerFullMemory.EngineExecuteAll(const aSQL: RawUTF8): boolean;
begin
  result := false; // not implemented in this basic REST server class
end;



{ TSQLRestServerRemoteDB }

constructor TSQLRestServerRemoteDB.Create(aRemoteClient: TSQLRestClient;
  aHandleUserAuthentication: boolean);
begin
  if aRemoteClient=nil then
    raise EORMException.CreateFmt('%s creation with no remote client',[ClassName]);
  inherited Create(aRemoteClient.Model,aHandleUserAuthentication);
  fClient := aRemoteClient;
end;

function TSQLRestServerRemoteDB.EngineAdd(Table: TSQLRecordClass;
  const SentData: RawUTF8): integer;
begin
  result := fClient.EngineAdd(Table,SentData);
end;

function TSQLRestServerRemoteDB.EngineDelete(Table: TSQLRecordClass;
  ID: integer): boolean;
begin
  result := fClient.EngineDelete(Table,ID);
end;

function TSQLRestServerRemoteDB.EngineDeleteWhere(Table: TSQLRecordClass;
  const SQLWhere: RawUTF8; const IDs: TIntegerDynArray): boolean;
begin
  result := fClient.EngineDeleteWhere(Table,SQLWhere,IDs);
end;

function TSQLRestServerRemoteDB.EngineExecuteAll(const aSQL: RawUTF8): boolean;
begin
  result := fClient.EngineExecute(aSQL);
end;

function TSQLRestServerRemoteDB.ExecuteList(const Tables: array of TSQLRecordClass;
  const SQL: RawUTF8): TSQLTableJSON;
begin
  result := fClient.ExecuteList(Tables,SQL);
end;

function TSQLRestServerRemoteDB.EngineList(const SQL: RawUTF8;
  ForceAJAX: Boolean; ReturnedRowCount: PPtrInt): RawUTF8;
begin
  result := fClient.EngineList(SQL,ForceAJAX,ReturnedRowCount);
end;

function TSQLRestServerRemoteDB.EngineRetrieve(TableModelIndex, ID: integer): RawUTF8;
var Dummy: cardinal;
begin
  if not fClient.EngineRetrieve(TableModelIndex,ID,False,Dummy,result) then
    result := '';
end;

function TSQLRestServerRemoteDB.EngineRetrieveBlob(Table: TSQLRecordClass;
  aID: integer; BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean;
begin
  if (self=nil) or (BlobField=nil) then
    result := false else
    result := fClient.EngineRetrieveBlob(Table,aID,BlobField,BlobData);
end;

function TSQLRestServerRemoteDB.EngineUpdate(Table: TSQLRecordClass;
  ID: integer; const SentData: RawUTF8): boolean;
begin
  result := fClient.EngineUpdate(Table,ID,SentData);
end;

function TSQLRestServerRemoteDB.EngineUpdateBlob(Table: TSQLRecordClass;
  aID: integer; BlobField: PPropInfo;
  const BlobData: TSQLRawBlob): boolean;
begin
  if (self=nil) or (BlobField=nil) then
    result := false else
    result := fClient.EngineUpdateBlob(Table,aID,BlobField,BlobData);
end;

function TSQLRestServerRemoteDB.EngineUpdateField(Table: TSQLRecordClass;
  const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean;
begin
  if (self=nil) or (Table.RecordProps.Fields.IndexByName(SetFieldName)<0) then
    result := false else
    result := fClient.EngineUpdateField(Table,SetFieldName,SetValue,WhereFieldName,WhereValue);
end;

function TSQLRestServerRemoteDB.AfterDeleteForceCoherency(Table: TSQLRecordClass;
  aID: integer): boolean;
begin
  result := true; // coherency will be performed on the server side
end;


{ TSQLRestClient }

function TSQLRestClient.Add(Value: TSQLRecord; SendData: boolean; ForceID: boolean=false): integer;
var Data: RawUTF8;
    TableIndex: integer;
begin
  result := 0;
  if (Value=nil) or (self=nil) then
    exit;
  TableIndex := Model.GetTableIndexExisting(PSQLRecordClass(Value)^);
  if SendData then begin // send content of Value to the server as JSON
    Value.ComputeFieldsBeforeWrite(self,seAdd); // update TModTime/TCreateTime fields
    if Model.fTableProps[TableIndex].Kind in INSERT_WITH_ID then
      ForceID := true;
    Data := Value.GetJSONValues(True, // Expanded=true
      (Value.fID<>0) and ForceID,soInsert);
  end;
  // POST/Insert Collection
  result := EngineAdd(PSQLRecordClass(Value)^,Data);
  if result<=0 then
    exit;
  if SendData then
    fCache.Notify(TableIndex,result,Data,soInsert);
  Value.fID := result;
  if ForceBlobTransfert then
    UpdateBlobFields(Value);
end;

function TSQLRestClient.Delete(Table: TSQLRecordClass; ID: integer): boolean;
var TableIndex: integer;
begin
  TableIndex := Model.GetTableIndexExisting(Table);
  if not inherited Delete(Table,ID) then
    result := false else begin
    fCache.NotifyDeletion(TableIndex,ID);
    result := EngineDelete(Table,ID);
  end;
end;

function TSQLRestClient.Retrieve(aID: integer; Value: TSQLRecord;
      ForUpdate: boolean=false): boolean;
var Resp: RawUTF8;
    TableIndex: integer;
begin
  result := false;
  if (self=nil) or (aID<=0) or (Value=nil) then
    exit;
  TableIndex := Model.GetTableIndexExisting(PSQLRecordClass(Value)^);
  if ForUpdate then begin
    if not Model.Lock(TableIndex,aID) then
      exit; // error marking as locked by the client
  end else begin
    Resp := fCache.Retrieve(TableIndex,aID);
    if Resp<>'' then begin
      Value.FillFrom(Resp);
      Value.fID := aID; // JSON object may not contain the ID
      result := true;
      exit; // fast retrieved from internal Client cache (BLOBs ignored)
    end;
  end;
  try
    if EngineRetrieve(TableIndex,aID,ForUpdate,Value.fInternalState,Resp) then begin
      Value.FillFrom(Resp);
      Value.fID := aID; // JSON object may not contain the ID
      if ForceBlobTransfert then
        result := RetrieveBlobFields(Value) else
        result := true;
      ForUpdate := false; // any exception shall unlock the record
    end;
  finally
    if ForUpdate then
      Model.UnLock(TableIndex,aID);
  end;
end;

function TSQLRestClient.Update(Value: TSQLRecord): boolean;
var JSON: RawUTF8;
begin
  if (self=nil) or not inherited Update(Value) or
     not BeforeUpdateEvent(Value) then begin
    result := false;
    exit;
  end;
  Value.ComputeFieldsBeforeWrite(self,seUpdate); // update sftModTime fields
  JSON := Value.GetJSONValues(true,false,soUpdate); // expanded + without ID
  result := EngineUpdate(PSQLRecordClass(Value)^,Value.fID,JSON);
  if result then begin
    if ForceBlobTransfert then
      result := UpdateBlobFields(Value);
    fCache.Notify(Value,soUpdate); // JSON may not include all fields on update
    if result and assigned(OnRecordUpdate) then
      OnRecordUpdate(Value);
  end;
end;

function TSQLRestClient.RetrieveBlob(Table: TSQLRecordClass;
  aID: integer; const BlobFieldName: RawUTF8;
  out BlobData: TSQLRawBlob): boolean;
var P: PPropInfo;
begin
  result := false;
  if (self=nil) or (aID<=0) then
    exit;
  P := Table.RecordProps.BlobFieldPropFromRawUTF8(BlobFieldName);
  if P<>nil then
    result := EngineRetrieveBlob(Table,aID,P,BlobData);
end;

function TSQLRestClient.UpdateBlob(Table: TSQLRecordClass; aID: integer;
  const BlobFieldName: RawUTF8; const BlobData: TSQLRawBlob): boolean;
var BlobField: PPropInfo;
begin
  result := false;
  if (self=nil) or (aID<=0) or not RecordCanBeUpdated(Table,aID,seUpdate) then
    exit;
  BlobField := Table.RecordProps.BlobFieldPropFromRawUTF8(BlobFieldName);
  if BlobField<>nil then
    result := EngineUpdateBlob(Table,aID,BlobField,BlobData);
end;

function TSQLRestClient.BeforeUpdateEvent(Value: TSQLRecord): Boolean;
begin
  Result := true; // by default, just allow the update to proceed
end;

function TSQLRestClient.Refresh(aID: integer; Value: TSQLRecord;
  var Refreshed: boolean): boolean;
var Resp, Original: RawUTF8;
begin
  result := false;
  if (aID>0) and (self<>nil) and (Value<>nil) then
    if EngineRetrieve(Model.GetTableIndexExisting(PSQLRecordClass(Value)^),aID,False,
       Value.fInternalState,Resp) then begin
      Original := Value.GetJSONValues(IsNotAjaxJSON(pointer(Resp)),true,soSelect);
      Resp := trim(Resp);
      if (Resp<>'') and (Resp[1]='[') then // '[{....}]' -> '{...}'
        Resp := copy(Resp,2,length(Resp)-2);
      if Original<>Resp then begin // did the content really change?
        Refreshed := true;
        Value.FillFrom(Resp);
      end;
      result := true;
    end;
end;

procedure TSQLRestClient.Commit(SessionID: cardinal);
begin
  inherited;
end;

function TSQLRestClient.TransactionBegin(aTable: TSQLRecordClass;
  SessionID: cardinal): boolean;
begin
  result := inherited TransactionBegin(aTable,SessionID);
end;

procedure TSQLRestClient.RollBack(SessionID: cardinal);
begin
  inherited;
end;

function TSQLRestClient.EngineExecuteFmt(SQLFormat: PUTF8Char;
  const Args: array of const): boolean;
begin
  result := EngineExecute(FormatUTF8(SQLFormat,Args));
end;

function TSQLRestClient.EngineExecuteFmt(SQLFormat: PUTF8Char;
  const Args, Bounds: array of const): boolean;
begin
  result := EngineExecute(FormatUTF8(SQLFormat,Args,Bounds));
end;

function TSQLRestClient.ListFmt(const Tables: array of TSQLRecordClass; const SQLSelect: RawUTF8;
  SQLWhereFormat: PUTF8Char; const Args: array of const): TSQLTableJSON;
begin
  result := List(Tables,SQLSelect,FormatUTF8(SQLWhereFormat,Args));
end;

function TSQLRestClient.ListFmt(const Tables: array of TSQLRecordClass;
  const SQLSelect: RawUTF8; SQLWhereFormat: PUTF8Char;
  const Args, Bounds: array of const): TSQLTableJSON;
begin
  result := List(Tables,SQLSelect,FormatUTF8(SQLWhereFormat,Args,Bounds));
end;

function TSQLRestClient.RTreeMatch(DataTable: TSQLRecordClass;
  const DataTableBlobFieldName: RawUTF8; RTreeTable: TSQLRecordRTreeClass;
  const DataTableBlobField: RawByteString; var DataID: TIntegerDynArray): boolean;
var Blob: PPropInfo;
    Res: TSQLTableJSON;
    B: TSQLRecordTreeCoords;
    Where: RawUTF8;
    Data, RTree: TSQLRecordProperties;
    i: integer;
begin
  result := false;
  if (self=nil) or (DataTable=nil) or (RTreeTable=nil) or (DataTableBlobField='') then
    exit;
  RTree := RTreeTable.RecordProps;
  Data := DataTable.RecordProps;
  Blob :=  Data.BlobFieldPropFromRawUTF8(DataTableBlobFieldName);
  if Blob=nil then
    exit;
  for i := 0 to (RTree.Fields.Count shr 1)-1 do
    Where := FormatUTF8('%% >= :(%): AND % <= :(%): AND ',
      [Where,RTree.Fields.List[i*2].Name,B[i].Min,RTree.Fields.List[i*2+1].Name,
       B[i].Max]);
  RTreeTable.BlobToCoord(DataTableBlobField[1],B);
  Res := ListFmt([DataTable,RTreeTable],Data.SQLTableName+'.RowID',
    'WHERE %.RowID=%.RowID AND %%(%,:(%):);',
      [Data.SQLTableName,RTree.SQLTableName,Where,
       RTreeTable.RTreeSQLFunctionName,Data.SQLTableName,
       BinToBase64WithMagic(DataTableBlobField)]);
  if Res<>nil then
  try
    if (Res.FieldCount<>1) or (Res.RowCount<=0) then
      exit;
    Res.GetRowValues(0,DataID);
    result := true;
  finally
    Res.Free;
  end;
end;


{ TSQLRecordLog }

destructor TSQLRecordLog.Destroy;
begin
  fLogTableWriter.Free;
  fLogTableStorage.Free;
  inherited;
end;

constructor TSQLRecordLog.CreateFrom(OneLog: TSQLRecord; const aJSON: RawUTF8);
var L,FieldCount: integer;
    P: PUTF8Char;
begin
  inherited Create;
  L := length(aJSON);
  if (L<10) or (Copy(aJSON,L-1,2)<>']}') then
    exit;
  fLogTableStorage := THeapMemoryStream.Create;
  fLogTableWriter := OneLog.RecordProps.CreateJSONWriter(
    fLogTableStorage,false,true,ALL_ACCESS_RIGHTS,0);
  fLogTableWriter.Flush;
  P := pointer(aJSON);
  if not CompareMem(fLogTableStorage.Memory,P,fLogTableStorage.Position) or
     not IsNotExpandedBuffer(P,P+length(aJSON),FieldCount,fLogTableRowCount) or
     (fLogTableRowCount<0) then begin
    // field format changed or invalid
    FreeAndNil(fLogTableWriter);
    FreeAndNil(fLogTableStorage);
    exit;
  end;
  fLogTableStorage.Seek(0,soFromBeginning);
  fLogTableStorage.Write(Pointer(aJSON)^,L-2);
end;

procedure TSQLRecordLog.Log(OneLog: TSQLRecord);
begin
  if OneLog=nil then
    exit;
  // simulate adding a row: compute new ID
  inc(OneLog.fID);
  // adding a row, in not-expanded format
  if not Assigned(fLogTableStorage) then begin
    fLogTableStorage := THeapMemoryStream.Create;
    fLogTableWriter := OneLog.RecordProps.CreateJSONWriter(
      fLogTableStorage,false,true,ALL_ACCESS_RIGHTS,0);
    fLogTableRowCount := 1;
  end else begin
    fLogTableWriter.Add(',');
    if (fMaxLogTableRowCount<>0) and (fLogTableRowCount>=fMaxLogTableRowCount) then
      fLogTableWriter.TrimFirstRow else
      inc(fLogTableRowCount);
  end;
  OneLog.GetJSONValues(fLogTableWriter)
end;

function TSQLRecordLog.LogCurrentPosition: integer;
begin
  if not Assigned(fLogTableStorage) then
    result := 0 else begin
    fLogTableWriter.Flush;
    result := fLogTableStorage.Position;
  end;
end;

function TSQLRecordLog.LogTableJSON: RawUTF8;
begin
  result := LogTableJSONFrom(0);
end;

function TSQLRecordLog.LogTableJSONFrom(StartPosition: integer): RawUTF8;
var JSONStart: RawUTF8;
    Data: PAnsiChar;
begin
  if not Assigned(fLogTableStorage) or (StartPosition<0) then
    result := '' else begin
    fLogTableWriter.Flush;
    Data := fLogTableStorage.Memory;
    SetString(result,Data+StartPosition,fLogTableStorage.Position-StartPosition);
    // format as valid not expanded JSON table content:
    if StartPosition<>0 then begin
      SetString(JSONStart,Data,fLogTableWriter.StartDataPosition);
      result := JSONStart+result;
    end;
    result := result+']}';
  end;
end;


{ RecordRef }

function RecordReference(Model: TSQLModel; aTable: TSQLRecordClass; aID: integer): TRecordReference;
begin
  if aID=0 then
    result := 0 else begin
    result := Model.GetTableIndexExisting(aTable);
    if result>63 then // TRecordReference handle up to 64=1 shl 6 tables
      result := 0 else
      inc(result,aID shl 6); // 64=1 shl 6
  end;
end;

procedure RecordRefToID(var aArray: TPtrUIntDynArray);
var i: Integer;
begin
  for i := 0 to high(aArray) do
    aArray[i] := aArray[i] shr 6;
end;

procedure RecordRef.From(Model: TSQLModel; aTable: TSQLRecordClass; aID: integer);
begin
  Value := Model.GetTableIndexExisting(aTable);
  if Value>63 then // TRecordReference handle up to 64=1 shl 6 tables
    Value := 0 else
    inc(Value,aID shl 6); // 64=1 shl 6
end;

function RecordRef.ID: integer;
begin
  result := Value shr 6;  // 64=1 shl 6
end;

function RecordRef.Table(Model: TSQLModel): TSQLRecordClass;
var V: integer;
begin
  if (Model=nil) or (Value=0) then
    result := nil else begin
    V := Value and 63;
    if V>high(Model.Tables) then
      result := nil else
      result := Model.Tables[V];
  end;
end;

function RecordRef.TableIndex: integer;
begin
  result := Value and 63;
end;

function RecordRef.Text(Model: TSQLModel): RawUTF8;
var aTable: TSQLRecordClass;
begin
  if ((Value shr 6)=0) then
    // Value=0 or no valid ID
    result := '' else begin
    aTable := Table(Model);
    if aTable=nil then
      result := '' else
      result := Model.TableProps[Value and 63].Props.SQLTableName+' '+
        {$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(Value shr 6);
  end;
end;

function RecordRef.Text(Rest: TSQLRest): RawUTF8;
var T: TSQLRecordClass;
    aID: integer;
begin
  result := '';
  if ((Value shr 6)=0) or (Rest=nil) then
    exit;
  T := Table(Rest.Model);
  if T=nil then
    exit;
  aID := ID;
  with Rest.Model.TableProps[Value and 63].Props do
  if aID<=0 then
    result := SQLTableName else begin
    result := Rest.MainFieldValue(T,aID,true);
    if result='' then
      result := FormatUTF8('% %',[SQLTableName,aID]) else
      result := FormatUTF8('% "%"',[SQLTableName,result]);
  end;
end;


{ TSQLLocks }

function TSQLLocks.isLocked(aID: integer): boolean;
begin
  result := (@self<>nil) and (Count<>0) and (aID<>0) and
    IntegerScanExists(@ID,Count,aID);
end;

function TSQLLocks.Lock(aID: integer): boolean;
var P: PCardinal;
begin
  if (@self=nil) or (Count=MAX_SQLLOCKS) or (aID=0) then
    // void or full
    result := false else begin
    P := IntegerScan(@ID,Count,aID);
    if P<>nil then
      // already locked
      result := false else begin
      // add to ID[] and Ticks[]
      P := IntegerScan(@ID,Count,0);
      if P=nil then begin
        // no free entry -> add at the end
        ID[Count] := aID;
        Ticks[Count] := GetTickCount;
        inc(Count);
      end else begin
        // store at free entry
        P^ := aID;
        Ticks[(PtrUInt(P)-PtrUInt(@ID))shr 2] := GetTickCount;
      end;
      result := true;
    end;
  end;
end;

procedure TSQLLocks.PurgeOlderThan(MinutesFromNow: cardinal);
var Now,OK: cardinal;
    i, LastEntry: integer;
begin
  if (@self=nil) or (Count=0) then
    exit; // nothing to purge
  MinutesFromNow := MinutesFromNow*(1000*60); // GetTickCount unit is ms
  Now := GetTickCount;
  OK  := Now-MinutesFromNow;
  LastEntry := -1;
  for i := 0 to Count-1 do
    if (ID[i]<>0) then
    if ((Ticks[i]>Now) or   // GetTickCount wrap around to zero after 49.7 days
        (Ticks[i]<OK)) then // too old
      ID[i] := 0 else    // 0 frees entry
      LastEntry := i; // refresh last existing entry
  Count := LastEntry+1; // update count (may decrease list length)
end;

function TSQLLocks.UnLock(aID: integer): boolean;
var P: PCardinal;
begin
  if (@self=nil) or (Count=0) or (aID=0) then
    result := false else begin
    P := IntegerScan(@ID,Count,aID);
    if P=nil then
      result := false else begin
      P^ := 0; // 0 marks free entry
      if ((PtrUInt(P)-PtrUInt(@ID))shr 2>=PtrUInt(Count-1)) then
        dec(Count); // freed last entry -> decrease list length
      result := true;
    end;
  end;
end;

procedure CopyObject(aFrom, aTo: TObject);
var P: PPropInfo;
    i: integer;
    C: TClass;
    CP: PClassProp;
label I64;
begin
  if (aFrom=nil) or (aTo=nil) then
    exit;
  {$ifndef LVCL}
  if aFrom.InheritsFrom(TCollection) then begin
    CopyCollection(TCollection(aFrom),TCollection(aTo));
    exit;    
  end;
  {$endif}
  C := PPointer(aFrom)^;
  if aTo.InheritsFrom(C) then
  while C<>nil do begin
    CP := InternalClassProp(C);
    if CP=nil then
      break; // no more RTTI information available
    P := @CP^.PropList;
    for i := 1 to CP^.PropCount do begin
      P^.CopyValue(aFrom,aTo); // shortstring not handled
      P := P^.Next;
    end;
    C := C.ClassParent;
  end;
end;

procedure WriteObject(Value: TObject; var IniContent: RawUTF8; const Section: RawUTF8;
  const SubCompName: RawUTF8=''); overload;
var P: PPropInfo;
    i, V: integer;
{$ifdef UNICODE}
    VV: RawUTF8;
{$endif}
    Obj: TObject;
    CP: PClassProp;
begin
  if Value=nil then
    exit;
  CP := InternalClassProp(PPointer(Value)^);
  if CP=nil then
    exit; // no RTTI available
  P := @CP^.PropList;
  for i := 1 to CP^.PropCount do begin
    case P^.PropType^^.Kind of
      tkInt64{$ifdef FPC}, tkQWord{$endif}:
        UpdateIniEntry(IniContent,Section,SubCompName+RawUTF8(P^.Name),
          {$ifndef ENHANCEDRTL}Int64ToUtf8{$else}IntToStr{$endif}(
            GetInt64Prop(Value,pointer(P))));
      {$ifdef FPC}tkBool,{$endif} tkEnumeration, tkSet, tkInteger: begin
        V := GetOrdProp(Value,pointer(P)); // pointer() to call typinfo
        //if V<>P^.Default then NO DEFAULT: update INI -> must override previous
        UpdateIniEntry(IniContent,Section,SubCompName+RawUTF8(P^.Name),
          {$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(V));
      end;
      {$ifdef FPC}tkAString,{$endif} tkLString:
        UpdateIniEntry(IniContent,Section,SubCompName+RawUTF8(P^.Name),
          P^.GetLongStrValue(Value));
      {$ifdef UNICODE}
      tkUString: begin
        VV := UnicodeStringToUtf8(GetUnicodeStrProp(Value,pointer(P)));
        UpdateIniEntry(IniContent,Section,SubCompName+RawUTF8(P^.Name),VV);
      end;
      {$endif}
      tkClass:
      if Section='' then begin // recursive call works only as plain object
        Obj := pointer(GetOrdProp(Value,pointer(P)));  // GetOrdProp() is OK for CPU64
        if (Obj<>nil) and Obj.InheritsFrom(TPersistent) then
          WriteObject(Value,IniContent,Section,SubCompName+RawUTF8(P^.Name)+'.');
      end;
      // tkString (shortstring) and tkWString are not handled
    end;
    P := P^.Next;
  end;
end;

function WriteObject(Value: TObject): RawUTF8; overload;
begin
  if Value<>nil then
    with TIniWriter.CreateOwnedStream do
    try
      WriteObject(Value,'');
      SetText(result);
    finally
      Free;
    end else
    result := '';
end;

function ObjectToJSON(Value: TObject; Options: TTextWriterWriteObjectOptions): RawUTF8;
begin
  with TJSONSerializer.CreateOwnedStream do
  try
    WriteObject(Value,Options);
    SetText(result);
  finally
    Free;
  end;
end;

function UrlEncode(const NameValuePairs: array of const): RawUTF8;
// (['select','*','where','ID=12','offset',23,'object',aObject]);
var A, n: PtrInt;
    name, value: RawUTF8;
  function Invalid(P: PAnsiChar): boolean;
  begin
    result := true;
    if P<>nil then begin
      repeat
        if not (P^ in ['a'..'z','A'..'Z']) then
          exit else
          inc(P);
      until P^=#0;
      result := false;
    end;
  end;
begin
  result := '';
  n := high(NameValuePairs);
  if n>0 then begin
    for A := 0 to n shr 1 do begin
      VarRecToUTF8(NameValuePairs[A*2],name);
      if Invalid(pointer(name)) then
        continue;
      with NameValuePairs[A*2+1] do
        if VType=vtObject then
          value := ObjectToJSON(VObject,[]) else
          VarRecToUTF8(NameValuePairs[A*2+1],value);
      result := result+'&'+name+'='+UrlEncode(value);
    end;
    result[1] := '?';
  end;
end;

var
  JSONCustomParsers: array of record
    Kind: TClass;
    Reader: TJSONSerializerCustomReader;
    Writer: TJSONSerializerCustomWriter;
  end;

type
  TJSONCustomParserExpectedDirection = (cpRead, cpWrite);
  TJSONCustomParserExpectedDirections = set of TJSONCustomParserExpectedDirection;

function JSONCustomParsersIndex(aClass: TClass;
  aExpectedReadWriteTypes: TJSONCustomParserExpectedDirections): integer; {$ifdef HASINLINE}inline;{$endif}
begin
  if JSONCustomParsers<>nil then
    for result := 0 to length(JSONCustomParsers)-1 do
      with JSONCustomParsers[result] do
      if Kind=aClass then
        if ((cpRead in aExpectedReadWriteTypes) and not Assigned(Reader)) or
           ((cpWrite in aExpectedReadWriteTypes) and not Assigned(Writer)) then
          break // any (un)serializer callbacks missing
        else
          exit; // found with appropriate (un)serializers callbacks
  result := -1;
end;

class procedure TJSONSerializer.RegisterCustomSerializer(aClass: TClass;
  aReader: TJSONSerializerCustomReader; aWriter: TJSONSerializerCustomWriter);
var i: integer;
begin
  i := JSONCustomParsersIndex(aClass,[]);
  if i<0 then begin
    i := length(JSONCustomParsers);
    SetLength(JSONCustomParsers,i+1);
  end;
  with JSONCustomParsers[i] do begin
    Kind := aClass;
    Writer := aWriter;
    Reader := aReader;
  end;
end;

type
  TJSONSerializerRegisteredClassAbstract = class(TList)
  protected
    LastClass: TClass;
    Lock: TRTLCriticalSection;
  public
    constructor Create;
    destructor Destroy; override;
  end;

  TJSONSerializerRegisteredClass = class(TJSONSerializerRegisteredClassAbstract)
  protected
  public
    procedure AddOnce(aItemClass: TClass);
    function Find(JSON: PUTF8Char; AndRegisterClass: boolean): TClass; overload;
    function Find(aClassName: PUTF8Char; aClassNameLen: integer): TClass; overload;
  end;

constructor TJSONSerializerRegisteredClassAbstract.Create;
begin
  InitializeCriticalSection(Lock);
end;

destructor TJSONSerializerRegisteredClassAbstract.Destroy;
begin
  DeleteCriticalSection(Lock);
  inherited;
end;

function TJSONSerializerRegisteredClass.Find(JSON: PUTF8Char; AndRegisterClass: boolean): TClass;
var ClassNameValue: PUTF8Char;
    ClassNameLen: integer;
begin // at input, JSON^='{'
  result := nil;
  if self<>nil then
  try
    EnterCriticalSection(Lock);
    JSON := JSONRetrieveStringField(JSON+1,ClassNameValue,ClassNameLen,true);
    if (JSON=nil) or not IdemPropName('ClassName',ClassNameValue,ClassNameLen) then
      exit; // we expect woStoreClassName option to have been used
    repeat inc(JSON) until not(JSON^ in [#1..' ']);
    if JSONRetrieveStringField(JSON,ClassNameValue,ClassNameLen,false)=nil then
      exit; //invalid JSON string value
    if (LastClass<>nil) and
       IdemPropName(PShortString(PPointer(PtrInt(LastClass)+vmtClassName)^)^,
       ClassNameValue,ClassNameLen) then begin
      result := LastClass; // for speed-up e.g. within a loop
      exit;
    end;
    result := Find(ClassNameValue,ClassNameLen);
    if result=nil then begin // not registered here -> try from Classes.pas
      {$ifndef LVCL}
      if AndRegisterClass then
        result := FindClass(UTF8DecodeToString(ClassNameValue,ClassNameLen));
      if result=nil then
      {$endif}
        exit; // unknown type
    end;
    LastClass  := result;
  finally
    LeaveCriticalSection(Lock)
  end;
end;

procedure TJSONSerializerRegisteredClass.AddOnce(aItemClass: TClass);
var i: integer;
begin
  try
    EnterCriticalSection(Lock);
    for i := 0 to Count-1 do
      if List[i]=aItemClass then
        exit; // already registered
    Add(aItemClass);
  finally
    LeaveCriticalSection(Lock)
  end;
end;

function TJSONSerializerRegisteredClass.Find(aClassName: PUTF8Char; aClassNameLen: integer): TClass;
var i: integer;
begin
  result := nil;
  try
    EnterCriticalSection(Lock);
    for i := 0 to Count-1 do
      // new TObject.ClassName is UnicodeString (since Delphi 20009) -> inline code
      // with vmtClassName = UTF-8 encoded text stored in a shortstring = -44
      if IdemPropName(PShortString(PPointer(PtrInt(List[i])+vmtClassName)^)^,
         aClassName,aClassNameLen) then begin
        result := List[i];
        exit;
      end;
  finally
    LeaveCriticalSection(Lock)
  end;
end;


{$ifndef LVCL}
type
  TJSONSerializerRegisteredCollection = class(TJSONSerializerRegisteredClassAbstract)
  protected
  public
    procedure AddOnce(aCollection: TCollectionClass; aItem: TCollectionItemClass);
    function Find(aCollClassName: PUTF8Char; aCollClassNameLen: integer): TCollectionItemClass; overload;
    function Find(aCollection: TCollectionClass): TCollectionItemClass; overload;
  end;

function TJSONSerializerRegisteredCollection.Find(aCollection: TCollectionClass): TCollectionItemClass;
var i: integer;
begin
  result := nil;
  if self<>nil then
    try
      EnterCriticalSection(Lock);
      for i := 0 to (Count shr 1)-1 do
        if List[i*2]=aCollection then begin
          result := List[i*2+1];
          exit;
        end;
    finally
      LeaveCriticalSection(Lock)
    end;
end;

procedure TJSONSerializerRegisteredCollection.AddOnce(aCollection: TCollectionClass; aItem: TCollectionItemClass);
begin
  if Find(aCollection)=nil then
    try
      EnterCriticalSection(Lock);
      Add(aCollection);
      Add(aItem);
    finally
      LeaveCriticalSection(Lock)
    end;
end;

function TJSONSerializerRegisteredCollection.Find(aCollClassName: PUTF8Char;
  aCollClassNameLen: integer): TCollectionItemClass;
var i: integer;
begin
  result := nil;
  try
    EnterCriticalSection(Lock);
    for i := 0 to (Count shr 1)-1 do
      // new TObject.ClassName is UnicodeString (since Delphi 20009) -> inline code
      // with vmtClassName = UTF-8 encoded text stored in a shortstring = -44
      if IdemPropName(PShortString(PPointer(PtrInt(List[i*2])+vmtClassName)^)^,
         aCollClassName,aCollClassNameLen) then begin
        result := List[i*2+1];
        exit;
      end;
  finally
    LeaveCriticalSection(Lock)
  end;
end;

var
  JSONSerializerRegisteredCollection: TJSONSerializerRegisteredCollection=nil;

class procedure TJSONSerializer.RegisterCollectionForJSON(aCollection: TCollectionClass;
  aItem: TCollectionItemClass);
begin
  if JSONSerializerRegisteredCollection=nil then
    GarbageCollectorFreeAndNil(JSONSerializerRegisteredCollection,
      TJSONSerializerRegisteredCollection.Create);
  JSONSerializerRegisteredCollection.AddOnce(aCollection,aItem);
  RegisterClassForJSON([aCollection,aItem]);
end;

{$endif LVCL}

var
  JSONSerializerRegisteredClass: TJSONSerializerRegisteredClass=nil;

class procedure TJSONSerializer.RegisterClassForJSON(aItemClass: TClass);
begin
  if JSONSerializerRegisteredClass=nil then
    GarbageCollectorFreeAndNil(JSONSerializerRegisteredClass,
      TJSONSerializerRegisteredClass.Create);
  JSONSerializerRegisteredClass.AddOnce(aItemClass);
end;

class procedure TJSONSerializer.RegisterClassForJSON(const aItemClass: array of TClass);
var i: integer;
begin
  for i := 0 to high(aItemClass) do
    RegisterClassForJSON(aItemClass[i]);
end;


function ClassInstanceCreate(aClass: TClass): TObject;
var C: TClass;
begin // guess constructor to be used (faster than multiple InheritsFrom calls)
  C := aClass;
  result := nil;
  if aClass<>nil then
  repeat
    if C<>TSQLRecord then
    if C<>TObjectList then
  {$ifndef LVCL}
    if C<>TInterfacedCollection then
    if C<>TCollection then
  {$endif}
    if PPointer(PtrInt(C)+vmtParent)^<>nil then begin
      C := PPointer(PPointer(PtrInt(C)+vmtParent)^)^;
      if C<>nil then
        continue else
        result := aClass.Create;
    end else
      result := aClass.Create else
  {$ifndef LVCL}
  begin // plain TCollection shall have been registered
      C := JSONSerializerRegisteredCollection.Find(TCollectionClass(aClass));
      if C<>nil then
        result := TCollectionClass(aClass).Create(TCollectionItemClass(C)) else
        raise EParsingException.CreateFmt('%s shall inherit from '+
         'TInterfacedCollection or call TJSONSerializer.RegisterCollectionForJSON()',
         [PShortString(PPointer(PtrInt(aClass)+vmtClassName)^)^]);
    end else
      result := TInterfacedCollectionClass(aClass).Create else
  {$endif}
      result := TObjectList.Create else
      result := TSQLRecordClass(aClass).Create;
    break;
  until false;
end;

function ClassInstanceCreate(const aClassName: RawUTF8): TObject;
var C: TClass;
begin
  if JSONSerializerRegisteredClass=nil then
    C := nil else
    C := JSONSerializerRegisteredClass.Find(Pointer(aClassName),length(aClassName));
  {$ifndef LVCL}
  if C=nil then
    C := FindClass(UTF8ToString(aClassName));
  {$endif}
  result := ClassInstanceCreate(C);
end;

function JSONToNewObject(var From: PUTF8Char; var Valid: boolean): TObject;
var ItemClass: TClass;
begin
  Valid := false;
  result := nil;
  if From=nil then
    exit;
  while From^ in [#1..' '] do inc(From);
  if PInteger(From)^=NULL_LOW then begin
    Valid := true;
    exit;
  end;
  if From^<>'{' then
    exit; // input should be either null, either {"ClassName":"TMyClass",...}
  ItemClass := JSONSerializerRegisteredClass.Find(From,true);
  if ItemClass=nil then
    exit; // unknown type
  result := ClassInstanceCreate(ItemClass);
  From := JSONToObject(result,From,Valid);
  if not Valid then
    FreeAndNil(result); // avoid memory leak
end;

type
  TJSONObject =
    (oNone, oList, oObjectList, {$ifndef LVCL}oCollection,{$endif}
     oUtfs, oStrings, oSQLRecord, oSQLMany, oPersistent, oCustom);

function JSONObject(aClassType: TClass; out aCustomIndex: integer;
  aExpectedReadWriteTypes: TJSONCustomParserExpectedDirections): TJSONObject;
begin
  // guess class type (faster than multiple InheritsFrom calls)
  result := oNone;
  repeat
    if aClassType<>TList then
    if aClassType<>TObjectList then
    if aClassType<>TPersistent then
    if aClassType<>TSQLRecordMany then
    if aClassType<>TSQLRecord then
    if aClassType<>TStrings then
    if aClassType<>TRawUTF8List then
{$ifndef LVCL}
    if aClassType<>TCollection then
{$endif} begin
      aCustomIndex := JSONCustomParsersIndex(aClassType,aExpectedReadWriteTypes);
      if aCustomIndex<0 then
        if PPointer(PtrInt(aClassType)+vmtParent)^<>nil then begin
          aClassType := PPointer(PPointer(PtrInt(aClassType)+vmtParent)^)^;
          if aClassType<>nil then
            continue else
            break;
        end else
        break else
      result := oCustom;
    end else
{$ifndef LVCL}
      result := oCollection else
{$endif}
      result := oUtfs else
      result := oStrings else
      result := oSQLRecord else
      result := oSQLMany else
      result := oPersistent else
      result := oObjectList else
      result := oList;
    break;
  until false;
end;

function JSONToObject(var ObjectInstance; From: PUTF8Char; var Valid: boolean;
  TObjectListItemClass: TClass): PUTF8Char;
var P: PPropInfo;
    Value: TObject absolute ObjectInstance;
{$ifndef LVCL}
    Coll: TCollection absolute ObjectInstance;
    CollItem: TObject;
{$endif}
    Str: TStrings absolute ObjectInstance;
    Utf: TRawUTF8List absolute ObjectInstance;
    Lst: TObjectList absolute ObjectInstance;
    Item: TObject;
    ItemClass: TClass;
    V: PtrInt;
    ndx,err: integer;
    E: extended;
    V64: Int64 absolute E;
    Obj: TObject absolute V;
    PropName: PUTF8Char;
    PropValue: PUTF8Char;
    EndOfObject: AnsiChar;
    Kind: TTypeKind;
    wasString, NestedValid: boolean;
    IsObj: TJSONObject;
    IsObjCustomIndex: integer;
    WS: WideString;
begin
  Valid := false;
  result := From;
  if (Value=nil) or (PPointer(Value)^=nil) then
    exit;
  IsObj := JSONObject(PPointer(Value)^,IsObjCustomIndex,[cpRead]); 
  if From=nil then begin
    case IsObj of // handle '' as Clear for arrays
{$ifndef LVCL}
    oCollection: Coll.Clear;
{$endif}
    oStrings:    Str.Clear;
    oUTfs:       Utf.Clear;
    oObjectList: Lst.Clear;
    end;
    exit;
  end;
  if PInteger(From)^=NULL_LOW then begin
    if (IsObj=oCustom) and Assigned(JSONCustomParsers[IsObjCustomIndex].Reader) then
      // custom JSON reader expects to be executed even if value is null
      result := JSONCustomParsers[IsObjCustomIndex].Reader(Value,From,Valid) else begin
      FreeAndNil(Value);
      result := From+4;
      Valid := true; // null is a valid JSON object
    end;
    exit;
  end;
  while From^ in [#1..' '] do inc(From);
  if IsObj=oCustom then
  with JSONCustomParsers[IsObjCustomIndex] do begin
    if Assigned(Reader) then // leave Valid=false if Reader=nil
      result := Reader(Value,From,Valid);
    exit;
  end;
  if From^='[' then begin
    // nested array = TObjectList, TCollection, TRawUTF8List or TStrings
    inc(From);
    case IsObj of
    oObjectList: begin // TList leaks memory, but TObjectList uses "ClassName":..
      Lst.Clear;
      repeat
        while From^ in [#1..' '] do inc(From);
        case From^ of
        #0: exit;
        ']': begin
          inc(From);
          break;
        end;
        ',':
          inc(From); // valid delimiter between objects
        '{': begin
          result := From;
          if TObjectListItemClass=nil then begin // recognize "ClassName":...
            ItemClass := JSONSerializerRegisteredClass.Find(From,true);
            if ItemClass=nil then
              exit; // unknown type
            Item := ClassInstanceCreate(ItemClass);
          end else
            Item := ClassInstanceCreate(TObjectListItemClass);
          From := JSONToObject(Item,From,NestedValid);
          if not NestedValid then begin
            result := From;
            exit;
          end else
          if From=nil then
            exit;
          Lst.Add(Item);
        end;
        else exit;
        end;
      until false;
      // only way of being here is to have an ending ] at expected place
      Valid := true;
    end;
{$ifndef LVCL}
    oCollection: begin
      Coll.BeginUpdate;  // Coll: TCollection absolute Value
      try
        Coll.Clear;
        repeat
          while From^ in [#1..' '] do inc(From);
          case From^ of
          #0: exit;
          ']': begin
            inc(From);
            break;
          end;
          ',':
            inc(From); // valid delimiter between objects
          '{': begin
            result := From;
            CollItem := Coll.Add;
            From := JSONToObject(CollItem,From,NestedValid);
            if not NestedValid then begin
              result := From;
              exit;
            end else
            if From=nil then
              exit;
          end;
          else exit;
          end;
        until false;
        // only way of being here is to have an ending ] at expected place
        Valid := true;
      finally
        Coll.EndUpdate;
      end;
    end;
{$endif}
    oStrings: begin
{$ifndef LVCL}
      Str.BeginUpdate; // Str: TStrings absolute Value
      try
{$endif}
        Str.Clear;
        repeat
          while From^ in [#1..' '] do inc(From);
          case From^ of
          #0: exit;
          ']': begin
            inc(From);
            break;
          end;
          '"': begin
            result := From;
            PropValue := GetJSONField(From,From,@wasString,@EndOfObject);
            if (PropValue=nil) or not wasString then
              exit;
            Str.Add(UTF8DecodeToString(PropValue,StrLen(PropValue)));
            case EndOfObject of
              ']': break;
              ',': continue;
              else exit;
            end;
          end;
          else exit;
          end;
        until false;
        Valid := true;
{$ifndef LVCL}
      finally
        Str.EndUpdate;
      end;
{$endif}
    end;
    oUtfs: begin
      utf.BeginUpdate; // utf: TStrings absolute Value
      try
        utf.Clear;
        repeat
          while From^ in [#1..' '] do inc(From);
          case From^ of
          #0: exit;
          ']': begin
            inc(From);
            break;
          end;
          '"': begin
            result := From;
            PropValue := GetJSONField(From,From,@wasString,@EndOfObject);
            if (PropValue=nil) or not wasString then
              exit;
            utf.Add(PropValue);
            case EndOfObject of
              ']': break;
              ',': if From=nil then exit else continue;
              else exit;
            end;
          end;
          else exit;
          end;
        until false;
        Valid := true;
      finally
        utf.EndUpdate;
      end;
    end;
    end; // case IsObj of
    // Valid=false if not TCollection, TRawUTF8List nor TStrings
    if Valid and (From<>nil) then begin
      while From^ in [#1..' '] do inc(From);
      if From^=#0 then
        From := nil;
    end;
    result := From;
    exit; // a JSON array begin with [
  end else
  if From^<>'{' then begin
    result := From;
    exit; // a JSON object MUST begin with {
  end;
  repeat inc(From) until (From^=#0) or (From^>' ');
  EndOfObject := #0;
  if From^='}' then begin
    // empty JSON object like {} (e.g. all properties having default values)
    EndOfObject := '}';
    Inc(From);
  end else
  repeat
    wasString := false;
    result := From;
    PropName := GetJSONField(From,From,@wasString,@EndOfObject);  // get property name
    if (From=nil) or (EndOfObject<>':') or not wasString then
      exit; // invalid JSON content
    if IdemPropName('ClassName',PropName,StrLen(PropName)) then begin
      // WriteObject() was called with woStoreClassName option -> handle it
      PropValue := GetJSONField(From,From,@wasString,@EndOfObject);
      if (PropValue=nil) or (not wasString) or not (EndOfObject in ['}',',']) then
        exit; // invalid JSON content
      continue; // just ignore the field here
    end;
    if (IsObj in [oSQLRecord,oSQLMany]) and IsRowID(PropName) then begin
      // manual handling of TSQLRecord.ID property unserialization
      PropValue := GetJSONField(From,From,@wasString,@EndOfObject); 
      if (PropValue=nil) or wasString or not (EndOfObject in ['}',',']) then
        exit; // invalid JSON content
      V := GetInteger(PropValue,err);
      if err<>0 then
        exit;
      TSQLRecord(Value).fID := V;
      continue;
    end;
    P := ClassFieldPropWithParentsFromUTF8(PPointer(Value)^,PropName);
    if P=nil then
      exit; // unknwown property
    Kind := P^.PropType^^.Kind;
    while From^ in [#1..' '] do inc(From);
    result := From;
    if PInteger(result)^=NULL_LOW then begin
      // nested null object
      if (IsObj in [oSQLRecord,oSQLMany]) or (Kind<>tkClass) then
        exit; // null expect a plain TObject
      V := GetOrdProp(Value,pointer(P));
      if Obj<>nil then begin
        // null -> FreeAndNil(Obj)
        Obj.Free;
        SetOrdProp(Value,pointer(P),0);
      end;
    end else
    if From^ in ['[','{'] then begin
      // nested array or object
      if Kind=tkDynArray then begin
        From := P^.GetDynArray(Value).LoadFromJSON(From);
        if From=nil then
          exit; // invalid '[dynamic array]' content
      end else
      if (Kind=tkSet) and (From^='[') then begin // set as string array
        repeat inc(From) until From^<>' ';
        V := 0;
        EndOfObject := From^;
        while EndOfObject<>']' do begin
          PropValue := GetJSONField(From,From,@wasString,@EndOfObject);
          if (PropValue=nil) or (not wasString) then
            exit;
          ndx := P^.PropType^^.SetEnumType^.GetEnumNameValue(PropValue);
          if ndx<0 then
            exit; // invalid enum string value
          SetBit(V,ndx);
        end;
        SetOrdProp(Value,pointer(P),V);
      end else begin
        if Kind<>tkClass then
          exit; // true nested object should begin with '[' or '{' 
        if (IsObj in [oSQLRecord,oSQLMany]) and
           (P^.PropType^^.ClassSQLFieldType=sftID) then
          exit; // only TSQLRecordMany properties are true instances  
        // will handle '[TCollection...' '[TStrings...' '{TObject...'
        From := P^.ClassFromJSON(Value,From,NestedValid);
        if not NestedValid then begin
          result := From;
          exit;
        end else
        if From=nil then
          exit; // invalid JSON content: we expect at least a last '}'
      end;
      while From^ in [#1..' '] do inc(From);
      EndOfObject := From^;
      if From^ in EndOfJSONField then
        inc(From);
    end else begin
      // normal property value
      PropValue := GetJSONField(From,From,@wasString,@EndOfObject); // get value
      if (PropValue=nil) or not (EndOfObject in ['}',',']) then
        exit; // invalid JSON content
      case Kind of
      tkInt64{$ifdef FPC}, tkQWord{$endif}:
        if wasString then
          exit else begin
          V64 := GetInt64(PropValue,err);
          if err<>0 then
            exit;
          SetInt64Prop(Value,pointer(P),V64);
        end;
      tkClass: begin
        if wasString or (P^.PropType^^.ClassSQLFieldType<>sftID) then
          exit; // should have been handled above
        V := GetInteger(PropValue,err);
        if err<>0 then
          exit; // invalid value
        SetOrdProp(Value,pointer(P),V);
      end;
      tkEnumeration: begin
        if wasString then begin // in case enum stored as string
          V := P^.PropType^^.EnumBaseType^.GetEnumNameValue(PropValue);
          if V<0 then
            exit;
        end else begin
          V := GetInteger(PropValue,err);
          if err<>0 then
            exit; // invalid value
        end;
        SetOrdProp(Value,pointer(P),V);
      end;
      {$ifdef FPC} tkBool, {$endif}
      tkInteger, tkSet:
        if wasString then
          exit else begin
          // From='true' or From='false' were converted into '1 or '0'
          V := GetInteger(PropValue,err);
          if err<>0 then
            exit; // invalid value
          SetOrdProp(Value,pointer(P),V);
        end;
      {$ifdef FPC}tkAString,{$endif} tkLString:
        if not wasString then
          exit else
          P^.SetLongStrValue(Value,RawUTF8(PropValue));
      {$ifdef UNICODE}
      tkUString:
        if not wasString then
          exit else
          SetUnicodeStrProp(Value,pointer(P),UTF8DecodeToUnicodeString(PropValue,StrLen(PropValue)));
      {$endif}
      tkWString:
        if not wasString then
          exit else begin
          UTF8ToWideString(PropValue,StrLen(PropValue),WS);
          SetWideStrProp(Value,pointer(P),WS);
        end;
      {$ifdef PUBLISHRECORD}
      tkRecord:
        if not wasString then
          exit else
          RecordLoad(P^.GetFieldAddr(Value)^,pointer(BlobToTSQLRawBlob(PropValue)),P^.PropType^);
      {$endif}
      {$ifdef USEVARIANTS}
      tkVariant:
         GetVariantFromJSON(PropValue,wasString,PVariant(P^.GetFieldAddr(Value))^);
      {$endif}
      tkFloat:
        if P^.PropType^=TypeInfo(Currency) then
          if wasString then
            exit else
            SetInt64Prop(Value,pointer(P),StrToCurr64(PropValue)) else
        if P^.PropType^=TypeInfo(TDateTime) then
          if wasString then
            SetFloatProp(Value,pointer(P),Iso8601ToDateTimePUTF8Char(PropValue,0)) else
            exit else begin
          E := GetExtended(pointer(PropValue),err);
          if (err<>0) or wasString then
            exit else // invalid JSON content
            SetFloatProp(Value,pointer(P),E);
        end;
      end;
    end;
  until (From=nil) or (EndOfObject='}');
  if From<>nil then begin
    while From^ in [#1..' '] do inc(From);
    if From^=#0 then
      From := nil;
  end;
  Valid := (EndOfObject='}'); // mark parsing success
  result := From;
end;

function UrlDecodeObject(U, Upper: PUTF8Char; var ObjectInstance; Next: PPUTF8Char=nil): boolean;
var tmp: RawUTF8;
begin
  result := UrlDecodeValue(U, Upper, tmp, Next);
  if result then
    JSONToObject(ObjectInstance,Pointer(tmp),result);
end;

function JSONFileToObject(const JSONFile: TFileName; var ObjectInstance;
  TObjectListItemClass: TClass=nil): boolean;
var tmp: RawUTF8;
begin
  tmp := StringFromFile(JSONFile);
  if tmp='' then
    result := false else begin
    RemoveCommentsFromJSON(pointer(tmp));
    JSONToObject(ObjectInstance,pointer(tmp),result,TObjectListItemClass);
  end;
end;

procedure ObjectToJSONFile(Value: TObject; const JSONFile: TFileName;
  Options: TTextWriterWriteObjectOptions);
begin
  FileFromString(ObjectToJSON(Value,Options),JSONFile);
end;

function TPropInfo.ClassFromJSON(Instance: TObject; From: PUTF8Char; var Valid: boolean): PUTF8Char;
var Field: ^TObject;
    tmp: TObject;
begin
  valid := false;
  result := nil;
  if (@self=nil) or (PropType^^.Kind<>tkClass) or (Instance=nil) then
    exit;
  if PropWrap(SetProc).Kind=$FF then
    // setter to field -> direct in-memory access
    Field := Pointer(PtrInt(Instance)+SetProc and $00FFFFFF) else
  if SetProc<>0  then begin
    // it is a setter method -> create a temporary object
    tmp := PropType^.ClassCreate;
    try
      result := JSONToObject(tmp,From,Valid);
      if not Valid then
        tmp.Free else
        SetOrdProp(Instance,@self,PtrInt(tmp)); // PtrInt(tmp) is OK for CPU64
    except
      on Exception do
        tmp.Free;
    end;
    exit;
  end else
  if PropWrap(GetProc).Kind=$FF then
    // no setter -> use direct in-memory access from getter (if available)
    Field := Pointer(PtrInt(Instance)+GetProc and $00FFFFFF) else
    // no setter, nor direct field offset -> impossible to set the instance
    exit;
  result := JSONToObject(Field^,From,Valid);
end;

procedure ReadObject(Value: TObject; From: PUTF8Char; const SubCompName: RawUTF8=''); overload;
var P: PPropInfo;
    i, V, err: integer;
    V64: Int64;
    E: extended;
    Obj: TObject;
    UpperName: array[byte] of AnsiChar;
    U: RawUTF8;
    CP: PClassProp;
begin
  if Value=nil then // allow From=nil -> default values
    exit;
  CP := InternalClassProp(PPointer(Value)^);
  if CP=nil then
    exit; // no RTTI available
  P := @CP^.PropList;
  for i := 1 to CP^.PropCount do begin
    PWord(UpperCopyShort(UpperCopy255(UpperName,SubCompName),P^.Name))^ := ord('=');
    U := FindIniNameValue(From,UpperName);
    case P^.PropType^^.Kind of
      tkInt64{$ifdef FPC}, tkQWord{$endif}: begin
        V64 := GetInt64(pointer(U),err);
        if err=0 then
          SetInt64Prop(Value,pointer(P),V64); // pointer() to call typinfo
      end;
      {$ifdef FPC}tkBool,{$endif} tkEnumeration, tkSet, tkInteger: begin
        V := GetInteger(pointer(U),err);
        if err=0 then
          SetOrdProp(Value,pointer(P),V) else // pointer() to call typinfo
          if P^.Default<>longint($80000000) then
            SetOrdProp(Value,pointer(P),P^.Default);
      end;
      tkFloat:
      if U<>'' then
        if P^.PropType^=TypeInfo(Currency) then
          SetInt64Prop(Value,pointer(P),StrToCurr64(pointer(U))) else begin
          E := GetExtended(pointer(U),err);
          if err=0 then
            SetFloatProp(Value,pointer(P),E);
        end;
      {$ifdef FPC}tkAString,{$endif} tkLString:
        P^.SetLongStrValue(Value,U);
      tkWString:
         SetWideStrProp(Value,Pointer(P),UTF8ToWideString(U));
      {$ifdef UNICODE}
      tkUString:
         SetUnicodeStrProp(Value,Pointer(P),UTF8ToString(U));
      {$endif}
      tkDynArray:
        P^.GetDynArray(Value).LoadFrom(pointer(BlobToTSQLRawBlob(pointer(U))));
{$ifdef PUBLISHRECORD}
      tkRecord:
        RecordLoad(P^.GetFieldAddr(Value)^,pointer(BlobToTSQLRawBlob(pointer(U))),P^.PropType^);
{$endif PUBLISHRECORD}
      tkClass: begin
        Obj := pointer(GetOrdProp(Value,pointer(P))); // GetOrdProp() is OK for CPU64
        if (PtrUInt(Obj)>=PtrUInt(SystemInfo.lpMinimumApplicationAddress)) and
           Obj.InheritsFrom(TPersistent) then
          ReadObject(Obj,From,SubCompName+RawUTF8(P^.Name)+'.');
      end;
{$ifdef USEVARIANTS}
      tkVariant:
        VariantLoadJSON(PVariant(P^.GetFieldAddr(Value))^,pointer(U));
{$endif} // tkString (shortstring) is not handled
    end;
    P := P^.Next; 
  end;
end;

procedure ReadObject(Value: TObject; const FromContent: RawUTF8;
  const SubCompName: RawUTF8=''); overload;
var source: PUTF8Char;
    UpperSection: array[byte] of AnsiChar;
begin
  if Value=nil then
    exit; // avoid GPF
  PWord(UpperCopyShort(UpperSection,PShortString(PPointer(
    PPtrInt(Value)^+vmtClassName)^)^))^ := ord(']');
  source := pointer(FromContent);
  if FindSectionFirstLine(source,UpperSection) then
    ReadObject(Value,source,SubCompName);
end;

procedure SetDefaultValuesObject(Value: TObject);
var P: PPropInfo;
    i: integer;
    Obj: TObject;
    CP: PClassProp;
begin
  if Value=nil then
    exit;
  CP := InternalClassProp(PPointer(Value)^);
  if CP=nil then
    exit; // no RTTI available
  P := @CP^.PropList;
  for i := 1 to CP^.PropCount do begin
    case P^.PropType^^.Kind of
      {$ifdef FPC}tkBool,{$endif} tkEnumeration, tkSet, tkInteger:
      if P^.Default<>longint($80000000) then
        SetOrdProp(Value,pointer(P),P^.Default); // pointer() to call typinfo
      tkClass: begin
        Obj := pointer(GetOrdProp(Value,pointer(P))); // GetOrdProp() is OK for CPU64
        if (Obj<>nil) and Obj.InheritsFrom(TPersistent) then
          SetDefaultValuesObject(Obj);
      end;
    end;
    P := P^.Next;
  end;
end;

{$ifdef MSWINDOWS}

{ TSQLRestClientURIMessage }

constructor TSQLRestClientURIMessage.Create(aModel: TSQLModel;
  const ServerWindowName: string; ClientWindow: HWND; TimeOutMS: cardinal);
begin
  inherited Create(aModel);
  fClientWindow := ClientWindow;
  fServerWindowName := ServerWindowName;
  fTimeOutMS := TimeOutMS;
  InitializeCriticalSection(fLock);
end;

constructor TSQLRestClientURIMessage.Create(aModel: TSQLModel;
  const ServerWindowName, ClientWindowName: string; TimeOutMS: cardinal);
var H: HWND;
begin
  H := CreateInternalWindow(ClientWindowName,self);
  if H=0 then
    raise ECommunicationException.CreateFmt('Impossible to create "%s" client window',
      [ClientWindowName]);
  fClientWindowName := ClientWindowName;
  Create(aModel,ServerWindowName,H,TimeOutMS);
end;

destructor TSQLRestClientURIMessage.Destroy;
begin
  try
    inherited Destroy;
  finally
    DeleteCriticalSection(fLock);
    ReleaseInternalWindow(fClientWindowName,fClientWindow);
  end;
end;

function TSQLRestClientURIMessage.InternalURI(const url, method: RawUTF8; Resp,
  Head, SendData: PRawUTF8): Int64Rec;
var Msg, aHead: RawUTF8;
    Data: TCopyDataStruct;
    Ticks, Start, Finished: cardinal;
    P: PUTF8Char;
    aMsg: TMsg;
{$ifdef WITHLOG}
    Log: ISynLog;
{$endif}
begin
{$ifdef WITHLOG}
  Log := SQLite3Log.Enter(self);
{$endif}
  if (fClientWindow=0) or not InternalCheckOpen then begin
    Int64(result) := HTML_NOTIMPLEMENTED; // 501 
    {$ifdef WITHLOG}
    Log.Log(sllClient,'InternalCheckOpen failure',self);
    {$endif}
    exit;
  end;
  // 1. send request
  // #1 is a field delimiter below, since Get*Item() functions return nil for #0
  SetString(Msg,PAnsiChar(@MAGIC_SYN),4);
  Msg := Msg+url+#1+method+#1;
  if Head<>nil then
    Msg := Msg+Head^+#1 else
    Msg := Msg+#1;
  if SendData<>nil then
    Msg := Msg+SendData^;
  Data.dwData := fClientWindow;
  Data.cbData := length(Msg);
  Data.lpData := pointer(Msg);
  EnterCriticalSection(fLock);
  try
    fCurrentResponse := #0; // mark expect some response
    Int64(result) := SendMessage(fServerWindow,WM_COPYDATA,fClientWindow,PtrInt(@Data));
    if not (result.Lo in [HTML_SUCCESS,HTML_CREATED]) then begin
      fCurrentResponse := '';
  {$ifdef WITHLOG}
      Log.Log(sllError,'% % result.Lo=%',[method,url,result.Lo],self);
  {$endif}
      exit;
    end;
    // 2. expect answer from server
    if fCurrentResponse=#0 then begin
      // in practice, we never reach here since SendMessage() did wait for the
      // message to be processed by the receiver, so the Server should have
      // already answered and fCurrentResponse field should have been set
      Start := GetTickCount; // (Ticks<Start) will avoid cardinal overflow
      Finished := Start+fTimeOutMS;
      repeat
        // incoming WM_COPYDATA will set fCurrentResponse in WMCopyData() method
        while PeekMessage(aMsg,0,0,0,PM_REMOVE) do begin
          TranslateMessage(aMsg);
          DispatchMessage(aMsg);
        end;
        Sleep(0);
        Ticks := GetTickCount;
        if (Ticks>Finished) or (Ticks<Start) then begin
          result.Lo := HTML_TIMEOUT; // 408 Request Timeout Error
          exit;
        end;
      until fCurrentResponse<>#0;
    end;
    // 3. return answer to caller
    if length(fCurrentResponse)<=sizeof(result) then
      result.Lo := HTML_NOTIMPLEMENTED else begin
      P := pointer(fCurrentResponse);
      if PCardinal(P)^<>MAGIC_SYN then // broadcasted WM_COPYDATA message? :(
        Int64(result) := 0 else
        Int64(result) := PInt64(P+4)^;
      if result.Lo=0 then
        result.Lo := HTML_NOTFOUND else begin
        inc(P,4+sizeof(result));
        aHead := GetNextItem(P,#1);
        if Head<>nil then
          Head^ := aHead;
        if Resp<>nil then
          if P=nil then
            Resp^ := '' else
            SetString(Resp^,P,length(fCurrentResponse)-(P-pointer(fCurrentResponse)));
      end;
    end;
  finally
    LeaveCriticalSection(fLock);
  end;
{$ifdef WITHLOG}
  Log.Log(sllClient,'% % result.Lo=% .Hi=%',[method,url,result.Lo,result.Hi],self);
{$endif}
end;

procedure TSQLRestClientURIMessage.WMCopyData(var Msg: TWMCopyData);
begin
  if (self=nil) or (Msg.From<>fServerWindow) or
     (Msg.CopyDataStruct^.dwData<>fServerWindow) then
    exit;
  Msg.Result := HTML_SUCCESS; // Send something back
  if fCurrentResponse=#0 then // expect some response?
    SetString(fCurrentResponse,PAnsiChar(Msg.CopyDataStruct^.lpData),
      Msg.CopyDataStruct^.cbData);
end;

function TSQLRestClientURIMessage.InternalCheckOpen: boolean;
begin
  EnterCriticalSection(fLock);
  try
    if fServerWindow<>0 then begin
      result := true;
      exit; // only reconnect if forced by InternalClose call or at first access
    end;
    fServerWindow := FindWindow(pointer(fServerWindowName),nil);
    result := fServerWindow<>0;
  finally
    LeaveCriticalSection(fLock);
  end;
end;

procedure TSQLRestClientURIMessage.InternalClose;
begin
  fServerWindow := 0;
end;


{$endif}



{ TSQLRecordSigned }

function TSQLRecordSigned.CheckSignature(const Content: RawByteString): boolean;
var tmp: RawUTF8;
    i: integer;
    SHA: TSHA256;
    Digest: TSHA256Digest;
begin
  result := false;
  i := PosEx(RawUTF8('/'),fSignature,1);
  if i=0 then exit;
  tmp := Iso8601(fSignatureTime).Text(false)+RawUTF8(ClassName)+copy(fSignature,1,i-1);
  SHA.Init;
  SHA.Update(pointer(tmp),length(tmp));
  SHA.Update(pointer(Content),length(Content)); // hash in place: no Content copy
  SHA.Final(Digest);
  if SHA256DigestToString(Digest)=copy(fSignature,i+1,sizeof(Digest)*2) then
    result := true;
end;

function TSQLRecordSigned.SetAndSignContent(const UserName: RawUTF8;
  const Content: RawByteString; ForcedSignatureTime: Int64): boolean;
var tmp: RawUTF8;
    SHA: TSHA256;
    Digest: TSHA256Digest;
begin
  result := (fSignature='') and (fSignatureTime=0);
  if not result then
    exit; // sign is allowed only once
  if ForcedSignatureTime<>0 then
    fSignatureTime := ForcedSignatureTime else
    fSignatureTime := Iso8601Now;
  { content is hashed with User Name value }
  tmp := Iso8601(fSignatureTime).Text(false)+RawUTF8(ClassName)+UserName;
  SHA.Init;
  SHA.Update(pointer(tmp),length(tmp));
  SHA.Update(pointer(Content),length(Content)); // hash in place: no Content copy
  SHA.Final(Digest);
  fSignature := UserName+'/'+SHA256DigestToString(Digest);
end;

function TSQLRecordSigned.SignedBy: RawUTF8;
var i: integer;
begin
  i := PosEx(RawUTF8('/'),fSignature,1);
  if i=0 then
    result := '' else
    result := copy(fSignature,1,i-1);
end;

procedure TSQLRecordSigned.UnSign;
begin
  fSignature := '';
  fSignatureTime := 0;
end;


{ TSQLRecordFTS3 }

class function TSQLRecordFTS3.OptimizeFTS3Index(Server: TSQLRestServer): boolean;
begin
  if (self=nil) or (Server=nil) then
    Result:= false else
    with RecordProps do
      Result := Server.EngineExecuteAll(FormatUTF8(
        'INSERT INTO %(%) VALUES(''optimize'');',[SQLTableName,SQLTableName]));
end;


{ TSQLRecordRTree }

class procedure TSQLRecordRTree.BlobToCoord(const InBlob;
  var OutCoord: TSQLRecordTreeCoords);
begin // direct memory copy with no memory check
  move(InBlob,OutCoord,(RecordProps.Fields.Count shr 1)*sizeof(double));
end;

class function TSQLRecordRTree.ContainedIn(const BlobA,BlobB): boolean;
var A,B: TSQLRecordTreeCoords;
    i: integer;
begin
  BlobToCoord(BlobA,A);
  BlobToCoord(BlobB,B);
  result := false;
  for i := 0 to (RecordProps.Fields.Count shr 1)-1 do
    if (A[i].max<B[i].min) or (A[i].min>B[i].max) then
      exit; // no match
  result := true; // box match
end;

class function TSQLRecordRTree.RTreeSQLFunctionName: RawUTF8;
begin
    result := RecordProps.SQLTableName+'_in';
end;


{ TSQLRecordMany }

constructor TSQLRecordMany.Create;
begin
  inherited Create;
  with RecordProps do
    if (fRecordManySourceProp<>nil) and (fRecordManyDestProp<>nil) then begin
      fSourceID := fRecordManySourceProp.GetFieldAddr(Self);
      fDestID := fRecordManyDestProp.GetFieldAddr(Self);
    end;
end;

function TSQLRecordMany.ManyAdd(aClient: TSQLRest; aSourceID, aDestID: Integer;
  NoDuplicates: boolean): boolean;
begin
  result := false;
  if (self=nil) or (aClient=nil) or (aSourceID=0) or (aDestID=0) or
     (fSourceID=nil) or (fDestID=nil) then
    exit; // invalid parameters
  if NoDuplicates and
     (InternalIDFromSourceDest(aClient,aSourceID,aDestID)<>0) then
      exit; // this TRecordReference pair already exists
  fSourceID^ := aSourceID;
  fDestID^ := aDestID;
  if aClient.Add(self,true)<>0 then
    result := true;
end;

function TSQLRecordMany.ManyAdd(aClient: TSQLRest; aDestID: Integer;
  NoDuplicates: boolean): boolean;
begin
  if (self=nil) or (fSourceID=nil) then
    result := false else // avoid GPF
    result := ManyAdd(aClient,fSourceID^,aDestID,NoDuplicates);
end;

function TSQLRecordMany.DestGet(aClient: TSQLRest; aSourceID: integer;
  out DestIDs: TIntegerDynArray): Boolean;
var Where: RawUTF8;
begin
  Where := IDWhereSQL(aClient,aSourceID,False);
  if Where='' then
    result := False else
    result := aClient.OneFieldValues(RecordClass,'Dest',Where,DestIDs);
end;

function TSQLRecordMany.DestGetJoined(aClient: TSQLRest;
  const aDestWhereSQL: RawUTF8; aSourceID: Integer;
  out DestIDs: TIntegerDynArray): boolean;
var aTable: TSQLTable;
begin
  aTable := DestGetJoinedTable(aClient,aDestWhereSQL,aSourceID,jkDestID);
  if aTable=nil then
    Result := False else
    try
      aTable.GetRowValues(0,DestIDs);
      Result := true;
    finally
      aTable.Free;
    end;
end;

function TSQLRecordMany.DestGetJoined(aClient: TSQLRest;
  const aDestWhereSQL: RawUTF8; aSourceID: Integer): TSQLRecord;
var aTable: TSQLTable;
begin
  aTable := DestGetJoinedTable(aClient,aDestWhereSQL,aSourceID,jkDestFields);
  if aTable=nil then
    Result := nil else begin
    Result := TSQLRecordClass(RecordProps.fRecordManyDestProp.ObjectClass).Create;
    aTable.OwnerMustFree := true;
    Result.FillPrepare(aTable,ctnTrimExisting); 
  end;
end;

function TSQLRecordMany.DestGetJoinedTable(aClient: TSQLRest;
  const aDestWhereSQL: RawUTF8; aSourceID: Integer; JoinKind: TSQLRecordManyJoinKind;
  const aCustomFieldsCSV: RawUTF8): TSQLTable;
var Select, SQL: RawUTF8;
    SelfProps, DestProps: TSQLModelRecordProperties;
procedure SelectFields(const Classes: array of TSQLModelRecordProperties);
var i: integer;
begin
  for i := 0 to high(Classes) do begin
    Select := Select+Classes[i].SQL.TableSimpleFields[True,True];
    if i<high(Classes) then
      Select := Select+',';
  end;
end;
begin
  result := nil;
  if (Self=nil) or (fSourceID=nil) or (fDestID=nil) or (aClient=nil) then
    exit;
  if aSourceID=0 then
    if fSourceID<>nil then
      aSourceID := fSourceID^;
  if aSourceID=0 then
    exit;
  SelfProps := aClient.Model.Props[PSQLRecordClass(self)^];
  DestProps := aClient.Model.Props[TSQLRecordClass(SelfProps.Props.fRecordManyDestProp.ObjectClass)];
  case JoinKind of
    jkDestID:
      Select := DestProps.Props.SQLTableName+'.RowID';
    jkPivotID:
      Select := SelfProps.Props.SQLTableName+'.RowID';
    jkDestFields:
      if aCustomFieldsCSV='' then
        SelectFields([DestProps]) else
        Select := AddPrefixToCSV(pointer(aCustomFieldsCSV),DestProps.Props.SQLTableName+'.');
    jkPivotFields:
      if aCustomFieldsCSV='' then
        SelectFields([SelfProps]) else
        Select := AddPrefixToCSV(pointer(aCustomFieldsCSV),SelfProps.Props.SQLTableName+'.');
    jkPivotAndDestFields:
      if aCustomFieldsCSV='' then
        SelectFields([SelfProps,DestProps]) else
        Select := aCustomFieldsCSV;
  end;
  if aDestWhereSQL='' then
    // fast inlined prepared statement
    SQL := 'SELECT % FROM %,% WHERE %.Source=:(%): AND %.Dest=%.RowID' else
    if PosEx(RawUTF8(':('),aDestWhereSQL,1)>0 then
      // statement is globaly inlined -> cache prepared statement
      SQL := 'SELECT % FROM %,% WHERE %.Source=:(%): AND %.Dest=%.RowID AND %' else
      // statement is not globaly inlined -> no caching of prepared statement
      SQL := 'SELECT % FROM %,% WHERE %.Source=% AND %.Dest=%.RowID AND %';
  result := aClient.ExecuteList([PSQLRecordClass(Self)^,
     TSQLRecordClass(SelfProps.Props.fRecordManyDestProp.ObjectClass)],
    FormatUTF8(pointer(SQL),
      [Select, DestProps.Props.SQLTableName,SelfProps.Props.SQLTableName,
       SelfProps.Props.SQLTableName,aSourceID, SelfProps.Props.SQLTableName,
       DestProps.Props.SQLTableName, aDestWhereSQL]));
end;

function TSQLRecordMany.DestGet(aClient: TSQLRest;
  out DestIDs: TIntegerDynArray): boolean;
begin
  if fSourceID=nil then
    result := false else // avoid GPF
    result := DestGet(aClient,fSourceID^,DestIDs);
   // fSourceID has been set by TSQLRecord.Create
end;

function TSQLRecordMany.ManyDelete(aClient: TSQLRest; aSourceID, aDestID: Integer;
  aUseBatchMode: boolean=false): boolean;
var aID: integer;
begin
  result := false;
  if (self=nil) or (aClient=nil) or (aSourceID=0) or (aDestID=0) then
    exit;
  aID := InternalIDFromSourceDest(aClient,aSourceID,aDestID);
  if aID<>0 then
    if aUseBatchMode and aClient.InheritsFrom(TSQLRestClientURI) then
      result := TSQLRestClientURI(aClient).BatchDelete(RecordClass,aID)>=0 else
      result := aClient.Delete(RecordClass,aID);
end;

function TSQLRecordMany.ManyDelete(aClient: TSQLRest; aDestID: Integer;
  aUseBatchMode: boolean=false): boolean;
begin
  if fSourceID=nil then
    result := false else // avoid GPF
    result := ManyDelete(aClient,fSourceID^,aDestID,aUseBatchMode);
end;

function TSQLRecordMany.ManySelect(aClient: TSQLRest; aSourceID, aDestID: Integer): boolean;
begin
  if (self=nil) or (aClient=nil) or (aSourceID=0) or (aDestID=0) then
    result := false else // invalid parameters
    result := aClient.Retrieve(FormatUTF8('Source=:(%): AND Dest=:(%):',
      [aSourceID,aDestID]),Self);
end;

function TSQLRecordMany.ManySelect(aClient: TSQLRest; aDestID: Integer): boolean;
begin
  if (self=nil) or (fSourceID=nil) then
    result := false else // avoid GPF
    result := ManySelect(aClient,fSourceID^,aDestID);
end;

function TSQLRecordMany.InternalFillMany(aClient: TSQLRest;
  aID: integer; const aAndWhereSQL: RawUTF8; isDest: boolean): integer;
var aTable: TSQLTable;
    Where: RawUTF8;
begin
  result := 0;
  if self=nil then
    exit;
  if not isDest and (aID=0)then
    if fSourceID<>nil then
      aID := fSourceID^; // has been set by TSQLRecord.Create
  Where := IDWhereSQL(aClient,aID,isDest,aAndWhereSQL);
  if Where='' then
    exit;
  aTable := aClient.InternalListRecordsJSON(RecordClass,Where);
  if aTable=nil then
    exit;
  aTable.OwnerMustFree := true;
  FillPrepare(aTable); // temporary storage for FillRow, FillOne and FillRewind
  result := aTable.RowCount;
end;

function TSQLRecordMany.FillMany(aClient: TSQLRest; aSourceID: integer;
  const aAndWhereSQL: RawUTF8): integer;
begin
  result := InternalFillMany(aclient,aSourceID,aAndWhereSQL,false);
end;

function TSQLRecordMany.FillManyFromDest(aClient: TSQLRest; aDestID: integer;
  const aAndWhereSQL: RawUTF8): integer;
begin
  result := InternalFillMany(aclient,aDestID,aAndWhereSQL,true);
end;

function TSQLRecordMany.IDWhereSQL(aClient: TSQLRest; aID: integer; isDest: boolean;
  const aAndWhereSQL: RawUTF8=''): RawUTF8;
const FieldName: array[boolean] of RawUTF8 = ('Source=','Dest=');
begin
  if (self=nil) or (aID=0) or (fSourceID=nil) or (fDestID=nil) or
     (aClient=nil) then
    Result := '' else begin
    if aAndWhereSQL<>'' then
      if PosEx(RawUTF8(':('),aAndWhereSQL,1)>0 then
        Result := '%:(%): AND %' else // inlined parameters
        Result := '%% AND %' else // no inlined parameters -> not cached
      Result := '%:(%):'; // no additional where clause -> inline ID
    Result := FormatUTF8(pointer(result),[FieldName[isDest],aID,aAndWhereSQL]);
  end;
end;

function TSQLRecordMany.SourceGet(aClient: TSQLRest; aDestID: integer;
  out SourceIDs: TIntegerDynArray): boolean;
var Where: RawUTF8;
begin
  Where := IDWhereSQL(aClient,aDestID,True);
  if Where='' then
    Result := false else
    Result := aClient.OneFieldValues(RecordClass,'Source',Where,SourceIDs);
end;

function TSQLRecordMany.InternalIDFromSourceDest(aClient: TSQLRest; aSourceID, aDestID: integer): integer;
begin
  result := GetInteger(Pointer(aClient.OneFieldValue(RecordClass,'RowID',
    FormatUTF8('Source=:(%): AND Dest=:(%):',[aSourceID,aDestID]))));
end;


{ TSQLRecordProperties }

procedure TSQLRecordProperties.InternalRegisterModel(aModel: TSQLModel;
  aTableIndex: integer; aProperties: TSQLModelRecordProperties);
var i: integer;
begin
  assert(aTableIndex>=0);
  for i := 0 to fModelMax do
    if fModel[i].Model=aModel then
      exit; // already registered
  inc(fModelMax);
  if fModelMax>=length(fModel) then
    SetLength(fModel,fModelMax+4);
  with fModel[fModelMax] do begin
    Model := aModel;
    Properties := aProperties;
    TableIndex := aTableIndex;
  end;
end;

constructor TSQLRecordProperties.Create(aTable: TSQLRecordClass);

  procedure AddParentsFirst(aClassType: TClass);
  var CP: PClassProp;
      P: PPropInfo;
      i: Integer;
  begin
    if aClassType=nil then
      exit; // no RTTI information (e.g. reached TObject level)
    AddParentsFirst(aClassType.ClassParent);
    CP := InternalClassProp(aClassType);
    if CP<>nil then begin
      P := @CP^.PropList;
      for i := 1 to CP^.PropCount do begin
        Fields.Add(aTable,TSQLPropInfoRTTI.CreateFrom(P));
        P := P^.Next;
      end;
    end;
  end;

var i,j, nProps: integer;
    nMany, nSimple, nDynArray, nBlob, nBlobCustom: integer;
    isTSQLRecordMany: boolean;
    F: TSQLPropInfo;
label Simple;
begin
  assert(aTable<>nil); // should not be called directly, but via PropsCreate()
  // register to the JSONToObject() TObjectList "ClassName":".." feature 
  TJSONSerializer.RegisterClassForJSON(aTable);
  // initialize internal structures
  fModelMax := -1;
  Table := aTable;
  SQLTableName := GetDisplayNameFromClass(aTable);
  SQLTableNameUpperWithDot := UpperCase(SQLTableName)+'.';
  // add properties to internal Fields list
  ClassProp := InternalClassProp(aTable);
  assert(ClassProp<>nil);
  nProps := PClassProp(aTable)^.FieldCountWithParents;
  if nProps>MAX_SQLFIELDS_INCLUDINGID then
    raise EModelException.CreateFmt('%s has too many fields: %d>=%d',
      [SQLTableName,nProps,MAX_SQLFIELDS]);
  Fields := TSQLPropInfoList.Create;
  AddParentsFirst(aTable);
  aTable.InternalRegisterCustomProperties(self);
  if Fields.Count>MAX_SQLFIELDS_INCLUDINGID then
    raise EModelException.CreateFmt(
      '%s has too many fields after InternalRegisterCustomProperties: %d>=%d',
      [SQLTableName,Fields.Count,MAX_SQLFIELDS]);
  SetLength(Fields.fList,Fields.Count);
  // generate some internal lookup information
  SetLength(ManyFields,MAX_SQLFIELDS);
  SetLength(SimpleFields,MAX_SQLFIELDS);
  SetLength(DynArrayFields,MAX_SQLFIELDS);
  SetLength(BlobCustomFields,MAX_SQLFIELDS);
  SetLength(BlobFields,MAX_SQLFIELDS);
  MainField[false] := -1;
  MainField[true] := -1;
  nMany := 0;
  nSimple := 0;
  nDynArray := 0;
  nBlob := 0;
  nBlobCustom := 0;
  for i := 0 to Fields.Count-1  do begin
    F := Fields.List[i];
    include(HasTypeFields,F.SQLFieldType);
    //  handle unique fields, i.e. if marked as "stored false"
    if aIsUnique in F.Attributes then begin
      include(IsUniqueFieldsBits,i);
      // must trim() text value before storage, and validate for unicity
      if F.SQLFieldType in [sftUTF8Text,sftAnsiText] then
        AddFilterOrValidate(i,TSynFilterTrim.Create);
      AddFilterOrValidate(i,TSynValidateUniqueField.Create);
    end;
    // get corresponding properties content
    case F.SQLFieldType of
      sftUnknown: ;
      sftUTF8Text: begin
        if aIsUnique in F.Attributes then
          if MainField[false]<0 then
            MainField[false] := i;
        if MainField[true]<0 then
          MainField[true] := i;
        goto Simple;
      end;
      sftBlob: begin
        BlobFields[nBlob] := F as TSQLPropInfoRTTI;
        inc(nBlob);
        SQLTableUpdateBlobFields := SQLTableUpdateBlobFields+F.Name+'=?,';
        SQLTableRetrieveBlobFields := SQLTableRetrieveBlobFields+F.Name+',';
      end;
      sftMany: begin
        ManyFields[nMany] := F as TSQLPropInfoRTTIMany;
        inc(nMany);
      end;
      sftBlobDynArray:
      with F as TSQLPropInfoRTTIDynArray do begin
        if DynArrayIndex>0 then
          for j := 0 to nDynArray-1 do
          if DynArrayFields[j].DynArrayIndex=DynArrayIndex then
            raise EModelException.CreateFmt('dup index %d for %s.%s and %s properties',
              [DynArrayIndex,aTable.ClassName,Name,DynArrayFields[j].Name]);
        DynArrayFields[nDynArray] := F as TSQLPropInfoRTTIDynArray;
        inc(nDynArray);
        goto Simple;
      end;
      sftBlobCustom, sftUTF8Custom: begin
        BlobCustomFields[nBlobCustom] := F;
        inc(nBlobCustom);
        goto Simple;
      end;
      else begin
        // this code follows NOT_SIMPLE_FIELDS const
Simple: SimpleFields[nSimple] := F;
        inc(nSimple);
        include(SimpleFieldsBits[soSelect],i);
        SQLTableSimpleFieldsNoRowID := SQLTableSimpleFieldsNoRowID+F.Name+',';
      end;
    end;
  end;
  if SQLTableSimpleFieldsNoRowID<>'' then
    SetLength(SQLTableSimpleFieldsNoRowID,length(SQLTableSimpleFieldsNoRowID)-1);
  if SQLTableUpdateBlobFields<>'' then
    SetLength(SQLTableUpdateBlobFields,length(SQLTableUpdateBlobFields)-1);
  if SQLTableRetrieveBlobFields<>'' then
    SetLength(SQLTableRetrieveBlobFields,length(SQLTableRetrieveBlobFields)-1);
  SetLength(ManyFields,nMany);
  SetLength(SimpleFields,nSimple);
  SetLength(DynArrayFields,nDynArray);
  SetLength(BlobCustomFields,nBlobCustom);
  SetLength(BlobFields,nBlob);
  SimpleFieldsBits[soInsert] := SimpleFieldsBits[soSelect];
  SimpleFieldsBits[soUpdate] := SimpleFieldsBits[soSelect];
  SimpleFieldsBits[soDelete] := SimpleFieldsBits[soSelect];
  SimpleFieldsCount[soInsert] := nSimple;
  SimpleFieldsCount[soUpdate] := nSimple;
  SimpleFieldsCount[soDelete] := nSimple;
  HasNotSimpleFields := nSimple<>Fields.Count;
  for i := 0 to Fields.Count-1 do
    if Fields.List[i].SQLFieldType=sftCreateTime then begin
      exclude(SimpleFieldsBits[soUpdate],i);
      dec(SimpleFieldsCount[soUpdate]);
    end;
  isTSQLRecordMany := aTable.InheritsFrom(TSQLRecordMany);
  if isTSQLRecordMany then begin
    fRecordManySourceProp := Fields.ByRawUTF8Name('Source') as TSQLPropInfoRTTIInstance;
    if fRecordManySourceProp=nil then
      raise EORMException.CreateFmt('%s=class(TSQLRecordMany) expects a SOURCE field',[ClassName]) else
    fRecordManyDestProp := Fields.ByRawUTF8Name('Dest') as TSQLPropInfoRTTIInstance;
    if fRecordManyDestProp=nil then
      raise EORMException.CreateFmt('%s=class(TSQLRecordMany) expects a DEST field',[ClassName]);
  end;
end;

function TSQLRecordProperties.BlobFieldPropFromRawUTF8(const PropName: RawUTF8): PPropInfo;
var i: integer;
begin
  if (self<>nil) and (PropName<>'') then
  for i := 0 to high(BlobFields) do
    if IdemPropNameU(BlobFields[i].Name,PropName) then begin
      result := BlobFields[i].PropInfo;
      exit;
    end;
  result := nil;
end;

function TSQLRecordProperties.SQLFieldTypeToSQL(Fieldindex: integer): RawUTF8;
const
  /// simple wrapper from each SQL used type into SQLite3 field datatype
  // - set to '' for fields with no column created in the database
  DEFAULT_SQLFIELDTYPETOSQL: array[TSQLFieldType] of RawUTF8 =
   ('',                              // sftUnknown
    ' TEXT COLLATE NOCASE, ',        // sftAnsiText
    ' TEXT COLLATE SYSTEMNOCASE, ',  // sftUTF8Text
    ' INTEGER, ',                    // sftEnumerate
    ' INTEGER, ',                    // sftSet
    ' INTEGER, ',                    // sftInteger
    ' INTEGER, ',                    // sftID
    ' INTEGER, ',                    // sftRecord
    ' INTEGER, ',                    // sftBoolean
    ' FLOAT, ',                      // sftFloat
    ' TEXT COLLATE ISO8601, ',       // sftDateTime
    ' INTEGER, ',                    // sftTimeLog
    ' FLOAT, ',                      // sftCurrency
    ' TEXT COLLATE NOCASE, ',        // sftObject
{$ifdef USEVARIANTS}
    ' TEXT COLLATE NOCASE, ',        // sftVariant
{$endif}
    ' BLOB, ',                       // sftBlob
    ' BLOB, ',                       // sftBlobDynArray
    ' BLOB, ',                       // sftBlobCustom
    ' TEXT COLLATE NOCASE, ',        // sftUTF8Custom
{$ifdef PUBLISHRECORD}
    ' BLOB, ',                       // sftBlobRecord
{$endif}
    '',                              // sftMany
    ' INTEGER, ',                    // sftModTime
    ' INTEGER, ');                   // sftCreateTime
begin
  if (self=nil) or (cardinal(FieldIndex)>=cardinal(Fields.Count)) then
    result := '' else
  if (FieldIndex<length(fCustomCollation)) and (fCustomCollation[FieldIndex]<>'') then
    result := ' TEXT COLLATE '+fCustomCollation[FieldIndex]+', ' else
    result := DEFAULT_SQLFIELDTYPETOSQL[Fields.List[FieldIndex].SQLFieldType];
end;

function TSQLRecordProperties.SetCustomCollation(FieldIndex: integer; const aCollationName: RawUTF8): boolean;
begin
  result := (self<>nil) and (cardinal(FieldIndex)<cardinal(Fields.Count));
  if result then begin
    if Fields.Count>length(fCustomCollation) then
      SetLength(fCustomCollation,Fields.Count);
    fCustomCollation[FieldIndex] := aCollationName;
  end;
end;

procedure TSQLRecordProperties.SetCustomCollationForAllRawUTF8(const aCollationName: RawUTF8);
var i: integer;
begin
  if self=nil then
    exit;
  if Fields.Count>length(fCustomCollation) then
    SetLength(fCustomCollation,Fields.Count);
  for i := 0 to Fields.Count-1 do
    if Fields.List[i].SQLFieldType=sftUTF8Text then
      fCustomCollation[i] := aCollationName;
end;

function TSQLRecordProperties.SQLAddField(FieldIndex: integer): RawUTF8;
begin
  if (self=nil) or (cardinal(FieldIndex)>=cardinal(Fields.Count)) then begin
    result := '';
    exit;
  end;
  result := SQLFieldTypeToSQL(FieldIndex);
  if result='' then
    exit; // some fields won't have any column created in the database
  result := FormatUTF8('ALTER TABLE % ADD COLUMN %%',
    [SQLTableName,Fields.List[FieldIndex].Name,result]);
  if FieldIndex in IsUniqueFieldsBits then
    insert(' UNIQUE',result,length(result)-1);
  result[length(result)-1] := ';' // SQLFieldTypeToSQL[] ends with ','
end;

procedure TSQLRecordProperties.SetJSONWriterColumnNames(W: TJSONSerializer;
  KnownRowsCount: integer);
var i,n: integer;
begin
  // get col count overhead
  if W.withID then
    n := 1 else
    n := 0;
  // set col names
  SetLength(W.ColNames,Fields.Count+n);
  if W.withID then
    W.ColNames[0] := 'RowID'; // works for both normal and FTS3 records
  for i := 0 to Fields.Count-1 do
    if i in W.Fields then begin
      W.ColNames[n] := Fields.List[i].Name;
      inc(n);
    end;
  // adjust col count
  if n<>length(W.ColNames) then
    SetLength(W.ColNames,n);
  W.AddColumns(KnownRowsCount); // write or init field names for appropriate JSON Expand
end;

function TSQLRecordProperties.CreateJSONWriter(JSON: TStream; Expand,
  withID: boolean; const aFields: TSQLFieldBits; KnownRowsCount: integer): TJSONSerializer;
begin
  if (self=nil) or ((Int64(Fields)=0) and not withID) then  // no data
    result := nil else begin
    result := TJSONSerializer.Create(JSON,Expand,withID,aFields);
    SetJSONWriterColumnNames(result,KnownRowsCount);
  end;
end;

procedure TSQLRecordProperties.SetSimpleFieldsExpandedJSONWriter(
  W: TJSONWriter; withID: boolean; Occasion: TSQLOccasion);
var i, id, n: integer;
begin
  if (self=nil) or (W=nil) then
    exit;
  if withID then
    id := 1 else
    id := 0;
  n := SimpleFieldsCount[Occasion]+id;
  if W.Expand and (W.WithID=withID) and (length(W.ColNames)=n) and
     IsEqual(W.Fields,SimpleFieldsBits[Occasion]) then
    exit; // already set -> do not compute it again
  SetLength(W.ColNames,n);
  if withID then
    W.ColNames[0] := '"RowID":'; // works for both normal and FTS3 records
  W.Expand := true;
  W.WithID := withID;
  W.Fields := SimpleFieldsBits[Occasion];
  for i := 0 to Fields.Count-1 do
    if i in W.Fields then begin
      W.ColNames[id] := '"'+Fields.List[i].Name+'":'; // as in TJSONWriter.AddColumns
      W.FieldMax := i;
      inc(id);
    end;
  assert(id=n);
end;

function TSQLRecordProperties.IsFieldName(const PropName: RawUTF8): boolean;
begin
  result := (PropName<>'') and
    (isRowID(pointer(PropName)) or (Fields.IndexByName(PropName)>=0));
end;

function TSQLRecordProperties.AddFilterOrValidate(aFieldIndex: integer;
  aFilter: TSynFilterOrValidate): TSynFilterOrValidate;
begin
  if (self=nil) or (cardinal(aFieldIndex)>=cardinal(Fields.Count)) or
    (aFilter=nil) then
    result := nil else begin
    if Filters=nil then
      SetLength(Filters,Fields.Count);
    if Filters[aFieldIndex]=nil then
      Filters[aFieldIndex] := TObjectList.Create;
    Filters[aFieldIndex].Add(aFilter);
    result := aFilter;
  end;
end;

function TSQLRecordProperties.AddFilterOrValidate(const aFieldName: RawUTF8;
  aFilter: TSynFilterOrValidate): TSynFilterOrValidate;
begin
  result := AddFilterOrValidate(Fields.IndexByName(aFieldName),aFilter);
end;

destructor TSQLRecordProperties.Destroy;
var f: integer;
begin
  for f := 0 to high(Filters) do
    Filters[f].Free; // will free any created TSynFilter instances
  inherited;
  Fields.Free;
end;

function TSQLRecordProperties.FieldIndexsFromRawUTF8(const aFields: array of RawUTF8;
  var Bits: TSQLFieldBits): boolean;
var f,ndx: integer;
begin
  fillchar(Bits,sizeof(TSQLFieldBits),0);
  result := false;
  if self=nil then
    exit;
  for f := 0 to high(aFields) do begin
    ndx := Fields.IndexByName(aFields[f]);
    if ndx<0 then
      exit; // invalid field name
    include(Bits,ndx);
  end;
  result := true;
end;

function TSQLRecordProperties.AppendFieldName(FieldIndex: Integer;
  var Text: RawUTF8; ForceNoRowID: boolean): boolean;
begin
  if FieldIndex=VIRTUAL_TABLE_ROWID_COLUMN then begin
    if ForceNoRowID then
      Text := Text+'ID' else
      Text := Text+'RowID';
    result := false;
  end else
  if (self=nil) or (cardinal(FieldIndex)>=cardinal(Fields.Count)) then
    result := true else begin 
    Text := Text+Fields.List[FieldIndex].Name;
    result := false;
  end;
end;

function TSQLRecordProperties.MainFieldName(Table: TSQLRecordClass;
  ReturnFirstIfNoUnique: boolean=false): RawUTF8;
begin
  if (self=nil) or (Table=nil) or (MainField[ReturnFirstIfNoUnique]<0) then
    result := '' else
    result := Fields.List[MainField[ReturnFirstIfNoUnique]].Name;
end;


{ TSynValidateUniqueField }

function TSynValidateUniqueField.Process(aFieldIndex: integer; const Value: RawUTF8;
  var ErrorMsg: string): boolean;
var aID: integer;
begin
  result := false;
  if Value='' then
    ErrorMsg := sValidationFieldVoid else
  if (fProcessRest=nil) or (fProcessRec=nil) then
    result := true else
  with fProcessRec.RecordProps do
    if cardinal(aFieldIndex)>=cardinal(Fields.Count) then
      result := true else begin
      aID := GetInteger(pointer(fProcessRest.OneFieldValue(Table,'RowID',
        Fields.List[aFieldIndex].Name+'=:('+QuotedStr(Value,'''')+'):')));
      if (aID>0) and (aID<>fProcessRec.fID) then
        ErrorMsg := sValidationFieldDuplicate else
        result := true;
    end;
end;


{ TJSONSerializer }

destructor TJSONSerializer.Destroy;
begin
  fInternalJSONWriter.Free;
  inherited;
end;

procedure TJSONSerializer.WriteObject(Value: TObject; Options: TTextWriterWriteObjectOptions);
var Added: boolean;
procedure HR(P: PPropInfo=nil);
var i: integer;
begin
  if woHumanReadable in Options then begin
    AddCR;
    for i := 1 to fHumanReadableLevel do
      Add(#9);
  end;
  if P=nil then
    exit;
  AddPropName(P^.Name);
  if woHumanReadable in Options then
    Add(' ');
  Added := true;
end;
var P: PPropInfo;
    i, j, V, c: integer;
    Obj: TObject;
    List: TList absolute Value;
{$ifndef LVCL}
    Coll: TCollection absolute Value;
{$endif}
    Str: TStrings absolute Value;
    Utf: TRawUTF8List absolute Value;
    aClassType: TClass;
    CP: PClassProp;
    Kind: TTypeKind;
    PS: PShortString;
    UtfP: PPUtf8CharArray;
    IsObj: TJSONObject;
    IsObjCustomIndex: integer;
    WS: WideString;
label next;
begin
  if not (woHumanReadable in Options) or (fHumanReadableLevel<0) then
    fHumanReadableLevel := 0;
  if (self=nil) or (Value=nil) then
    aClassType := nil else
    aClassType := PPointer(Value)^;
  if aClassType=nil then begin
    AddShort('null'); // return void object
    exit;
  end;
  if woFullExpand in Options then begin
    Add('{');
    AddInstanceName(Value,':');
  end;
  IsObj := JSONObject(aClassType,IsObjCustomIndex,[cpWrite]);
  case IsObj of
  // handle custom class serialization
  oCustom:
    with JSONCustomParsers[IsObjCustomIndex] do begin
      if Assigned(Writer) then
        Writer(self,Value,Options);
      exit;
    end;
  // handle JSON arrays
  oList, oObjectList, {$ifndef LVCL}oCollection,{$endif} oUtfs, oStrings: begin
    HR;
    Add('['); // write as JSON array of JSON objects
    inc(fHumanReadableLevel);
    case IsObj of
    oList: // TList
      for c := 0 to List.Count-1 do begin
        WriteObject(List.List[c],Options);
        Add(',');
      end;
    oObjectList: // TObjectList will include "ClassName":"TMyObject" field
      for c := 0 to List.Count-1 do begin
        WriteObject(List.List[c],Options+[woStoreClassName]);
        Add(',');
      end;
{$ifndef LVCL}
    oCollection:
      for c := 0 to Coll.Count-1 do begin
        WriteObject(Coll.Items[c],Options);
        Add(',');
      end;
{$endif}
    oUtfs: begin
      UtfP := Utf.ListPtr;
      for c := 0 to Utf.Count-1 do begin
        HR;
        Add('"');
        AddJSONEscape(UtfP^[c]);
        Add('"',',');
      end;
    end;
    oStrings:
      for c := 0 to Str.Count-1 do begin
        HR;
        Add('"');
        AddJSONEscapeString(Str[c]);
        Add('"',',');
      end;
    end;
    CancelLastComma;
    dec(fHumanReadableLevel);
    HR;
    Add(']');
    if woFullExpand in Options then
      Add('}');
    exit;
  end;
  end;
  // handle JSON object
  if fHumanReadableLevel>0 then
    HR;
  Add('{');
  inc(fHumanReadableLevel);
  if woStoreClassName in Options then begin // optional "ClassName":"TObjectClass"
    HR;
    AddShort('"ClassName":"');
    AddShort(PShortString(PPointer(PPtrInt(Value)^+vmtClassName)^)^);
    Add('"',',');
  end;
  if IsObj in [oSQLRecord,oSQLMany] then begin
    // manual handling of TSQLRecord.ID property serialization
    HR;
    AddPropName('ID');
    if woHumanReadable in Options then
      Add(' ');
    Add(TSQLRecord(Value).fID);
    Add(',');
  end;
  repeat
    CP := InternalClassProp(aClassType);
    if CP=nil then
      break; // no more RTTI information available
    P := @CP^.PropList;
    for i := 1 to CP^.PropCount do begin
      if IsObj in [oSQLRecord,oSQLMany] then begin
        if IsRowIDShort(P^.Name) then
          goto next;
      end else
        if not P^.IsStored(Value) then
          goto next;
      Added := false;
      Kind := P^.PropType^^.Kind;
      case Kind of
        tkInt64{$ifdef FPC}, tkQWord{$endif}: begin
          HR(P);
          Add(GetInt64Prop(Value,pointer(P)));
        end;
        {$ifdef FPC} tkBool, {$endif}
        tkEnumeration, tkInteger, tkSet: begin
          V := GetOrdProp(Value,pointer(P)); // pointer() to call typinfo
          if (V<>P^.Default) or not (woDontStoreDefault in Options) then begin
            HR(P);
            if {$ifdef FPC}(Kind=tkBool){$else}
               (Kind=tkEnumeration) and (P^.PropType^=TypeInfo(boolean)){$endif} then
              AddString(JSON_BOOLEAN[boolean(V)]) else
              if (woFullExpand in Options) or (woHumanReadable in Options) then
              case Kind of
              tkEnumeration: begin
                 Add('"');
                 AddShort(P^.PropType^^.EnumBaseType^.GetEnumNameOrd(V)^);
                 Add('"');
              end;
              tkSet: begin
                Add('[');
                with P^.PropType^^.SetEnumType^ do begin
                  PS := @NameList;
                  for j := MinValue to MaxValue do begin
                    if GetBit(V,j) then begin
                      Add('"');
                      AddShort(PS^);
                      Add('"',',');
                    end;
                    inc(PtrUInt(PS),ord(PS^[0])+1); // next item
                  end;
                end;
                CancelLastComma;
                Add(']');
              end;
              else
                Add(V);
              end else
                Add(V); // typecast enums and sets as plain integer by default
          end;
        end;
        {$ifdef FPC}tkAString,{$endif} tkLString: begin
          HR(P);
          Add('"');
          AddJSONEscape(pointer(P^.GetLongStrValue(Value)));
          Add('"');
        end;
        tkFloat: begin
          HR(P);
          if P^.PropType^=TypeInfo(Currency) then
            AddCurr64(GetInt64Prop(Value,pointer(P))) else
          if P^.PropType^=TypeInfo(TDateTime) then begin
            Add('"');
            AddDateTime(GetFloatProp(Value,pointer(P)));
            Add('"');
          end else
            Add(GetFloatProp(Value,pointer(P)));
        end;
        {$ifdef UNICODE}
        tkUString: begin // write converted to UTF-8
          HR(P);
          Add('"');
          AddJSONEscapeW(pointer(GetUnicodeStrProp(Value,pointer(P))));
          Add('"');
        end;
        {$endif}
        tkWString: begin // write converted to UTF-8
          HR(P);
          Add('"');
          GetWideStrProp(Value,pointer(P),WS);
          AddJSONEscapeW(pointer(WS));
          Add('"');
        end;
        tkDynArray: begin
          HR(P);
          AddDynArrayJSON(P^.GetDynArray(Value));
        end;
        {$ifdef PUBLISHRECORD}
        tkRecord: begin
          HR(P);
          WrRecord(P^.GetFieldAddr(Value)^,P^.PropType^);
        end;
        {$endif}
        {$ifdef USEVARIANTS}
        tkVariant: begin // stored as JSON, e.g. '1.234' or '"text"'
          HR(P);
          AddVariantJSON(PVariant(P^.GetFieldAddr(Value))^,twJSONEscape);
        end;
        {$endif}
        tkClass: begin
          Obj := pointer(GetOrdProp(Value,pointer(P)));  // works also for CPU64
          if P^.PropType^^.ClassSQLFieldType=sftID then begin
            HR(P);
            Add(PtrInt(Obj));
          end else
          if Obj<>nil then begin
            HR(P);
            WriteObject(Obj,Options);
          end;
        end;
        // tkString (shortstring) is not handled
      end;
      if Added then
        Add(',');
next: P := P^.Next;
    end;
    aClassType := aClassType.ClassParent;
  until aClassType=nil;
  CancelLastComma;
  dec(fHumanReadableLevel);
  HR;
  Add('}');
  if woFullExpand in Options then
    Add('}');
end;

procedure TJSONSerializer.WriteObjectAsString(Value: TObject;
  Options: TTextWriterWriteObjectOptions);
begin
  Add('"');
  if fInternalJSONWriter=nil then
    fInternalJSONWriter := TJSONSerializer.CreateOwnedStream else
    fInternalJSONWriter.CancelAll;
  fInternalJSONWriter.WriteObject(Value,Options);
  AddJSONEscape(Pointer(fInternalJSONWriter.Text),0);
  Add('"');
end;

procedure TJSONSerializer.AddTypedJSON(aTypeInfo: pointer; var aValue);
var i: integer;
    PS: PShortString;
begin
  if aTypeInfo=nil then
  case PTypeInfo(aTypeInfo)^.Kind of
  tkSet: begin
    Add('(');
    with PTypeInfo(aTypeInfo)^.SetEnumType^ do begin
      PS := @NameList;
      for i := MinValue to MaxValue do begin
        if GetBit(aValue,i) then begin
          AddShort(PS^);
          Add(',');
        end;
        inc(PtrUInt(PS),ord(PS^[0])+1);
      end;
    end;
    CancelLastComma;
    Add(')');
  end;
  {$ifdef PUREPASCAL}
  tkEnumeration:
    AddShort(PTypeInfo(aTypeInfo)^.EnumBaseType^.GetEnumName(aValue)^);
  {$endif}
  else
    inherited; // handle other types
  end else
    AddShort('null');
end;


{ TSQLVirtualTableModule }

constructor TSQLVirtualTableModule.Create(aTableClass: TSQLVirtualTableClass;
  aServer: TSQLRestServer);
begin
  fTableClass := aTableClass;
  fServer := aServer;
  fTableClass.GetTableModuleProperties(fFeatures);
  fModuleName := fTableClass.ModuleName;
  if fFeatures.FileExtension='' then // default extension is the module name 
    fFeatures.FileExtension := UTF8ToString(LowerCase(fModuleName));
end;

function TSQLVirtualTableModule.FileName(const aTableName: RawUTF8): TFileName;
begin
  result := UTF8ToString(aTableName)+'.'+FileExtension;;
  if fFilePath='' then
    result := ExtractFilePath(paramstr(0))+result else
    result := IncludeTrailingPathDelimiter(fFilePath)+result;
end;


{ TSQLVirtualTable }

constructor TSQLVirtualTable.Create(aModule: TSQLVirtualTableModule;
  const aTableName: RawUTF8; FieldCount: integer; Fields: PPUTF8CharArray);
var aTable: TSQLRecordClass;
    aTableIndex: integer;
begin
  if (aModule=nil) or (aTableName='') then
    raise EModelException.CreateFmt('Invalid parameters to %s.Create',[ClassName]);
  fModule := aModule;
  fTableName := aTableName;
  if fModule.fFeatures.StaticClass<>nil then
    // create new fStatic instance e.g. for TSQLVirtualTableLog
    if fModule.Server=nil then
      raise EModelException.CreateFmt('Missing aModule.Server for %s.Create',[ClassName]) else
    with fModule.Server do begin
      aTableIndex := Model.GetTableIndex(aTableName);
      if aTableIndex>=0 then begin
        aTable := Model.Tables[aTableIndex];
        fStatic := fModule.fFeatures.StaticClass.Create(aTable,fModule.Server,
          fModule.FileName(aTableName),self.InheritsFrom(TSQLVirtualTableBinary));
        if length(fStaticVirtualTable)<>length(Model.Tables) then
          SetLength(fStaticVirtualTable,length(Model.Tables));
        fStaticVirtualTable[aTableIndex] := fStatic;
      end;
    end;
end;

destructor TSQLVirtualTable.Destroy;
var aTableIndex: cardinal;
begin
  if fStatic<>nil then begin
    if (Module<>nil) and (Module.Server<>nil) then
      with Module.Server do begin
        aTableIndex := Model.GetTableIndex(TableName);
        if aTableIndex<cardinal(length(fStaticVirtualTable)) then begin
          fStaticVirtualTable[aTableIndex] := nil;
          if IsZero(fStaticVirtualTable,length(fStaticVirtualTable)*sizeof(pointer)) then
            SetLength(fStaticVirtualTable,0);
        end;
      end;
    fStatic.Free;
  end;
  inherited;
end;

function TSQLVirtualTable.Prepare(var Prepared: TSQLVirtualTablePrepared): boolean;
begin
  result := Self<>nil;
  if result then
    if (vtWhereIDPrepared in fModule.Features) and
       Prepared.IsWhereIDEquals(true) then
    with Prepared.Where[0] do begin // check ID=?
      Value.VType := varAny; // mark TSQLVirtualTableCursorJSON expects it
      OmitCheck := true;
      Prepared.EstimatedCost := 1;
    end else
      Prepared.EstimatedCost := 1E10; // generic high cost  
end;

function TSQLVirtualTable.Drop: boolean;
begin
  result := false;  // no DROP TABLE to be implemented here
end;

function TSQLVirtualTable.Delete(aRowID: Int64): boolean;
begin
  result := false;  // no DELETE to be implemented here
end;

function TSQLVirtualTable.Insert(aRowID: Int64;
  var Values: TVarDataDynArray; out insertedRowID: Int64): boolean;
begin
  result := false;  // no INSERT to be implemented here
end;

function TSQLVirtualTable.Update(oldRowID, newRowID: Int64;
  var Values: TVarDataDynArray): boolean;
begin
  result := false;  // no UPDATE to be implemented here
end;

function TSQLVirtualTable.Transaction(aState: TSQLVirtualTableTransaction;
  aSavePoint: integer): boolean;
begin
  result := (Module<>nil) and (vtWrite in Module.Features) and
    (aState in [vttBegin, vttSync, vttCommit, vttSavePoint, vttRelease]);
end;

function TSQLVirtualTable.Rename(const NewName: RawUTF8): boolean;
begin
  result := false;
end;

class function TSQLVirtualTable.ModuleName: RawUTF8;
begin
  if self=nil then
    result := '' else begin
    result := RawUTF8(ClassName);
    if IdemPChar(pointer(result),'TSQLVIRTUALTABLE') then
      system.delete(result,1,16) else
    if IdemPChar(pointer(result),'TSQLVIRTUAL') then
      system.delete(result,1,11) else
    if IdemPChar(pointer(result),'TSQL') then
      system.delete(result,1,4) else
      system.delete(result,1,1);
  end;
end;

class function TSQLVirtualTable.StructureFromClass(aClass: TSQLRecordClass;
  const aTableName: RawUTF8): RawUTF8;
begin
  result := FormatUTF8('CREATE TABLE % (%',[aTableName,
    GetVirtualTableSQLCreate(aClass.RecordProps)]);
end;

function TSQLVirtualTable.Structure: RawUTF8;
begin
  result := '';
  if Self<>nil then
    if Static<>nil then
      // e.g. for TSQLVirtualTableJSON or TSQLVirtualTableExternal
      Result := StructureFromClass(Static.StoredClass,TableName) else
    if (Module<>nil) and (Module.RecordClass<>nil) then
      // e.g. for TSQLVirtualTableLog
      Result := StructureFromClass(Module.RecordClass,TableName);
end;


{ TSQLVirtualTableCursor }

constructor TSQLVirtualTableCursor.Create(aTable: TSQLVirtualTable);
begin
  fTable := aTable;
end;

procedure TSQLVirtualTableCursor.SetColumn(var aResult: TVarData;
  aValue: Int64);
begin
  aResult.VType := varInt64;
  aResult.VInt64 := aValue;
end;

procedure TSQLVirtualTableCursor.SetColumn(var aResult: TVarData;
  const aValue: double);
begin
  aResult.VType := varDouble;
  aResult.VDouble := aValue;
end;

procedure TSQLVirtualTableCursor.SetColumn(var aResult: TVarData;
  const aValue: RawUTF8);
begin
  aResult.VType := varString;
  fColumnTemp := aValue; // temporary copy available until next Column() call
  aResult.VString := pointer(fColumnTemp);
end;

procedure TSQLVirtualTableCursor.SetColumn(var aResult: TVarData;
  aValue: PUTF8Char; aValueLength: integer);
begin
  aResult.VType := varString;
  SetString(fColumnTemp,PAnsiChar(aValue),aValueLength); // temporary copy 
  aResult.VString := pointer(fColumnTemp);
end;

procedure TSQLVirtualTableCursor.SetColumnBlob(var aResult: TVarData;
  aValue: pointer; aValueLength: integer);
begin
  aResult.VType := varAny;
  SetString(fColumnTemp,PAnsiChar(aValue),aValueLength); // temporary copy
  aResult.VPointer := pointer(fColumnTemp);
  aResult.VLongs[0] := aValueLength;
end;


{ TSQLLog }

procedure TSQLLog.CreateLogWriter;
begin
  if integer(fFamily.EchoToConsole)=0 then // force fWriter=TTextWriterEcho
    fWriter := TJSONSerializer.Create(nil,fFamily.BufferSize);
  inherited CreateLogWriter;
  fWriter.Stream := fWriterStream;
end;



{ TSQLVirtualTableCursorIndex }

function TSQLVirtualTableCursorIndex.HasData: boolean;
begin
  result := (self<>nil) and (fCurrent<=fMax);
end;

function TSQLVirtualTableCursorIndex.Next: boolean;
begin
  if self=nil then
    result := false else begin
    if fCurrent<=fMax then
      inc(fCurrent);
    result := true;
  end;
end;

function TSQLVirtualTableCursorIndex.Search(
  const Prepared: TSQLVirtualTablePrepared): boolean;
begin
  fCurrent := 0; // mark EOF by default
  fMax := -1;
  result := self<>nil;
end;


{ TSQLVirtualTablePrepared }

function TSQLVirtualTablePrepared.IsWhereIDEquals(CalledFromPrepare: Boolean): boolean;
begin
  result := (WhereCount=1) and (Where[0].Column=VIRTUAL_TABLE_ROWID_COLUMN) and
     (CalledFromPrepare or (Where[0].Value.VType=varInt64)) and
     (Where[0].Operation=soEqualTo);
end;

function TSQLVirtualTablePrepared.IsWhereOneFieldEquals: boolean;
begin
  result := (WhereCount=1) and (Where[0].Column>=0) and
     (Where[0].Operation=soEqualTo);
end;


{ TSQLVirtualTableJSON }


function TSQLVirtualTableJSON.Delete(aRowID: Int64): boolean;
begin
  result := (self<>nil) and (Static<>nil) and
            Static.Delete(Static.StoredClass,aRowID);
  if result and (Static.Owner<>nil) then
    Static.Owner.fCache.NotifyDeletion(Static.StoredClass,aRowID);
end;

function TSQLVirtualTableJSON.Drop: boolean;
begin
  if (self<>nil) and (Static<>nil) then
  with Static as TSQLRestServerStaticInMemory do begin
    RollBack(0); // close any pending transaction
    fValue.Clear;
    Modified := true; // force update file after clear
    UpdateFile;
    result := true;
  end else
    result := false;
end;

class procedure TSQLVirtualTableJSON.GetTableModuleProperties(
  var aProperties: TVirtualTableModuleProperties);
begin
  aProperties.Features := [vtWrite,vtWhereIDPrepared];
  aProperties.CursorClass := TSQLVirtualTableCursorJSON;
  aProperties.StaticClass := TSQLRestServerStaticInMemoryExternal; // will flush Cache
  if InheritsFrom(TSQLVirtualTableBinary) then
    aProperties.FileExtension := 'data';
  // default will follow the class name, e.g. '.json' for TSQLVirtualTableJSON
end;

function TSQLVirtualTableJSON.Insert(aRowID: Int64;
  var Values: TVarDataDynArray; out insertedRowID: Int64): boolean;
var aRecord: TSQLRecord;
begin
  result := false;
  if (self=nil) or (Static=nil) then
    exit;
  aRecord := Static.StoredClass.Create;
  try
    if aRecord.SetFieldVarDatas(Values) then begin
      if aRowID>0 then
        aRecord.fID := aRowID;
      insertedRowID := (Static as TSQLRestServerStaticInMemory).AddOne(aRecord,aRowID>0);
      if insertedRowID>0 then begin
        if Static.Owner<>nil then
          Static.Owner.fCache.Notify(aRecord,soInsert);
        result := true;
      end;
    end;
  finally
    if not result then
      aRecord.Free; // on success, aRecord will stay in Values[]
  end;
end;

function TSQLVirtualTableJSON.Prepare(var Prepared: TSQLVirtualTablePrepared): boolean;
begin
  result := inherited Prepare(Prepared); // optimize ID=? WHERE clause
  if result and (Static<>nil) then
  with Static as TSQLRestServerStaticInMemory do begin
    if Prepared.IsWhereOneFieldEquals then
    with Prepared.Where[0] do
    if UniqueFieldHash(Column)<>nil then begin
      Value.VType := varAny; // mark TSQLVirtualTableCursorJSON expects it
      OmitCheck := true;
      Prepared.EstimatedCost := 1; 
    end;
    if Prepared.EstimatedCost>1E9 then
      Prepared.EstimatedCost := Count;
    if fIDSorted and (Prepared.OrderByCount=1) then // check ascending IDs
      with Prepared.OrderBy[0] do
        if (Column=VIRTUAL_TABLE_ROWID_COLUMN) and not Desc then
          Prepared.OmitOrderBy := true;
  end;
end;

function TSQLVirtualTableJSON.Update(oldRowID, newRowID: Int64;
  var Values: TVarDataDynArray): boolean;
var i: integer;
begin
  result := false;
  if (self=nil) or (Static=nil) or
     (oldRowID<>newRowID) or (newRowID<=0) then // don't allow ID change
    exit;
  with Static as TSQLRestServerStaticInMemory do
    if UpdateOne(newRowID,Values) then begin
      if Static.Owner<>nil then begin
        i := IDToIndex(newRowID);
        if i>=0 then
          Static.Owner.fCache.Notify(TSQLRecord(fValue.List[i]),soUpdate);
      end;
      result := true;
    end;
end;


{ TSQLVirtualTableCursorJSON }

function TSQLVirtualTableCursorJSON.Column(aColumn: integer;
  var aResult: TVarData): boolean;
var Static: TSQLRestServerStaticInMemory;
begin
  if (self=nil) or (fCurrent>fMax) or
     (TSQLVirtualTableJSON(Table).Static=nil) then begin
    result := false;
    exit;
  end;
  Static := TSQLRestServerStaticInMemory(TSQLVirtualTableJSON(Table).Static);
  if Cardinal(fCurrent)>=Cardinal(Static.fValue.Count) then
    result := False else begin
    if aColumn=VIRTUAL_TABLE_ROWID_COLUMN then begin
      aResult.VType := varInt64;
      aResult.VInt64 := TSQLRecord(Static.fValue.List[fCurrent]).fID;
    end else
    with Static.fStoredClassRecordProps.Fields do
      if cardinal(aColumn)>=cardinal(Count) then
        aResult.VType := varNull else
        List[aColumn].GetFieldVarData(Static.fValue.List[fCurrent],aResult,fColumnTemp);
    result := true;
  end;
end;

function TSQLVirtualTableCursorJSON.Search(
  const Prepared: TSQLVirtualTablePrepared): boolean;
var Hash: TListFieldHash;
begin
  result := inherited Search(Prepared); // mark EOF by default
  if (not result) or (not Table.InheritsFrom(TSQLVirtualTableJSON)) or
     (TSQLVirtualTableJSON(Table).Static=nil) then
    result := false else
    with TSQLRestServerStaticInMemory(TSQLVirtualTableJSON(Table).Static) do begin
      if Count>0 then // if something to search in
        if Prepared.IsWhereIDEquals(false) then begin // ID=?
          fMax := IDToIndex(Prepared.Where[0].Value.VInt64); // binary search
          if fMax>=0 then
            fCurrent := fMax; // ID found
        end else
        if Prepared.IsWhereOneFieldEquals then
        with Prepared.Where[0] do begin
          Hash := UniqueFieldHash(Column); // optimized hash-based search
          if Hash<>nil then begin
            fStoredClassRecordProps.Fields.List[Column].SetFieldVarData(fSearchRec,Value);
            fMax := Hash.Find(fSearchRec);
            if fMax>=0 then
              fCurrent := fMax; // value found with O(1) search
          end else
           fMax := Count-1; // loop all records in ID order
        end else
          fMax := Count-1; // loop all records in ID order
      result := true; // no DB error
    end;
end;


{ TSQLVirtualTableLog }

type
  {/ Record associated to Virtual Table implemented in Delphi, for Read/Only
    access to a .log file, as created by TSynLog
   - not used as real instances, but only used by the TSQLVirtualTableLog module
     to provide the field layout needed to create the column layout for the
     CREATE TABLE statement }
  TSQLRecordLogFile = class(TSQLRecordVirtualTableAutoID)
  protected
    fContent: RawUTF8;
    fDateTime: TDateTime;
    fLevel: TSynLogInfo;
  published
    /// the log event time stamp
    property DateTime: TDateTime read fDateTime;
    /// the log event level
    property Level: TSynLogInfo read fLevel;
    /// the textual message associated to the log event
    property Content: RawUTF8 read fContent;
  end;


constructor TSQLVirtualTableLog.Create(aModule: TSQLVirtualTableModule;
  const aTableName: RawUTF8; FieldCount: integer; Fields: PPUTF8CharArray);
var aFileName: TFileName;
begin
  inherited Create(aModule,aTableName,Fieldcount,Fields); 
  if (FieldCount=1) then
    aFileName := UTF8ToString(Fields[0]) else
    aFileName := aModule.FileName(aTableName);
  fLogFile := TSynLogFile.Create(aFileName);
end;

destructor TSQLVirtualTableLog.Destroy;
begin
  fLogFile.Free;
  inherited;
end;

class procedure TSQLVirtualTableLog.GetTableModuleProperties(
  var aProperties: TVirtualTableModuleProperties);
begin
  aProperties.Features := [vtWhereIDPrepared];
  aProperties.CursorClass := TSQLVirtualTableCursorLog;
  aProperties.RecordClass := TSQLRecordLogFile;
end;


{ TSQLVirtualTableCursorLog }

function TSQLVirtualTableCursorLog.Column(aColumn: integer;
  var aResult: TVarData): boolean;
var LogFile: TSynLogFile;
begin
  result := false;
  if (self=nil) or (fCurrent>fMax) then
    exit;
  LogFile := TSQLVirtualTableLog(Table).fLogFile;
  if LogFile=nil then
    exit;
  case aColumn of
   -1: SetColumn(aResult,fCurrent+1); // ID = row index + 1
    0: SetColumn(aResult,LogFile.EventDateTime(fCurrent));
    1: SetColumn(aResult,ord(LogFile.EventLevel[fCurrent]));
    2: SetColumn(aResult,LogFile.LinePointers[fCurrent],LogFile.LineSize(fCurrent));
    else exit;
  end;
  result := true;
end;

function TSQLVirtualTableCursorLog.Search(
  const Prepared: TSQLVirtualTablePrepared): boolean;
begin
  result := inherited Search(Prepared); // mark EOF by default
  if result then begin
    fMax := TSQLVirtualTableLog(Table).fLogFile.Count-1; // search all range
    if Prepared.IsWhereIDEquals(false) then begin
      fCurrent := Prepared.Where[0].Value.VInt64-1; // ID=? -> index := ID-1
      if cardinal(fCurrent)<=cardinal(fMax) then
        fMax := fCurrent else // found one
        fMax := fCurrent-1;   // out of range ID
    end;
  end;
end;


{ TAuthSession }

constructor TAuthSession.Create(aServer: TSQLRestServer; aUser: TSQLAuthUser;
  aContext: PSQLRestServerURIParams);
var GID: TSQLAuthGroup;
begin
  fUser := aUser;
  if (aServer<>nil) and (User<>nil) and (User.fID<>0) then begin
    GID := User.GroupRights; // save pseudo TSQLAuthGroup = ID
    User.GroupRights := TSQLAuthGroup.Create(aServer,User.GroupRights);
    if User.GroupRights.fID<>0 then begin
      // compute the next Session ID
      if aServer.fSessionCounter>=cardinal(maxInt) then
        aServer.fSessionCounter := 10 else
        if aServer.fSessionCounter=76 then // avoid IDCardinal=0 (77) or 1 (76)
          aServer.fSessionCounter := 78 else
          inc(aServer.fSessionCounter);
      fIDCardinal := aServer.fSessionCounter xor 77;
      fID := UInt32ToUtf8(fIDCardinal);
      // set session parameters
      fTimeOut := User.GroupRights.SessionTimeout*(1000*60); // min to ms
      fAccessRights := User.GroupRights.SQLAccessRights;
      fPrivateKey := SHA256(NowToString+fID);
      fPrivateSalt := fID+'+'+fPrivateKey;
      fPrivateSaltHash :=
        crc32(crc32(0,pointer(fPrivateSalt),length(fPrivateSalt)),
          pointer(User.PasswordHashHexa),length(User.PasswordHashHexa));
      fLastAccess := GetTickCount;
      aServer.RetrieveBlob(TSQLAuthUser,User.fID,'Data',User.fData); 
      if (aContext<>nil) and (aContext.InHead<>'') then begin
        fSentHeaders := aContext.InHead;
        fRemoteIP := FindIniNameValue(pointer(fSentHeaders),'REMOTEIP: ');
        fConnectionID := FindIniNameValue(pointer(fSentHeaders),'CONNECTIONID: ');
      end;
      {$ifdef WITHLOG}
      SQLite3Log.Family.SynLog.Log(sllUserAuth,
        'New "%" session %/% created at %/% running %',
        [User.GroupRights.Ident,User.LogonName,fIDCardinal,fRemoteIP,fConnectionID,
         FindIniNameValue(pointer(fSentHeaders),'USER-AGENT: ')],self);
      {$endif}
      exit; // create successfull
    end;
    // on error: set GroupRights back to a pseudo TSQLAuthGroup = ID
    User.GroupRights.Free;
    User.GroupRights := GID;
  end;
  raise ESecurityException.Create('TAuthSession.Create');
end;

destructor TAuthSession.Destroy;
begin
  if User<>nil then begin
    User.GroupRights.Free;
    fUser.Free;
  end;
  inherited;
end;

function TAuthSession.IsValidURL(const aURL: RawUTF8; aURLlength: integer): boolean;
// expected format is 'session_signature='Hexa8(SessionID)+Hexa8(TimeStamp)+
// Hexa8(crc32('SessionID+HexaSessionPrivateKey'+Sha256('salt'+PassWord)+
//  Hexa8(TimeStamp)+url))
var aTimeStamp, aSignature: cardinal;
    PTimeStamp: PAnsiChar;
begin
  PTimeStamp := @aURL[aURLLength+(20+8)]; // P^ points to Hexa8(TimeStamp)
  result := (self<>nil) and
     HexDisplayToCardinal(PTimeStamp,aTimeStamp) and
     (aTimeStamp>=fLastTimeStamp) and // check time stamp coherency
     HexDisplayToCardinal(PTimeStamp+8,aSignature) and
     (crc32(crc32(fPrivateSaltHash,PTimeStamp,8),pointer(aURL),aURLlength)=aSignature);
  if result then
    fLastTimeStamp := aTimeStamp;
end;



{ TSQLAccessRights }

procedure TSQLAccessRights.Edit(aTableIndex: integer; C, R, U, D: Boolean);
begin
  if C then
    Include(POST,aTableIndex) else
    Exclude(POST,aTableindex);
  if R then
    Include(GET,aTableIndex) else
    Exclude(GET,aTableindex);
  if U then
    Include(PUT,aTableIndex) else
    Exclude(PUT,aTableindex);
  if D then
    Include(DELETE,aTableIndex) else
    Exclude(DELETE,aTableindex);
end;

procedure TSQLAccessRights.Edit(aTableIndex: integer; aRights: TSQLOccasions);
begin
  if soInsert in aRights then
    Include(POST,aTableIndex) else
    Exclude(POST,aTableindex);
  if soSelect in aRights then
    Include(GET,aTableIndex) else
    Exclude(GET,aTableindex);
  if soUpdate in aRights then
    Include(PUT,aTableIndex) else
    Exclude(PUT,aTableindex);
  if soDelete in aRights then
    Include(DELETE,aTableIndex) else
    Exclude(DELETE,aTableindex);
end;

procedure TSQLAccessRights.FromString(P: PUTF8Char);
begin
  fillchar(self,sizeof(self),0);
  if P=nil then
    exit;
  AllowRemoteExecute := TSQLAllowRemoteExecute(byte(GetNextItemCardinal(P)));
  SetBitCSV(GET,MAX_SQLTABLES,P);
  SetBitCSV(POST,MAX_SQLTABLES,P);
  SetBitCSV(PUT,MAX_SQLTABLES,P);
  SetBitCSV(DELETE,MAX_SQLTABLES,P);
end;

function TSQLAccessRights.ToString: RawUTF8;
begin
  result := FormatUTF8('%,%,%,%,%',
    [Byte(AllowRemoteExecute),
     GetBitCSV(GET,MAX_SQLTABLES), GetBitCSV(POST,MAX_SQLTABLES),
     GetBitCSV(PUT,MAX_SQLTABLES), GetBitCSV(DELETE,MAX_SQLTABLES)]);
end;


{ TSQLAuthGroup }

function TSQLAuthGroup.GetSQLAccessRights: TSQLAccessRights;
begin
  if self=nil then
    fillchar(result,sizeof(result),0) else
    result.FromString(pointer(AccessRights));
end;

class procedure TSQLAuthGroup.InitializeTable(Server: TSQLRestServer;
  const FieldName: RawUTF8);
var G: TSQLAuthGroup;
    A: TSQLAccessRights;
    U: TSQLAuthUser;
    AdminID, SupervisorID, UserID: PtrInt;
begin
  inherited; // will create any needed index
  if (Server<>nil) and (FieldName='') then
    if Server.HandleAuthentication then begin
      // create default Groups and Users (we are already in a Transaction) 
      G := TSQLAuthGroup.Create;
      try
        //            POST SQL  Service Auth R  Auth W  Tables R  Tables W
        // Admin        Yes       Yes    Yes     Yes      Yes      Yes
        // Supervisor   No        Yes    Yes     No       Yes      Yes
        // User         No        Yes    No      No       Yes      Yes
        // Guest        No        No     No      No       Yes      No
        A := FULL_ACCESS_RIGHTS;
        G.Ident := 'Admin';
        G.SQLAccessRights := A;
        G.SessionTimeout := 10;
        AdminID := Server.Add(G,true);
        G.Ident := 'Supervisor';
        A.AllowRemoteExecute := SUPERVISOR_ACCESS_RIGHTS.AllowRemoteExecute;
        A.Edit(Server.fAuthUserIndex,[soSelect]); // AuthUser  R/O
        A.Edit(Server.fAuthGroupIndex,[soSelect]); // AuthGroup R/O
        G.SQLAccessRights := A;
        G.SessionTimeout := 60;
        SupervisorID := Server.Add(G,true);
        G.Ident := 'User';
        Exclude(A.GET,Server.fAuthUserIndex); // no Auth R
        Exclude(A.GET,Server.fAuthGroupIndex);
        G.SQLAccessRights := A;
        G.SessionTimeout := 60;
        UserID := Server.Add(G,true);
        G.Ident := 'Guest';
        A.AllowRemoteExecute := [];
        fillchar(A.POST,sizeof(TSQLFieldTables),0); // R/O access
        fillchar(A.PUT,sizeof(TSQLFieldTables),0);
        fillchar(A.DELETE,sizeof(TSQLFieldTables),0);
        G.SQLAccessRights := A;
        G.SessionTimeout := 60;
        Server.Add(G,true);
      finally
        G.Free;
      end;
      U := TSQLAuthUser.Create;
      try
        U.LogonName := 'Admin';
        U.PasswordPlain := 'synopse';
        U.DisplayName := U.LogonName;
        U.GroupRights := TSQLAuthGroup(AdminID);
        Server.Add(U,true);
        U.LogonName := 'Supervisor';
        U.DisplayName := U.LogonName;
        U.GroupRights := TSQLAuthGroup(SupervisorID);
        Server.Add(U,true);
        U.LogonName := 'User';
        U.DisplayName := U.LogonName;
        U.GroupRights := TSQLAuthGroup(UserID);
        Server.Add(U,true);
      finally
        U.Free;
      end;
    end;
end;

procedure TSQLAuthGroup.SetSQLAccessRights(const Value: TSQLAccessRights);
begin
  if self<>nil then
    AccessRights := Value.ToString;
end;


{ TSQLAuthUser }

procedure TSQLAuthUser.SetPasswordPlain(const Value: RawUTF8);
begin
  if self<>nil then
    PasswordHashHexa := SHA256('salt'+Value);
end;


{ TServiceContainer }

type
  PInterfaceTypeData = ^TInterfaceTypeData;
  TInterfaceTypeData = packed record
    IntfParent : PPTypeInfo; // ancestor
    IntfFlags : set of (ifHasGuid, ifDispInterface, ifDispatch);
    IntfGuid : TGUID;
    IntfUnit : ShortString;
  end;

  TMethodKind = (mkProcedure, mkFunction, mkConstructor, mkDestructor,
    mkClassProcedure, mkClassFunction, { Obsolete } mkSafeProcedure, mkSafeFunction);

  TIntfMethodEntryTail = packed record
    Kind: TMethodKind;
    CC: TCallingConvention;
    ParamCount: Byte;
  end;

function TServiceContainer.AddInterface(
  const aInterfaces: array of PTypeInfo; aInstanceCreation: TServiceInstanceImplementation;
  aContractExpected: RawUTF8): boolean;
var i: integer;
    F: TServiceFactoryClient;
begin
  result := false;
  if (self=nil) or (high(aInterfaces)<0) then
    exit;
  CheckInterface(aInterfaces);
  for i := 0 to high(aInterfaces) do begin
    F := TServiceFactoryClient.Create(
      Rest,aInterfaces[i],aInstanceCreation,aContractExpected);
    AddServiceInternal(F);
    aContractExpected := ''; // supplied contract is only for the 1st interface
  end;
  result := true;
end;

function TServiceContainer.AddInterface(aInterface: PTypeInfo;
  aInstanceCreation: TServiceInstanceImplementation;
  const aContractExpected: RawUTF8=''): TServiceFactoryClient;
begin
  CheckInterface([aInterface]);
  result := TServiceFactoryClient.Create(Rest,aInterface,aInstanceCreation,aContractExpected);
  AddServiceInternal(result);
end;

function TServiceContainer.Count: integer;
begin
  if self=nil then
    result := 0 else
    result := fList.Count;
end;

constructor TServiceContainer.Create(aRest: TSQLRest);
begin
  fRest := aRest;
  fList := TRawUTF8ListHashed.Create;
  fList.CaseInsensitive := true;
  fListInterfaceMethod := TRawUTF8ListHashed.Create;
  fListInterfaceMethod.CaseInsensitive := true;
end;

destructor TServiceContainer.Destroy;
var i: integer;
begin
  for i := 0 to fList.Count-1 do
    fList.Objects[i].Free;
  fList.Free;
  fListInterfaceMethod.Free;
  inherited;
end;

function TServiceContainer.AddServiceInternal(aService: TServiceFactory): integer;
var aURI: RawUTF8;
    internal: TServiceInternalMethod;
    m: Integer;
begin
  if (self=nil) or (aService=nil) then
    result := 0 else
  with aService do begin
    // add service factory
    if ExpectMangledURI then
      aURI := fInterfaceMangledURI else
      aURI := fInterfaceURI;
    result := fList.AddObject(aURI,aService);
    // add associated methods
    aURI := aURI+'.';
    for internal := Low(TServiceInternalMethod) to High(TServiceInternalMethod) do
      fListInterfaceMethod.AddObject(aURI+SERVICE_PSEUDO_METHOD[internal],
        pointer(ord(internal) shl 16+result));
    for m := 0 to fInterface.fMethodsCount-1 do
      fListInterfaceMethod.AddObject(aURI+fInterface.fMethods[m].URI,
        pointer((m+length(SERVICE_PSEUDO_METHOD)) shl 16+result));
  end;
end;

procedure TServiceContainer.CheckInterface(const aInterfaces: array of PTypeInfo);
var i: integer;
begin
  for i := 0 to high(aInterfaces) do
    if aInterfaces[i]=nil then
      raise EServiceException.Create('Supplied a nil interface type') else
    with aInterfaces[i]^, PInterfaceTypeData(ClassType)^ do
    if Kind<>tkInterface then
      raise EServiceException.CreateFmt('%s is not an interface',[Name]) else
    if not (ifHasGuid in IntfFlags) then
      raise EServiceException.CreateFmt('%s interface has no GUID',[Name]) else
    if Guid(IntfGuid)<>nil then
      raise EServiceException.CreateFmt('%s GUID already registered',[Name]);
end;

procedure TServiceContainer.SetExpectMangledURI(aValue: Boolean);
var f: Integer;
    Fac: array of TServiceFactory;
begin
  if aValue=fExpectMangledURI then
    exit;
  fExpectMangledURI := aValue;
  fList.CaseInsensitive := not aValue;
  fListInterfaceMethod.CaseInsensitive := not aValue;
  SetLength(Fac,fList.Count);
  for f := 0 to fList.Count-1 do
    Fac[f] := fList.Objects[f] as TServiceFactory;
  fList.Clear;
  fListInterfaceMethod.Clear;
  for f := 0 to High(Fac) do
    AddServiceInternal(Fac[f]);
end;

function TServiceContainer.GetService(const aURI: RawUTF8): TServiceFactory;
var i: Integer;
begin
  if (self<>nil) and (aURI<>'') then begin
    i := fList.IndexOf(aURI);
    if i>=0 then
      result := TServiceFactory(fList.Objects[i]) else
      result := nil;
  end else
    result := nil;
end;

function TServiceContainer.Info(aTypeInfo: PTypeInfo): TServiceFactory;
var i: Integer;
    Obj: PPointerArray;
begin
  if self<>nil then begin
    Obj := fList.ObjectPtr;
    for i := 0 to fList.Count-1 do begin
      result := Obj[i];
      if result.fInterface.fInterfaceTypeInfo=aTypeInfo then
        exit;
    end;
  end;
  result := nil;
end;

function TServiceContainer.Index(aIndex: integer): TServiceFactory;
begin
  if Self=nil then
    result := nil else
    result := TServiceFactory(fList.Objects[aIndex]);
end;

function IsEqualGUID(const guid1, guid2: TGUID): Boolean; {$ifdef HASINLINE}inline;{$endif}
{$ifdef CPU64}
var a: array[0..1] of Int64 absolute guid1;
    b: array[0..1] of Int64 absolute guid2;
{$else}
var a: array[0..3] of integer absolute guid1;
    b: array[0..3] of integer absolute guid2;
{$endif}
begin // faster implementation than in SysUtils.pas
{$ifdef CPU64}
  Result := (a[0]=b[0]) and (a[1]=b[1]);
{$else}
  Result := (a[0]=b[0]) and (a[1]=b[1]) and (a[2]=b[2]) and (a[3]=b[3]);
{$endif}
end;

function TServiceContainer.GUID(const aGUID: TGUID): TServiceFactory;
var i: Integer;
    Obj: PPointerArray;
begin
  if self<>nil then begin
    Obj := fList.ObjectPtr;
    for i := 0 to fList.Count-1 do begin
      result := Obj[i];
      if IsEqualGUID(result.InterfaceIID,aGUID) then
        exit;
    end;
  end;
  result := nil;
end;


{ TInterfacedObjectFake (private class for TInterfaceFactory.CreateFakeInstance) }

// see http://docwiki.embarcadero.com/RADStudio/en/Program_Control
const
  // this is used to avoid creating dynamic arrays if not needed
  MAX_METHOD_ARGS = 32;

  // QueryInterface, _AddRef and _Release methods are hard-coded
  RESERVED_VTABLE_SLOTS = 3;

  {$ifdef CPU64}
  
  // maximum stack size at method execution must match .PARAMS 64 (minus 4 regs)
  MAX_EXECSTACK = 60*8;

  REGRCX = 1;
  REGRDX = 2;
  REGR8 = 3;
  REGR9 = 4;
  REGXMM0 = 1;
  REGXMM1 = 2;
  REGXMM2 = 3;
  REGXMM3 = 4;
  REG_FIRST = REGRCX;
  REG_LAST = REGR9;

  {$else}

  // maximum stack size at method execution
  MAX_EXECSTACK = 1024;

  REGEAX = 1;
  REGEDX = 2;
  REGECX = 3;
  REG_FIRST = REGEAX;
  REG_LAST = REGECX;

  {$endif CPU64}

  PTRSIZ = sizeof(Pointer);

  STACKOFFSET_NONE = -1;

  // ordinal values are stored within 64 bit buffer, and records in a RawUTF8
  CONST_ARGS_TO_VAR: array[TServiceMethodValueType] of TServiceMethodValueVar = (
    smvvNone, smvvSelf, smvv64, smvv64, smvv64, smvv64, smvv64, smvv64, smvv64,
    smvv64, smvv64,
    smvvRawUTF8, smvvString, smvvWideString, smvvRecord,
    {$ifdef USEVARIANTS}smvvRecord,{$endif} smvvObject, smvvRawUTF8, smvvDynArray);

  {$ifdef CPU64}
  CONST_STOREDINXMM: TServiceMethodValueTypes = [smvDouble, smvDateTime];
  {$else}
  // always 8 or x64
  CONST_ARGS_IN_STACK_SIZE: array[TServiceMethodValueType] of Cardinal = (
     0,  PTRSIZ,PTRSIZ, PTRSIZ,PTRSIZ,PTRSIZ, PTRSIZ,    8,     8,      8,
 // None, Self, Boolean, Enum, Set,  Integer, Cardinal, Int64, Double, DateTime,
     8,       PTRSIZ,  PTRSIZ, PTRSIZ,     PTRSIZ, {$ifdef USEVARIANTS}PTRSIZ,{$endif}
 // Currency, RawUTF8, String, WideString, Record,  Variant,
    PTRSIZ, PTRSIZ,  PTRSIZ);
 // Object, RawJSON, DynArray
   {$endif}

  CONST_ARGS_RESULT_BY_REF: TServiceMethodValueTypes = [
    smvRawUTF8, smvRawJSON, smvString, smvWideString, smvRecord,
    {$ifdef USEVARIANTS}smvVariant,{$endif} smvDynArray];

  CONST_PSEUDO_RESULT_NAME: string[6] = 'Result';

type
  /// map the stack memory layout at TInterfacedObjectFake.FakeCall()
  TFakeCallStack = packed record
    {$ifdef CPU64}
    XMM1, XMM2, XMM3: double;
    MethodIndex: PtrUInt;
    Frame, Ret: pointer;
    RCX, RDX, R8, R9: pointer;
    {$else}
    EDX, ECX, MethodIndex, EBP, Ret: Cardinal;
    {$endif}
    Stack: array[word] of byte;
  end;

  /// instances of this class will emulate a given interface
  TInterfacedObjectFake = class(TInterfacedObject)
  protected
    fVTable: PPointerArray;
    fFactory: TInterfaceFactory;
    fInvoke: TOnFakeInstanceInvoke;
    fNotifyDestroy: TOnFakeInstanceDestroy;
    fClientDrivenID: Cardinal;
    function FakeCall(var aCall: TFakeCallStack): Int64;
    function FakeQueryInterface(const IID: TGUID; out Obj): HResult; stdcall;
    function Fake_AddRef: Integer; stdcall;
    function Fake_Release: Integer; stdcall;
    function SelfFromInterface: TInterfacedObjectFake;
      {$ifdef PUREPASCAL} {$ifdef HASINLINE}inline;{$endif} {$endif}
  public
    /// create an instance, using the specified interface
    constructor Create(aFactory: TInterfaceFactory;
      aInvoke: TOnFakeInstanceInvoke; aNotifyDestroy: TOnFakeInstanceDestroy);
    /// release the remote server instance (in sicClientDriven mode);
    destructor Destroy; override;
    /// the ID used in sicClientDriven mode
    property ClientDrivenID: Cardinal read fClientDrivenID;
  end;

  EInterfaceStub = class(EInterfaceFactoryException)
  public
    constructor Create(Sender: TInterfaceStub; const Method: TServiceMethod;
      const Error: string); overload;
    constructor Create(Sender: TInterfaceStub; const Method: TServiceMethod;
      const Format: string; const Args: array of const); overload;
  end;


constructor TInterfacedObjectFake.Create(aFactory: TInterfaceFactory;
  aInvoke: TOnFakeInstanceInvoke; aNotifyDestroy: TOnFakeInstanceDestroy);
begin
  inherited Create;
  fFactory := aFactory;
  fVTable := aFactory.GetMethodsVirtualTable;
  fInvoke := aInvoke;
  fNotifyDestroy := aNotifyDestroy;
end;

destructor TInterfacedObjectFake.Destroy;
var C: TClass;
begin
  if Assigned(fNotifyDestroy) then
  try // release server instance
    fNotifyDestroy(fClientDrivenID);
  except
    on E: Exception do begin
      C := E.ClassType;
      if (C=EInterfaceStub) or (C=EInterfaceFactoryException) or
         (C=EAccessViolation) {$IFNDEF  LVCL}or (C=EInvalidPointer){$endif} then
        raise; // ignore all low-level exceptions
    end;
  end;
  inherited;
end;

function TInterfacedObjectFake.SelfFromInterface: TInterfacedObjectFake;
{$ifdef PUREPASCAL}
begin
  result := pointer(PtrInt(self)-PtrInt(@TInterfacedObjectFake(nil).fVTable));
end;
{$else}
asm
  sub eax,TInterfacedObjectFake.fVTable
end;
{$endif}

function TInterfacedObjectFake.Fake_AddRef: Integer;
begin
  result := SelfFromInterface._AddRef;
end;

function TInterfacedObjectFake.Fake_Release: Integer;
begin
  result := SelfFromInterface._Release;
end;

function TInterfacedObjectFake.FakeQueryInterface(const IID: TGUID; out Obj): HResult;
begin
  self := SelfFromInterface;
  if IsEqualGUID(IID,fFactory.fInterfaceIID) then begin
    pointer(Obj) := @fVTable;
    _AddRef;
    result := NOERROR;
  end else
  if GetInterface(IID,Obj) then
    result := NOERROR else
    result := E_NOINTERFACE;
end;

procedure ValueAdd(ValueType: TServiceMethodValueType; WR: TTextWriter; V: Pointer;
  SizeInStorage: integer);
begin
  case ValueType of
  smvBoolean:   WR.AddString(JSON_BOOLEAN[PBoolean(V)^]);
  smvEnum..smvInt64:
  case SizeInStorage of
    1: WR.Add(PByte(V)^);
    2: WR.Add(PWord(V)^);
    4: if ValueType=smvInteger then
         WR.Add(PInteger(V)^) else
         WR.AddU(PCardinal(V)^);
    8: WR.Add(PInt64(V)^);
  end;
  smvDouble, smvDateTime: WR.Add(PDouble(V)^);
  smvCurrency:   WR.AddCurr64(PInt64(V));
  smvRawUTF8:    WR.AddJSONEscape(PPointer(V)^);
  smvRawJSON:    WR.AddNoJSONEscape(PPointer(V)^);
  smvString:     {$ifdef UNICODE}
                 WR.AddJSONEscapeW(pointer(PString(V)^));
                 {$else}
                 WR.AddJSONEscapeAnsiString(PString(V)^);
                 {$endif}
  smvWideString: WR.AddJSONEscapeW(PPointer(V)^);
  smvObject:     WR.WriteObject(PPointer(V)^,[]);
  end;
end;

procedure IgnoreComma(var P: PUTF8Char);
begin
  if P^ in [#1..' '] then repeat inc(P) until not(P^ in [#1..' ']);
  if P^=',' then inc(P);
end;

function TInterfacedObjectFake.FakeCall(var aCall: TFakeCallStack): Int64;
var method: ^TServiceMethod;
procedure RaiseError(const Msg: RawUTF8);
begin
  raise EInterfaceFactoryException.CreateFmt('Invalid fake %s.%s interface call: %s',
    [fFactory.fInterfaceTypeInfo^.Name,method^.URI,Msg]);
end;
var resultType: TServiceMethodValueType; // type of value stored into result
procedure InternalProcess;
var Params: TJSONSerializer;
    Error, ResArray: RawUTF8;
    a: integer;
    V: PPointer;
    R, Val: PUTF8Char;
    valid, wasString: boolean;
    ServiceCustomAnswerPoint: PServiceCustomAnswer;
    DynArrays: array[0..MAX_METHOD_ARGS-1] of TDynArray;
    Value: array[0..MAX_METHOD_ARGS-1] of pointer;
    I64s: array[0..MAX_METHOD_ARGS-1] of Int64;
begin
  method := @fFactory.fMethods[aCall.MethodIndex];
  Params := TJSONSerializer.CreateOwnedStream;
  try
    // create the parameters
    FillChar(I64s,method^.ArgsUsedCount[smvv64]*sizeof(Int64),0);
    for a := 0 to high(method^.Args) do
    with method^.Args[a] do
    if ValueType>smvSelf then begin
      case RegisterIdent of
      {$ifdef CPU64}
      REGRCX: RaiseError('unexpected self');
      REGRDX: if ValueType in CONST_STOREDINXMM then
                V := @aCall.XMM1 else
                V := @aCall.RDX;
      REGR8:  if ValueType in CONST_STOREDINXMM then
                V := @aCall.XMM2 else
                V := @aCall.R8;
      REGR9:  if ValueType in CONST_STOREDINXMM then
                V := @aCall.XMM3 else
                V := @aCall.R9;
      {$else}
      REGEAX: begin V := nil; RaiseError('unexpected self'); end;
      REGEDX: V := @aCall.EDX;
      REGECX: V := @aCall.ECX;
      {$endif}
      else if SizeInStack>0 then
        V := @aCall.Stack[InStackOffset] else
        V := @I64s[IndexVar]; // for results in CPU
      end;
      if vPassedByReference in ValueKindAsm then
        V := PPointer(V)^;
      if ValueType=smvDynArray then
        DynArrays[IndexVar].Init(TypeInfo,V^);
      Value[a] := V;
      if ValueDirection in [smdConst, smdVar] then begin
        if vIsString in ValueKindAsm then
          Params.Add('"');
        case ValueType of
        smvRecord:   Params.AddRecordJSON(V^,TypeInfo);
        {$ifdef USEVARIANTS}
        smvVariant:  Params.AddVariantJSON(PVariant(V)^,twJSONEscape);
        {$endif}
        smvDynArray: Params.AddDynArrayJSON(DynArrays[IndexVar]);
        else ValueAdd(ValueType,Params,V,SizeInStorage);
        end;
        if vIsString in ValueKindAsm then
          Params.Add('"',',') else
          Params.Add(',');
      end;
    end;
    Params.CancelLastComma;
    // call remote server or stub implementation
    if method^.ArgsResultIsServiceCustomAnswer then
      ServiceCustomAnswerPoint := Value[method^.ArgsResultIndex] else
      ServiceCustomAnswerPoint := nil;
    if not fInvoke(method^,Params.Text,@ResArray,@Error,@fClientDrivenID,
       ServiceCustomAnswerPoint) then
      RaiseError(Error);
  finally
    Params.Free;
  end;
  // retrieve method result and var/out parameters content
  if ServiceCustomAnswerPoint=nil then begin
    R := pointer(ResArray);
    if R^ in [#1..' '] then repeat inc(R) until not(R^ in [#1..' ']);
    if R^<>'[' then
      RaiseError('JSON array result expected');
    inc(R);
    for a := method^.ArgsOutFirst to method^.ArgsOutLast do
    with method^.Args[a] do
    if ValueDirection in [smdVar,smdOut,smdResult] then begin
      V := Value[a];
      case ValueType of
      smvObject: begin
        R := JSONToObject(V^,R,valid);
        if not valid then
          RaiseError('returned object');
        IgnoreComma(R);
      end;
      smvRawJSON: begin
        Val := R;
        R := GotoNextJSONItem(R);
        if R<=Val then
          RaiseError('incorrect returned RawJSON content');
        SetString(PRawUTF8(V)^,PAnsiChar(Val),R-Val);
      end;
      smvDynArray: begin
        R := DynArrays[IndexVar].LoadFromJSON(R);
        if R=nil then
          RaiseError('returned array');
        IgnoreComma(R);
      end;
      smvBoolean..smvWideString: begin
        Val := GetJSONField(R,R,@wasString);
        if (Val=nil) or (wasString<>(vIsString in ValueKindAsm)) then
          RaiseError('incorrect returned result JSON array (missing or invalid value); '+
            'values shall follow method var/out/result order');
        case ValueType of
        smvBoolean, smvEnum, smvSet, smvCardinal:
          case SizeInStorage of
          1: PByte(V)^     := GetCardinal(Val);
          2: PWord(V)^     := GetCardinal(Val);
          4: PCardinal(V)^ := GetCardinal(Val);
          end;
        smvInteger:    PInteger(V)^ := GetInteger(Val);
        smvInt64:      SetInt64(Val,PInt64(V)^);
        smvDouble,smvDateTime: PDouble(V)^ := GetExtended(Val);
        smvCurrency:   PInt64(V)^   := StrToCurr64(Val);
        smvRawUTF8:    PRawUTF8(V)^ := Val;
        smvString:     UTF8DecodeToString(Val,StrLen(Val),PString(V)^);
        smvWideString: UTF8ToWideString(Val,StrLen(Val),PWideString(V)^);
        else RaiseError('ValueType?');
        end;
      end;
      smvRecord: begin
        R := RecordLoadJSON(V^,R,TypeInfo);
        if R=nil then
          RaiseError('returned record');
      end;
      {$ifdef USEVARIANTS}
      smvVariant: begin
        R := VariantLoadJSON(PVariant(V)^,R);
        if R=nil then
          RaiseError('returned variant');
      end;
      {$endif}
      end;
      if ValueDirection=smdResult then begin
        resultType := ValueType;
        if ValueType in [smvBoolean..smvCurrency] then
          // ordinal/real result values to CPU/FPU registers
          Move(V^,Result,SizeInStorage);
      end;
    end;
  end;
end;
begin
  self := SelfFromInterface;
  if aCall.MethodIndex>=fFactory.fMethodsCount then
    RaiseError('out of range method');
  if not Assigned(fInvoke)then
    RaiseError('missing FakeInterfaceInvoker');
  result := 0;
  resultType := smvNone;
  InternalProcess; // use an inner proc to ensure direct fld/fild FPU ops
  {$ifdef CPU64}
  if resultType in CONST_STOREDINXMM then
    aCall.XMM1 := PDouble(@result)^;
  {$else}
  case resultType of // al/ax/eax/eax:edx already in result
  smvDouble,smvDateTime: asm fld  qword ptr [result] end;  // in st(0)
  smvCurrency:           asm fild qword ptr [result] end;  // in st(0)
  end;
  {$endif}
end;


{ TInterfaceFactory }

function ToText(aValue: TServiceInstanceImplementation): RawUTF8;
begin
  result := GetEnumNameTrimed(TypeInfo(TServiceInstanceImplementation),aValue);
end;

function TypeInfoToMethodValueType(P: PTypeInfo): TServiceMethodValueType;
var IsObjCustomIndex: integer;
begin
  result := smvNone;
  if P<>nil then
  case P^.Kind of
  tkInteger:
    case P^.OrdType of
    otSLong: result := smvInteger;
    otULong: result := smvCardinal;
    end;
  tkInt64{$ifdef FPC}, tkQWord{$endif}:
    result := smvInt64;
  {$ifdef FPC}
  tkBool:
    result := smvBoolean;
  tkEnumeration:
    result := smvEnum;
  {$else}
  tkEnumeration:
    if P=TypeInfo(boolean) then
      result := smvBoolean else
      result := smvEnum;
  {$endif}
  tkSet:
    result := smvSet;
  tkFloat:
    if P=TypeInfo(TDateTime) then
      result := smvDateTime else
    case P^.FloatType of
      ftDouble: result := smvDouble;
      ftCurr:   result := smvCurrency;
    end;
  tkLString:
    if P=TypeInfo(RawUTF8) then
      result := smvRawUTF8 else
    if P=TypeInfo(RawJSON) then
      result := smvRawJSON
{$ifndef UNICODE}
      else result := smvString;
{$else};
  tkUString:
    result := smvString;
{$endif}
  tkWString:
    result := smvWideString;
  tkClass:
    if JSONObject(P^.ClassType^.ClassType,IsObjCustomIndex,[cpRead,cpWrite]) in
       [{$ifndef LVCL}oCollection,{$endif}oObjectList,oUtfs,oStrings,
         oSQLRecord,oSQLMany,oPersistent,oCustom] then
      result := smvObject; // JSONToObject/ObjectToJSON types
  tkRecord:   // Base64 encoding of our RecordLoad / RecordSave binary format
    result := smvRecord;
  {$ifdef USEVARIANTS}
  tkVariant:
    result := smvVariant;
  {$endif}
  tkDynArray: // TDynArray.LoadFromJSON / TTextWriter.AddDynArrayJSON type
    result := smvDynArray;
  end;
end;

var
  InterfaceFactoryCache: TObjectList;
  InterfaceFactoryCacheLock: TRTLCriticalSection; // deleted with process

procedure EnterInterfaceFactoryCache;
begin
  if InterfaceFactoryCache=nil then begin
    InitializeCriticalSection(InterfaceFactoryCacheLock);
    EnterCriticalSection(InterfaceFactoryCacheLock);
    GarbageCollectorFreeAndNil(InterfaceFactoryCache,TObjectList.Create);
  end else
    EnterCriticalSection(InterfaceFactoryCacheLock);
end;

class function TInterfaceFactory.Get(aInterface: PTypeInfo): TInterfaceFactory;
var i: integer;
begin
  EnterInterfaceFactoryCache;
  try
    for i := 0 to InterfaceFactoryCache.Count-1 do begin
      result := InterfaceFactoryCache.List[i];
      if result.fInterfaceTypeInfo=aInterface then
        exit; // retrieved from cache
    end;
    // not existing -> create new instance
    result := TInterfaceFactory.Create(aInterface);
    InterfaceFactoryCache.Add(result);
  finally
    LeaveCriticalSection(InterfaceFactoryCacheLock);
  end;
end;

class procedure TInterfaceFactory.RegisterInterfaces(const aInterfaces: array of PTypeInfo);
var i: integer;
begin
  for i := 0 to high(aInterfaces) do
    Get(aInterfaces[i]);
end;

class function TInterfaceFactory.Get(const aGUID: TGUID): TInterfaceFactory;
var i: integer;
begin
  if InterfaceFactoryCache<>nil then
    for i := 0 to InterfaceFactoryCache.Count-1 do begin
      result := InterfaceFactoryCache.List[i];
      if IsEqualGUID(result.fInterfaceIID,aGUID) then
        exit; // retrieved from cache
    end;
  result := nil;
end;

class function TInterfaceFactory.Get(const aInterfaceName: RawUTF8): TInterfaceFactory;
var L,i: integer;
begin
  L := length(aInterfaceName);
  if (InterfaceFactoryCache<>nil) and (L<>0) then
    for i := 0 to InterfaceFactoryCache.Count-1 do begin
      result := InterfaceFactoryCache.List[i];
      if IdemPropName(result.fInterfaceTypeInfo^.Name,pointer(aInterfaceName),L) then
        exit; // retrieved from cache
    end;
  result := nil;
end;

function TInterfaceFactory.CreateFakeInstance(aInvoke: TOnFakeInstanceInvoke;
  aNotifyDestroy: TOnFakeInstanceDestroy): TInterfacedObject;
begin
  result := TInterfacedObjectFake.Create(self,aInvoke,aNotifyDestroy);
end;

constructor TInterfaceFactory.Create(aInterface: PTypeInfo);
var m,a,reg: integer;
{$ifdef CPU64}
    resultIsRDX: boolean;
{$else}
    offs: integer;
{$endif}
begin
  fInterfaceTypeInfo := aInterface;
  fInterfaceIID := PInterfaceTypeData(aInterface^.ClassType)^.IntfGuid;
  // retrieve all interface methods (recursively including ancestors)
  fMethod.Init(TypeInfo(TServiceMethodDynArray),fMethods,nil,nil,nil,@fMethodsCount,true);
  AddMethodsFromTypeInfo(aInterface);
  if fMethodsCount=0 then
    raise EInterfaceFactoryException.CreateFmt('%s interface has no RTTI',[aInterface^.Name]);
  SetLength(fMethods,fMethodsCount);
  // compute asm low-level layout of the parameters for each method
  for m := 0 to fMethodsCount-1 do
  with fMethods[m] do begin
    // prepare stack and register layout
    reg := REG_FIRST;
    {$ifdef CPU64}
    resultIsRDX := (ArgsResultIndex>=0) and
      (Args[ArgsResultIndex].ValueType in CONST_ARGS_RESULT_BY_REF);
    {$endif}
    for a := 0 to high(Args) do
    with Args[a] do begin
      ValueVar := CONST_ARGS_TO_VAR[ValueType];
      IndexVar := ArgsUsedCount[ValueVar];
      inc(ArgsUsedCount[ValueVar]);
      include(ArgsUsed,ValueType);
      if ValueType in [smvRawUTF8..smvWideString] then
        Include(ValueKindAsm,vIsString);
      if (ValueType in [smvRecord{$ifdef USEVARIANTS},smvVariant{$endif}]) or
         (ValueDirection in [smdVar,smdOut]) or
         ((ValueDirection=smdResult) and (ValueType in CONST_ARGS_RESULT_BY_REF)) then
        Include(ValueKindAsm,vPassedByReference);
      case ValueType of
        smvBoolean:
          SizeInStorage := 1;
        smvInteger, smvCardinal:
          SizeInStorage := 4;
        smvInt64, smvDouble, smvDateTime, smvCurrency:
          SizeInStorage := 8;
        smvEnum:
          case TypeInfo^.EnumBaseType^.MaxValue of
          0..255:     SizeInStorage := 1;
          256..65535: SizeInStorage := 2;
          else        SizeInStorage := 4;
          end;
        smvSet:
          case TypeInfo^.SetEnumType^.MaxValue of
          0..7:   SizeInStorage := 1;
          8..15:  SizeInStorage := 2;
          16..31: SizeInStorage := 4;
          else raise EInterfaceFactoryException.CreateFmt(
            '%s set too big in %s.%s method %s parameter',
            [TypeName^,fInterfaceTypeInfo^.Name,URI,ParamName^]);
          end;
        smvRecord:
          if TypeInfo^.RecordType^.Size<=PTRSIZ then
            raise EInterfaceFactoryException.CreateFmt(
              '%s record too small in %s.%s method %s parameter',
              [TypeName^,fInterfaceTypeInfo^.Name,URI,ParamName^]) else
            SizeInStorage := PTRSIZ; // handle only records when passed by ref
        else
          SizeInStorage := PTRSIZ;
      end;
      if ValueDirection=smdResult then begin
        if not(ValueType in CONST_ARGS_RESULT_BY_REF) then
          continue; // ordinal/real/class results are returned in CPU/FPU registers
        {$ifdef CPU64} // Delphi always put the result pointer as RDX in x64 
        InStackOffset := STACKOFFSET_NONE; 
        RegisterIdent := REGRDX;
        continue;
        {$endif}
      end;
      {$ifndef CPU64}
      if ValueDirection=smdConst then
        SizeInStack := CONST_ARGS_IN_STACK_SIZE[ValueType] else
      {$endif}
        SizeInStack := PTRSIZ;
      if (reg>REG_LAST) or (SizeInStack<>PTRSIZ) then begin
        InStackOffset := ArgsSizeInStack;
        inc(ArgsSizeInStack,SizeInStack);
      end else begin
        InStackOffset := STACKOFFSET_NONE;
        {$ifdef CPU64}
        if resultIsRDX and (reg=REGRDX) then
          inc(reg); // RDX is reserved by Delphi for function result pointer
        {$endif}
        RegisterIdent := reg;
        inc(reg);
      end;
    end;
    if ArgsSizeInStack>MAX_EXECSTACK then
        raise EInterfaceFactoryException.CreateFmt(
          'Stack size %d > %d for %s.%s method',
          [ArgsSizeInStack,MAX_EXECSTACK,fInterfaceTypeInfo^.Name,URI]);
    {$ifndef CPU64}
    // pascal/register convention are passed left-to-right -> reverse order
    offs := ArgsSizeInStack;
    for a := 0 to high(Args) do
    with Args[a] do
      if InStackOffset>=0 then begin
        dec(offs,SizeInStack);
        InStackOffset := offs;
      end;
    assert(offs=0);
    {$endif}
  end;
  with TTextWriter.CreateOwnedStream do
  try
    // compute the default result as a JSON array containing all methods
    for m := 0 to fMethodsCount-1 do
    with fMethods[m] do begin
      CancelAll;
      Add('[');
      for a := ArgsOutFirst to ArgsOutLast do
      with Args[a] do
      if ValueDirection in [smdVar,smdOut,smdResult] then
      case ValueType of
      smvBoolean:  AddShort('false,');
      smvObject:   AddShort('null,'); // may raise an error on the client side
      smvDynArray: AddShort('[],');
      smvRecord:   begin
        AddVoidRecordJSON(TypeInfo);
        Add(',');
      end;
      {$ifdef USEVARIANTS}
      smvVariant:  AddShort('null,');
      {$endif}
      else
        if vIsString in ValueKindAsm then
          AddShort('"",') else
          AddShort('0,');
      end;
      CancelLastComma;
      Add(']');
      SetText(DefaultResult);
    end;
    // compute the method contract as a JSON object
    CancelAll;
    Add('[');
    for m := 0 to fMethodsCount-1 do
    with fMethods[m] do begin
      Add('{"method":"%","arguments":[',[URI]);
      for a := 0 to High(Args) do
        AddString(Args[a].SerializeToContract);
      CancelLastComma;
      AddShort(']},');
    end;
    CancelLastComma;
    Add(']');
    SetText(fContract);
  finally
    Free;
  end;
end;

procedure TInterfaceFactory.AddMethodsFromTypeInfo(aInterface: PTypeInfo);
var P: Pointer absolute aInterface;
    PB: PByte absolute aInterface;
    PI: PInterfaceTypeData absolute P;
    PW: PWord absolute P;
    PS: PShortString absolute P;
    PME: ^TIntfMethodEntryTail absolute P;
    PF: ^TParamFlags absolute P;
    PP: ^PPTypeInfo absolute P;
    Ancestor: PTypeInfo;
    wasAdded: boolean;
    Kind: TMethodKind;
    f: TParamFlags;
    i,j: integer;
    n: cardinal;
    aURI: RawUTF8;
    ErrorMsg: string;
    C: TClass;
begin
  // handle interface inheritance via recursive calls
  P := aInterface^.ClassType;
  if PI^.IntfParent<>nil then
    Ancestor := PI^.IntfParent^ else
    Ancestor := nil;
  if Ancestor<>nil then
    AddMethodsFromTypeInfo(Ancestor);
  P := @PI^.IntfUnit[ord(PI^.IntfUnit[0])+1];
  // retrieve methods for this interface level
  n := PW^; inc(PW);
  if (PW^=$ffff) or (n=0) then
    exit; // no RTTI or no method at this level of interface
  inc(PW);
  for i := fMethodsCount to fMethodsCount+n-1 do begin
    // retrieve method name, and add to the methods list (with hashing)
    SetString(aURI,PAnsiChar(@PS^[1]),ord(PS^[0]));
    if (fMethod.FindHashedForAdding(aURI,wasAdded)<>i) or not wasAdded then
      raise EInterfaceFactoryException.CreateFmt('%s.%s method: duplicated name',
        [fInterfaceTypeInfo^.Name,aURI]);
    with fMethods[i] do begin
      URI := aURI;
      MethodIndex := i+RESERVED_VTABLE_SLOTS;
      PS := @PS^[ord(PS^[0])+1];
      Kind := PME^.Kind;
      if PME^.CC<>ccRegister then
        raise EInterfaceFactoryException.CreateFmt(
          '%s.%s method shall use register calling convention',
          [fInterfaceTypeInfo^.Name,URI]);
      // retrieve method call arguments
      n := PME^.ParamCount;
      inc(PME);
      if Kind=mkFunction then
        SetLength(Args,n+1) else
        SetLength(Args,n);
      if length(Args)>MAX_METHOD_ARGS then
        raise EInterfaceFactoryException.CreateFmt(
          '%s.%s method has too many parameters: %d>%d',
          [fInterfaceTypeInfo^.Name,URI,Length(Args),MAX_METHOD_ARGS]);
      ArgsOutFirst := -1;
      ArgsOutLast := -2;
      for j := 0 to n-1 do
      with Args[j] do begin
        f := PF^;
        inc(PF);
        if pfVar in f then
          ValueDirection := smdVar else
        if pfOut in f then
          ValueDirection := smdOut;
        if ValueDirection<>smdConst then begin
          if ArgsOutFirst<0 then
            ArgsOutFirst := j;
          ArgsOutLast := j;
          inc(ArgsOutputValuesCount);
        end;
        ParamName := PS;
        PS := @PS^[ord(PS^[0])+1];
        TypeName := PS;
        PS := @PS^[ord(PS^[0])+1];
        if PP^=nil then
          raise EInterfaceFactoryException.CreateFmt(
            '%s.%s: %s parameter has no information',
            [fInterfaceTypeInfo^.Name,URI,ParamName^]);
        TypeInfo := PP^^;
        inc(PP);
        {$ifdef ISDELPHIXE}
        inc(PB,PW^); // skip custom attributes
        {$endif}
        if j=0 then
          ValueType := smvSelf else begin
          if ValueDirection<>smdOut then
            inc(ArgsInputValuesCount);
          ValueType := TypeInfoToMethodValueType(TypeInfo);
          case ValueType of
          smvNone: begin
            case TypeInfo^.Kind of
            tkClass: begin
              C := TypeInfo^.ClassType^.ClassType;
              if C.InheritsFrom(TList) then
                ErrorMsg := ' - use TObjectList instead' else
              {$ifndef LVCL}
              if (C.InheritsFrom(TCollection) and not C.InheritsFrom(TInterfacedCollection)) and
                (JSONSerializerRegisteredCollection.Find(TCollectionClass(C))=nil) then
                ErrorMsg := ' - inherit from TInterfacedCollection '+
                  'or use TJSONSerializer.RegisterCollectionForJSON()' else
              {$endif}
                ErrorMsg := ' - use TJSONSerializer.RegisterCustomSerializer()';
            end;
            tkInteger: ErrorMsg := ' - use integer/cardinal instead';
            tkFloat:   ErrorMsg := ' - use double instead';
            end;
            raise EInterfaceFactoryException.CreateFmt(
              '%s.%s: %s parameter has unexpected type %s%s',
              [fInterfaceTypeInfo^.Name,URI,ParamName^,TypeInfo^.Name,ErrorMsg]);
          end;
          smvRecord: if f*[pfConst,pfVar,pfOut]=[] then
            raise EInterfaceFactoryException.CreateFmt(
              '%s.%s: %s record parameter should be declared as const, var or out',
              [fInterfaceTypeInfo^.Name,URI,ParamName^]);
          end;
        end;
      end;
      // add a pseudo argument after all arguments for functions
      if Kind=mkFunction then
      with Args[n] do begin
        ParamName := @CONST_PSEUDO_RESULT_NAME;
        ArgsResultIndex := n;
        if ArgsOutFirst<0 then
          ArgsOutFirst := n;
        ArgsOutLast := n;
        ValueDirection := smdResult;
        inc(ArgsOutputValuesCount);
        TypeName := PS;
        PS := @PS^[ord(PS^[0])+1];
        TypeInfo := PP^^;
        inc(PP);
        ValueType := TypeInfoToMethodValueType(TypeInfo);
      end else
        ArgsResultIndex := -1;
      // go to next method
      {$ifdef ISDELPHIXE}
      inc(PW); // skip attributes
      {$endif}
    end;
  end;
end;

function TInterfaceFactory.FindMethodIndex(const aMethodName: RawUTF8): integer;
begin
  if fMethodsCount<10 then begin
    for result := 0 to fMethodsCount-1 do
      if IdemPropNameU(fMethods[result].URI,aMethodName) then
        exit;
    result := -1;
  end else
    result := fMethod.FindHashed(aMethodName);
end;

function TInterfaceFactory.CheckMethodIndex(const aMethodName: RawUTF8): integer;
begin
  result := FindMethodIndex(aMethodName);
  if result<0 then
    raise EInterfaceFactoryException.CreateFmt('%s.%s does not exists',
      [fInterfaceTypeInfo^.Name,aMethodName]);
end;

{$ifdef CPU64}
procedure x64FakeStub;
var smetndx, sxmm3, sxmm2, sxmm1: pointer;
asm // mov ax,{MethodIndex}; jmp x64FakeStub
  .params 2 // FakeCall(self: TInterfacedObjectFake; var aCall: TFakeCallStack): Int64
  and rax,$ffff
  movsd sxmm1,xmm1
  movsd sxmm2,xmm2
  movsd sxmm3,xmm3
  mov smetndx,rax
  mov [rbp+$50],rcx
  mov [rbp+$58],rdx
  mov [rbp+$60],r8
  mov [rbp+$68],r9
  lea rdx,sxmm1
  call TInterfacedObjectFake.FakeCall
  // FakeCall should set Int64 result in method result, and float in aCall.XMM1
  movsd xmm0,sxmm1
end;
{$endif}

const
  STUB_SIZE = 65536; // 16*4 KB (4 KB = memory granularity)

type
  // internal memory buffer created with PAGE_EXECUTE_READWRITE flags
  TFakeStubBuffer = class
  protected
    fStub: PByteArray;
    fStubUsed: cardinal;
  public
    constructor Create;
    destructor Destroy; override;
    // call shall be protected by InterfaceFactoryCacheLock critical section
    class function Reserve(size: Cardinal): pointer;
  end;

var
  CurrentFakeStubBuffer: TFakeStubBuffer;

constructor TFakeStubBuffer.Create;
begin
  fStub := VirtualAlloc(nil,STUB_SIZE,MEM_COMMIT,PAGE_EXECUTE_READWRITE);
end;

destructor TFakeStubBuffer.Destroy;
begin
  VirtualFree(fStub,0,MEM_RELEASE);
  inherited;
end;

class function TFakeStubBuffer.Reserve(size: Cardinal): pointer;
begin
  if size>STUB_SIZE then
    raise EServiceException.CreateFmt('TFakeStubBuffer.Reserve(size=%d>%d)',
      [size,STUB_SIZE]);
  if CurrentFakeStubBuffer=nil then
    GarbageCollectorFreeAndNil(CurrentFakeStubBuffer,TFakeStubBuffer.Create) else
  if CurrentFakeStubBuffer.fStubUsed+size>STUB_SIZE then begin
    GarbageCollector.Add(CurrentFakeStubBuffer);
    CurrentFakeStubBuffer := TFakeStubBuffer.Create;
  end;
  with CurrentFakeStubBuffer do begin
    result := @fStub[fStubUsed];
    inc(fStubUsed,size);
  end;
end;


function TInterfaceFactory.GetMethodsVirtualTable: pointer;
var i: integer;
    P: PCardinal;
begin
  if fFakeVTable=nil then begin
    EnterCriticalSection(InterfaceFactoryCacheLock);
    try
      if fFakeVTable=nil then begin // avoid race condition error
        SetLength(fFakeVTable,fMethodsCount+RESERVED_VTABLE_SLOTS);
        fFakeVTable[0] := @TInterfacedObjectFake.FakeQueryInterface;
        fFakeVTable[1] := @TInterfacedObjectFake.Fake_AddRef;
        fFakeVTable[2] := @TInterfacedObjectFake.Fake_Release;
        fFakeStub := TFakeStubBuffer.Reserve(fMethodsCount*{$ifdef CPU64}12{$else}24{$endif});
        P := pointer(fFakeStub);
        for i := 0 to fMethodsCount-1 do begin
          fFakeVTable[i+RESERVED_VTABLE_SLOTS] := P;
          {$ifdef CPU64}
          P^ := $b866+(i shl 16); inc(P);          // mov ax,{MethodIndex}
          PByte(P)^ := $e9; inc(PByte(P));         // jmp x64FakeStub
          P^ := PtrUInt(@x64FakeStub)-PtrUInt(P)-4; inc(P);
          P^ := $909090;
          {$else}
          P^ := $68ec8b55; inc(P);                 // push ebp; mov ebp,esp
          P^ := i; inc(P);                         // push {MethodIndex}
          P^ := $e2895251; inc(P);                 // push ecx; push edx; mov edx,esp
          PByte(P)^ := $e8; inc(PByte(P));         // call FakeCall
          P^ := PtrUInt(@TInterfacedObjectFake.FakeCall)-PtrUInt(P)-4; inc(P);
          P^ := $c25dec89; inc(P);                 // mov esp,ebp; pop ebp
          P^ := fMethods[i].ArgsSizeInStack or $900000;  // ret {StackSize}; nop
          {$endif}
          inc(PByte(P),3);
        end;
      end;
    finally
      LeaveCriticalSection(InterfaceFactoryCacheLock);
    end;
  end;
  result := pointer(fFakeVTable);
end;


{ TInterfaceStubRules }

function TInterfaceStubRules.FindRuleIndex(const aParams: RawUTF8): integer;
begin
  for result := 0 to length(Rules)-1 do
    if Rules[result].Params=aParams then
      exit;
  result := -1;
end;

function TInterfaceStubRules.FindStrongRuleIndex(const aParams: RawUTF8): integer;
begin
  for result := 0 to length(Rules)-1 do
    if (Rules[result].Kind<>isUndefined) and (Rules[result].Params=aParams) then
      exit;
  result := -1;
end;

procedure TInterfaceStubRules.AddRule(Sender: TInterfaceStub;
  aKind: TInterfaceStubRuleKind; const aParams, aValues: RawUTF8;
  const aEvent: TNotifyEvent; aExceptionClass: ExceptClass;
  aExpectedPassCountOperator: TSQLQueryOperator; aValue: cardinal);
var n,ndx: integer;
begin
  ndx := FindRuleIndex(aParams);
  n := length(Rules);
  if ndx<0 then
    SetLength(Rules,n+1) else
    n := ndx;
  if (aParams='') and (aKind<>isUndefined) then
    DefaultRule := n;
  with Rules[n] do begin
    Params := aParams;
    case aKind of
    isUndefined:
      ; // do not overwrite Values for weak rules like ExpectsCount/ExpectsTrace
    isReturns:
      Values := '['+AValues+']';
    isFails:
      Values := RawUTF8(Sender.ClassName)+' returned error: '+aValues;
    else
      Values := aValues;
    end;
    if aKind=isUndefined then
      if aExpectedPassCountOperator=qoContains then
        ExpectedTraceHash := aValue else begin
        ExpectedPassCountOperator := aExpectedPassCountOperator;
        ExpectedPassCount := aValue;
      end else begin
      Kind := aKind;
      Execute := aEvent;
      ExceptionClass := aExceptionClass;
    end;
  end;
end;


{ TInterfaceStub }

constructor EInterfaceStub.Create(Sender: TInterfaceStub;
  const Method: TServiceMethod; const Error: string);
begin
  inherited CreateFmt('Error in %s for %s.%s - %s',
    [Sender.ClassName,Sender.fInterface.fInterfaceTypeInfo^.Name,Method.URI,Error]);
end;

constructor EInterfaceStub.Create(Sender: TInterfaceStub;
  const Method: TServiceMethod; const Format: string; const Args: array of const);
begin
  Create(Sender,Method,SysUtils.format(Format,Args));
end;

function TInterfaceStubLog.Results: RawUTF8;
begin
  if CustomResults='' then
    result := Method^.DefaultResult else
    result := CustomResults;
end;

procedure TInterfaceStubLog.AddAsText(WR: TTextWriter; aScope: TInterfaceStubLogLayouts);
begin
  if wName in aScope then
    WR.AddString(Method^.URI);
  if wParams in aScope then begin
    WR.Add('(');
    WR.AddString(Params);
    WR.Add(')');
  end;
  if WasError then begin
    WR.AddShort(' error "');
    WR.AddString(CustomResults);
    WR.Add('"');
  end else
  if (wResults in aScope) and (Method^.ArgsResultIndex>=0) then begin
    if (wName in aScope) or (wParams in aScope) then
      WR.Add('=');
    if CustomResults='' then
      WR.AddString(Method^.DefaultResult) else
      WR.AddString(CustomResults);
  end;
  WR.Add(',');
end;

constructor TOnInterfaceStubExecuteParamsAbstract.Create(aSender: TInterfaceStub;
  aMethod: PServiceMethod; const aParams,aEventParams: RawUTF8);
begin
  fSender := aSender;
  fMethod := aMethod;
  fParams := aParams;
  fEventParams := aEventParams;
end;

procedure TOnInterfaceStubExecuteParamsAbstract.Error(Format: PUTF8Char; const Args: array of const);
begin
  Error(FormatUTF8(Format,Args));
end;

procedure TOnInterfaceStubExecuteParamsAbstract.Error(const aErrorMessage: RawUTF8);
begin
  fFailed := true;
  fResult := aErrorMessage;
end;

function TOnInterfaceStubExecuteParamsAbstract.GetSenderAsMockTestCase: TSynTestCase;
begin
  result := (fSender as TInterfaceMock).TestCase;
end;

procedure TOnInterfaceStubExecuteParamsJSON.Returns(const Values: array of const);
begin
  JSONEncodeArrayOfConst(Values,false,fResult);
end;

{$ifdef USEVARIANTS}

constructor TOnInterfaceStubExecuteParamsVariant.Create(aSender: TInterfaceStub;
  aMethod: PServiceMethod; const aParams, aEventParams: RawUTF8);
var i: integer;
    P: PUTF8Char;
begin
  inherited;
  SetLength(fInput,fMethod^.ArgsInputValuesCount);
  P := pointer(aParams);
  for i := 0 to fMethod^.ArgsInputValuesCount-1 do
    P := VariantLoadJSON(fInput[i],P);
  SetLength(fOutput,fMethod^.ArgsOutputValuesCount);
end;

function TOnInterfaceStubExecuteParamsVariant.GetInput(Index: Integer): variant;
begin
  if cardinal(Index)>=fMethod^.ArgsInputValuesCount then
    raise EInterfaceStub.Create(fSender,fMethod^,'Input[%d>=%d]',
      [Index,fMethod^.ArgsInputValuesCount]) else
    result := fInput[Index];
end;

procedure TOnInterfaceStubExecuteParamsVariant.SetOutput(Index: Integer;
  const Value: variant);
begin
  if cardinal(Index)>=fMethod^.ArgsOutputValuesCount then
    raise EInterfaceStub.Create(fSender,fMethod^,'Output[%d>=%d]',
      [Index,fMethod^.ArgsOutputValuesCount]) else
    fOutput[Index] := Value;
end;

function TOnInterfaceStubExecuteParamsVariant.GetInNamed(const aParamName: RawUTF8): variant;
var L,a,ndx: integer;
begin
  L := Length(aParamName);
  ndx := 0;
  if (L>0) and (fInput<>nil) then
    for a := 1 to high(fMethod^.Args) do // ignore Args[0]=self
      with fMethod^.Args[a] do
      if ValueDirection in [smdConst,smdVar] then begin
        if IdemPropName(ParamName^,pointer(aParamName),L) then begin
          result := fInput[ndx];
          exit;
        end;
        inc(ndx);
        if cardinal(ndx)>=cardinal(fMethod^.ArgsInputValuesCount) then
          break;
      end;
  raise EInterfaceStub.Create(fSender,fMethod^,'unknown input parameter "%s"',[aParamName]);
end;

procedure TOnInterfaceStubExecuteParamsVariant.SetOutNamed(const aParamName: RawUTF8;
  const Value: variant);
var L,a,ndx: integer;
begin
  L := Length(aParamName);
  ndx := 0;
  if (L>0) and (fOutput<>nil) then
    for a := fMethod^.ArgsOutFirst to fMethod^.ArgsOutLast do
      with fMethod^.Args[a] do
      if ValueDirection<>smdConst then begin
        if IdemPropName(ParamName^,pointer(aParamName),L) then begin
          fOutput[ndx] := Value;
          exit;
        end;
        inc(ndx);
        if cardinal(ndx)>=cardinal(fMethod^.ArgsOutputValuesCount) then
          break;
      end;
  raise EInterfaceStub.Create(fSender,fMethod^,'unknown output parameter "%s"',[aParamName]);
end;

procedure TOnInterfaceStubExecuteParamsVariant.SetResult(var Result: RawUTF8);
var i: integer;
begin
  if fOutput=nil then
    fResult := '' else
    with TJSONSerializer.CreateOwnedStream do
    try
      Add('[');
      for i := 0 to fMethod^.ArgsOutputValuesCount-1 do begin
        if TVarData(fOutput[i]).VType=varEmpty then
          raise EInterfaceStub.Create(fSender,fMethod^,'Output[%d] not set',[i]);
        AddVariantJSON(fOutput[i],twJSONEscape);
        Add(',');
      end;
      CancelLastComma;
      Add(']');
      SetText(result);
    finally
      Free;
    end;
end;

{$endif}

procedure TInterfaceStub.InternalCreate(out aStubbedInterface);
var i: integer;
begin
  SetLength(fRules,fInterface.MethodsCount);
  for i := 0 to fInterface.MethodsCount-1 do
    fRules[i].DefaultRule := -1;
  fLog.Init(TypeInfo(TInterfaceStubLogDynArray),fLogs,@fLogCount);
  with TInterfacedObjectFake.Create(fInterface,Invoke,InstanceDestroyed) do begin
    pointer(aStubbedInterface) := @fVTable;
    _AddRef;
  end;
end;

function TInterfaceStub.InternalCheck(aValid: boolean; const aErrorMessage: RawUTF8;
  aExpectationFailed: boolean): boolean;
begin
  result := aValid;
  if aExpectationFailed and not aValid then
    raise EInterfaceFactoryException.CreateFmt('%s - Error validating %s.%s',
      [ClassName,fInterface.fInterfaceTypeInfo^.Name,aErrorMessage]);
end;

constructor TInterfaceStub.Create(const aInterfaceName: RawUTF8; out aStubbedInterface);
begin
  fInterface := TInterfaceFactory.Get(aInterfaceName);
  if fInterface=nil then
    raise EInterfaceStub.CreateFmt('Interface %s non registered',[aInterfaceName]);
  InternalCreate(aStubbedInterface);
end;

constructor TInterfaceStub.Create(const aGUID: TGUID; out aStubbedInterface);
begin
  fInterface := TInterfaceFactory.Get(aGUID);
  if fInterface=nil then
    raise EInterfaceStub.CreateFmt(
      'Interface %s non registered',[GUIDToString(aGUID)]);
  InternalCreate(aStubbedInterface);
end;

constructor TInterfaceStub.Create(aInterface: PTypeInfo; out aStubbedInterface);
begin
  fInterface := TInterfaceFactory.Get(aInterface);
  InternalCreate(aStubbedInterface);
end;

procedure TInterfaceStub.IntSetOptions(Options: TInterfaceStubOptions);
begin
  if Options=fOptions then
    exit;
  fOptions := Options;
end;

procedure TInterfaceStub.IntCheckCount(aMethodIndex, aComputed: cardinal;
  aOperator: TSQLQueryOperator; aCount: cardinal);
const
  OPERATORS: array[qoEqualTo..qoGreaterThanOrEqualTo] of RawUTF8 = (
    '=','<>','<','<=','>','>=');
function SQLQueryCompare(aOperator: TSQLQueryOperator; A,B: cardinal): boolean;
begin
  case aOperator of
  qoEqualTo:              result := A=B;
  qoNotEqualTo:           result := A<>B;
  qoLessThan:             result := A<B;
  qoLessThanOrEqualTo:    result := A<=B;
  qoGreaterThan:          result := A>B;
  qoGreaterThanOrEqualTo: result := A>=B;
  else                    result := true;
  end;
end;
begin
  InternalCheck(SQLQueryCompare(aOperator,aComputed,aCount),
    FormatUTF8('% pass count % % % failed',
      [fInterface.Methods[aMethodIndex].URI,
       aComputed,OPERATORS[aOperator],aCount]),True);
end;

procedure TInterfaceStub.InstanceDestroyed(aClientDrivenID: cardinal);
var m,r,asmndx: integer;
    num: cardinal;
begin
  if self<>nil then
  try
    if eCount in fHasExpects then
      for m := 0 to fInterface.MethodsCount-1 do
      with fRules[m] do
        for r := 0 to high(Rules) do
        with Rules[r] do
          if ExpectedPassCountOperator<>qoNone then begin
            if Params='' then
              num := MethodPassCount else
              num := RulePassCount;
            IntCheckCount(m,num,ExpectedPassCountOperator,ExpectedPassCount);
          end;
    if fInterfaceExpectedTraceHash<>0 then
      InternalCheck(LogHash=fInterfaceExpectedTraceHash,'* interface expected execution',True);
    if eTrace in fHasExpects then
      for m := 0 to fInterface.MethodsCount-1 do
      with fRules[m] do begin
        asmndx := m+RESERVED_VTABLE_SLOTS;
        for r := 0 to high(Rules) do
        with Rules[r] do
        if ExpectedTraceHash<>0 then
          InternalCheck(ExpectedTraceHash=
            Hash32(IntGetLogAsText(asmndx,Params,[wName,wParams,wResults])),
            fInterface.Methods[m].URI+' method expected execution',True);
      end;
  finally
    if not (imoFakeInstanceWontReleaseTInterfaceStub in Options) then
      Free; // creature will release its creator
  end;
end;

function TInterfaceStub.SetOptions(Options: TInterfaceStubOptions): TInterfaceStub;
begin
  IntSetOptions(Options);
  result := self;
end;


function TInterfaceStub.Executes(const aMethodName, aParams: RawUTF8;
  aEvent: TOnInterfaceStubExecuteJSON; const aEventParams: RawUTF8): TInterfaceStub;
begin
  fRules[fInterface.CheckMethodIndex(aMethodName)].
    AddRule(self,isExecutesJSON,aParams,aEventParams,TNotifyEvent(aEvent));
  result := self;
end;

function TInterfaceStub.Executes(const aMethodName: RawUTF8;
  aEvent: TOnInterfaceStubExecuteJSON; const aEventParams: RawUTF8): TInterfaceStub;
begin
  result := Executes(aMethodName,'',aEvent,aEventParams);
end;

function TInterfaceStub.Executes(const aMethodName: RawUTF8;
  const aParams: array of const; aEvent: TOnInterfaceStubExecuteJSON;
  const aEventParams: RawUTF8): TInterfaceStub;
begin
  result := Executes(aMethodName,JSONEncodeArrayOfConst(aParams,true),
    aEvent,aEventParams);
end;

{$ifdef USEVARIANTS}

function TInterfaceStub.Executes(const aMethodName, aParams: RawUTF8;
  aEvent: TOnInterfaceStubExecuteVariant; const aEventParams: RawUTF8): TInterfaceStub;
begin
  fRules[fInterface.CheckMethodIndex(aMethodName)].
    AddRule(self,isExecutesVariant,aParams,aEventParams,TNotifyEvent(aEvent));
  result := self;
end;

function TInterfaceStub.Executes(const aMethodName: RawUTF8;
  aEvent: TOnInterfaceStubExecuteVariant; const aEventParams: RawUTF8): TInterfaceStub;
begin
  result := Executes(aMethodName,'',aEvent,aEventParams);
end;

function TInterfaceStub.Executes(const aMethodName: RawUTF8;
  const aParams: array of const; aEvent: TOnInterfaceStubExecuteVariant;
  const aEventParams: RawUTF8): TInterfaceStub;
begin
  result := Executes(aMethodName,JSONEncodeArrayOfConst(aParams,true),
    aEvent,aEventParams);
end;

{$endif}

function TInterfaceStub.ExpectsCount(const aMethodName: RawUTF8; aOperator: TSQLQueryOperator;
  aValue: cardinal): TInterfaceStub;
begin
  result := ExpectsCount(aMethodName,'',aOperator,aValue);
end;

function TInterfaceStub.ExpectsCount(const aMethodName, aParams: RawUTF8; aOperator: TSQLQueryOperator;
  aValue: cardinal): TInterfaceStub;
var ndx: integer;
begin
  ndx := fInterface.CheckMethodIndex(aMethodName);
  if aOperator in [qoEqualTo..qoGreaterThanOrEqualTo] then
    with fRules[ndx] do
      AddRule(self,isUndefined,aParams,'',nil,nil,aOperator,aValue) else
    raise EInterfaceStub.Create(self,fInterface.fMethods[ndx],
      'incorrect ExpectsCount(aOperator)');
  include(fHasExpects,eCount);
  result := self;
end;

function TInterfaceStub.ExpectsCount(const aMethodName: RawUTF8;
  const aParams: array of const; aOperator: TSQLQueryOperator; aValue: cardinal): TInterfaceStub;
begin
  result := ExpectsCount(aMethodName,JSONEncodeArrayOfConst(aParams,true),aOperator,aValue);
end;

function TInterfaceStub.ExpectsTrace(aValue: cardinal): TInterfaceStub;
begin
  include(fOptions,imoLogMethodCallsAndResults);
  fInterfaceExpectedTraceHash := aValue;
  result := self;
end;

function TInterfaceStub.ExpectsTrace(const aMethodName: RawUTF8; aValue: cardinal): TInterfaceStub;
begin
  result := ExpectsTrace(aMethodName,'',aValue);
end;

function TInterfaceStub.ExpectsTrace(const aMethodName, aParams: RawUTF8;
  aValue: cardinal): TInterfaceStub;
begin
  fRules[fInterface.CheckMethodIndex(aMethodName)].
    AddRule(self,isUndefined,aParams,'',nil,nil,qoContains,aValue);
  include(fOptions,imoLogMethodCallsAndResults);
  include(fHasExpects,eTrace);
  result := self;
end;

function TInterfaceStub.ExpectsTrace(const aMethodName: RawUTF8;
  const aParams: array of const; aValue: cardinal): TInterfaceStub;
begin
  result := ExpectsTrace(aMethodName,JSONEncodeArrayOfConst(aParams,true),aValue);
end;

function TInterfaceStub.Fails(const aMethodName, aErrorMsg: RawUTF8): TInterfaceStub;
begin
  result := Fails(aMethodName,'',aErrorMsg);
end;

function TInterfaceStub.Fails(const aMethodName, aParams, aErrorMsg: RawUTF8): TInterfaceStub;
begin
  fRules[fInterface.CheckMethodIndex(aMethodName)].
    AddRule(self,isFails,aParams,aErrorMsg);
  result := self;
end;

function TInterfaceStub.Fails(const aMethodName: RawUTF8; const aParams: array of const;
  const aErrorMsg: RawUTF8): TInterfaceStub;
begin
  result := Fails(aMethodName,JSONEncodeArrayOfConst(aParams,true),aErrorMsg);
end;

function TInterfaceStub.Raises(const aMethodName, aParams: RawUTF8;
  aException: ExceptClass; const aMessage: string): TInterfaceStub;
begin
  fRules[fInterface.CheckMethodIndex(aMethodName)].
    AddRule(self,isRaises,aParams,StringToUTF8(aMessage),nil,aException);
  result := self;
end;

function TInterfaceStub.Raises(const aMethodName: RawUTF8;
  const aParams: array of const; aException: ExceptClass;
  const aMessage: string): TInterfaceStub;
begin
  result := Raises(aMethodName,JSONEncodeArrayOfConst(aParams,true),
    aException,aMessage);
end;

function TInterfaceStub.Raises(const aMethodName: RawUTF8;
  aException: ExceptClass; const aMessage: string): TInterfaceStub;
begin
  result := Raises(aMethodName,'',aException,aMessage);
end;

function TInterfaceStub.Returns(const aMethodName, aParams,
  aExpectedResults: RawUTF8): TInterfaceStub;
begin
  fRules[fInterface.CheckMethodIndex(aMethodName)].
    AddRule(self,isReturns,aParams,aExpectedResults);
  result := self;
end;

function TInterfaceStub.Returns(const aMethodName: RawUTF8; const aParams,
  aExpectedResults: array of const): TInterfaceStub;
begin
  result := Returns(aMethodName,JSONEncodeArrayOfConst(aParams,true),
    JSONEncodeArrayOfConst(aExpectedResults,true));
end;

function TInterfaceStub.Returns(const aMethodName,
  aExpectedResults: RawUTF8): TInterfaceStub;
begin
  result := Returns(aMethodName,'',aExpectedResults);
end;

function TInterfaceStub.Returns(const aMethodName: RawUTF8;
  const aExpectedResults: array of const): TInterfaceStub;
begin
  result := Returns(aMethodName,'',JSONEncodeArrayOfConst(aExpectedResults,true));
end;

function TInterfaceStub.Invoke(const aMethod: TServiceMethod;
  const aParams: RawUTF8; aResult, aErrorMsg: PRawUTF8;
  aClientDrivenID: PCardinal; aServiceCustomAnswer: PServiceCustomAnswer): boolean;
var ndx: cardinal;
    rule: integer;
    ExecutesCtxt: TOnInterfaceStubExecuteParamsAbstract;
    Log: TInterfaceStubLog;
begin
  ndx := aMethod.MethodIndex-RESERVED_VTABLE_SLOTS;
  if ndx>=fInterface.MethodsCount then
    result := false else
    with fRules[ndx] do begin
      inc(MethodPassCount);
      rule := FindStrongRuleIndex(aParams);
      if rule<0 then begin
        rule := FindRuleIndex(aParams);
        if rule>=0 then
          inc(Rules[rule].RulePassCount);
        rule := DefaultRule;
      end;
      if rule<0 then
        if imoRaiseExceptionIfNoRuleDefined in Options then
          raise EInterfaceStub.Create(self,aMethod,'No rule defined') else begin
        rule := FindRuleIndex(aParams);
        if rule>=0 then
          inc(Rules[rule].RulePassCount);
        if imoReturnErrorIfNoRuleDefined in Options then begin
          result := false;
          Log.CustomResults := FormatUTF8('No stubbing rule defined for %s.%s',
            [fInterface.fInterfaceTypeInfo^.Name,aMethod.URI]);
        end else
          result := true;
      end else
      with Rules[rule] do begin
        inc(RulePassCount);
        case Kind of
        isExecutesJSON: begin
          ExecutesCtxt := TOnInterfaceStubExecuteParamsJSON.Create(
            self,@aMethod,aParams,Values);
          try
            TOnInterfaceStubExecuteJSON(Execute)
              (TOnInterfaceStubExecuteParamsJSON(ExecutesCtxt));
            result := not ExecutesCtxt.fFailed;
            Log.CustomResults := ExecutesCtxt.fResult;
          finally
            ExecutesCtxt.Free;
          end;
        end;
{$ifdef USEVARIANTS}
        isExecutesVariant: begin
          ExecutesCtxt := TOnInterfaceStubExecuteParamsVariant.Create(
            self,@aMethod,aParams,Values);
          try
            TOnInterfaceStubExecuteVariant(Execute)
              (TOnInterfaceStubExecuteParamsVariant(ExecutesCtxt));
            result := not ExecutesCtxt.fFailed;
            if result then
              TOnInterfaceStubExecuteParamsVariant(ExecutesCtxt).
                SetResult(Log.CustomResults);
          finally
            ExecutesCtxt.Free;
          end;
        end;
{$endif}isRaises:
          raise ExceptionClass.Create(UTF8ToString(Values));
        isReturns: begin
          result := true;
          Log.CustomResults := Values;
        end;
        isFails: begin
          result := InternalCheck(false,Values,false);
          if not result then
            Log.CustomResults := Values;
        end;
        else
          result := true; // ignore isUndefined (ExpectsCount only) rules
        end;
      end;
      if result then begin
        if aResult<>nil then // make unique due to JSONDecode()
          if Log.CustomResults='' then
            SetString(aResult^,PAnsiChar(pointer(aMethod.DefaultResult)),
              length(aMethod.DefaultResult)) else
            SetString(aResult^,PAnsiChar(pointer(Log.CustomResults)),
              length(Log.CustomResults));
      end else
      if aErrorMsg<>nil then
        aErrorMsg^ := Log.CustomResults;
      if imoLogMethodCallsAndResults in Options then begin
        Log.TimeStamp := GetTickCount;
        Log.WasError := not result;
        Log.Method := @aMethod;
        Log.Params := aParams;
        fLog.Add(Log);
      end;
    end;
end;

function TInterfaceStub.GetLogAsText: RawUTF8;
begin
  result := IntGetLogAsText(0,'',[wName,wParams,wResults]);
end;

function TInterfaceStub.IntGetLogAsText(asmndx: integer; const aParams: RawUTF8;
  aScope: TInterfaceStubLogLayouts): RawUTF8;
var i: integer;
    WR: TTextWriter;
    Log: ^TInterfaceStubLog;
begin
  if fLogCount=0 then
    result := '' else begin
    WR := TTextWriter.CreateOwnedStream;
    try
      Log := Pointer(fLogs);
      if asmndx<RESERVED_VTABLE_SLOTS then
        for i := 1 to fLogCount do begin
          Log^.AddAsText(WR,aScope);
          inc(Log);
        end else
        for i := 1 to fLogCount do begin
          if Log^.Method^.MethodIndex=asmndx then
            if (aParams='') or (Log^.Params=aParams) then
              Log^.AddAsText(WR,aScope);
          inc(Log);
        end;
      WR.CancelLastComma;
      WR.SetText(result);
    finally
      WR.Free;
    end;
  end;
end;

function TInterfaceStub.GetLogHash: cardinal;
begin
  result := Hash32(GetLogAsText);
end;


{ TInterfaceMock }

constructor TInterfaceMock.Create(aInterface: PTypeInfo;
  out aMockedInterface; aTestCase: TSynTestCase);
begin
  inherited Create(aInterface,aMockedInterface);
  fTestCase := aTestCase;
end;

constructor TInterfaceMock.Create(const aGUID: TGUID; out aMockedInterface;
  aTestCase: TSynTestCase);
begin
  inherited Create(aGUID,aMockedInterface);
  fTestCase := aTestCase;
end;

constructor TInterfaceMock.Create(const aInterfaceName: RawUTF8;
  out aMockedInterface; aTestCase: TSynTestCase);
begin
  inherited Create(aInterfaceName,aMockedInterface);
  fTestCase := aTestCase;
end;

function TInterfaceMock.InternalCheck(aValid: boolean; const aErrorMessage: RawUTF8;
  aExpectationFailed: boolean): boolean;
begin
  if fTestCase=nil then
    result := inherited InternalCheck(aValid,aErrorMessage,aExpectationFailed) else begin
    fTestCase.Check(aValid xor (imoMockFailsWillPassTestCase in Options),
      UTF8ToString(aErrorMessage));
    result := true; // do not raise any exception at this stage for TInterfaceMock
  end;
end;


{ TInterfaceMockSpy }

procedure TInterfaceMockSpy.InternalCreate(out aStubbedInterface);
begin
  inherited;
  include(fOptions,imoLogMethodCallsAndResults);
end;

procedure TInterfaceMockSpy.IntSetOptions(Options: TInterfaceStubOptions);
begin
  include(Options,imoLogMethodCallsAndResults);
  inherited IntSetOptions(Options);
end;

procedure TInterfaceMockSpy.Verify(const aMethodName: RawUTF8;
  const aParams: array of const; aOperator: TSQLQueryOperator;
  aCount: cardinal);
begin
  Verify(aMethodName,JSONEncodeArrayOfConst(aParams,true),aOperator,aCount);
end;

procedure TInterfaceMockSpy.Verify(const aMethodName: RawUTF8;
  const aParams: array of const; const aTrace: RawUTF8);
begin
  Verify(aMethodName,JSONEncodeArrayOfConst(aParams,true),aTrace);
end;

procedure TInterfaceMockSpy.Verify(const aMethodName: RawUTF8;
  aOperator: TSQLQueryOperator; aCount: cardinal);
var m: integer;
begin
  m := fInterface.CheckMethodIndex(aMethodName);
  IntCheckCount(m,fRules[m].MethodPassCount,aOperator,aCount);
end;

procedure TInterfaceMockSpy.Verify(const aMethodName, aParams: RawUTF8;
  aOperator: TSQLQueryOperator; aCount: cardinal);
var asmndx, i: integer;
    c: cardinal;
begin
  asmndx := fInterface.CheckMethodIndex(aMethodName)+RESERVED_VTABLE_SLOTS;
  if aParams='' then
    c := fRules[asmndx-RESERVED_VTABLE_SLOTS].MethodPassCount else begin
    c := 0;
    for i := 0 to fLogCount-1 do
      with fLogs[i] do
      if (Method.MethodIndex=asmndx) and (Params=aParams) then
        inc(c);
  end;
  IntCheckCount(asmndx-RESERVED_VTABLE_SLOTS,c,aOperator,aCount);
end;


procedure TInterfaceMockSpy.Verify(const aTrace: RawUTF8;
  aScope: TInterfaceMockSpyCheck);
const
  VERIFY_SCOPE: array[TInterfaceMockSpyCheck] of TInterfaceStubLogLayouts = (
    [wName], [wName, wParams], [wName, wParams, wResults]);
begin
  InternalCheck(IntGetLogAsText(0,'',VERIFY_SCOPE[aScope])=aTrace,'Verify() failed',true);
end;

procedure TInterfaceMockSpy.Verify(const aMethodName, aParams, aTrace: RawUTF8);
var m: integer;
begin
  m := fInterface.CheckMethodIndex(aMethodName);
  InternalCheck(
    IntGetLogAsText(m+RESERVED_VTABLE_SLOTS,aParams,[wResults])=aTrace,
    fInterface.Methods[m].URI+' Verify() failed',true);
end;

procedure TInterfaceMockSpy.Verify(const aMethodName, aTrace: RawUTF8;
  aScope: TInterfaceMockSpyCheck);
const
  VERIFY_SCOPE: array[TInterfaceMockSpyCheck] of TInterfaceStubLogLayouts = (
    [], [wParams], [wParams, wResults]);
var m: integer;
begin
  m := fInterface.CheckMethodIndex(aMethodName);
  if aScope=chkName then
    raise EInterfaceStub.Create(self,fInterface.Methods[m],'Invalid scope for Verify()');
  InternalCheck(
    IntGetLogAsText(m+RESERVED_VTABLE_SLOTS,'',VERIFY_SCOPE[aScope])=aTrace,
    fInterface.Methods[m].URI+' Verify() failed',true);
end;


{ TServiceFactory }

function TServiceFactory.GetInterfaceTypeInfo: PTypeInfo;
begin
  if (Self<>nil) and (fInterface<>nil) then
    result := fInterface.fInterfaceTypeInfo else
    result := nil;
end;

function TServiceFactory.GetInterfaceIID: TGUID;
begin
  result := fInterface.fInterfaceIID;
end;

constructor TServiceFactory.Create(aRest: TSQLRest;
  aInterface: PTypeInfo; aInstanceCreation: TServiceInstanceImplementation;
  const aContractExpected: RawUTF8);
var m,j: integer;
begin
  // check supplied interface
  if (aRest=nil) or (aInterface=nil) then
    raise EServiceException.Create('Invalid call');
  inherited Create;
  fInterface := TInterfaceFactory.Get(aInterface);
  fRest := aRest;
  fInstanceCreation := aInstanceCreation;
  fInterfaceURI := aInterface^.Name;
  fInterfaceMangledURI := BinToBase64URI(@fInterface.fInterfaceIID,sizeof(TGUID));
  if fInterfaceURI[1] in ['I','i'] then
    Delete(fInterfaceURI,1,1);
  if fRest.Model.GetTableIndex(fInterfaceURI)>=0 then
    raise EServiceException.CreateFmt('"%s" interface name is already used by a SQL table name',
      [fInterfaceURI]);
  for m := 0 to fInterface.fMethodsCount-1 do
  with fInterface.fMethods[m] do begin
    if ArgsResultIndex>=0 then
    with Args[ArgsResultIndex] do
    case ValueType of
    smvNone, smvObject:
      raise EServiceException.CreateFmt('%s.%s: unexpected result type %s',
        [fInterface.fInterfaceTypeInfo^.Name,URI,TypeName^]);
    smvRecord:
      if TypeInfo=System.TypeInfo(TServiceCustomAnswer) then
        if InstanceCreation=sicClientDriven then
          raise EServiceException.CreateFmt(
            '%s.%s: sicClientDriven mode not allowed with TServiceCustomAnswer result',
            [fInterface.fInterfaceTypeInfo^.Name,URI]) else begin
        for j := ArgsOutFirst to ArgsOutLast do
          if Args[j].ValueDirection in [smdVar,smdOut] then
            raise EServiceException.CreateFmt(
              '%s.%s: var/out parameter "%s" not allowed with TServiceCustomAnswer result',
              [fInterface.fInterfaceTypeInfo^.Name,URI,Args[j].ParamName^]);
        ArgsResultIsServiceCustomAnswer := true;
      end;
    end;
  end;
  SetLength(fExecution,fInterface.fMethodsCount);
  // compute interface signature (aka "contract"), serialized as a JSON object
  fContract := FormatUTF8('{"contract":"%","implementation":"%","methods":%}',
      [InterfaceURI,LowerCase(ToText(InstanceCreation)),fInterface.fContract]);
  fContractHash := '"'+CardinalToHex(Hash32(fContract))+
    CardinalToHex(CRC32string(fContract))+'"'; // 2 hashes to avoid collision
  if aContractExpected<>'' then // override default contract
    fContractExpected := aContractExpected else
    fContractExpected := fContractHash; // for security
end;


{ TServiceContainerServer }

function TServiceContainerServer.AddImplementation(
  aImplementationClass: TInterfacedClass; const aInterfaces: array of PTypeInfo;
  aInstanceCreation: TServiceInstanceImplementation): TServiceFactoryServer;
var C: TClass;
    T: PInterfaceTable;
    i, j: integer;
    UID: array of ^TGUID;
    F: TServiceFactoryServer;
begin
  result := nil;
  // check input parameters
  if (self=nil) or (aImplementationClass=nil) or (high(aInterfaces)<0) then
    exit;
  CheckInterface(aInterfaces);
  SetLength(UID,length(aInterfaces));
  for j := 0 to high(aInterfaces) do
    UID[j] := @PInterfaceTypeData(aInterfaces[j]^.ClassType)^.IntfGuid;
  // check that all interfaces are implemented by this class
  C := aImplementationClass;
  repeat
    T := C.GetInterfaceTable;
    if T<>nil then
      for i := 0 to T^.EntryCount-1 do
        with T^.Entries[i] do
        for j := 0 to high(aInterfaces) do
          if (UID[j]<>nil) and IsEqualGUID(UID[j]^,IID) then begin
            UID[j] := nil;
            break;
          end;
    C := C.ClassParent;
  until C=nil;
  for j := 0 to high(aInterfaces) do
    if UID[j]<>nil then
      raise EServiceException.CreateFmt('Interface %s not found in %s implementation',
        [aInterfaces[j]^.Name,aImplementationClass.ClassName]);
  // register this implementation class
  for j := 0 to high(aInterfaces) do begin
    F := TServiceFactoryServer.Create(Rest as TSQLRestServer,aInterfaces[j],
      aInstanceCreation,aImplementationClass);
    if result=nil then
      result := F; // returns the first registered interface
    AddServiceInternal(F);
  end;
end;

procedure TServiceContainerServer.OnCloseSession(aSessionID: cardinal);
var i: Integer;
    Inst: TServiceFactoryServerInstance;
begin
  Inst.InstanceID := aSessionID;
  for i := 0 to Count-1 do
    with TServiceFactoryServer(Index(i)) do
    if InstanceCreation=sicPerSession then
      InternalInstanceRetrieve(Inst,-1); // aMethodIndex=-1 to Free it
end;

{ TInterfacedObjectWithCustomCreate }

constructor TInterfacedObjectWithCustomCreate.Create;
begin // nothing to do by default - overriden constructor may add custom code
end;

procedure TInterfacedObjectWithCustomCreate.InternalRelease;
begin
  IInterface(self)._Release; // call the release interface
end;


{ TServiceFactoryServer }

constructor TServiceFactoryServer.Create(aRestServer: TSQLRestServer; aInterface: PTypeInfo;
  aInstanceCreation: TServiceInstanceImplementation;
  aImplementationClass: TInterfacedClass; const aContractExpected: RawUTF8;
  aTimeOutSec: cardinal);
begin
  // extract RTTI from the interface
  inherited Create(aRestServer,aInterface,aInstanceCreation,aContractExpected);
  if fRest.MethodAddress(ShortString(InterfaceURI))<>nil then
    raise EServiceException.CreateFmt('%s is already exposed as %s published method',
      [InterfaceURI,fRest.ClassName]) else
  fImplementationClass := aImplementationClass;
  if fImplementationClass.InheritsFrom(TInterfacedObjectWithCustomCreate) then
    fImplementationClassWithCustomCreate := true;
  // initialize the shared instance or client driven parameters
  case InstanceCreation of
  sicShared: begin
    fSharedInstance := CreateInstance(false);
    if (fSharedInstance=nil) or
       not fSharedInstance.GetInterface(fInterface.fInterfaceIID,fSharedInterface) then
      raise EServiceException.CreateFmt('No implementation available for I%s interface',
        [fInterfaceURI]);
  end;
  sicClientDriven, sicPerSession, sicPerUser, sicPerGroup, sicPerThread:
    if (aTimeOutSec=0) and (InstanceCreation<>sicPerThread) then
      fInstanceCreation := sicSingle else begin
      // only instances list is protected, since client calls shall be pipelined
      fInstance.Init(TypeInfo(TServiceFactoryServerInstanceDynArray),
        fInstances,@fInstancesCount);
      fInstance.Compare := SortDynArrayInteger; // sort by InstanceID: cardinal
      if InstanceCreation<>sicPerThread then begin
        InitializeCriticalSection(fInstanceLock);
        fInstanceTimeOut := aTimeOutSec*1000;
      end;
    end;
  end;
end;

destructor TServiceFactoryServer.Destroy;
var i: integer;
begin
  try // release any internal instance (should have been done by client)
    for i := 0 to fInstancesCount-1 do
      if fInstances[i].Instance<>nil then
        fInstances[i].SafeFreeInstance({$ifndef LVCL}fImplementationFreeInMainThread{$endif});
  except
    ; // better ignore any error in business logic code
  end;
  if Assigned(fInstance.Compare) and (InstanceCreation<>sicPerThread) then
    DeleteCriticalSection(fInstanceLock);
  inherited;
end;

function TServiceFactoryServer.Get(out Obj): Boolean;
var Inst: TServiceFactoryServerInstance;
begin
  result := false;
  if Self<>nil then
    case fInstanceCreation of
    sicShared:
    if fSharedInterface<>nil then begin
      IInterface(Obj) := fSharedInterface; // copy implementation interface
      result := true;
    end;
    sicPerThread: begin
      Inst.Instance := nil;
      Inst.InstanceID := GetCurrentThreadId;
      if not InternalInstanceRetrieve(Inst,0) and (Inst.Instance<>nil) then
        result := Inst.Instance.GetInterface(fInterface.fInterfaceIID,Obj);
    end;
    else begin // no user/group/session on pure server-side -> always sicSingle
      Inst.Instance := CreateInstance(false);
      if Inst.Instance<>nil then
        result := Inst.Instance.GetInterface(fInterface.fInterfaceIID,Obj);
    end;
    end;
end;

function TServiceFactoryServer.RetrieveSignature: RawUTF8;
begin
  if self=nil then
    result := '' else
    result := Contract; // just return the current value
end;

{$ifdef DELPHI6OROLDER}
type
  TThreadHook = class(TThread);
{$endif}

procedure TServiceFactoryServerInstance.SafeFreeInstance(
  {$ifndef LVCL}ReleaseInMainThread: boolean{$endif});
var Obj: TInterfacedObject;
begin
  InstanceID := 0;
  Obj := Instance;
  Instance := nil;
  {$ifndef LVCL}
  if ReleaseInMainThread and (GetCurrentThreadID<>MainThreadID) then
    {$ifdef DELPHI6OROLDER}TThreadHook(nil).Synchronize(
    {$else}                TThread.Synchronize(nil,
    {$endif}  TInterfacedObjectWithCustomCreate(Obj).InternalRelease) else
  {$endif}
    IInterface(Obj)._Release;
end;

function TServiceFactoryServer.InternalInstanceRetrieve(
  var Inst: TServiceFactoryServerInstance; aMethodIndex: integer): boolean;
procedure AddNew;
var i: integer;
    P: ^TServiceFactoryServerInstance;
begin
  Inst.Instance := CreateInstance(true);
  if Inst.Instance=nil then
    exit;
  P := pointer(fInstances);
  for i := 1 to fInstancesCount do
    if P^.InstanceID=0 then begin
      P^ := Inst; // found an empty entry -> use it
      exit;
    end else
    inc(P);
  fInstance.Add(Inst); // append a new entry
end;
var i: integer;
begin
  result := false;
  Inst.LastAccess := GetTickCount;
  if InstanceCreation<>sicPerThread then
    EnterCriticalSection(fInstanceLock);
  try
    // first release any deprecated instances
    if fInstanceTimeout<>0 then
    for i := 0 to fInstancesCount-1 do
      with fInstances[i] do
      if (Inst.LastAccess<LastAccess) or
         (QWord(Inst.LastAccess)>QWord(LastAccess)+QWord(fInstanceTimeout)) then
        // mark this entry is empty
        SafeFreeInstance({$ifndef LVCL}fImplementationFreeInMainThread{$endif});
    if Inst.InstanceID=0 then begin
      // retrieve or initialize a sicClientDriven instance
      if (cardinal(aMethodIndex)>=fInterface.fMethodsCount) or
         (InstanceCreation<>sicClientDriven) then
        exit;
      // initialize the new instance
      inc(fInstanceCurrentID);
      Inst.InstanceID := fInstanceCurrentID;
      AddNew;
    end else begin
      // search the instance corresponding to Inst.InstanceID
      for i := 0 to fInstancesCount-1 do
        with fInstances[i] do
        if InstanceID=Inst.InstanceID then begin
          if aMethodIndex<0 then begin
            // aMethodIndex=-1 for {"method":"_free_", "params":[], "id":1234}
            SafeFreeInstance({$ifndef LVCL}fImplementationFreeInMainThread{$endif});
            result := true; // successfully released instance
            exit;
          end;
          LastAccess := Inst.LastAccess;
          Inst.Instance := Instance;
          exit;
        end;
      // add any new session/user/group instance if necessary
      if InstanceCreation<>sicClientDriven then
        AddNew;
    end;
  finally
    if InstanceCreation<>sicPerThread then
      LeaveCriticalSection(fInstanceLock);
  end;
end;

function TServiceFactoryServer.RestServer: TSQLRestServer;
begin
  result := TSQLRestServer(Rest);
end;

function TServiceFactoryServer.CreateInstance(AndIncreaseRefCount: boolean): TInterfacedObject;
begin
  if fImplementationClassWithCustomCreate then
    result := TInterfacedObjectWithCustomCreateClass(fImplementationClass).Create else
    result := fImplementationClass.Create;
  if AndIncreaseRefCount then
    IInterface(result)._AddRef; // allow passing self to sub-methods
end;

procedure TServiceFactoryServer.ExecuteMethod(
  var Ctxt: TSQLRestServerCallBackParams;
  aMethodIndex, aInstanceID: cardinal; aParamsJSONArray: PUTF8Char);
procedure Error(Msg: PUTF8Char);
begin
  Ctxt.Error(Msg,[UnCamelCase(ToText(InstanceCreation))]);
end;
var Inst: TServiceFactoryServerInstance;
    WR: TTextWriter;
    entry: PInterfaceEntry;
    ThreadServer: PServiceRunningContext;
begin
  // 1. initialize Inst.Instance and Inst.InstanceID
  Inst.InstanceID := 0;
  Inst.Instance := nil;
  case InstanceCreation of
    sicSingle:
      if aMethodIndex>=fInterface.fMethodsCount then
        exit else
        Inst.Instance := CreateInstance(true);
    sicShared:
      if aMethodIndex>=fInterface.fMethodsCount then
        exit else
        Inst.Instance := fSharedInstance;
    sicClientDriven, sicPerSession, sicPerUser, sicPerGroup, sicPerThread: begin
      case InstanceCreation of
      sicClientDriven:
        Inst.InstanceID := aInstanceID;
      sicPerThread:
        Inst.InstanceID := GetCurrentThreadId;
      else
        if Ctxt.Session>CONST_AUTHENTICATION_NOT_USED then
          case InstanceCreation of // authenticated user -> handle context
          sicPerSession: Inst.InstanceID := Ctxt.Session;
          sicPerUser:    Inst.InstanceID := Ctxt.SessionUser;
          sicPerGroup:   Inst.InstanceID := Ctxt.SessionGroup;
          end else begin
            Error('% mode expects an authenticated session');
            exit;
          end;
      end;
      if InternalInstanceRetrieve(Inst,aMethodIndex) then begin
        Ctxt.Success;
        exit; // {"method":"_free_", "params":[], "id":1234}
      end;
    end;
  end;
  if Inst.Instance=nil then begin
    Error('% instance not found or deprecated');
    exit;
  end;
  // 2. call method implementation
  try
    entry := Inst.Instance.GetInterfaceEntry(fInterface.fInterfaceIID);
    if entry=nil then
      exit;
    ThreadServer := @ServiceContext;
    WR := TJSONSerializer.CreateOwnedStream;
    try
      with ThreadServer^ do begin
        Factory := self;
        Session := @Ctxt;
      end; // RunningThread is already set at thread initialization
      // root/calculator {"method":"add","params":[1,2]} -> {"result":[3],"id":0}
      try
        WR.AddShort('{"result":[');
        if not fInterface.fMethods[aMethodIndex].InternalExecute(
            [PAnsiChar(Inst.Instance)+entry^.IOffset],aParamsJSONArray,WR,
             Ctxt.Call.OutHead,fExecution[aMethodIndex].Options) then
          exit; // wrong request
        if Ctxt.Call.OutHead='' then begin // <>'' for TServiceCustomAnswer
          WR.AddShort('],"id":');
          WR.Add(Inst.InstanceID); // only used in sicClientDriven mode
          WR.AddShort('}');
          Ctxt.Call.OutHead := JSON_CONTENT_TYPE_HEADER;
        end;
        WR.SetText(Ctxt.Call.OutBody);
        Ctxt.Call.OutStatus := HTML_SUCCESS;
      except
        on E: Exception do
          Ctxt.Error('Exception %: %',
           [PShortString(PPointer(PPtrInt(E)^+vmtClassName)^)^,E.Message],
           HTML_SERVERERROR);
      end;
    finally
      with ThreadServer^ do begin
        Factory := nil;
        Session := nil;
      end;
      WR.Free;
    end;
  finally
    if InstanceCreation=sicSingle then // always release single shot instance
      Inst.SafeFreeInstance({$ifndef LVCL}fImplementationFreeInMainThread{$endif});
  end;
end;

function TServiceFactoryServer.AllowAll: TServiceFactoryServer;
var m: integer;
begin
  if self<>nil then
    for m := 0 to fInterface.fMethodsCount-1 do
      fillchar(fExecution[m].Denied,sizeof(fExecution[m].Denied),0);
  result := self;
end;

function TServiceFactoryServer.AllowAllByID(const aGroupID: array of integer): TServiceFactoryServer;
var m,g: integer;
begin
  if self<>nil then
    for m := 0 to fInterface.fMethodsCount-1 do
    with fExecution[m] do
      for g := 0 to high(aGroupID) do
        exclude(Denied,aGroupID[g]-1);
  result := self;
end;

function TServiceFactoryServer.AllowAllByName(const aGroup: array of RawUTF8): TServiceFactoryServer;
var IDs: TIntegerDynArray;
begin
  if self<>nil then
    if Rest.MainFieldIDs(TSQLAuthGroup,aGroup,IDs) then
      AllowAllByID(IDs);
  result := self;
end;

function TServiceFactoryServer.DenyAll: TServiceFactoryServer;
var m: integer;
begin
  if self<>nil then
    for m := 0 to fInterface.fMethodsCount-1 do
      fillchar(fExecution[m].Denied,sizeof(fExecution[m].Denied),255);
  result := self;
end;

function TServiceFactoryServer.DenyAllByID(const aGroupID: array of integer): TServiceFactoryServer;
var m,g: integer;
begin
  if self<>nil then
    for m := 0 to fInterface.fMethodsCount-1 do
    with fExecution[m] do
      for g := 0 to high(aGroupID) do
        include(Denied,aGroupID[g]-1);
  result := self;
end;

function TServiceFactoryServer.DenyAllByName(const aGroup: array of RawUTF8): TServiceFactoryServer;
var IDs: TIntegerDynArray;
begin
  if self<>nil then
    if Rest.MainFieldIDs(TSQLAuthGroup,aGroup,IDs) then
      DenyAllByID(IDs);
  result := self;
end;

function TServiceFactoryServer.Allow(const aMethod: array of RawUTF8): TServiceFactoryServer;
var m: integer;
begin
  if self<>nil then
    for m := 0 to high(aMethod) do
      fillchar(fExecution[fInterface.CheckMethodIndex(aMethod[m])].Denied,
        sizeof(fExecution[0].Denied),0);
  result := self;
end;

function TServiceFactoryServer.AllowByID(const aMethod: array of RawUTF8; const aGroupID: array of integer): TServiceFactoryServer;
var m,g: integer;
begin
  if self<>nil then 
    if high(aGroupID)>=0 then
    for m := 0 to high(aMethod) do
      with fExecution[fInterface.CheckMethodIndex(aMethod[m])] do
        for g := 0 to high(aGroupID) do
          exclude(Denied,aGroupID[g]-1);
  result := self;
end;

function TServiceFactoryServer.AllowByName(const aMethod: array of RawUTF8; const aGroup: array of RawUTF8): TServiceFactoryServer;
var IDs: TIntegerDynArray;
begin
  if self<>nil then
    if Rest.MainFieldIDs(TSQLAuthGroup,aGroup,IDs) then
      AllowByID(aMethod,IDs);
  result := self;
end;

function TServiceFactoryServer.Deny(const aMethod: array of RawUTF8): TServiceFactoryServer;
var m: integer;
begin
  if self<>nil then
    for m := 0 to high(aMethod) do
      fillchar(fExecution[fInterface.CheckMethodIndex(aMethod[m])].Denied,
        sizeof(fExecution[0].Denied),255);
  result := self;
end;

function TServiceFactoryServer.DenyByID(const aMethod: array of RawUTF8; const aGroupID: array of integer): TServiceFactoryServer;
var m,g: integer;
begin
  if self<>nil then
    for m := 0 to high(aMethod) do
      with fExecution[fInterface.CheckMethodIndex(aMethod[m])] do
        for g := 0 to high(aGroupID) do
          include(Denied,aGroupID[g]-1);
  result := self;
end;

function TServiceFactoryServer.DenyByName(const aMethod: array of RawUTF8; const aGroup: array of RawUTF8): TServiceFactoryServer;
var IDs: TIntegerDynArray;
begin
  if self<>nil then
    if Rest.MainFieldIDs(TSQLAuthGroup,aGroup,IDs) then
      DenyByID(aMethod,IDs);
  result := self;
end;

function TServiceFactoryServer.SetOptions(const aMethod: array of RawUTF8;
  aOptions: TServiceMethodOptions): TServiceFactoryServer;
var m,i: integer;
begin
  if self<>nil then begin
    {$ifndef LVCL}
    if (fInstanceCreation=sicPerThread) and
      ([optExecInMainThread,optFreeInMainThread]*aOptions<>[]) then
      raise EServiceException.CreateFmt(
        'opt*InMainThread option not compatible with sicPerThread for I%s interface',
        [fInterfaceURI]);
    {$endif}
    if high(aMethod)<0 then
      for i := 0 to fInterface.fMethodsCount-1 do
        fExecution[i].Options := aOptions else
    for m := 0 to high(aMethod) do
      fExecution[fInterface.CheckMethodIndex(aMethod[m])].Options := aOptions;
    {$ifndef LVCL}
    fImplementationFreeInMainThread := optFreeInMainThread in aOptions;
    {$endif}
  end;
  result := self;
end;


{ TServiceMethodArgument }

const
  CONST_METHODDIRTOJSON: array[TServiceMethodValueDirection] of RawUTF8 = (
    // convert into generic in/out direction (assume result is out)
    'in','both','out','out');

  // AnsiString (Delphi <2009) is handled with care (may loose data otherwise)
  CONST_METHODTYPETOJSON: array[TServiceMethodValueType] of RawUTF8 = (
    '??','self','boolean', '', '','integer','cardinal','int64',
    'double','datetime','currency','utf8',
    {$ifdef UNICODE}'utf8'{$else}''{$endif},'utf8','',
    {$ifdef USEVARIANTS}'variant',{$endif}'','json','');

function TServiceMethodArgument.SerializeToContract: RawUTF8;
begin
  result := '{"argument":"'+RawUTF8(ParamName^)+'","direction":"'+
    CONST_METHODDIRTOJSON[ValueDirection]+'","type":"';
  {$ifndef UNICODE}
  if ValueType=smvString then // will specify the Ansi code page for no data loss
    result := result+'ansi'+Int32ToUTF8(CurrentAnsiConvert.CodePage) else
  {$endif}
  if CONST_METHODTYPETOJSON[ValueType]='' then
    result := result+ShortStringToAnsi7String(TypeInfo^.Name) else
    result := result+CONST_METHODTYPETOJSON[ValueType];
  result := result+'"},';
end;


{$ifndef LVCL}

{ TInterfacedCollection }

constructor TInterfacedCollection.Create;
begin
  inherited Create(GetClass);
end;

{$endif LVCL}

{ TServiceMethod }

type
  TDynArrayFake = record
    Wrapper: TDynArray;
    Value: Pointer;
  end;
  TCallMethodArgs = record
    StackSize, StackAddr, method: PtrInt;
    Regs: array[REG_FIRST..REG_LAST] of PtrInt;
    res64: Int64Rec;
    resKind: TServiceMethodValueType;
    callContext: PServiceRunningContext;
  end;

procedure CallMethod(var Args: TCallMethodArgs);
{$ifdef CPU64}
asm
    .params 64    // size for 64 parameters
    .pushnv r12   // generate prolog+epilog to save and restore non-volatile r12
    mov r12,Args
    // copy stack content (if any)
    mov rcx,[r12].TCallMethodArgs.StackAddr
    lea rdx,[rsp+$20]
    mov r8, [r12].TCallMethodArgs.StackSize
    call Move
    // call method
    mov rcx,[r12+TCallMethodArgs.Regs+REGRCX*8-8]
    mov rdx,[r12+TCallMethodArgs.Regs+REGRDX*8-8]
    mov r8, [r12+TCallMethodArgs.Regs+REGR8 *8-8]
    mov r9, [r12+TCallMethodArgs.Regs+REGR9 *8-8]
    movsd xmm0,[r12+TCallMethodArgs.Regs+REGXMM0*8-8]
    movsd xmm1,[r12+TCallMethodArgs.Regs+REGXMM1*8-8]
    movsd xmm2,[r12+TCallMethodArgs.Regs+REGXMM2*8-8]
    movsd xmm3,[r12+TCallMethodArgs.Regs+REGXMM3*8-8]
    call [r12].TCallMethodArgs.method
    // retrieve result
    mov [r12].TCallMethodArgs.res64,rax
    mov cl,[r12].TCallMethodArgs.resKind
    cmp cl,smvDouble
    je @d
    cmp cl,smvDateTime
    je @d
    cmp cl,smvCurrency
    jne @e
@d: movsd [r12].TCallMethodArgs.res64,xmm0
@e:
end;
{$else}
asm
    push esi
    push ebp
    mov ebp,esp
    mov esi,Args
    // copy stack content (if any)
    mov eax,[esi].TCallMethodArgs.StackSize
    mov edx,dword ptr [esi].TCallMethodArgs.StackAddr
    add edx,eax // pascal/register convention = left-to-right
    shr eax,2
    jz @z
@n: sub edx,4
    mov ecx,[edx]
    push ecx
    dec eax
    jnz @n
    // call method
@z: mov eax,[esi+TCallMethodArgs.Regs+REGEAX*4-4]
    mov edx,[esi+TCallMethodArgs.Regs+REGEDX*4-4]
    mov ecx,[esi+TCallMethodArgs.Regs+REGECX*4-4]
    call [esi].TCallMethodArgs.method
    // retrieve result
    mov cl,[esi].TCallMethodArgs.resKind
    cmp cl,smvDouble
    je @d
    cmp cl,smvDateTime
    je @d
    cmp cl,smvCurrency
    jne @i
    fistp qword [esi].TCallMethodArgs.res64
    jmp @e
@d: fstp qword [esi].TCallMethodArgs.res64
    jmp @e
@i: mov [esi].TCallMethodArgs.res64.Lo,eax
    mov [esi].TCallMethodArgs.res64.Hi,edx
@e: mov esp,ebp
    pop ebp
    pop esi
end;
{$endif CPU64}

{$ifndef LVCL}
procedure CallMethodSynch(var Args: TCallMethodArgs);
var ThreadServer: PServiceRunningContext;
    backup: TServiceRunningContext;
begin
  ThreadServer := @ServiceContext; // faster to use a pointer than GetTls()
  backup := ThreadServer^;
  try
    with Args.callContext^ do begin
      ThreadServer^.Factory := Factory;
      ThreadServer^.Session := Session;
    end;
    ThreadServer^.RunningThread := nil; // here, main thread is identified as nil
    CallMethod(Args);
  finally
    ThreadServer^ := backup;
  end;
end;
{$endif}

{$ifndef LVCL}
type
  TCollectionClass = class of TInterfacedCollection;
{$endif}

function TServiceMethod.InternalExecute(Instances: array of pointer;
  Par: PUTF8Char; Res: TTextWriter; var aHead: RawUTF8;
  Options: TServiceMethodOptions): boolean;
var RawUTF8s: TRawUTF8DynArray;
    Strings: TStringDynArray;
    WideStrings: TWideStringDynArray;
    Records: array of TBytes;
    Value: pointer;
    i,a: integer;
    wasString, valid: boolean;
    Val: PUTF8Char;
    r: TCallMethodArgs;
{$ifndef LVCL}
    SyncMethod: TMethod;
{$endif}
    Stack: array[0..MAX_EXECSTACK-1] of byte;
    Int64s: array[0..MAX_METHOD_ARGS-1] of Int64;
    Objects: array[0..MAX_METHOD_ARGS-1] of TObject;
    DynArrays: array[0..MAX_METHOD_ARGS-1] of TDynArrayFake;
    Values: array[0..MAX_METHOD_ARGS-1] of PPointer;
begin
  result := false;
  if high(Instances)<0 then
    exit;
  if ArgsUsedCount[smvvRawUTF8]>0 then
    SetLength(RawUTF8s,ArgsUsedCount[smvvRawUTF8]);
  if ArgsUsedCount[smvvString]>0 then
    SetLength(Strings,ArgsUsedCount[smvvString]);
  if ArgsUsedCount[smvvWideString]>0 then
    SetLength(WideStrings,ArgsUsedCount[smvvWideString]);
  if ArgsUsedCount[smvvRecord]>0 then
    SetLength(Records,ArgsUsedCount[smvvRecord]);
  if ArgsUsedCount[smvvObject]>0 then
    fillchar(Objects,ArgsUsedCount[smvvObject]*sizeof(TObject),0); // for finally
  if ArgsUsedCount[smvvDynArray]>0 then
    fillchar(DynArrays,ArgsUsedCount[smvvDynArray]*sizeof(TDynArrayFake),0);
  try
    // 1. read the parameters
    if Par^ in [#1..' '] then repeat inc(Par) until not(Par^ in [#1..' ']);
    if Par^<>'[' then
      Exit;
    inc(Par);
    for a:= 0 to high(Args) do
    with Args[a] do begin
      case ValueType of
      smvSelf:
        continue; // self parameter is never transmitted
      smvObject: begin
        Objects[IndexVar] := TypeInfo^.ClassCreate; 
        if ValueDirection in [smdConst,smdVar] then begin
          Par := JSONToObject(Objects[IndexVar],Par,valid);
          if not valid then
            exit;
          IgnoreComma(Par);
        end;
      end;
      smvRawJSON:
      if ValueDirection in [smdConst,smdVar] then begin
        Val := Par;
        Par := GotoNextJSONItem(Par);
        if Par<=Val then
          exit;
        SetString(RawUTF8s[IndexVar],PAnsiChar(Val),Par-Val);
      end;
      smvDynArray:
      with DynArrays[IndexVar] do begin
        Wrapper.Init(TypeInfo,Value);
        if ValueDirection in [smdConst,smdVar] then begin
          Par := Wrapper.LoadFromJSON(Par);
          if Par=nil then
            exit;
          IgnoreComma(Par);
        end;
      end;
      smvRecord: begin
        SetLength(Records[IndexVar],TypeInfo^.RecordType^.Size);
        if ValueDirection in [smdConst,smdVar] then
          Par := RecordLoadJSON(pointer(Records[IndexVar])^,Par,TypeInfo);
      end;
      {$ifdef USEVARIANTS}
      smvVariant: begin
        SetLength(Records[IndexVar],sizeof(Variant));
        if ValueDirection in [smdConst,smdVar] then
          Par := VariantLoadJSON(PVariant(pointer(Records[IndexVar]))^,Par);
      end;
      {$endif}
      smvBoolean..smvWideString:
      if ValueDirection in [smdConst,smdVar] then begin
        Val := GetJSONField(Par,Par,@wasString);
        if (Val=nil) or (wasString<>(vIsString in ValueKindAsm)) then
          exit;
        case ValueType of
        smvBoolean..smvInt64:  SetInt64(Val,Int64s[IndexVar]);
        smvDouble,smvDateTime: PDouble(@Int64s[IndexVar])^ := GetExtended(Val);
        smvCurrency:   Int64s[IndexVar] := StrToCurr64(Val);
        smvRawUTF8:    RawUTF8s[IndexVar] := Val;
        smvString:     Strings[IndexVar] := UTF8DecodeToString(Val,StrLen(Val));
        smvWideString: UTF8ToWideString(Val,StrLen(Val),WideStrings[IndexVar]);
        else exit; // should not happen
        end;
      end;
      else exit; // unhandled type
      end;
    end;
    // 2. create the stack content
    r.StackAddr := PtrInt(@Stack);
    r.StackSize := ArgsSizeInStack;
    for a:= 0 to high(Args) do
    with Args[a] do begin
      case ValueVar of
      smvvSelf:       continue; // r.Regs[REG_FIRST] := Instance[i] below
      smvv64:         Value := @Int64s[IndexVar];
      smvvRawUTF8:    Value := @RawUTF8s[IndexVar];
      smvvString:     Value := @Strings[IndexVar];
      smvvWideString: Value := @WideStrings[IndexVar];
      smvvObject:     Value := @Objects[IndexVar];
      smvvRecord:     Value := pointer(Records[IndexVar]);
      smvvDynArray:   Value := @DynArrays[IndexVar].Value;
      else raise EInterfaceFactoryException.CreateFmt(
        'Invalid argument type %d',[ord(ValueType)]);
      end;
      Values[a] := Value;
      if (ValueDirection<>smdConst) or
         (ValueType in [smvRecord{$ifdef USEVARIANTS},smvVariant{$endif}]) then
        // pass by reference
        if RegisterIdent=0 then
          move(Value,Stack[InStackOffset],SizeInStack) else
          r.Regs[RegisterIdent] := PtrInt(Value) else
        // pass by value
        if RegisterIdent=0 then
          move(Value^,Stack[InStackOffset],SizeInStack) else
          r.Regs[RegisterIdent] := PPtrInt(Value)^;
    end;
    // 3. execute the method
    for i := 0 to high(Instances) do begin
      r.Regs[REG_FIRST] := PtrInt(Instances[i]);
      r.method := PPtrIntArray(PPointer(Instances[i])^)^[MethodIndex];
      if ArgsResultIndex>=0 then
      with Args[ArgsResultIndex] do begin
        r.resKind := ValueType;
        if ValueVar=smvv64 then
          Values[ArgsResultIndex] := @r.res64;
      end else
        r.resKind := smvNone;
      {$ifndef LVCL}
      if (optExecInMainThread in Options) and
         (GetCurrentThreadID<>MainThreadID) then begin
        r.callContext := @ServiceContext; // to be copied into main threadvar
        SyncMethod.Code := @CallMethodSynch;
        SyncMethod.Data := @r; // fake call: PCallMethodArgs(self)^=Params
        {$ifdef DELPHI6OROLDER}TThreadHook(ServiceContext.RunningThread).Synchronize(
        {$else}                TThread.Synchronize(ServiceContext.RunningThread,
        {$endif}  TThreadMethod(SyncMethod));
      end else
      {$endif}
        CallMethod(r);
    end;
    // 4. send back any result
    if Res<>nil then begin
      // 4.1 handle custom content (not JSON object answer)
      if (r.resKind=smvRecord) and ArgsResultIsServiceCustomAnswer then
        with PServiceCustomAnswer(Values[ArgsResultIndex])^ do
        if Header<>'' then begin
          Res.CancelAll;
          aHead := Header;
          if Res.Stream.InheritsFrom(TRawByteStringStream) then
            TRawByteStringStream(Res.Stream).DataString := Content else
            Res.Stream.Write(pointer(Content)^,length(Content));
          Result := true;
          exit;
        end;
      // 4.2 write the '{"result":[...' array
      for a := ArgsOutFirst to ArgsOutLast do
      with Args[a] do
      if ValueDirection in [smdVar,smdOut,smdResult] then begin
        if vIsString in ValueKindAsm then
          Res.Add('"');
        case ValueType of
        smvRecord:   Res.AddRecordJSON(Values[a]^,TypeInfo);
        {$ifdef USEVARIANTS}
        smvVariant:  Res.AddVariantJSON(PVariant(Values[a])^,twJSONEscape);
        {$endif}
        smvDynArray: Res.AddDynArrayJSON(DynArrays[IndexVar].Wrapper);
        else ValueAdd(ValueType,Res,Values[a],SizeInStorage);
        end;
        if vIsString in ValueKindAsm then
          Res.Add('"',',') else
          Res.Add(',');
      end;
      Res.CancelLastComma;
    end;
    Result := true;
  finally // manual release memory for Records[], Objects[] and DynArrays[]
    for i := 0 to ArgsUsedCount[smvvObject]-1 do
      Objects[i].Free;
    for i := 0 to ArgsUsedCount[smvvDynArray]-1 do
      DynArrays[i].Wrapper.Clear;
    if Records<>nil then begin
      i := 0;
      for a := 0 to high(Args) do
        with Args[a] do
        case ValueType of
        smvRecord: begin
          RecordClear(pointer(Records[i])^,TypeInfo);
          inc(i);
        end;
        {$ifdef USEVARIANTS}
        smvVariant: begin
          VarClear(PVariant(pointer(Records[i]))^); // fast
          inc(i);
        end;
        {$endif}
        end;
    end;
  end;
end;


{ TServiceContainerClient }

function TServiceContainerClient.Info(aTypeInfo: PTypeInfo): TServiceFactory;
begin
  result := inherited Info(aTypeInfo);
  if result=nil then
    result := AddInterface(aTypeInfo,sicClientDriven);
end;



{ TServiceFactoryClient }

function TServiceFactoryClient.CreateFakeInstance: TInterfacedObject;
begin
  if fInstanceCreation=sicClientDriven then
    result := fInterface.CreateFakeInstance(Invoke,NotifyInstanceDestroyed) else
    result := fInterface.CreateFakeInstance(Invoke);
end;

function TServiceFactoryClient.Invoke(const aMethod: TServiceMethod;
  const aParams: RawUTF8; aResult: PRawUTF8; aErrorMsg: PRawUTF8;
  aClientDrivenID: PCardinal; aServiceCustomAnswer: PServiceCustomAnswer): boolean;
begin
  result := InternalInvoke(aMethod.URI,aParams,aResult,aErrorMsg,aClientDrivenID,aServiceCustomAnswer);
end;

function TServiceFactoryClient.InternalInvoke(const aMethod: RawUTF8;
  const aParams: RawUTF8=''; aResult: PRawUTF8=nil; aErrorMsg: PRawUTF8=nil;
  aClientDrivenID: PCardinal=nil; aServiceCustomAnswer: PServiceCustomAnswer=nil): boolean; 
var uri,sent,resp,head: RawUTF8;
    Values: TPUtf8CharDynArray;
    {$ifdef WITHLOG}
    LogLevel: TSynLogInfos; // faster execution if logging is not enabled
    {$endif}
begin
  result := false;
  if Self=nil then
    exit;
  if fClient=nil then
    fClient := fRest as TSQLRestClientURI;
  {$ifdef WITHLOG}
  LogLevel := SQLite3Log.Family.Level;
  if sllEnter in LogLevel then
    SQLite3Log.Enter(Self,pointer(fInterfaceURI+'.'+aMethod),true);
  {$endif}
  // compute URI according to current routing scheme
  if fRest.Services.ExpectMangledURI then
    uri := fClient.Model.Root+'/'+fInterfaceMangledURI else
    uri := fClient.Model.Root+'/'+fInterfaceURI;
  case fRest.ServicesRouting of
  rmREST: begin
    if (aClientDrivenID<>nil) and (aClientDrivenID^>0) then
      uri := uri+'.'+aMethod+'/'+UInt32ToUTF8(aClientDrivenID^) else
      uri := uri+'.'+aMethod;
    sent := '['+aParams+']'; // we may also encode them within the URI
  end;
  rmJSON_RPC: begin
    sent := '{"method":"'+aMethod+'","params":['+aParams;
    if aClientDrivenID=nil then
      sent := sent+']}' else
      sent := sent+'], "id":'+UInt32ToUTF8(aClientDrivenID^)+'}';
  end;
  else exit;
  end;
  // call remote server
  if fClient.URI(uri,'POST',@resp,@head,@sent).Lo<>HTML_SUCCESS then begin
    if aErrorMsg<>nil then
      aErrorMsg^ := ': '+resp;
    exit;
  end;
  // decode result
  if aServiceCustomAnswer=nil then begin // decode JSON object
    {$ifdef WITHLOG}
    if (sllServiceReturn in LogLevel) and (resp<>'') then
        SQLite3Log.Add.Log(sllServiceReturn,resp,nil,MAX_SIZE_RESPONSE_LOG);
    {$endif}
    JSONDecode(resp,['result','id'],Values,True);
    if (Values[0]=nil) or (Values[1]=nil) then begin
      if aErrorMsg<>nil then
        aErrorMsg^ := 'Invalid returned JSON content';
      exit;
    end;
    if aResult<>nil then
      aResult^ := Values[0];
    if aClientDrivenID<>nil then
      aClientDrivenID^ := GetCardinal(Values[1]);
  end else begin                         // BLOB answer
    {$ifdef WITHLOG}
    if sllServiceReturn in LogLevel then
      SQLite3Log.Add.Log(sllServiceReturn,'TServiceCustomAnswer(%) returned len=%',
        [head,length(resp)]);
    {$endif}
    aServiceCustomAnswer^.Header := head;
    aServiceCustomAnswer^.Content := resp;
    if aClientDrivenID<>nil then
      aClientDrivenID^ := 0;
  end;
  result := true;
end;

procedure TServiceFactoryClient.NotifyInstanceDestroyed(aClientDrivenID: cardinal);
begin
  if aClientDrivenID<>0 then
    InternalInvoke(SERVICE_PSEUDO_METHOD[imFree],'',nil,nil,@aClientDrivenID);
end;

constructor TServiceFactoryClient.Create(aRest: TSQLRest;
  aInterface: PTypeInfo; aInstanceCreation: TServiceInstanceImplementation;
  const aContractExpected: RawUTF8);
var Error, RemoteContract: RawUTF8;
begin
  // extract interface RTTI and create fake interface (and any shared instance)
  if not aRest.InheritsFrom(TSQLRestClientURI) then
    EServiceException.CreateFmt('%s interface needs a Client connection',
      [aInterface^.Name]);
  inherited Create(aRest,aInterface,aInstanceCreation,aContractExpected);
  // initialize a shared instance (if needed)
  if fInstanceCreation in [sicShared,sicPerSession,sicPerUser,sicPerGroup,sicPerThread] then begin
    // the instance shall remain active during the whole client session
    fSharedInstance := CreateFakeInstance;
    TInterfacedObjectFake(fSharedInstance)._AddRef; // force stay alive
  end;
  // check if this interface is supported on the server
  if not InternalInvoke(SERVICE_PSEUDO_METHOD[imContract],'',@RemoteContract,@Error) then
    raise EServiceException.CreateFmt('I%s interface or %s routing not supported by server%s',
      [fInterfaceURI,GetEnumNameTrimed(TypeInfo(TServiceRoutingMode),fRest.ServicesRouting),Error]);
  if '['+ContractExpected+']'<>RemoteContract then
    raise EServiceException.CreateFmt(
      'Server''s I%s contract differs from client''s: expected [%s], received %s',
      [fInterfaceURI,ContractExpected,RemoteContract]);
end;

destructor TServiceFactoryClient.Destroy;
begin
  if fSharedInstance<>nil then
  with TInterfacedObjectFake(fSharedInstance) do
    if fRefCount<>1 then
      raise EServiceException.CreateFmt(
        'RefCount=%d: shall release I%s interface (.. := nil) before Client.Free',
        [fRefCount,fInterfaceURI]) else
      _Release; // bonne nuit les petits
  inherited;
end;

function TServiceFactoryClient.RetrieveSignature: RawUTF8;
begin
  if InternalInvoke(SERVICE_PSEUDO_METHOD[imSignature],'',@result) and
     (result<>'') and (result[1]='[') then
    result := copy(result,2,length(result)-2) else
    result := '';
end;

function TServiceFactoryClient.Get(out Obj): Boolean;
var O: TInterfacedObjectFake;
begin
  result := false;
  if Self=nil then
    exit;
  case fInstanceCreation of
  sicShared, sicPerSession, sicPerUser, sicPerGroup, sicPerThread:
    O := TInterfacedObjectFake(fSharedInstance);
  sicSingle, sicClientDriven:
    O := TInterfacedObjectFake(CreateFakeInstance);
  else exit;
  end;
  if O=nil then
    exit; 
  pointer(Obj) := @O.fVTable;
  O._AddRef;
  result := true;
end;



function ObjectFromInterface(const aValue: IInterface): TObject;
{$ifndef ISDELPHI2010}
{$ifndef CPU64}
type
  TObjectFromInterfaceStub = packed record
    Stub: cardinal;
    case integer of
    0: (ShortJmp: shortint);
    1: (LongJmp:  longint)
  end;
  PObjectFromInterfaceStub = ^TObjectFromInterfaceStub;
{$endif}
{$endif}
begin
  if aValue=nil then
    result := nil else
    {$ifdef CPU64}
    result := aValue as TObject;
    {$else}
    {$ifdef ISDELPHI2010}
    result := aValue as TObject; // slower but always working
    {$else}
    with PObjectFromInterfaceStub(PPointer(PPointer(aValue)^)^)^ do
    case Stub of // address of VMT[0] entry, i.e. QueryInterface
      $04244483: result := pointer(PtrInt(aValue)+ShortJmp);
      $04244481: result := pointer(PtrInt(aValue)+LongJmp);
      else // recognize TInterfaceFactory.CreateFakeInstance() mocks
      if Stub=PCardinal(@TInterfacedObjectFake.FakeQueryInterface)^ then
        result := TInterfacedObjectFake(pointer(aValue)).SelfFromInterface else
        result := nil;
    end;
    {$endif}
    {$endif}
end;

procedure SetWeak(aInterfaceField: PIInterface; const aValue: IInterface);
begin
  PPointer(aInterfaceField)^ := Pointer(aValue);
end;

type
  TSetWeakZeroInstance = class(TObjectListHashed)
  protected
    fInstance: TObject;
  public
    constructor Create(aObject: TObject; aReference: pointer);
    destructor Destroy; override;
    property Instance: TObject read fInstance;
  end;

  TSetWeakZeroClass = class(TObjectListPropertyHashed)
  protected
    fHookedFreeInstance: PtrUInt;
    fLock: TRTLCriticalSection;
    procedure HookedFreeInstance;
  public
    constructor Create(aClass: TClass);
    destructor Destroy; override;
    function Find(aObject: TObject): TSetWeakZeroInstance;
    function FindOrAdd(aObject: TObject; aReference: pointer): TSetWeakZeroInstance;
  end;

  
{ TSetWeakZeroInstance }

constructor TSetWeakZeroInstance.Create(aObject: TObject; aReference: pointer);
var wasAdded: boolean;
begin
  inherited Create(false);
  fInstance := aObject;
  Add(aReference,wasAdded);
  //assert(IndexOf(aReference)>=0);
end;

destructor TSetWeakZeroInstance.Destroy;
var i: integer;
begin
  for i := 0 to Count-1 do
    PPointer(List[i])^ := nil;
  inherited;
end;


{ TSetWeakZeroClass }

function WeakZeroClassSubProp(aObject: TObject): TObject;
begin
  result := TSetWeakZeroInstance(aObject).fInstance;
end;

constructor TSetWeakZeroClass.Create(aClass: TClass);
var PVMT: ^TObject;
    P: PPtrUInt;
begin
  inherited Create(@WeakZeroClassSubProp);
  PVMT := pointer(PtrInt(aClass)+vmtAutoTable);
  if PVMT^=nil then begin
    PatchCodePtrUInt(pointer(PVMT),PtrUInt(self),true); // LeaveUnprotected=true
    GarbageCollectorFreeAndNil(PVMT^,self); // set to nil at finalization
  end else
    if PPointer(PVMT^)^=TSQLRecordProperties then
      GarbageCollectorFreeAndNil(  // set to nil at finalization
        TSQLRecordProperties(PVMT^).fWeakZeroClass,self) else
      raise EORMException.CreateFmt(
        'SetWeakZero: %s.AutoTable VMT entry already used',
        [PShortString(PPointer(PtrInt(aClass)+vmtClassName)^)^]);
  InitializeCriticalSection(fLock);
  EnterCriticalSection(fLock);
  {$WARN SYMBOL_DEPRECATED OFF}
  P := pointer(PtrInt(aClass)+vmtFreeInstance);
  {$WARN SYMBOL_DEPRECATED ON}
  fHookedFreeInstance := P^;
  PatchCodePtrUInt(P,PtrUInt(@TSetWeakZeroClass.HookedFreeInstance));
end;

destructor TSetWeakZeroClass.Destroy;
begin
  DeleteCriticalSection(fLock);
  inherited;
end;

function EnterWeakZeroClass(aObject: TObject; CreateIfNonExisting: boolean): TSetWeakZeroClass;
 {$ifdef HASINLINE}inline;{$endif}
begin
  result := PPointer(PPtrInt(aObject)^+vmtAutoTable)^;
  if (result<>nil) and (PPointer(result)^=TSQLRecordProperties) then
    result := TSetWeakZeroClass(TSQLRecordProperties(result).fWeakZeroClass);
  if result=nil then
    if CreateIfNonExisting then
      result := TSetWeakZeroClass.Create(PPointer(aObject)^) else
      exit;
  EnterCriticalSection(result.fLock);
end;

procedure TSetWeakZeroClass.HookedFreeInstance;
type Call = procedure(self: TObject);
begin
  with EnterWeakZeroClass(self,false) do begin // if hooked -> never nil
    try
      Delete(self);
    finally
      LeaveCriticalSection(fLock);
    end;
    Call(fHookedFreeInstance)(self);
  end;
end;

function TSetWeakZeroClass.Find(aObject: TObject): TSetWeakZeroInstance;
var i: integer;
begin
  i := IndexOf(aObject); // search List[i].fInstance=aObject
  if i>=0 then
    result := TSetWeakZeroInstance(List[i]) else
    result := nil;
end;

function TSetWeakZeroClass.FindOrAdd(aObject: TObject; aReference: pointer): TSetWeakZeroInstance;
var wasAdded: boolean;
    i: integer;
begin
  i := inherited Add(aObject,wasAdded);
  if wasAdded then begin
    result := TSetWeakZeroInstance.Create(aObject,aReference);
    List[i] := result;
    //assert(IndexOf(aObject)>=0);
  end else begin
    result := TSetWeakZeroInstance(List[i]);
    result.Add(aReference,wasAdded);
  end;
  //assert(result.IndexOf(aReference)>=0);
  //assert(result.fInstance=aObject);
end;

procedure SetWeakZero(aObject: TObject; aObjectInterfaceField: PIInterface;
  const aValue: IInterface);
var aObjectWeakClass, aObjectInterfaceWeakClass: TSetWeakZeroClass;
    aObjectInterfaceObject, aValueObject: TObject;
begin
  if (aObjectInterfaceField=nil) or (aObject=nil) or (aObjectInterfaceField^=aValue) then
    exit;
  aObjectWeakClass := EnterWeakZeroClass(aObject,false);
  try
    if aObjectInterfaceField^<>nil then begin
      if aValue=nil then
        aObjectWeakClass.Delete(TObject(aObjectInterfaceField));
      aObjectInterfaceObject := ObjectFromInterface(aObjectInterfaceField^);
      if aObjectInterfaceObject<>nil then begin
        aObjectInterfaceWeakClass := EnterWeakZeroClass(aObjectInterfaceObject,false);
        if aObjectInterfaceWeakClass<>nil then
        try
          aObjectInterfaceWeakClass.Find(aObjectInterfaceObject).Delete(TObject(aObjectInterfaceField));
        finally
          LeaveCriticalSection(aObjectInterfaceWeakClass.fLock);
        end;
      end;
      SetWeak(aObjectInterfaceField,nil);
      if aValue=nil then
        exit;
    end;
    if aObjectWeakClass=nil then // for faster Delete() just above
      aObjectWeakClass := TSetWeakZeroClass.Create(PPointer(aObject)^);
    aObjectWeakClass.FindOrAdd(aObject,aObjectInterfaceField);
    aValueObject := ObjectFromInterface(aValue);
    if aValueObject<>nil then
      with EnterWeakZeroClass(aValueObject,true) do
      try
        FindOrAdd(aValueObject,aObjectInterfaceField);
      finally
        LeaveCriticalSection(fLock);
      end;
    SetWeak(aObjectInterfaceField,aValue);
  finally
    if aObjectWeakClass<>nil then
      LeaveCriticalSection(aObjectWeakClass.fLock);
  end;
end;

{$ifdef ISDELPHIXE}
procedure TWeakZeroInterfaceHelper.SetWeak0(aObjectInterfaceField: PIInterface;
  const aValue: IInterface);
begin
  SetWeakZero(self,aObjectInterfaceField,aValue);
end;
{$endif}


initialization
  pointer(@SQLFieldTypeComp[sftAnsiText]) := @AnsiIComp;
  pointer(@SQLFieldTypeComp[sftUTF8Custom]) := @AnsiIComp;
{$ifndef USENORMTOUPPER}
  pointer(@SQLFieldTypeComp[sftUTF8Text]) := @AnsiIComp;
{$endif}
  DefaultHasher := @crc32; // faster and more accurate than kr32()

  assert(sizeof(TServiceMethod)and 3=0,'Adjust padding');

end.

